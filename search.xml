<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MockMvc</title>
    <url>/2023/12/09/MockMvc/</url>
    <content><![CDATA[<h1 id="MockMvc"><a href="#MockMvc" class="headerlink" title="MockMvc"></a>MockMvc</h1><p>MockMvc是由spring-test包提供，实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，使得测试速度快、不依赖网络环境。同时提供了一套验证的工具，结果的验证十分方便。</p>
<p><strong>开发步骤：</strong></p>
<ul>
<li><p>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span> (<span class="string">&quot;/logger&quot;</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">testLogger</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass())</span><br><span class="line">    logger.debug (<span class="string">&quot;测试级别日志&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在test包下创建一个测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(classes = &#123;SpringbootApplication.class &#125;,webEnvironment =SpringBootTest.WebEnvfironment.RANDOM_PORT)</span></span><br><span class="line">)</span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockMvcTestor</span></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;测试用例名称&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMock1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MvcResult res = mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/logger&quot;</span>))</span><br><span class="line">            <span class="comment">// 对状态码进行校验</span></span><br><span class="line">         	.andExpect(MockMvcResultMatchers.status().isok())</span><br><span class="line">            <span class="comment">// 对比内容</span></span><br><span class="line">            .andExpect(MockMvcResultMatchers.content().string(<span class="string">&quot;SUCCESS&quot;</span>))</span><br><span class="line">            <span class="comment">// 结果正确后打印结果</span></span><br><span class="line">            .andDo(MockMvcResultHandlers.print())</span><br><span class="line">            <span class="comment">// 真正执行请求</span></span><br><span class="line">            .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;高级用法&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMock2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MvcResult res = mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/logger&quot;</span>)</span><br><span class="line">                                       .header(<span class="string">&quot;token&quot;</span>,<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">                                       .param(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;123&quot;</span>))</span><br><span class="line">            <span class="comment">// 对状态码进行校验</span></span><br><span class="line">         	.andExpect(MockMvcResultMatchers.status().isok())</span><br><span class="line">            <span class="comment">// 对比内容</span></span><br><span class="line">            .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">&quot;access token&quot;</span>).value(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">            <span class="comment">// 结果正确后打印结果</span></span><br><span class="line">            .andDo(MockMvcResultHandlers.print())</span><br><span class="line">            <span class="comment">// 真正执行请求</span></span><br><span class="line">            .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>阿里有个mock框架【TestableMock】</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring全家桶</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>MockMvc</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL读写分离</title>
    <url>/2023/12/19/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="主从读写分离"><a href="#主从读写分离" class="headerlink" title="主从读写分离"></a>主从读写分离</h1><p>大部分系统的访问模型是<strong>读多写少</strong>，读写请求量的差距可能达到几个数量级。</p>
<p>因此，我们优先考虑数据库如何抵抗更高的查询请求，那么首先你需要<strong>把读写流量区分开</strong>，因为这样才方便<strong>针对读流量做单独的扩展</strong>（但是不易太对IO线程消耗太大，一般一个主库最多挂 3～5 个从库），这就是我们所说的主从读写分离。从库也可以当成一个备库来使用，以避免主库故障导致数据丢失。</p>
<p><strong>主从读写分离有两个技术关键点：</strong></p>
<ol>
<li><p>一个是数据的拷贝，我们称为主从复制；</p>
</li>
<li><p>在主从分离的情况下，我们如何屏蔽主从分离带来的访问数据库方式的变化，让开发像是在使用单一数据库一样。</p>
</li>
</ol>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>以MySQL的主从复制为例，MySQL 的主从复制是依赖于 binlog 的，主从复制就是将 binlog 中的数据从主库传输到从库上，一般这个过程是异步的，即主库上的操作不会等待 binlog 同步的完成。</p>
<p><strong>同步完整流程：</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230320152932581.png" alt="image-20230320152932581" style="zoom: 80%;" />

<p>一个事务日志同步的完整过程是这样的：</p>
<ol>
<li>在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。</li>
<li>在备库B上执行start slave命令，这时候备库会启动两个线程，就是图中的io_thread和sql_thread。其中io_thread负责与主库建立连接。</li>
<li>主库A校验完用户名、密码后，创建一个 log dump 线程来开始按照备库B传过来的位置，从本地读取binlog，发给B。</li>
<li>备库B拿到binlog后，写到本地文件，称为中转日志（relay log），避免写入从库实际存储会比较耗时，最终造成从库和主库延迟变长。</li>
<li>sql_thread读取中转日志，解析出日志里的命令，并执行。</li>
</ol>
<p><strong>缺点：</strong></p>
<ul>
<li>带来了部署上的复杂度。</li>
<li>主从同步可能会产生延迟，正常的时间是在毫秒级别，一旦落后的时间达到了秒级别就需要告警了。</li>
</ul>
<blockquote>
<ul>
<li>主从同步问题会在MySQL中讲解，如果遇到刚插入就需要查询的业务可以强制查询主库避免主从延迟，或者保证MySQL是MGR那种全同步高可用方案。</li>
<li>还可以利用KeepAlived 做了一个简单的自动主从切换机制，或利用云服务本身提供的这种自动切换功能。</li>
</ul>
</blockquote>
<h2 id="如何访问数据库"><a href="#如何访问数据库" class="headerlink" title="如何访问数据库"></a>如何访问数据库</h2><p>当使用了多节点实现主从读写分离之后，访问方式就跟以前的一个地址有差别了；现在需要使用一个主库地址和多个从库地址，并且需要区分写入操作和查询操作。</p>
<p>为了降低实现的复杂度，业界涌现了很多数据库中间件来解决数据库的访问问题，这些中间件可以分为两类。</p>
<ul>
<li><p>淘宝的 TDDL（ Taobao Distributed Data Layer）</p>
<p>这种以代码形式内嵌运行在应用程序内部。你可以把它看成是一种<strong>数据源的代理</strong>，它的配置管理着多个数据源，每个数据源对应一个数据库，可能是主库，可能是从库。当有一个数据库请求时，中间件将 SQL 语句发给某一个指定的数据源来处理，然后将处理结果返回。</p>
<p>特点：</p>
<ul>
<li>简单易用，没有多余的部署成本</li>
<li>只支持Java</li>
</ul>
</li>
<li><p>另一类是单独部署的代理层方案，如早期阿里巴巴开源的 Cobar，基于 Cobar 开发出来的 Mycat，360 开源的 Atlas，美团开源的基于 Atlas 开发的 DBProxy 等等。</p>
<p>这一类中间件部署在独立的服务器上，业务代码如同在使用单一数据库一样使用它，实际上它内部管理着很多的数据源，当有数据库请求时，它会对 SQL 语句做必要的改写，然后发往指定的数据源。</p>
<p>特点：</p>
<ul>
<li>独立部署，方便维护升级</li>
<li>支持多种语言</li>
<li>所有的 SQL 语句都需要跨两次网络：从应用到代理层和从代理层到数据源</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>MySQL读写分离</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL分库分表</title>
    <url>/2023/12/22/MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><p>系统正在持续不断地发展，注册的用户越来越多，数据库中存储的数据也越来越多。</p>
<p>会遇到的问题：</p>
<ul>
<li>这时即使你使用了索引，索引占用的空间也随着数据量的增长而增大，数据库就无法缓存全量的索引信息，那么就需要从磁盘上读取索引数据，就会影响到查询的性能了。</li>
<li>数据量的增加也占据了磁盘的空间，数据库在备份和恢复的时间变长。</li>
<li>不同模块的数据，比如用户数据和用户关系数据，全都存储在一个主库中，一旦主库发生故障，所有的模块都会受到影响。</li>
</ul>
<p>这些问题都是数据库的写入请求量大造成的性能和可用性方面的问题，一般采取的措施就是对数据进行分片即<strong>分库分表</strong>。</p>
<blockquote>
<p>为什么要分库分表：</p>
<ul>
<li>如果数据库已经到了写瓶颈怎么办？要么优化写操作，要么分库。<ul>
<li>对于写瓶颈来说，分区表可以缓解问题，而读写分离几乎没有效果，比如频繁地增删改操作。</li>
</ul>
</li>
<li>如果数据库已经到了读瓶颈怎么办？要么优化读操作，要么加从库，要么分库或分表。</li>
<li>对于硬件瓶颈来说，读写分离、分区表基本上也解决不了，比如写操作引发的网络带宽问题。</li>
</ul>
<p>一般非必要不进行分库分表，大致要求如下：</p>
<ul>
<li>单表数据超过1000w</li>
<li>单表数据文件大小超过20GB</li>
</ul>
<p>方案分为：</p>
<ul>
<li>单库多表：有效缩小磁盘扫描范围<ul>
<li>单表数据量过大、锁竞争等跟表维度相关的资源引发的性能问题时选择</li>
</ul>
</li>
<li>多库单表：根据不同业务分库<ul>
<li>当单一数据库实例无法满足整体业务的读写需求时，可以考虑根据业务模块分库。</li>
</ul>
</li>
<li>多库多表：提供数据库并行处理能力<ul>
<li>当系统面临高并发、大数据量的情况，即使分库仍然无法满足性能需求时，可以选择分库分表。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>好处：</strong></p>
<ul>
<li>每个节点只保存部分的数据，这样可以有效地<strong>减少单个数据库节点和单个数据表中存储的数据量</strong>，在解决了数据存储瓶颈的同时也能有效地提升数据查询的性能。</li>
<li>让单一写请求变为多个数据分片节点的请求，在一定程度上也会提升并发写入的性能。</li>
</ul>
<p>数据库分库分表的方式有两种：一种是<strong>垂直拆分</strong>，另一种是<strong>水平拆分</strong>。</p>
<h2 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h2><p>垂直拆分，顾名思义就是对数据库竖着拆分，也就是将数据库的表拆分到多个不同的数据库中。原则一般是<strong>按照业务类型来拆分</strong>，核心思想是专库专用，将业务耦合度比较高的表拆分到单独的库中。这样在数据层面还起到<strong>故障隔离</strong>的作用。</p>
<p><strong>垂直拆分示例图：</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230422165257447.png" alt="image-20230422165257447" style="zoom:67%;" />

<p><strong>问题：</strong></p>
<p>垂直拆分依然不能解决某一个业务模块的数据大量膨胀的问题，一旦你的系统遭遇某一个业务库的数据量暴增，就需要将数据拆分到多个数据库和数据表中，<strong>也就是对数据库和数据表做水平拆分了。</strong></p>
<h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><p>水平拆分就和垂直拆分的关注点不一样了，关注点在数据的特点，将单一数据表按照某一种规则拆分到多个数据库和多个数据表中。</p>
<p><strong>常见拆分的规则：</strong></p>
<ol>
<li><p>按照某一个<strong>字段的哈希值</strong>做拆分，这种拆分规则比较适用于实体表；</p>
<p>比如说用户表，内容表，我们一般按照这些实体表的 ID 字段来拆分，先对ID做一次hash对n取余得到是哪个库，再对m取余得到哪个表。</p>
<p><strong>缺点：</strong>存在范围查询跨库问题</p>
</li>
<li><p>另一种比较常用的是<strong>按照某一个字段的区间</strong>来拆分，比较常用的是时间字段。</p>
<p>比如说内容表，按照创建时间进行分片，根据数据量来判断每天一个表或者每个月一个表。在查询时就可以根据创建时间先定位数据存储在哪个表里面，再按照查询条件来查询。</p>
<p><strong>缺点：</strong>存在明显的热点问题，数据倾斜，例如一般只会关注最近的数据。</p>
<p><strong>注意事项：</strong>需要提前创建好数据库表，不然没库表可写会发生故障。</p>
</li>
</ol>
<h2 id="容量预估"><a href="#容量预估" class="headerlink" title="容量预估"></a>容量预估</h2><p>分库分表容量确定需要依据两点：你现在有多少数据、你将来有多少数据。所以如果讨论到了容量估算的问题，你就要直接指出核心：<strong>现有数据和增长趋势。</strong></p>
<ul>
<li><p>存量数据：存量数据是最好处理的。基本上你只需要简单计算一下就可以得到。</p>
<blockquote>
<p>不过并不是所有存量数据都需要进行分库分表，部分不重要的、用不上的、历史悠久的数据，不如直接归档，或者放到大数据平台上。所以你真正需要计算的是那些还需要线上继续查询的数据的量。</p>
</blockquote>
</li>
<li><p>增长趋势：你需要考虑两点，一个是现有<strong>数据增长率（一阶导数）</strong>，另一个是<strong>数据增长率的变化趋势（二阶导数）</strong>。</p>
<ul>
<li>数据增长率：数据的增长趋势只需要根据公司的战略规划来就可以（按照业务可能的增长上限3-5年来评估，避免扩容）。比如说今年公司的目标是业务翻倍，那么就可以认为今年数据的增长率是 100%。</li>
</ul>
</li>
</ul>
<blockquote>
<p>大厂在容量规划的时候都是按照 2 的幂来规划的，比如说 4×2×8 ，或者 8×4×32。而且在扩容的时候，也是按照 2 的幂来进行的。也就是说，基本上扩容都是选择容量翻倍。这其实是因为 2 的特性，在使用哈希取余来进行分库分表的时候，可以使用位运算来计算余数，非常高效。</p>
</blockquote>
<h2 id="分库分表引入的问题："><a href="#分库分表引入的问题：" class="headerlink" title="分库分表引入的问题："></a>分库分表引入的问题：</h2><ul>
<li><p><strong>分布式事务问题：</strong></p>
<p>需要引入XA、TCC、SAGA等分布式事务解决方案。</p>
</li>
<li><p><strong>查询的复杂度问题：</strong></p>
<p>原先只需要根据查询条件到从库中查询数据即可，现在则需要先确认数据在哪一个库表中，再到那个库表中查询数据。但是可以通过前面提到的<strong>数据库中间件</strong>来解决。</p>
</li>
<li><p><strong>分库分表键问题：</strong></p>
<p>无论是哈希拆分还是区间段的拆分，我们首先都需要选取一个数据库字段，这样之后<strong>所有的查询都需要带上这个字段</strong>，才能找到数据所在的库和表，否则就只能向所有的数据库和数据表发送查询命令。</p>
<ul>
<li><p>如果主键Id中可以解析出分表键的话，这种方案是最简单的。</p>
</li>
<li><p>如果需要按照别的字段来查询，最合适的解决方案是<strong>建立一个该字段和 ID 的映射表</strong>。在查询的时候要先通过昵称查询到 ID，再通过 ID 查询完整的数据。</p>
<blockquote>
<p>一般来说，在设计中间表的时候应该包含尽可能少的列，而且这些列的值应该尽可能不变，会频繁更新的列就不要放了，而且大表存在表结构改变问题。</p>
</blockquote>
</li>
<li><p>二次分库分表：二次分库分表指复制出来一份数据，然后尝试再进行分库分表。所以你的系统里面就会有两份数据，分别按照不同的分库分表规则存储。缺陷就是数据一致性问题，以及数据复制一份需要很多存储空间。</p>
</li>
<li><p>使用其他中间件：为了支持复杂多样的查询，可以尝试使用别的中间件，比如说 Elasticsearch。为了减轻 Elasticsearch 的压力，我们选择了只同步部分字段。一些非常庞大的字段，比如说 TEXT 或者 BLOB 本身我们是不会同步过去的。</p>
</li>
<li><p>我们还有一些兜底措施，也就是如果一个查询确实没办法使用前面那些方案的时候，那就可以考虑使用广播。也就是说直接把所有的请求发送到所有的候选节点里面，然后收集到的数据就是查询的结果。</p>
</li>
</ul>
<blockquote>
<p>数据同步问题：在引入中间表、二次分库分表和使用其他中间件三个解决方案里面，都面临一个同样的问题：你怎么进行数据同步？</p>
<ul>
<li>双写：就是在写入源数据表的时候，同时写到另外一个地方。这个可以通过改造 ORM 或者分库分表中间件来达成。</li>
<li>利用 Canal：利用 Canal 之类的框架监听 binlog，然后异步地把数据库同步到其他地方。</li>
</ul>
<p>不管是双写，还是监控 binlog，都绕不开失败这个话题。那失败的时候怎么办呢？无非就是各种重试（<strong>Spring-Retry</strong>），在重试都失败之后进行异步修护，如果修护失败就人手工介入处理。</p>
<p><strong>亮点方案：</strong></p>
<p>在分库分表之后，为了充分满足不同情况下的查询需求，我们公司综合使用了三种方案：引入中间表、二次分库分表和 Elasticsearch。对于卖家查询来说，我们直接复制了一份数据，按照卖家 ID 分库分表。对于一些复杂的查询来说，就是利用 Elasticsearch。还有一些查询是通过建立中间表来满足，比如说商品 ID 和订单 ID 的映射关系。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20231205111335092.png" alt="image-20231205111335092"></p>
<p>买家和卖家同时修改订单问题：</p>
<ul>
<li>所以类似的场景最好是采用<strong>分布式锁和双写方案</strong>。比如买家修改状态的时候，要先拿到分布式锁，然后同时修改买家库和卖家库。当然，要是覆盖数据也没关系，那么就还是可以继续采用 Canal 的同步方案</li>
<li>也可以考虑只允许从买家库进去修改数据，也就是说，不允许直接修改卖家库的数据。举个例子，如果卖家想要修改某个订单的数据，那么他需要在卖家库查到订单的信息，但是在修改的时候要拿着订单信息去买家库修改。</li>
</ul>
</blockquote>
</li>
<li><p><strong>一些数据库的特性在实现时可能变得很困难：</strong></p>
<ul>
<li><p>比如说多表的 JOIN 在单库时是可以通过一个 SQL 语句完成的，但是拆分到多个数据库之后就无法跨库执行 SQL 了。</p>
<p><strong>解决：</strong>可以在业务层去处理先查A库再查B库；使用MyCat、ShardingSphere实现两表跨库join</p>
</li>
<li><p>count()问题</p>
<p><strong>解决：</strong>将计数的数据单独存储在一张表中或者记录在 Redis 里面</p>
</li>
<li><p>跨节点分页查询问题</p>
<p><strong>解决：</strong></p>
<ul>
<li>业务端单节点各取n条，之后合并运算取top n；</li>
<li>禁止跨页查询，通过上一次查询条件来进行where筛除</li>
<li>或者就同步到es中在es中进行查询</li>
</ul>
<blockquote>
<p>亮点方案：</p>
<ul>
<li><p>二次查询：二次查询的基本理念是先尝试<strong>获得某个数据的全局偏移量，然后再根据这个偏移量来计算剩下数据的偏移量</strong>。</p>
<p>假设你的分库分表总共有 N 个表，查询是 LIMIT X OFFSET Y，步骤如下：</p>
<ul>
<li>首先发送查询语句 LIMIT X OFFSET Y/N 到所有的表。</li>
<li>找到所有返回结果中的最小值（升序），记为 min。</li>
<li>执行第二次查询，关键是 BETWEEN min AND max。其中 max 是在第一次查询的数据中每个表各自的最大值。</li>
<li>根据 min、第一次查询和第二次查询的值来确定 min 的全局偏移量。总的来说，min 在某个表里面的偏移量这样计算：如果第二次查询比第一次查询多了 K 条数据，那么偏移量就是 Y 除以 N 减去 K。然后把所有表的偏移量加在一起，得到的就是 min 的全局偏移量。</li>
<li>根据 min 的全局偏移量，在第二次查询的结果里面向后补足到 Y，得到第一条数据的位置，再取 X 条。</li>
</ul>
</li>
<li><p>引入中间表：引入中间表的意思是额外存储一份数据，只用来排序。这个方案里面就是在中间表里<strong>加上排序相关的列</strong>。</p>
<p>缺点：</p>
<ul>
<li><p>这个方案有两个明显的缺陷，一个是 WHERE 也只能使用中间表上的列；另外一个是维护中间表也会引入数据一致性的问题。</p>
<ul>
<li><p>对于一致性问题：</p>
<p>比较简单的做法就是业务保持双写，也就是写入目标表也写入中间表。不过这里我更加建议使用 <strong>Canal</strong> 之类的框架来监听 binlog，异步更新中间表。这样做的好处是业务完全没有感知，没有什么改造成本。更新的时候可以考虑引入重试机制，进一步降低失败的几率。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>唯一主键生成问题：</strong></p>
<p>当我们分库分表之后，同一个逻辑表的数据被分布到多个库中，这时如果使用数据库自增字段作为主键，那么只能保证在这个库中是唯一的，无法保证全局的唯一性。</p>
<blockquote>
<ul>
<li><p>uuid：</p>
<ul>
<li><strong>UUID 不是递增的</strong>：<ul>
<li>因为这样可以迫使数据库的树朝着一个方向增长，而不会造成中间叶节点分裂，这样插入性能最好。随机会引起更加频繁地页分裂，在糟糕的情况下，这种分裂可能引起连锁反应，整棵树的树形结构都会受到影响。</li>
<li>顺序读问题：自增主键还有一个好处，就是数据会有更大的概率按照主键的大小排序，两条主键相近的记录，在磁盘上位置也是相近的。</li>
</ul>
</li>
</ul>
</li>
<li><p>设置步长递增：</p>
<p>例如：经过分库分表之后我有十个表，那么我可以让每一个表按照步长来生成自增 ID。比如说第一个表就是生成 1、11、21、31 这种 ID，第二个表就是生成 2、12、22、32 这种 ID。</p>
<p>ID 虽然并不一定是全局递增的，但是在一个表内部，它肯定是递增的。这个方案的性能基本取决于数据库性能，应用层面上也不需要关注。</p>
</li>
</ul>
</blockquote>
<p><strong>解决：</strong></p>
<ul>
<li><p>基于 Snowflake 算法</p>
<p>Snowflake 的核心思想是将 64bit 的二进制数字分成若干部分，每一部分都存储有特定含义的数据，比如说时间戳、机器 ID、序列号等等，最终生成全局唯一的有序 ID。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230424151618698.png" alt="image-20230424151618698"></p>
<p>有些时候还可以缩短序列号，加入一些业务ID字段；又或者进一步切割，机器 ID 前半部分表示机器，后半部分可以表示这个机器上用于产生 ID 的进程、线程或者协程。</p>
<blockquote>
<p>注意嵌入业务代码带来的问题：</p>
<ul>
<li><p>无法保证全局递增，但是性能比完全随机好</p>
</li>
<li><p>产生一样 ID 的概率不是没有，而是极低。它要求同一个用户在同一时刻创建了两个订单，然后订单 ID 的随机数部分一模一样，这是一个很低的概率。</p>
<p>解决方案其实也很简单，就是在插入数据的时候，如果返回了主键冲突错误，那么重新产生一个，再次尝试就可以了。</p>
</li>
</ul>
</blockquote>
<p>实现方式：</p>
<ul>
<li>一种是嵌入到业务代码里，也就是分布在业务服务器中</li>
<li>另外一个部署方式是作为独立的服务部署，这也就是我们常说的发号器服务。</li>
</ul>
<blockquote>
<p>可以利用提前批量取并缓存TLB中来优化发号器。</p>
</blockquote>
<p>问题：</p>
<ul>
<li><p>依赖于时间戳，一旦系统时间不准，就有可能生成重复的 ID，时间回拨问题。</p>
<p>发现系统时钟不准，就可以让发号器暂时拒绝发号，直到时钟准确为止</p>
</li>
<li><p>如果请求发号器的 QPS 不高，比如说发号器每毫秒只发一个 ID，就会造成生成 ID 的末位永远是 1，那么在分库分表时如果使用 ID 作为分区键就会造成库表分配的不均匀。</p>
<ol>
<li>时间戳不记录毫秒而是记录秒，这样在一个时间区间里可以多发出几个号。</li>
<li>生成的序列号的起始号可以做一下随机。</li>
</ol>
</li>
<li><p>并发很高，序列号不够用：</p>
<ol>
<li>如果 12 比特不够，你就给更多比特，这部分比特可以从时间戳里面拿出来</li>
<li>如果还不够，那么就让业务方等待一下，到下一个时刻，自然又可以生成新的 ID 了，也就是时间戳变了，这也是一种变相的限流。</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>其他唯一主键方案：</p>
<ul>
<li>百度开源的UidGenerator（仅支持单机部署）使用Snowflake算法，单机QPS可达600万。</li>
<li>美团Leaf（分布式ID生成系统），QPS近5万。</li>
<li>微信序列号生成器</li>
</ul>
</blockquote>
</li>
<li><p>扩容问题：</p>
<ul>
<li>范围分表容易扩容，但存在尾部热点问题</li>
<li>Hash分表极难扩容，建议改为一致性Hash，但迁移难度较大</li>
</ul>
</li>
<li><p>访问查询问题：例如对于以uid为hash进行分库后，如果需要按照username来查询就会遇到不知道去哪个库的问题。</p>
<ul>
<li>基因法：会改变uid生成的策略，会对username进行md5加密取最后两位，uid的生成策略就是前62位随机生成+上面的两位组成（不一定是两位，看有几台数据库2的次方）。<ul>
<li>优点：性能极好，不用额外查询便可快捷分表查询。</li>
<li>缺点：<ul>
<li>建议2(1)/4(2)/8(3)/16(4)数据库节点，提前规划不具备迁移条件</li>
<li>主键生成器算法要求更高，如62+2全局唯一</li>
<li>只能由1个非主键字段与之主键对应</li>
</ul>
</li>
</ul>
</li>
<li>倒排索引：生成Redis倒排索引，key为需要查询的<code>关键字:值</code>，value为<code>uid,服务器编号</code><ul>
<li>优点：最通用的分库分表检索方案，几乎适用于所有系统。</li>
<li>缺点：<ul>
<li>控制不好数据量爆炸，对Redis内存需求量大（如果SSD性能好，也可使用InnoDB表替代)</li>
<li>需要手动维护数据库与缓存间的一致性，存在软状态</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当然，虽然分库分表会对我们使用数据库带来一些不便，但是相比它所带来的扩展性和性能方面的提升，我们还是需要做的。</p>
<p>所以总结了下面分库分表的原则：</p>
<ol>
<li><p>如果在性能上没有瓶颈点那么就尽量不做分库分表；</p>
</li>
<li><p>如果要做，就尽量一次到位，比如说 16 库，每个库 64 表就基本能够满足几年内你的业务的需求。</p>
</li>
<li><p>如果更加熟悉 NoSQL 数据库，那么也可以考虑使用这些 NoSQL 数据库替代传统的关系型数据库。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>MySQL分库分表</tag>
      </tags>
  </entry>
  <entry>
    <title>利用NoSQL优化数据库</title>
    <url>/2023/12/27/%E5%88%A9%E7%94%A8NoSQL%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="利用NoSQL数据库"><a href="#利用NoSQL数据库" class="headerlink" title="利用NoSQL数据库"></a>利用NoSQL数据库</h1><p>当系统中某业务的数据已经无法用分库分表来解决的时候，就应该考虑是否需要利用NoSQL数据库来补充传统关系型数据库了。因为它有着<strong>天生分布式的能力</strong>，能够提供<strong>优秀的读写性能</strong>，可以很好地补充传统关系型数据库的短板。但是只是互补关系不能完全替代。</p>
<h2 id="提高写入性能"><a href="#提高写入性能" class="headerlink" title="提高写入性能"></a>提高写入性能</h2><p>数据库系统大多使用的是传统的机械磁盘，对于机械磁盘的访问方式有两种：一种是随机 IO；另一种是顺序 IO。</p>
<p>以 MySQL 的 InnoDB 存储引擎来说，更新 binlog、redolog、undolog 都是在做顺序 IO，而更新 datafile 和索引文件则是在做随机 IO，而为了减少随机 IO 的发生，关系数据库已经做了很多的优化，比如说写入时先写入内存，然后批量刷新到磁盘上，但是随机 IO 还是会发生。</p>
<p>而NoSQL大多是直接写入内存，为了持久化会做顺序IO以日志形式写入磁盘。它们的<strong>核心思想就是将随机 IO 变成顺序的 IO，从而提升写入的性能。</strong></p>
<h2 id="场景补充"><a href="#场景补充" class="headerlink" title="场景补充"></a>场景补充</h2><p>例如商品的搜索场景，如果直接使用传统数据库的模糊查询，性能是根据无法接受的。这个时候就可以使用NoSQL来进行场景补充例如：开源组件 <strong>Elasticsearch</strong> 来支持搜索的请求</p>
<p>Elasticsearch 作为一种常见的 NoSQL 数据库，<strong>就以倒排索引作为核心技术原理，为你提供了分布式的全文搜索服务，这在传统的关系型数据库中使用 SQL 语句是很难实现的。</strong></p>
<h2 id="提升扩展性"><a href="#提升扩展性" class="headerlink" title="提升扩展性"></a>提升扩展性</h2><p>在扩展性方面，很多 NoSQL 数据库也有着先天的优势。例如本来规划好的分库分表大小，但是上线后发现不够了，如果再扩展就会遇到很麻烦的数据迁移过程，所以这个时候也可以考虑使用 NoSQL 数据库来彻底解决扩展性的问题。例如 <strong>MongoDB 就有三个扩展性方面的特性。</strong></p>
<ul>
<li>其一是 <strong>Replica</strong>，也叫做副本集，你可以理解为主从分离，也就是通过将数据拷贝成多份来保证当主挂掉后数据不会丢失。</li>
<li>其二是 <strong>Shard</strong>，也叫做分片，你可以理解为分库分表，即将数据按照某种规则拆分成多份，存储在不同的机器上。</li>
<li>其三是<strong>负载均衡</strong>，就是当 MongoDB 发现 Shard 之间数据分布不均匀，会启动 Balancer 进程对数据做重新的分配，最终让不同 Shard Server 的数据可以尽量的均衡。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Ajax</title>
    <url>/2022/08/22/%E5%89%8D%E7%AB%AF/Ajax/</url>
    <content><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><h3 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h3><p>1.设置跨域属性的响应头</p>
<ul>
<li>response.setHeader(‘Access-Controll-Allow-Origin’.’*’);</li>
</ul>
<p>2.jsonp（利用一些h5标签可以跨域的特性发送请求）</p>
<ul>
<li>发送jsonp请求</li>
</ul>
<h3 id="发送异步请求"><a href="#发送异步请求" class="headerlink" title="发送异步请求"></a>发送异步请求</h3><h3 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;http://127.0.0.1:8000/server?a=100&amp;b=100&#x27;</span>);</span><br><span class="line"><span class="comment">//设置响应体数据的类型</span></span><br><span class="line">xhr.responseType = <span class="string">&#x27;json&#x27;</span>;</span><br><span class="line"><span class="comment">//设置请求头</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">xhr.send();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;http://127.0.0.1:8000/server&#x27;</span>);</span><br><span class="line"><span class="comment">//设置响应体数据的类型</span></span><br><span class="line">xhr.responseType = <span class="string">&#x27;json&#x27;</span>;</span><br><span class="line"><span class="comment">//设置请求头</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">xhr.send(<span class="string">&#x27;a=100&amp;b=100&#x27;</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h3><h4 id="请求超时"><a href="#请求超时" class="headerlink" title="请求超时"></a>请求超时</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超时设置</span></span><br><span class="line">xhr.timeout = <span class="number">2000</span>;</span><br><span class="line"><span class="comment">//超时回调</span></span><br><span class="line">xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;请稍后重试！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//网络异常回调</span></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;你的网络似乎出了问题！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取消请求的发送</span></span><br><span class="line">xhr.abort();</span><br></pre></td></tr></table></figure>
<h4 id="解决请求重复发送"><a href="#解决请求重复发送" class="headerlink" title="解决请求重复发送"></a>解决请求重复发送</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isSending = <span class="literal">false</span>;</span><br><span class="line">btn[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isSending) x.abort();</span><br><span class="line">	<span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"> 	isSending = <span class="literal">true</span>;  </span><br><span class="line">    xhr.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;http://127.0.0.1:8000/server&#x27;</span>);</span><br><span class="line">	xhr.send();	</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">            isSending = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="jQuery发送异步请求"><a href="#jQuery发送异步请求" class="headerlink" title="jQuery发送异步请求"></a>jQuery发送异步请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.get(<span class="string">&#x27;http://127.0.0.0:8080/server&#x27;</span>,&#123;<span class="attr">a</span>:<span class="number">100</span>,<span class="attr">b</span>:<span class="number">200</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;<span class="built_in">console</span>.log(data);&#125;,<span class="string">&#x27;json&#x27;</span>);</span><br><span class="line">$.post(<span class="string">&#x27;http://127.0.0.0:8080/server&#x27;</span>,&#123;<span class="attr">a</span>:<span class="number">100</span>,<span class="attr">b</span>:<span class="number">200</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;<span class="built_in">console</span>.log(data);&#125;,<span class="string">&#x27;json&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>通用方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">&#x27;http://127.0.0.0:8080/server&#x27;</span>,</span><br><span class="line">    data:&#123;<span class="attr">a</span>:<span class="number">100</span>,<span class="attr">b</span>:<span class="number">200</span>&#125;,</span><br><span class="line">    type:<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    dataType:<span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;,</span><br><span class="line">    timeout:<span class="number">2000</span>,<span class="comment">//超时时间</span></span><br><span class="line">    error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;请稍后重试！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>异步通信</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>博客的搭建</title>
    <url>/2021/02/22/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="博客的搭建"><a href="#博客的搭建" class="headerlink" title="博客的搭建"></a>博客的搭建</h1><h2 id="环境的准备"><a href="#环境的准备" class="headerlink" title="环境的准备"></a>环境的准备</h2><p><strong>1.安装node.js</strong></p>
<ul>
<li>下载：官方地址：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></li>
<li>直接安装：无脑next下一步</li>
<li>校验是否安装成功：<code>node -v</code></li>
</ul>
<p><strong>2.安装镜像源cnpm</strong></p>
<ul>
<li>利用npm安装：<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></li>
</ul>
<p><strong>3.安装hexo博客框架</strong></p>
<ul>
<li>利用cnpm安装：<code>cnpm install -g hexo-cli</code></li>
<li>校验：<code>hexo -v</code></li>
</ul>
<p><strong>4.安装git</strong></p>
<ul>
<li>下载：官方地址:<a href="https://git-scm.com/">https://git-scm.com/</a></li>
<li>直接安装：无脑next下一步</li>
<li>校验是否安装成功：鼠标右会多两个git选项</li>
</ul>
<p><strong>5.创建博客放置文件夹</strong></p>
<ul>
<li>选择一个你想存放博客的地方创建一个文件夹</li>
</ul>
<h2 id="安装博客"><a href="#安装博客" class="headerlink" title="安装博客"></a>安装博客</h2><ol>
<li><p>在你文件夹下右键点击<strong>Git Bash Here</strong>进入git命令行</p>
</li>
<li><p>输入**hexo init **命令</p>
</li>
<li><p>出现Start blogging with Hexo!说明安装成功</p>
</li>
</ol>
<h2 id="博客使用"><a href="#博客使用" class="headerlink" title="博客使用"></a>博客使用</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol>
<li>先使用hexo new “xxxx”创建一篇文章（创建一篇博文（生成的md文件在source_posts路径下））</li>
<li>然后再hexo clean清理缓存</li>
<li>hexo generate/hexo g 生成静态文件</li>
<li>hexo s启动博客</li>
<li>在浏览器中输入<a href="http://localhost:4000/%E5%8D%B3%E5%8F%AF%E8%AE%BF%E9%97%AE">http://localhost:4000/即可访问</a></li>
<li>部署网站：<code>hexo d</code>后续会使用</li>
</ol>
<blockquote>
<p>更多具体命令参考<a href="https://hexo.io/zh-cn/docs/commands.html">https://hexo.io/zh-cn/docs/commands.html</a></p>
</blockquote>
<h2 id="博客部署"><a href="#博客部署" class="headerlink" title="博客部署"></a>博客部署</h2><p><strong>1.创建一个远程厂库</strong></p>
<ul>
<li>仓库名一定为[github的昵称].github.io</li>
</ul>
<p><strong>2.安装部署插件</strong></p>
<ul>
<li><code>cnpm install --save hexo-deployer-git</code></li>
</ul>
<p><strong>3.在文件夹根目录_config.yml中配置部署</strong></p>
<ul>
<li><p>原生样子：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230321090223900.png" alt="image-20230321090223900" style="zoom:67%;" />
</li>
<li><p>修改后：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230321090255009.png" alt="image-20230321090255009" style="zoom:67%;" />

</li>
</ul>
<p><strong>4.部署</strong></p>
<ul>
<li><code>hexo d</code></li>
</ul>
<p><strong>5.浏览博客</strong></p>
<ul>
<li>地址：<a href="https://iooooot.github.io/">https://iooooot.github.io/</a></li>
</ul>
<blockquote>
<p>注意如果github没有打开<strong>github-pages</strong>，可能会出现404的情况。</p>
</blockquote>
<h2 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h2><p><strong>1.找hexo主题</strong></p>
<ul>
<li>例如：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></li>
</ul>
<p><strong>2.下载主题</strong></p>
<ul>
<li>直接克隆下来：<code>$ git clone 地址</code></li>
</ul>
<p><strong>3.安装主题</strong></p>
<ul>
<li>直接将<strong>克隆下来的文件夹放在博客根目录下的themes文件下</strong></li>
</ul>
<p><strong>4.修改配置文件</strong></p>
<ul>
<li><p>再次修改<strong>根目录下的_config.yml</strong>：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230321091020629.png" alt="image-20230321091020629" style="zoom:67%;" />

</li>
</ul>
<p><strong>5.自行美化</strong></p>
<ul>
<li>可以参考相应博客说明文档进行个性美化。</li>
</ul>
<p><strong>6.部署</strong></p>
<ul>
<li>重新清理缓存并生成静态文件：<code>hexo clean &amp;&amp; hexo g</code></li>
<li>部署：<code>hexo d</code></li>
</ul>
<blockquote>
<p>若出现 ERROR Deployer not found: git</p>
<p>npm install <code>--</code>save hexo-deployer-git即可</p>
</blockquote>
]]></content>
      <categories>
        <category>工具的使用</category>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Axios</title>
    <url>/2022/08/24/%E5%89%8D%E7%AB%AF/Axios/</url>
    <content><![CDATA[<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>axios是一个基于promise的网络请求库，作用于node.js和浏览器中，它是 isomorphic 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生node.js http模块, 而在客户端 (浏览端) 则使用XMLHttpRequest。</p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ol>
<li>使用npm安装：<code>$ npm install axios</code></li>
<li>使用 cdn：<code>&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.min.js&quot;&gt;&lt;/script&gt;</code></li>
</ol>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="comment">//获取按钮</span></span><br><span class="line">        <span class="keyword">const</span> btns = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个</span></span><br><span class="line">        btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//发送 AJAX 请求</span></span><br><span class="line">            axios(&#123;</span><br><span class="line">                <span class="comment">//请求类型</span></span><br><span class="line">                method: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">                <span class="comment">//URL</span></span><br><span class="line">                url: <span class="string">&#x27;http://localhost:3000/posts/1&#x27;</span>,</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(response);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加一篇新的文章</span></span><br><span class="line">        btns[<span class="number">1</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//发送 AJAX 请求</span></span><br><span class="line">            axios(&#123;</span><br><span class="line">                <span class="comment">//请求类型</span></span><br><span class="line">                method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">                <span class="comment">//URL</span></span><br><span class="line">                url: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span><br><span class="line">                <span class="comment">//设置请求体</span></span><br><span class="line">                data: &#123;</span><br><span class="line">                    title: <span class="string">&quot;今天天气不错, 还挺风和日丽的&quot;</span>,</span><br><span class="line">                    author: <span class="string">&quot;张三&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(response);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新数据</span></span><br><span class="line">        btns[<span class="number">2</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//发送 AJAX 请求</span></span><br><span class="line">            axios(&#123;</span><br><span class="line">                <span class="comment">//请求类型</span></span><br><span class="line">                method: <span class="string">&#x27;PUT&#x27;</span>,</span><br><span class="line">                <span class="comment">//URL</span></span><br><span class="line">                url: <span class="string">&#x27;http://localhost:3000/posts/2&#x27;</span>,</span><br><span class="line">                <span class="comment">//设置请求体</span></span><br><span class="line">                data: &#123;</span><br><span class="line">                    title: <span class="string">&quot;今天天气不错, 还挺风和日丽的&quot;</span>,</span><br><span class="line">                    author: <span class="string">&quot;李四&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(response);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除数据</span></span><br><span class="line">        btns[<span class="number">3</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//发送 AJAX 请求</span></span><br><span class="line">            axios(&#123;</span><br><span class="line">                <span class="comment">//请求类型</span></span><br><span class="line">                method: <span class="string">&#x27;delete&#x27;</span>,</span><br><span class="line">                <span class="comment">//URL</span></span><br><span class="line">                url: <span class="string">&#x27;http://localhost:3000/posts/2&#x27;</span>,</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(response);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="其他使用"><a href="#其他使用" class="headerlink" title="其他使用"></a>其他使用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送 GET 请求</span></span><br><span class="line">btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// axios()</span></span><br><span class="line">    axios.request(&#123;</span><br><span class="line">        method:<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        url: <span class="string">&#x27;http://localhost:3000/comments&#x27;</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送 POST 请求</span></span><br><span class="line">btns[<span class="number">1</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// axios()</span></span><br><span class="line">    axios.post(</span><br><span class="line">        <span class="string">&#x27;http://localhost:3000/comments&#x27;</span>, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;body&quot;</span>: <span class="string">&quot;喜大普奔&quot;</span>,</span><br><span class="line">            <span class="string">&quot;postId&quot;</span>: <span class="number">2</span></span><br><span class="line">        &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//并发多个请求</span></span><br><span class="line">btns[<span class="number">3</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//发送 AJAX 请求</span></span><br><span class="line">    axios.all([axios(&#123;</span><br><span class="line">                <span class="comment">//请求类型</span></span><br><span class="line">                method: <span class="string">&#x27;delete&#x27;</span>,</span><br><span class="line">                <span class="comment">//URL</span></span><br><span class="line">                url: <span class="string">&#x27;http://localhost:3000/posts/2&#x27;</span>,</span><br><span class="line">            &#125;),</span><br><span class="line">               axios(&#123;</span><br><span class="line">                <span class="comment">//请求类型</span></span><br><span class="line">                method: <span class="string">&#x27;PUT&#x27;</span>,</span><br><span class="line">                <span class="comment">//URL</span></span><br><span class="line">                url: <span class="string">&#x27;http://localhost:3000/posts/2&#x27;</span>,</span><br><span class="line">                <span class="comment">//设置请求体</span></span><br><span class="line">                data: &#123;</span><br><span class="line">                    title: <span class="string">&quot;今天天气不错, 还挺风和日丽的&quot;</span>,</span><br><span class="line">                    author: <span class="string">&quot;李四&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    ])then(axios.spread(<span class="function">(<span class="params">res1,res2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res1);</span><br><span class="line">        <span class="built_in">console</span>.log(res2);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其余详细使用见<a href="https://github.com/axios/axios#features">官方文档</a></p>
</blockquote>
<h2 id="axios响应结果结构"><a href="#axios响应结果结构" class="headerlink" title="axios响应结果结构"></a>axios响应结果结构</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `data` 响应体的结果，由服务器提供的响应</span></span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `status` 来自服务器响应的 HTTP 状态码</span></span><br><span class="line">  status: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span></span><br><span class="line">  statusText: <span class="string">&#x27;OK&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` 服务器响应的头信息</span></span><br><span class="line">  headers: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `config` 是为请求提供的配置信息对象</span></span><br><span class="line">  config: &#123;&#125;,</span><br><span class="line">      </span><br><span class="line">   <span class="comment">// &#x27;request&#x27;原生的AJAX对象</span></span><br><span class="line">  request: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认配置</span></span><br><span class="line">axios.defaults.method = <span class="string">&#x27;GET&#x27;</span>;<span class="comment">//设置默认的请求类型为 GET</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;http://localhost:3000&#x27;</span>;<span class="comment">//设置基础 URL</span></span><br><span class="line">axios.defaults.params = &#123;<span class="attr">id</span>:<span class="number">100</span>&#125;; <span class="comment">//设置请求参数</span></span><br><span class="line">axios.defaults.timeout = <span class="number">3000</span>;<span class="comment">// 超时时间</span></span><br><span class="line"></span><br><span class="line">btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    axios(&#123;</span><br><span class="line">        url: <span class="string">&#x27;/posts&#x27;</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建实例对象发送请求"><a href="#创建实例对象发送请求" class="headerlink" title="创建实例对象发送请求"></a>创建实例对象发送请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="comment">//创建实例对象  /getJoke</span></span><br><span class="line">        <span class="keyword">const</span> duanzi = axios.create(&#123;</span><br><span class="line">            baseURL: <span class="string">&#x27;https://api.apiopen.top&#x27;</span>,</span><br><span class="line">            timeout: <span class="number">2000</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里  duanzi 与 axios 对象的功能几近是一样的</span></span><br><span class="line">        <span class="comment">// duanzi(&#123;</span></span><br><span class="line">        <span class="comment">//     url: &#x27;/getJoke&#x27;,</span></span><br><span class="line">        <span class="comment">// &#125;).then(response =&gt; &#123;</span></span><br><span class="line">        <span class="comment">//     console.log(response);</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line">        duanzi.get(<span class="string">&#x27;/getJoke&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(response.data)</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="comment">// Promise</span></span><br><span class="line">        <span class="comment">// 设置请求拦截器  config 配置对象</span></span><br><span class="line">        axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 成功 - 1号&#x27;</span>);</span><br><span class="line">            <span class="comment">//修改 config 中的参数</span></span><br><span class="line">            config.params = &#123;<span class="attr">a</span>:<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> config;</span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 失败 - 1号&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 成功 - 2号&#x27;</span>);</span><br><span class="line">            <span class="comment">//修改 config 中的参数</span></span><br><span class="line">            config.timeout = <span class="number">2000</span>;</span><br><span class="line">            <span class="keyword">return</span> config;</span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 失败 - 2号&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置响应拦截器</span></span><br><span class="line">        axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 成功 1号&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> response.data;</span><br><span class="line">            <span class="comment">// return response;</span></span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 失败 1号&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 成功 2号&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 失败 2号&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送请求</span></span><br><span class="line">        axios(&#123;</span><br><span class="line">            method: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">            url: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span><br><span class="line">        &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;自定义回调处理成功的结果&#x27;</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(response);</span><br><span class="line">        &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取按钮</span></span><br><span class="line"><span class="keyword">const</span> btns = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="comment">//2.声明全局变量</span></span><br><span class="line"><span class="keyword">let</span> cancel = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//发送请求</span></span><br><span class="line">btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//检测上一次的请求是否已经完成</span></span><br><span class="line">    <span class="keyword">if</span>(cancel !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//取消上一次的请求</span></span><br><span class="line">        cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    axios(&#123;</span><br><span class="line">        method: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        url: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span><br><span class="line">        <span class="comment">//1. 添加配置对象的属性</span></span><br><span class="line">        cancelToken: <span class="keyword">new</span> axios.CancelToken(<span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//3. 将 c 的值赋值给 cancel</span></span><br><span class="line">            cancel = c;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response);</span><br><span class="line">        <span class="comment">//将 cancel 的值初始化</span></span><br><span class="line">        cancel = <span class="literal">null</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定第二个事件取消请求</span></span><br><span class="line">btns[<span class="number">1</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cancel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>异步通信</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Axios</tag>
      </tags>
  </entry>
  <entry>
    <title>H5本地存储</title>
    <url>/2022/08/25/%E5%89%8D%E7%AB%AF/H5%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h1 id="浏览器本地存储-webStorage"><a href="#浏览器本地存储-webStorage" class="headerlink" title="浏览器本地存储(webStorage)"></a>浏览器本地存储(webStorage)</h1><h2 id="LoaclStorage"><a href="#LoaclStorage" class="headerlink" title="LoaclStorage"></a>LoaclStorage</h2><p>一种存在浏览器的域对象;并且关闭浏览器之后依然有效，只有手动清除或者清空缓存才会消失。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>localStorage<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>localStorage<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;saveData()&quot;</span>&gt;</span>点我保存一个数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;readData()&quot;</span>&gt;</span>点我读取一个数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;delData()&quot;</span>&gt;</span>点我删除一个数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;clearData()&quot;</span>&gt;</span>点我清空数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">saveData</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//键值对形式，并且所有数据必须都是字符串</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.localStorage.setItem(<span class="string">&#x27;msg&#x27;</span>,<span class="string">&#x27;hello!&#x27;</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> p = &#123;<span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.localStorage.setItem(<span class="string">&#x27;person&#x27;</span>,<span class="built_in">JSON</span>.stringify(p))</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">readData</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;msg&#x27;</span>));</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;person&#x27;</span>)));</span></span><br><span class="line"><span class="javascript">            <span class="comment">//当读取不存的数据时返回null并且JSON解析之后也是null</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;msg3&#x27;</span>));</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">delData</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">localStorage</span>.removeItem(<span class="string">&#x27;msg&#x27;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">clearData</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">localStorage</span>.clear();</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><p>与localStorage功能类似的数据域对象，但是作用域会小于localStorage，关闭浏览器后清空。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>sessionStorage<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>sessionStorage<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;saveData()&quot;</span>&gt;</span>点我保存一个数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;readData()&quot;</span>&gt;</span>点我读取一个数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;delData()&quot;</span>&gt;</span>点我删除一个数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;clearData()&quot;</span>&gt;</span>点我清空数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">saveData</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//键值对形式，并且所有数据必须都是字符串</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.sessionStorage.setItem(<span class="string">&#x27;msg&#x27;</span>,<span class="string">&#x27;hello!&#x27;</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> p = &#123;<span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.sessionStorage.setItem(<span class="string">&#x27;person&#x27;</span>,<span class="built_in">JSON</span>.stringify(p))</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">readData</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(sessionStorage.getItem(<span class="string">&#x27;msg&#x27;</span>));</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(sessionStorage.getItem(<span class="string">&#x27;person&#x27;</span>)));</span></span><br><span class="line"><span class="javascript">            <span class="comment">//当读取不存的数据时返回null并且JSON解析之后也是null</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(sessionStorage.getItem(<span class="string">&#x27;msg3&#x27;</span>));</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">delData</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            sessionStorage.removeItem(<span class="string">&#x27;msg&#x27;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">clearData</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">            sessionStorage.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>原生基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2022/08/23/%E5%89%8D%E7%AB%AF/Promise/</url>
    <content><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise是一门新的技术（ES6规范）,Promis是JS中进行异步编程的新解决方案（旧方案是单纯使用回调函数）</p>
<p>优点：</p>
<ul>
<li>指定回调函数的方式更加灵活</li>
<li>支持链式调用，可以解决回调地狱问题</li>
</ul>
<h3 id="Promise的状态改变"><a href="#Promise的状态改变" class="headerlink" title="Promise的状态改变"></a>Promise的状态改变</h3><p>promise的状态为实例对象中的一个属性[PromiseState]</p>
<p>1.pending(初始状态)变为resolved<br>2.pending(初始状态)变为rejected</p>
<p>说明：只有这2种，且一个promise对象只能改变一次无论变为成功还是失败都会有一个结果数据成功的结果数据一般称为value，失败的结果数据一般称为reason</p>
<h3 id="Promise的工作流程"><a href="#Promise的工作流程" class="headerlink" title="Promise的工作流程"></a>Promise的工作流程</h3><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220626214917661.png"></p>
<h3 id="相关Api"><a href="#相关Api" class="headerlink" title="相关Api"></a>相关Api</h3><p>Promise(excutor){}</p>
<ul>
<li>executor：(resolve,reject)=&gt;{}</li>
<li>resolve函数：内部定义成功时调用的函数value=&gt;{}</li>
<li>reject函数：内部定义失败时我们调用的函数reason=&gt;{}</li>
</ul>
<p>Promise.prototype.then 方法:(onResolved,onRejected)=&gt;{}</p>
<ul>
<li>onResolved函数：成功的回调函数(value)=&gt;{}</li>
<li>onRejected函数：失败的回调函数(reason)=&gt;{}</li>
</ul>
<p>Promise.prototype.catch方法：(onRejected)=&gt;{}</p>
<ul>
<li>onRejected函数：失败的回调函数(reason)=&gt;{}</li>
</ul>
<p>Promise.resolve 方法：(value)=&gt;{}</p>
<ul>
<li>value：成功的数据或promise对象</li>
</ul>
<p>Promise.reject方法：(reason)=&gt;{}</p>
<ul>
<li>reason：失败的原因</li>
</ul>
<p>Promise.all方法：(promise)=&gt;{}</p>
<ul>
<li>promises：包含n个promise的数组</li>
<li>返回一个新的promise，只有所有promise都成功才成功，只要有一个失败就直接失败</li>
</ul>
<p>Promise.race方法：(promise)=&gt;{}</p>
<ul>
<li>promises：包含n个promise的数组</li>
<li>返回一个新的promise,第一个完成的promise的结果就是最终的结果状态</li>
</ul>
<h3 id="初体验"><a href="#初体验" class="headerlink" title="初体验"></a>初体验</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//resolve、reject函数类型的数据</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> n = rand(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">30</span>)&#123;</span><br><span class="line">            resolve(n); <span class="comment">//将promise对象得状态为成功</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            reject(n); <span class="comment">//将promise对象得状态为失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//调用then方法指定异步回调</span></span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>)=&gt;</span> &#123; <span class="comment">//成功时的回调</span></span><br><span class="line">    alert(value+<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">&#125;,<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    alert(reason+<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="发送ajax请求"><a href="#发送ajax请求" class="headerlink" title="发送ajax请求"></a>发送ajax请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>);</span><br><span class="line">        xhr.send();</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">                    resolve(xhr.response);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    reject(xhr.status);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    p.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(reason);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h3><ol>
<li><p>函数的返回值为promise对象</p>
</li>
<li><p>promise对象的结果由async函数执行的返回值决定</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//return 111; 返回非promise数据则返回成功的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;&#125;) <span class="comment">//返回与该promise的状态一致的promise</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="await表达式"><a href="#await表达式" class="headerlink" title="await表达式"></a>await表达式</h3><ol>
<li>await右侧的表达式一般为promise对象，但也可以是其它的凰</li>
<li>如果表达式是promise对象，await返回的是promise成功的值</li>
<li>如果表达式是其它值，直接将此值作为await的返回值</li>
</ol>
<h3 id="async和await结合发送ajxa"><a href="#async和await结合发送ajxa" class="headerlink" title="async和await结合发送ajxa"></a>async和await结合发送ajxa</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendAjax</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">&#x27;GET&#x27;</span>,url);</span><br><span class="line">        xhr.send();</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">                    resolve(xhr.response);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    reject(xhr.status);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dunzi = <span class="keyword">await</span> sendAjax(<span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>);</span><br><span class="line">    alert(dunzi);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>前端</category>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/2022/08/19/%E5%89%8D%E7%AB%AF/JavaScript/</url>
    <content><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>Number：默认值0<ul>
<li>具体细节：<ul>
<li>0开头8进制</li>
<li>0b二进制</li>
<li>默认是10进制</li>
<li>0x表示16进制</li>
<li>Number.MAX_VALUE数字型最大值</li>
<li>Number.MIN_VALUE最小值</li>
<li>Infinity无穷大</li>
<li>-Infinity无穷小</li>
<li>NaN非数字</li>
</ul>
</li>
<li>相关函数：<ul>
<li>isNaN：判断是否是非数字</li>
</ul>
</li>
</ul>
</li>
<li>Boolean：默认值false</li>
<li>String：默认值””<ul>
<li>length属性：返回长度</li>
</ul>
</li>
<li>Undefined：默认值undefined</li>
<li>Null：默认值null</li>
</ul>
<h3 id="类型函数"><a href="#类型函数" class="headerlink" title="类型函数"></a>类型函数</h3><ul>
<li><p>typeof()：判断类型</p>
</li>
<li><p>toString()：转换字符串</p>
</li>
<li><p>String()：转成字符串</p>
</li>
<li><p>parseInt()：转换为数字型</p>
</li>
<li><p>parseFloat()：转换为浮点型</p>
</li>
<li><p>Number()：转换为数字型</p>
</li>
<li><p>Boolean()：转换为布尔值</p>
</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式:"></a>创建方式:</h4><ul>
<li>new出来：new Array()</li>
<li>利用字面量：let arr = [1,2,”1231”,true];</li>
</ul>
<h4 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h4><ul>
<li>利用索引（索引号从0开始）：数组名[索引号]</li>
</ul>
<h4 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h4><ul>
<li>arr.length：获取数组长度</li>
</ul>
<h4 id="判断是否为数组"><a href="#判断是否为数组" class="headerlink" title="判断是否为数组"></a>判断是否为数组</h4><ul>
<li>arr instanceof Array;</li>
<li>Array.isArray();</li>
</ul>
<h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><ul>
<li>arr.push()：添加元素，返回数组长度</li>
<li>arr.pop()：删除最后一个元素，并返回删除的元素值</li>
<li>arr.unshift()：向数组开头添加元素，返回数组长度</li>
<li>arr.shift()：删除数组的第一个元素，返回第一个删除的值</li>
<li>arr.reverse()：翻转数组</li>
<li>arr.sort(function(a,b){return a-b})：数组排序升序</li>
<li>arr.indexOf()：查找元素索引,查不到返回-1</li>
<li>arr.lastIndexOf()：在数组中的最后一个索引</li>
<li>arr.toString()：转换为字符串</li>
<li>arr.join(‘分隔符’):以分隔符转换为字符串</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="申明方式"><a href="#申明方式" class="headerlink" title="申明方式"></a>申明方式</h4><ul>
<li>直接申明：function 函数名(){}</li>
<li>利用变量名：var 变量名 = function(){}</li>
</ul>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li>arguments：可以接收函数的参数（以伪数组的形式）</li>
</ul>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="创建方式-1"><a href="#创建方式-1" class="headerlink" title="创建方式"></a>创建方式</h4><ul>
<li>利用字面量：var obj = {name:”11”,age=18,hello:function(){}};</li>
<li>new一个：var obj = new Object();obj.name=”111”;</li>
<li>利用构造函数：function gg(name,age){this.name=name,this.age=age};</li>
</ul>
<h4 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h4><ul>
<li>利用for循环：for(var k : obj){console.log(k)};</li>
</ul>
<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><h4 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h4><ul>
<li>Math.PI：圆周率</li>
<li>Math.max()：输出最大值</li>
<li>Math.min()：返回最小值</li>
<li>Math.floor()：向下取整</li>
<li>Math.ceil()：向上取整</li>
<li>Math.round：四舍五入</li>
<li>Math.abs()：最对值</li>
<li>Math.random()：返回随机的小数[0~1)</li>
</ul>
<h4 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h4><ul>
<li>构造函数：new Date()/new Date(“2000-10-1 8:8:8”)/new Date(2000,10,1);</li>
<li>格式化日期：通过get获取日期并利用字符串拼接输出</li>
<li>获取总毫秒数：date.valueOf()/Date.now()</li>
</ul>
<h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><ul>
<li>str.indexOf(‘x’)：返回字符索引</li>
<li>str.charAt(index)：返回该位置上的字符</li>
<li>str.charCodeAt(index)：返回该位置字符的ASCII码</li>
<li>str[index]：获取该位字符</li>
<li>concat(str1,str2,…)：拼接字符串</li>
<li>substr(start,length)：截取字符串</li>
<li>slice(start,end)：截取到end位置，end不取</li>
<li>substring(start,end)：基本和slice一致单不接受负值</li>
<li>replace(‘被替换的字符’,’替换为的字符’):替换字符</li>
<li>split(‘分隔符’):将字符串以分隔符分割</li>
</ul>
<h3 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h3><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><ul>
<li>getElementById：以id获取元素</li>
<li>getElementsByTagName：以标签名获取元素</li>
<li>getElementsByClassName：根据类名元素集合</li>
<li>quertSelector(‘选择器’)：以选择器直接选择</li>
<li>document.body：直接获取body标签</li>
<li>document.documentElement：获取html标签</li>
<li>元素.parentNode：获取父节点</li>
<li>元素.childNodes：获取所有子节点，如果只需要元素节点，需要判断nodeType==1</li>
<li>元素.children：只获取所有子元素节点</li>
<li>元素.firstElementChild：获取第一个子元素</li>
<li>元素.lastElementChild：获取最后一个子元素</li>
<li>元素.nextSibling：获取下一个兄弟节点包括文本节点</li>
<li>元素.previousSibling：获取上一个兄弟节点包括文本节点</li>
<li>元素.nextElementSibling：获取下一个兄弟节点不包括文本节点</li>
<li>元素.previousElementSibling：获取上一个兄弟节点不包括文本节点</li>
</ul>
<h4 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h4><h5 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h5><ul>
<li>元素.onclick = function(){}：绑定点击事件</li>
<li>元素.onclick=null：解绑事件</li>
<li>onmouseover：鼠标经过触发</li>
<li>mouseenter：鼠标进入不会冒泡</li>
<li>onmouseout：鼠标离开触发</li>
<li>onfocus：获得鼠标焦点触发</li>
<li>onblur：失去鼠标焦点触发</li>
<li>onmousemove：鼠标移动触发</li>
<li>onmouseup：鼠标弹起触发</li>
<li>onmousedown：鼠标按下触发</li>
<li>contextmenu：文本操作菜单</li>
<li>selectstart：禁止选择文字</li>
</ul>
<h5 id="方法监听注册事件"><a href="#方法监听注册事件" class="headerlink" title="方法监听注册事件"></a>方法监听注册事件</h5><p>同一个元素同一个事件可以添加多个监听器</p>
<ul>
<li>元素.addEventListener(type,listener[useCapture])<ul>
<li>type：事件类型，不需要加on</li>
<li>listener：回调函数</li>
</ul>
</li>
<li>元素.removeEventListener(type,listener[useCapture])</li>
</ul>
<h5 id="修改属性"><a href="#修改属性" class="headerlink" title="修改属性"></a>修改属性</h5><ul>
<li>innerText：修改标签文本内容</li>
<li>innerHtml（常用）：修改标签的结构内容</li>
<li>src：修改src属性</li>
<li>href：修改href</li>
<li>表单属性：type、value、checked、selected、disabled</li>
<li>修改样式属性：元素.style.样式属性=’修改的值’</li>
<li>修改类名属性:元素.className=”修改的类名”</li>
<li>元素.属性：获取内置属性</li>
<li>元素.getAttribute(‘’)：获取自定义属性</li>
<li>元素.setAttribute(‘属性’,’值’)：设置自定义属性值</li>
<li>元素.removeAttribute()：移除属性</li>
<li>元素.dataset.属性名：获取data-属性的值</li>
</ul>
<h5 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h5><ul>
<li><p>document.createElement(‘标签名’)：创建节点（效率远远比innerHtml快的多）但是可以利用数组先存好，再添加到innerHtml中更快</p>
</li>
<li><p>元素.appendChild()：在父节点的子节点末尾添加节点</p>
</li>
<li><p>元素.insertBefore(child,指定元素)：在父节点的指定元素前面添加节点</p>
</li>
<li><p>元素.removeChild()：移除元素</p>
</li>
<li><p>元素.cloneNode(false/true)：复制当前节点(false为浅拷贝，true为深拷贝复制内容)</p>
</li>
</ul>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>event就是一个事件对象写到我们侦听函数的小括号里面当形参来看；事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数；事件对象是我们事件的一系列相关数据的集合跟事件相关的比如鼠标点击里面就包含了鼠标的相长信息，鼠标坐标啊，如果是键盘事件里面就包含的键盘事件的信息比如判断用户按下了那个键</p>
<ul>
<li>target：触发该事件的元素</li>
<li>this：返回绑定的对象</li>
<li>type：事件类型</li>
<li>preventDefalut：阻止默认行为如跳转等/或者用return false；</li>
<li>stopPropagation：阻止冒泡行为</li>
<li>pageX：鼠标在页面文档的x坐标</li>
<li>pageY：鼠标在页面文档的y坐标</li>
<li>keyCode：获取相应键的ASCII码值</li>
</ul>
<h3 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h3><h4 id="相关事件"><a href="#相关事件" class="headerlink" title="相关事件"></a>相关事件</h4><ul>
<li>window.onload：页面加载事件</li>
<li>window.onresize：调整窗口大小加载事件（window.innerWidth获取窗口宽度）</li>
<li>scroll(x,y)：滚动到指定位置</li>
</ul>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><ul>
<li>window.setTimeout（调用函数，延迟毫秒值）;</li>
<li>window.clearTimeout(timeoutId)：停止定时器</li>
<li>window.setInterval（调用函数，延迟毫秒值）：会循环调用</li>
<li>window.clearInterval(IntervalId)：停止定时器</li>
</ul>
<h4 id="Localtion对象"><a href="#Localtion对象" class="headerlink" title="Localtion对象"></a>Localtion对象</h4><ul>
<li>href：该页面的url地址</li>
<li>host：主机名</li>
<li>port：端口</li>
<li>pathname：路径</li>
<li>search：返回参数</li>
<li>hash：片段</li>
<li>assign：进行页面跳转记录历史可以后退</li>
<li>replace：不记录历史不能后退</li>
<li>reload()：刷新页面，如果带了true这个参数会强制刷新</li>
</ul>
<h4 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h4><ul>
<li>userAgent：可以判断使用什么端访问</li>
</ul>
<h4 id="History"><a href="#History" class="headerlink" title="History"></a>History</h4><ul>
<li>back()：后退功能</li>
<li>forward()：前进功能</li>
<li>go(参数)：前进后退功能，后退为负数</li>
</ul>
<h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h4><ul>
<li><p>元素.offsetTop：返回元素</p>
</li>
<li><p>元素.offsetParent返回作为该元嘉带有足位的父级元素如果父烟都设有定位则返回body</p>
</li>
<li><p>元素.offsetTop返回元素相对带有定位父元素上方的偏移</p>
</li>
<li><p>元素.offsetLeft返回元素相对带有定位父元素左边的偏移</p>
</li>
<li><p>元素.offsetWidth返回自身包括padding，边框。内容区的宽度，返回数值不带单位</p>
</li>
<li><p>元素.offsetHeight返回自身包括adding。边框、内容区的亮度，返回数值不带单位</p>
</li>
<li><p>元素.clientTop：返回元素上边框的大小</p>
</li>
<li><p>元素.clientLeft：返回元素左边框的大小</p>
</li>
<li><p>元素.clientWidth：返回自身报考padding、内容区的宽度，不包含边框</p>
</li>
<li><p>元素.clientHeight：返回自身报考padding、内容区的高度，不包含边框</p>
</li>
<li><p>元素.srcollTop：返回被卷去的上侧距离，返回数值不带单位</p>
</li>
<li><p>元素.scrollLeft：返回被卷去的左侧距离，返回数值不带单位</p>
</li>
<li><p>元素.srollWiddth：返回自身实际宽度，不含边框，返回数值不带单位</p>
</li>
<li><p>元素.srollHeight：返回自身实际高度，不含边框，返回数值不带单位</p>
</li>
<li><p>window.pageYOffset：获取页面被卷去的高度</p>
</li>
</ul>
<h3 id="存储对象"><a href="#存储对象" class="headerlink" title="存储对象"></a>存储对象</h3><h4 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h4><p>会话级别，关闭浏览器失效</p>
<ul>
<li>setItem(key,value)：存储数据</li>
<li>getItem(key)：获取数据</li>
<li>removeItem(key)：移除数据</li>
</ul>
<h4 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h4><p>永久生效，除非手动删除</p>
<ul>
<li>setItem(key,value)：存储数据</li>
<li>getItem(key)：获取数据</li>
<li>removeItem(key)：移除数据</li>
</ul>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><ul>
<li>let变量：修饰局部变量</li>
<li>const：声明常量，不能修改</li>
<li>解构赋值：let{name,age} = {name:”1”,age=2};</li>
<li>模板字符串：<code>里面直接写字符串$&#123;里面写拼接的变量&#125;</code> </li>
<li>对象得简写：{name:name,age:age}简写为{name,age}</li>
<li>箭头函数：()=&gt;{};注意this指向该函数定义的位置</li>
<li>…args：rest参数根argments一样</li>
<li>…运算符：将数组以逗号分割，</li>
<li>Number.EPSILON：表示js的最小精度可以用来比较浮点数</li>
<li>isFinite()：判断是否是有限数</li>
<li>isInteger()：判断是否是整数</li>
<li>Object.is()：判断两个值是否想等，和===差不多</li>
<li>Object.assign()：对象合并</li>
</ul>
<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><ul>
<li>new Set()：构造set集合</li>
<li>set.has(‘’)：是否包含</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li>new Map()</li>
<li>m.set(“key”,”value”)：添加元素</li>
<li>m.delete(“key”)：删除元素</li>
<li>m.get(key)：获取元素</li>
<li>m.clear()：清空map集合</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>原生基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery</title>
    <url>/2022/08/17/%E5%89%8D%E7%AB%AF/jQuery/</url>
    <content><![CDATA[<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><h2 id="Dom和jQuery对象的转换"><a href="#Dom和jQuery对象的转换" class="headerlink" title="Dom和jQuery对象的转换"></a>Dom和jQuery对象的转换</h2><ul>
<li>DOM-jQuery：$(DOM对象)</li>
<li>jQuery-DOM：$(“div”)[index]/$(“div”).get(index)</li>
</ul>
<h2 id="常用选择器"><a href="#常用选择器" class="headerlink" title="常用选择器"></a>常用选择器</h2><ul>
<li><p>#id：获取指定id的元素</p>
</li>
<li><p>*：所有元素</p>
</li>
<li><p>.class：获取同一个class的元素</p>
</li>
<li><p>div：同标签元素</p>
</li>
<li><p>div,p,li：多个元素</p>
</li>
<li><p>li.current：交集元素</p>
</li>
<li><p>ul&gt;li：子代选择</p>
</li>
<li><p>ul li：后代选择</p>
</li>
<li><p>:first：第一个元素</p>
</li>
<li><p>:last：最后一个</p>
</li>
<li><p>:eq(index)：第几个元素从0开始</p>
</li>
<li><p>:odd：索引为奇数的元素</p>
</li>
<li><p>:even：索引号为偶数的元素</p>
</li>
<li><p>parent()：获取父级</p>
</li>
<li><p>children(selector)：最近的儿子</p>
</li>
<li><p>find(selector)：后代选择</p>
</li>
<li><p>siblings(selector)：兄弟节点</p>
</li>
<li><p>nextAll([expr])：该元素之后的同辈元素</p>
</li>
<li><p>prevtAll([expr])：该元素之前的同辈元素</p>
</li>
<li><p>hasClass(class)：指定类的元素</p>
</li>
<li><p>eq(index)：index位的元素</p>
</li>
</ul>
<h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><ul>
<li><p>$(“div”).css(“属性名”,“属性值”);</p>
</li>
<li><p>addClass()：添加类名</p>
</li>
<li><p>removeClass()：移除类名</p>
</li>
<li><p>toggleClass()：切换类，若存在该类名去掉，没有加上</p>
</li>
<li><p>show(speed,easing,fn)：显示</p>
</li>
<li><p>hide()：隐藏</p>
</li>
<li><p>toggle()：切换</p>
</li>
<li><p>slideDown()：滑动</p>
</li>
<li><p>slideup()：滑动</p>
</li>
<li><p>slideToggle()：滑动</p>
</li>
<li><p>fadeIn():淡入淡出</p>
</li>
<li><p>fadeOut():淡入淡出</p>
</li>
<li><p>fadeToggle():淡入淡出</p>
</li>
<li><p>fadeTo():淡入淡出</p>
</li>
<li><p>animate()：自定义动画</p>
</li>
<li><p>prop()：获取标签自身属性值</p>
</li>
<li><p>attr()：获取自定义属性</p>
</li>
<li><p>text()：文本内容</p>
</li>
<li><p>html()：元素内容</p>
</li>
<li><p>val()：获取value值</p>
</li>
<li><p>each(function(index,domEle){})：遍历元素</p>
</li>
<li><p>$(“<li></li>“)：创建标签</p>
</li>
<li><p>remove()：删除自身</p>
</li>
<li><p>empty()：清空子节点</p>
</li>
<li><p>html(“”)：清空元素内容</p>
</li>
<li><p>width()/height()：宽度/高度</p>
</li>
<li><p>innerWidth()/innerHeight()：宽度/高度包含padding</p>
</li>
<li><p>outerWidth()/outerHeight()：宽度/高度包含padding、border</p>
</li>
<li><p>outerWidth(true)/outerHeight(true)：宽度/高度包含padding、border、margin</p>
</li>
<li><p>offset()：相对文档的偏移坐标，返回obj，有left/top属性，可以设置</p>
</li>
<li><p>postion()：距离带有定位的父亲节点的坐标对象，不能设置</p>
</li>
<li><p>scrollTop()/scrollLeft()：被卷去的距离</p>
</li>
<li><p>on({click:function(){}})：绑定多个事件</p>
</li>
<li><p>off(“事件名”)：解绑事件</p>
</li>
<li><p>one(“click”,function(){})：执行一次事件</p>
</li>
<li><p>元素.事件：手动触发事件</p>
</li>
<li><p>trigger(“事件名”)：手动触发事件</p>
</li>
<li><p>triggerHandler(“事件名”)：手动触发事件不触发默认行为</p>
</li>
<li><p>$.extend(targetObj,obj)：对象拷贝</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>mock</title>
    <url>/2022/08/26/%E5%89%8D%E7%AB%AF/mock/</url>
    <content><![CDATA[<h1 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h1><p>当前端工程师需要独立于后端并行开发时，后端接口还没有完成那么前端怎么获取数据？<br>这时可以考虑前端搭建web server自己模拟假数据，这里我们选第三方库mockjs用来生成随机数据拦截Ajax请求。</p>
<blockquote>
<p><a href="https://github.com/nuysoft/Mock/wiki">官方文档</a></p>
</blockquote>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul>
<li><p>安装mockjs：<code>cnpm install mockjs --save-dev</code></p>
</li>
<li><p>创建mock文件夹以及mock配置的js文件</p>
</li>
<li><p>方式一：直接创建随机数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Mock = <span class="built_in">require</span>(<span class="string">&#x27;mockjs&#x27;</span>)</span><br><span class="line"><span class="comment">//随机生成id</span></span><br><span class="line"><span class="keyword">let</span> id = Mock.mock(<span class="string">&#x27;@id&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(id)</span><br><span class="line"><span class="comment">//随机生成对象</span></span><br><span class="line"><span class="keyword">let</span> obj = Mock.mock(&#123;</span><br><span class="line">    id: <span class="string">&#x27;@id()&#x27;</span>,<span class="comment">//随机id</span></span><br><span class="line">    username: <span class="string">&#x27;@cname()&#x27;</span>,<span class="comment">//随机生成中文名字</span></span><br><span class="line">    date: <span class="string">&#x27;@date()&#x27;</span>,<span class="comment">//随机生成日期</span></span><br><span class="line">    avatar: <span class="string">&quot;@image(&#x27;200x200&#x27;,&#x27;red&#x27;,&#x27;#fff&#x27;,&#x27;avatar&#x27;)&quot;</span>,<span class="comment">//生成图片，参数：size,background,foreground,text</span></span><br><span class="line">    description: <span class="string">&#x27;@paragraph()&#x27;</span>, <span class="comment">//描述</span></span><br><span class="line">    ip: <span class="string">&#x27;@ip()&#x27;</span>, <span class="comment">//ip地址</span></span><br><span class="line">    email: <span class="string">&#x27;@email()&#x27;</span> <span class="comment">//随机生成邮箱</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure></li>
<li><p>方式二：读取json文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> JSON5 = <span class="built_in">require</span>(<span class="string">&#x27;json5&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> Mock = <span class="built_in">require</span>(<span class="string">&#x27;mockjs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取JSON文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJsonFile</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> json = fs.readFileSync(path.join(__dirname, filePath), <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> JSON5.parse(json);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个函数</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">devServer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//监听http请求</span></span><br><span class="line">    devServer.app.get(<span class="string">&#x27;/user/userinfo&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">rep, res</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//每次相应请求时获取mock data的json文件</span></span><br><span class="line">        <span class="keyword">var</span> json = getJsonFile(<span class="string">&#x27;./userInfo.json5&#x27;</span>);</span><br><span class="line">        <span class="comment">//将json传入mock方法，生成的数据返回给浏览器</span></span><br><span class="line">        res.json(Mock.mock(json))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置vue.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    <span class="comment">// before: require(&#x27;./mock&#x27;),在vuecli3中使用</span></span><br><span class="line">    <span class="comment">//setupMiddlewares: require(&#x27;./mock&#x27;),在vuecli5中使用</span></span><br><span class="line">    onBeforeSetupMiddleware: <span class="built_in">require</span>(<span class="string">&#x27;./mock/index&#x27;</span>)<span class="comment">//引入mock/index.js </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当后端开发完成时，移除mock</p>
</li>
<li><p>编写环境配置文件env.development：<code>MOCK=true</code></p>
</li>
<li><p>并在mock文件夹下的index.js里面添加判断条件<code>if (process.env.MOCK == &#39;true&#39;) </code></p>
</li>
<li><p>移除只需要将环境配置文件的MOCK改为false即可</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Mock</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Mock</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT认证</title>
    <url>/2023/09/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/JWT%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h1 id="JWT认证"><a href="#JWT认证" class="headerlink" title="JWT认证"></a>JWT认证</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>JWT（JSON Web Token）是一种用于认证和授权的开放标准；是一个经过加密的，包含用户信息的且具有时效性的固定格式字符串，通常用于在不同的系统之间安全地传递声明（claims）。</p>
<p>JWT 由三部分组成：</p>
<ol>
<li><p><strong>头部（Header）</strong>：头部通常包含了两部分信息，令牌的类型（JWT）和所使用的签名算法（例如 HMAC SHA256 或 RSA）。</p>
</li>
<li><p><strong>载荷（Payload）</strong>：载荷包含了一系列声明（claims）。声明是关于实体（通常是用户）和其他数据的声明。有三种类型的声明：</p>
<ul>
<li>注册声明（Registered Claims）：这些是一组预定义的声明，包括 iss（签发者）、sub（主题）、aud（受众）、exp（到期时间）、nbf（生效时间）和iat（签发时间）等。</li>
<li>私有声明（Private Claims）：这些声明是应用程序特定的，通常用于在双方之间共享信息。</li>
<li>公共声明（Public Claims）：这些声明是可选的，可以按需要添加到令牌中。</li>
</ul>
</li>
<li><p><strong>签名（Signature）</strong>：签名用于验证令牌的真实性和完整性。它是通过将头部和载荷进行签名生成的，使用密钥来生成签名。验证方可以使用相同的密钥来验证签名，以确保令牌内容未被篡改。</p>
<p>按照下面的公式产生签名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>整个JWT的头部、载荷、签名都会用Base64URL算法转成加密字符串</p>
</blockquote>
</li>
</ol>
<h2 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h2><p>在分布式架构下，利用网关和认证中心来实现JWT认证通常涉及多个服务和组件，以确保对应用程序的安全访问和身份验证。下面是两种方式的认证流程示例：</p>
<h3 id="统一校验方式："><a href="#统一校验方式：" class="headerlink" title="统一校验方式："></a>统一校验方式：</h3><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230923155754228.png" alt="image-20230923155754228" style="zoom: 67%;" />

<ol>
<li><strong>用户登录</strong>：<ul>
<li>用户通过网关发送登录请求，提供用户名和密码。</li>
<li>网关将登录请求转发给认证中心。</li>
</ul>
</li>
<li><strong>认证中心验证用户</strong>：<ul>
<li>认证中心验证用户提供的凭据（用户名和密码）是否有效。</li>
<li>如果凭据有效，认证中心将创建一个JWT令牌，并在令牌的载荷中包含用户的信息（例如用户ID、角色等）。</li>
<li>认证中心使用私钥对JWT令牌进行签名。</li>
</ul>
</li>
<li><strong>JWT令牌生成</strong>：<ul>
<li>认证中心生成JWT令牌，将其签名后返回给网关。</li>
</ul>
</li>
<li><strong>网关接收JWT令牌</strong>：<ul>
<li>网关接收到JWT令牌，并在将其发送到客户端之前，可以选择对令牌进行一些处理，如添加HTTP头信息。</li>
</ul>
</li>
<li><strong>客户端存储JWT令牌</strong>：<ul>
<li>客户端（通常是前端应用程序）收到JWT令牌后，将其存储在安全的地方，例如浏览器的本地存储或HTTP Cookie中。</li>
</ul>
</li>
<li><strong>后续请求</strong>：<ul>
<li>客户端在后续请求中将JWT令牌包含在HTTP请求的头部中（通常是Authorization头），以证明其身份。</li>
</ul>
</li>
<li><strong>网关验证JWT令牌</strong>：<ul>
<li>网关接收到后续请求，并从请求头中提取JWT令牌。</li>
<li>网关使用与认证中心共享的公钥来验证JWT令牌的签名。</li>
<li>如果签名验证成功，网关允许请求通过，并将请求转发给适当的微服务。</li>
</ul>
</li>
<li><strong>微服务处理请求</strong>：<ul>
<li>微服务接收到请求后，可以从JWT令牌中提取用户信息，以确定请求的上下文和权限。</li>
<li>微服务根据令牌中的信息来处理请求，执行相应的业务逻辑。</li>
</ul>
</li>
</ol>
<h3 id="应用认证方式："><a href="#应用认证方式：" class="headerlink" title="应用认证方式："></a>应用认证方式：</h3><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230923160243730.png" alt="image-20230923160243730"></p>
<ol>
<li><strong>用户登录</strong>：<ul>
<li>用户通过网关发送登录请求，提供用户名和密码。</li>
</ul>
</li>
<li><strong>网关将请求转发给应用程序</strong>：<ul>
<li>网关将登录请求转发给特定的应用程序微服务，而不对JWT进行验证或处理。</li>
</ul>
</li>
<li><strong>应用程序处理登录请求</strong>：<ul>
<li>应用程序微服务接收到登录请求，将用户名和密码传递给认证中心。</li>
</ul>
</li>
<li><strong>认证中心验证用户</strong>：<ul>
<li>认证中心验证用户提供的凭据（用户名和密码）是否有效。</li>
<li>如果凭据有效，认证中心将创建一个JWT令牌，并在令牌的载荷中包含用户的信息（例如用户ID、角色等）。</li>
<li>认证中心使用私钥对JWT令牌进行签名。</li>
</ul>
</li>
<li><strong>JWT令牌生成</strong>：<ul>
<li>认证中心生成JWT令牌，将其签名后返回给应用程序微服务。</li>
</ul>
</li>
<li><strong>应用程序微服务将JWT令牌返回给网关</strong>：<ul>
<li>应用程序微服务将生成的JWT令牌返回给网关。</li>
</ul>
</li>
<li><strong>网关接收JWT令牌并将其传递到客户端</strong>：<ul>
<li>网关接收到JWT令牌，并将其传递到客户端，通常存储在客户端的本地存储中。</li>
</ul>
</li>
<li><strong>后续请求</strong>：<ul>
<li>客户端在后续请求中将JWT令牌包含在HTTP请求的头部中（通常是Authorization头），以证明其身份。</li>
</ul>
</li>
<li><strong>网关将请求转发给应用程序</strong>：<ul>
<li>网关将包含JWT令牌的请求转发给特定的应用程序微服务。</li>
</ul>
</li>
<li><strong>应用程序微服务向认证中心验证JWT令牌</strong>：<ul>
<li>应用程序微服务接收到请求后，从请求中提取JWT令牌，并将令牌发送到认证中心进行验证获取用户与权限数据。</li>
</ul>
</li>
</ol>
<h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ul>
<li><p><strong>方案一：</strong>JWT校验无感知，验签过程无侵入执行效率低，适用于低并发企业级应用</p>
</li>
<li><p><strong>方案二：</strong>控制更加灵活，有一定代码侵入，代码可以灵活控制，适用于追求性能互联网应用</p>
</li>
</ul>
<h2 id="续签"><a href="#续签" class="headerlink" title="续签"></a>续签</h2><p>JWT通常具有一个预定的生命周期（通常以秒为单位），一旦JWT到期，就需要续签或重新生成新的JWT。续签JWT的方法取决于你的使用情境和安全需求，</p>
<p>以下是一些常见的JWT续签方案：</p>
<ol>
<li><p><strong>基于Redis的续签方案</strong>：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230925102732404.png" alt="image-20230925102732404"></p>
<ul>
<li>在登录认证之后需要在redis中存储key为用户信息的缓存并设置过期时间（这个过期时间就是JWT最大存活时间）；</li>
<li>再次进行登录校验的时候，就需要去redis中获取数据判断是否有效：<ul>
<li>不存在该key则直接拒绝访问（即长时间不操作）</li>
<li>存在判断有效期：<ul>
<li>超过一个小时不做任何处理正常响应</li>
<li>不足一小时：对redis中有效期进行延长</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>缺点：</strong>JWT从无状态变为了有状态</p>
</li>
<li><p><strong>刷新令牌方案</strong>：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230925104104832.png" alt="image-20230925104104832"></p>
<p>使用刷新令牌是一种常见的JWT续签方法。用户在登录时会获得一个JWT和一个刷新令牌。JWT用于短期访问，而刷新令牌用于获取新的JWT。当JWT过期时，客户端可以使用刷新令牌向服务器请求新的JWT，服务器会验证刷新令牌的有效性，如果有效，则签发一个新的JWT。</p>
<blockquote>
<p>为什么必须要两个refresh_token?为什么不直接设置token一个小时过期，判断还有10分钟过期的时候，生成新的token进行替换？</p>
<p>refresh_token和access_token的设计最根本的原因是因为 <strong>token验证服务器 和 token分发服务器 是分离的</strong>，换句话说 refresh_token 从来没有发送到真正执行验证的业务服务器上面过 这样保证了安全性（流程是access_token去业务服务区上验证能不能用，不能用那么客户端拿着refresh_token到真正的token分发服务器上换取新的 access_token 然后再去请求业务服务器）</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>分布式权限认证</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>权限认证</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统认证</title>
    <url>/2023/03/17/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h1 id="分布式系统认证方案"><a href="#分布式系统认证方案" class="headerlink" title="分布式系统认证方案"></a>分布式系统认证方案</h1><h2 id="什么是分布式系统"><a href="#什么是分布式系统" class="headerlink" title="什么是分布式系统"></a>什么是分布式系统</h2><p>随着软件环境和需求的变化 ，软件的架构由单体结构演变为分布式架构，具有分布式架构的系统叫分布式系统，分布式系统的运行通常依赖网络，它将单体结构的系统分为若干服务，服务之间通过网络交互来完成用户的业务处<br>理，当前流行的微服务架构就是分布式系统架构，如下图：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221124201044322.png" alt="image-20221124201044322"></p>
<h3 id="分布式认证需求"><a href="#分布式认证需求" class="headerlink" title="分布式认证需求"></a>分布式认证需求</h3><p>分布式系统的每个服务都会有认证、授权的需求，如果每个服务都实现一套认证授权逻辑会非常冗余，考虑分布式系统共享性的特点，需要由独立的认证服务处理系统认证授权的请求；考虑分布式系统开放性的特点，不仅对系统内部服务提供认证，对第三方系统也要提供认证。分布式认证的需求总结如下：<br>统一认证授权</p>
<ul>
<li>统一认证授权：提供独立的认证服务，统一处理认证授权。</li>
<li>应用接入认证：应提供扩展和开放能力，提供安全的系统对接机制，并可开放部分API给接入第三方使用，一方应用（内部 系统服务）和三方应用（第三方应用）均采用统一机制接入。</li>
</ul>
<h3 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h3><p>根据 选型的分析，决定采用基于token的认证方式，它的优点是：</p>
<ol>
<li><p>适合统一认证的机制，客户端、一方应用、三方应用都遵循一致的认证机制。</p>
</li>
<li><p>token认证方式对第三方应用接入更适合，因为它更开放，可使用当前有流行的开放协议Oauth2.0、JWT等。</p>
</li>
<li><p>一般情况服务端无需存储会话信息，减轻了服务端的压力。</p>
</li>
</ol>
<p>分布式系统认证技术方案见下图：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221124201452492.png" alt="image-20221124201452492"></p>
<p>系统大致流程如下：</p>
<ol>
<li>用户通过接入方（应用）登录，接入方采取OAuth2.0方式在统一认证服务(UAA)中认证。</li>
<li>认证服务(UAA)调用验证该用户的身份是否合法，并获取用户权限信息。</li>
<li>认证服务(UAA)获取接入方权限信息，并验证接入方是否合法。</li>
<li>若登录用户以及接入方都合法，认证服务生成jwt令牌返回给接入方，其中jwt中包含了用户权限及接入方权限。</li>
<li>后续，接入方携带jwt令牌对API网关内的微服务资源进行访问。</li>
<li>API网关对令牌解析、并验证接入方的权限是否能够访问本次请求的微服务。</li>
<li>如果接入方的权限没问题，API网关将原请求header中附加解析后的明文Token，并将请求转发至微服务。</li>
<li>微服务收到请求，明文token中包含登录用户的身份和权限信息。因此后续微服务自己可以干两件事：<ul>
<li>用户授权拦截（看当前用户是否有权访问该资源）</li>
<li>将用户信息存储进当前线程上下文（有利于后续业务逻辑随时获取当前用户信息）</li>
</ul>
</li>
</ol>
<h2 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h2><p>OAuth（开放授权）是一个开放标准，允许用户授权第三方应用访问他们存储在另外的服务提供者上的信息，而不<br>需要将用户名和密码提供给第三方应用或分享他们数据的所有内容。OAuth2.0是OAuth协议的延续版本，但不向<br>后兼容OAuth 1.0即完全废止了OAuth1.0。很多大公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服<br>务，这些都足以说明OAUTH标准逐渐成为开放资源授权的标准。</p>
<p>OAauth2.0认证流程：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221124201956413.png" alt="image-20221124201956413" style="zoom:67%;" />

<p>OAauth2.0包括以下角色：</p>
<ol>
<li><p>客户端：<br>本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：Android客户端、Web客户端（浏览器端）、微信客户端等。</p>
</li>
<li><p>资源拥有者：<br>通常为用户，也可以是应用程序，即该资源的拥有者。</p>
</li>
<li><p>授权服务器（也称认证服务器）：</p>
<p>用于服务提供商对资源拥有的身份进行认证、对访问资源进行授权，认证成功后会给客户端发放令牌<br>（access_token），作为客户端访问资源服务器的凭据。本例为微信的认证服务器。</p>
</li>
<li><p>资源服务器：存储资源的服务器。</p>
</li>
</ol>
<h2 id="Spring-Cloud-Security-OAuth2"><a href="#Spring-Cloud-Security-OAuth2" class="headerlink" title="Spring Cloud Security OAuth2"></a>Spring Cloud Security OAuth2</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>Spring-Security-OAuth2是对OAuth2的一种实现，并且跟我们之前学习的Spring Security相辅相成，与Spring<br>Cloud体系的集成也非常便利，接下来，我们需要对它进行学习，最终使用它来实现我们设计的分布式认证授权解<br>决方案。<br>OAuth2.0的服务提供方涵盖两个服务，即授权服务 (Authorization Server，也叫认证服务) 和资源服务 (Resource<br>Server)，使用 Spring Security OAuth2 的时候你可以选择把它们在同一个应用程序中实现，也可以选择建立使用<br>同一个授权服务的多个资源服务。</p>
<p><strong>授权服务 (Authorization Server）</strong>应包含对接入端以及登入用户的合法性进行验证并颁发token等功能，对令牌<br>的请求端点由 Spring MVC 控制器进行实现，下面是配置一个认证服务必须要实现的endpoints：</p>
<ul>
<li><p>AuthorizationEndpoint 服务于认证请求。默认 URL： /oauth/authorize 。</p>
</li>
<li><p>TokenEndpoint 服务于访问令牌的请求。默认 URL： /oauth/token 。</p>
</li>
</ul>
<p>**资源服务 (Resource Server)**应包含对资源的保护功能，对非法请求进行拦截，对请求中token进行解析鉴<br>权等，下面的过滤器用于实现 OAuth 2.0 资源服务：</p>
<ul>
<li>OAuth2AuthenticationProcessingFilter用来对请求给出的身份令牌解析鉴权。</li>
</ul>
<p>本教程分别创建uaa授权服务（也可叫认证服务）和order订单资源服务。</p>
<p>认证流程如下：</p>
<ol>
<li>客户端请求UAA授权服务进行认证。</li>
<li>认证通过后由UAA颁发令牌。</li>
<li>客户端携带令牌Token请求资源服务。</li>
<li>资源服务校验令牌的合法性，合法即返回资源信息。</li>
</ol>
<h3 id="授权模式"><a href="#授权模式" class="headerlink" title="授权模式"></a>授权模式</h3><h4 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h4><p>下图是授权码模式交互图：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221126192301196.png" alt="image-20221126192301196" style="zoom: 50%;" />

<p>（1）资源拥有者打开客户端，客户端要求资源拥有者给予授权，它将浏览器被重定向到授权服务器，重定向时会<br>附加客户端的身份信息。如：<code>http://localhost:53020/uaa/oauth/authorize? client_id=c1&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://www.baidu.com</code></p>
<p>（2）浏览器出现向授权服务器授权页面，之后将用户同意授权。<br>（3）授权服务器将授权码（AuthorizationCode）转经浏览器发送给client(通过redirect_uri)。<br>（4）客户端拿着授权码向授权服务器索要访问access_token，请求如下：<code>/uaa/oauth/token? client_id=c1&amp;client_secret=secret&amp;grant_type=authorization_code&amp;code=5PgfcD&amp;redirect_uri=http://www.baidu.com</code></p>
<p>（5）授权服务器返回令牌(access_token)</p>
<blockquote>
<p>请求参数说明：</p>
<ul>
<li>client_id：客户端准入标识。</li>
<li>client_secret：客户端秘钥。</li>
<li>grant_type：授权类型，填写authorization_code，表示授权码模式</li>
<li>code：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。</li>
<li>redirect_uri：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致。</li>
</ul>
</blockquote>
<p>这种模式是四种模式中最安全的一种模式。一般用于client是Web服务器端应用或第三方的原生App调用资源服务<br>的时候。因为在这种模式中access_token不会经过浏览器或移动端的App，而是直接从服务端去交换，这样就最大<br>限度的减小了令牌泄漏的风险。</p>
<h4 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h4><p>下图是简化模式交互图：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221126195637438.png" alt="image-20221126195637438" style="zoom: 50%;" />

<p>（1）资源拥有者打开客户端，客户端要求资源拥有者给予授权，它将浏览器被重定向到授权服务器，重定向时会<br>附加客户端的身份信息。如：<code>/uaa/oauth/authorize?client_id=c1&amp;response_type=token&amp;scope=all&amp;redirect_uri=http://www.baidu.com</code></p>
<p>（2）浏览器出现向授权服务器授权页面，之后将用户同意授权。<br>（3）授权服务器将授权码将令牌（access_token）以Hash的形式存放在重定向uri的fargment中发送给浏览<br>器。</p>
<p>一般来说，简化模式用于没有服务器端的第三方单页面应用，因为没有服务器端就无法接收授权码。</p>
<h4 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h4><p>下图是密码模式交互图：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221126195737441.png" alt="image-20221126195737441" style="zoom: 50%;" />

<p>（1）资源拥有者将用户名、密码发送给客户端<br>（2）客户端拿着资源拥有者的用户名、密码向授权服务器请求令牌（access_token），请求如下：<code>/uaa/oauth/token? client_id=c1&amp;client_secret=secret&amp;grant_type=password&amp;username=shangsan&amp;password=123</code></p>
<p>（3）授权服务器将令牌（access_token）发送给client</p>
<p>这种模式十分简单，但是却意味着直接将用户敏感信息泄漏给了client，因此这就说明这种模式只能用于client是我<br>们自己开发的情况下。因此密码模式一般用于我们自己开发的，第一方原生App或第一方单页面应用。</p>
<h4 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h4><p>下图是客户端模式交互图：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221126200038251.png" alt="image-20221126200038251" style="zoom:50%;" />

<p>（1）客户端向授权服务器发送自己的身份信息，并请求令牌（access_token）<br>（2）确认客户端身份无误后，将令牌（access_token）发送给client，请求如下：<code>/uaa/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=client_credentials</code></p>
<p>这种模式是最方便但最不安全的模式。因此这就要求我们对client完全的信任，而client本身也是安全的。因<br>此这种模式一般用来提供给我们完全信任的服务器端服务。比如，合作方系统对接，拉取一组用户信息。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>我们理想的解决方案应该是这样的，认证服务负责认证，网关负责校验认证和鉴权，其他API服务负责处理自己的业务逻辑。安全相关的逻辑只存在于认证服务和网关服务中，其他服务只是单纯地提供服务而没有任何安全相关逻辑。</p>
<p>相关服务划分：</p>
<ul>
<li>oauth2-gateway：网关服务，负责请求转发和鉴权功能，整合Spring Security+Oauth2；</li>
<li>oauth2-auth：Oauth2认证服务，负责对登录用户进行认证，整合Spring Security+Oauth2；</li>
<li>oauth2-api：受保护的API服务，用户鉴权通过后可以访问该服务，不整合Spring Security+Oauth2。</li>
</ul>
<h4 id="oauth2-auth"><a href="#oauth2-auth" class="headerlink" title="oauth2-auth"></a>oauth2-auth</h4><p>Oauth2认证服务，负责对登录用户进行认证，整合Spring Security+Oauth2；</p>
<p><strong>依赖导入：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--mybatisPlus依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql数据库驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注册中心--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- web--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Redis依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Redis依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--fastjson依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jwt依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- actuator--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>application.yml配置</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8003</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">securityTest</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/demo_security?characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment">#Redis服务器地址</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">1800000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>创建<code>UserServiceImpl</code>类</strong></p>
<p>实现Spring Security的<code>UserDetailsService</code>接口，用于加载用户信息；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MenuMapper menuMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//根据用户名查询用户信息</span></span><br><span class="line">        User user = userMapper.selectOne(<span class="keyword">new</span> LambdaQueryWrapper&lt;User&gt;().eq(User::getUserName,username));</span><br><span class="line">        <span class="comment">//如果查询不到数据就通过抛出异常来给出提示</span></span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(user))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//封装成UserDetails对象返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoginUser(user,menuMapper.selectPermsByUserId(user.getId()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其余springSecurity的东西：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/js/**&quot;</span>, <span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/images/**&quot;</span>,<span class="string">&quot;/verifyCode&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .requestMatchers(EndpointRequest.toAnyEndpoint()).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">        http.cors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>配置使用JWT存储令牌：</strong></p>
<p>把令牌存储在内存中的，这样如果部署多个服务，就会导致无法使用令牌的问题。 Spring Cloud Security中有两种存储令牌的方式可用于解决该问题，一种是使用Redis来存储，另一种是使用JWT来存储。</p>
<ul>
<li><p>添加使用JWT存储令牌的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TokenStore <span class="title">jwtTokenStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenStore(jwtAccessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtAccessTokenConverter <span class="title">jwtAccessTokenConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JwtAccessTokenConverter accessTokenConverter = <span class="keyword">new</span> JwtAccessTokenConverter();</span><br><span class="line">        <span class="comment">//配置JWT使用的秘钥</span></span><br><span class="line">        accessTokenConverter.setSigningKey(<span class="string">&quot;wht&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> accessTokenConverter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * token 增强器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtTokenEnhancer <span class="title">jwtTokenEnhancer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenEnhancer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在认证服务器配置中指定令牌的存储策略为JWT：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置令牌访问管理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> endpoints</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;</span><br><span class="line">    endpoints</span><br><span class="line">        <span class="comment">// 密码模式需要</span></span><br><span class="line">        .authenticationManager(authenticationManager)</span><br><span class="line">        <span class="comment">// 用户信息</span></span><br><span class="line">        .userDetailsService(userDetailsService)</span><br><span class="line">        <span class="comment">// 配置令牌存储策略</span></span><br><span class="line">        .tokenStore(tokenStore)</span><br><span class="line">        .accessTokenConverter(accessTokenConverter)</span><br><span class="line">        <span class="comment">// 允许post提交</span></span><br><span class="line">        .allowedTokenEndpointRequestMethods(HttpMethod.POST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对token进行增强：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenEnhancer</span> <span class="keyword">implements</span> <span class="title">TokenEnhancer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OAuth2AccessToken <span class="title">enhance</span><span class="params">(OAuth2AccessToken accessToken, OAuth2Authentication authentication)</span> </span>&#123;</span><br><span class="line">        LoginUser loginUser = (LoginUser) authentication.getPrincipal();</span><br><span class="line">        User user = loginUser.getUser();</span><br><span class="line">        Map&lt;String, Object&gt; info = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 把用户ID设置到JWT中</span></span><br><span class="line">        info.put(<span class="string">&quot;uid&quot;</span>, user.getId());</span><br><span class="line">        ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(info);</span><br><span class="line">        <span class="keyword">return</span> accessToken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>配置认证服务器</strong></p>
<p>接下来进行以下的配置：</p>
<ul>
<li><strong>ClientDetailsServiceConfigurer：</strong>用来配置客户端详情服务（ClientDetailsService），客户端详情信息在<br>这里进行初始化，你能够把客户端详情信息写死在这里或者是通过数据库来存储调取详情信息。</li>
<li><strong>AuthorizationServerEndpointsConfigurer：</strong>用来配置令牌（token）的访问端点和令牌服务(token<br>services)。</li>
<li><strong>AuthorizationServerSecurityConfigurer：</strong>用来配置令牌端点的安全约束.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsServiceImpl userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ClientDetailsService clientDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;jwtTokenStore&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;jwtAccessTokenConverter&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> JwtAccessTokenConverter accessTokenConverter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenEnhancer jwtTokenEnhancer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来配置客户端详情服务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clients</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 自动从数据库查询出来进行校验</span></span><br><span class="line">        clients.withClientDetails(clientDetailsService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置从数据库查询客户端信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientDetailsService <span class="title">clientDetailsService</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        ClientDetailsService clientDetailsService = <span class="keyword">new</span> JdbcClientDetailsService(dataSource);</span><br><span class="line">        ((JdbcClientDetailsService) clientDetailsService).setPasswordEncoder(passwordEncoder);</span><br><span class="line">        <span class="keyword">return</span> clientDetailsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置令牌访问管理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endpoints</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加增强器</span></span><br><span class="line">        TokenEnhancerChain tokenEnhancerChain = <span class="keyword">new</span> TokenEnhancerChain();</span><br><span class="line">        tokenEnhancerChain.setTokenEnhancers(Arrays.asList(jwtTokenEnhancer,accessTokenConverter));</span><br><span class="line">        endpoints</span><br><span class="line">                <span class="comment">// 密码模式需要</span></span><br><span class="line">                .authenticationManager(authenticationManager)</span><br><span class="line">                <span class="comment">// 用户信息</span></span><br><span class="line">                .userDetailsService(userDetailsService)</span><br><span class="line">                <span class="comment">// 配置令牌存储策略</span></span><br><span class="line">                .tokenStore(tokenStore)</span><br><span class="line">                .accessTokenConverter(accessTokenConverter)</span><br><span class="line">                .tokenEnhancer(tokenEnhancerChain)</span><br><span class="line">                <span class="comment">// 允许post提交</span></span><br><span class="line">                .allowedTokenEndpointRequestMethods(HttpMethod.POST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 令牌端点的安全约束配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> security</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span></span>&#123;</span><br><span class="line">        security</span><br><span class="line">                <span class="comment">// 允许公钥获取端点</span></span><br><span class="line">                .tokenKeyAccess(<span class="string">&quot;permitAll()&quot;</span>)</span><br><span class="line">                <span class="comment">// 允许检查token</span></span><br><span class="line">                .checkTokenAccess(<span class="string">&quot;permitAll()&quot;</span>)</span><br><span class="line">                <span class="comment">// 允许表单认证</span></span><br><span class="line">                .allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>管理令牌：</strong></p>
<p>AuthorizationServerTokenServices 接口定义了一些操作使得你可以对令牌进行一些必要的管理，令牌可以被用来加载身份信息，里面包含了这个令牌的相关权限。</p>
<p>自己可以创建 AuthorizationServerTokenServices 这个接口的实现，则需要继承 DefaultTokenServices 这个类，里面包含了一些有用实现，你可以使用它来修改令牌的格式和令牌的存储。默认的，当它尝试创建一个令牌的时候，是使用随机值来进行填充的，除了持久化令牌是委托一个 TokenStore 接口来实现以外，这个类几乎帮你做了所有的事情。并且 TokenStore 这个接口有一个默认的实现，它就是 InMemoryTokenStore ，如其命名，所有的令牌是被保存在了内存中。除了使用这个类以外，你还可以使用一些其他的预定义实现，下面有几个版本，它们都实现了TokenStore接口：</p>
<ul>
<li>InMemoryTokenStore：这个版本的实现是被默认采用的，它可以完美的工作在单服务器上（即访问并发量压力不大的情况下，并且它在失败的时候不会进行备份），大多数的项目都可以使用这个版本的实现来进行尝试，你可以在开发的时候使用它来进行管理，因为不会被保存到磁盘中，所以更易于调试。</li>
<li>JdbcTokenStore：这是一个基于JDBC的实现版本，令牌会被保存进关系型数据库。使用这个版本的实现时，你可以在不同的服务器之间共享令牌信息，使用这个版本的时候请注意把”spring-jdbc”这个依赖加入到你的classpath当中。</li>
<li>JwtTokenStore：这个版本的全称是 JSON Web Token（JWT），它可以把令牌相关的数据进行编码（因此对于后端服务来说，它不需要进行存储，这将是一个重大优势），但是它有一个缺点，那就是撤销一个已经授权令牌将会非常困难，所以它通常用来处理一个生命周期较短的令牌以及撤销刷新令牌（refresh_token）。另外一个缺点就是这个令牌占用的空间会比较大，如果你加入了比较多用户凭证信息。JwtTokenStore 不会保存任何数据，但是它在转换令牌值以及授权信息方面与 DefaultTokenServices 所扮演的角色是一样的。</li>
</ul>
<p><strong>配置授权类型（Grant Types）</strong></p>
<p>AuthorizationServerEndpointsConfigurer 这个对象的实例可以完成令牌服务以及令牌endpoint配置。</p>
<p>AuthorizationServerEndpointsConfigurer 通过设定以下属性决定支持的授权类型（Grant Types）:</p>
<ul>
<li>authenticationManager：认证管理器，当你选择了资源所有者密码（password）授权类型的时候，请设置这个属性注入一个 AuthenticationManager 对象。</li>
<li>userDetailsService：如果你设置了这个属性的话，那说明你有一个自己的 UserDetailsService 接口的实现，或者你可以把这个东西设置到全局域上面去（例如 GlobalAuthenticationManagerConfigurer 这个配置对象），当你设置了这个之后，那么 “refresh_token” 即刷新令牌授权类型模式的流程中就会包含一个检查，用来确保这个账号是否仍然有效，假如说你禁用了这个账户的话。</li>
<li>authorizationCodeServices：这个属性是用来设置授权码服务的（即 AuthorizationCodeServices 的实例对象），主要用于 “authorization_code” 授权码类型模式。</li>
<li>implicitGrantService：这个属性用于设置隐式授权模式，用来管理隐式授权模式的状态。</li>
<li>tokenGranter：当你设置了这个东西（即 TokenGranter 接口实现），那么授权将会交由你来完全掌控，并且会忽略掉上面的这几个属性，这个属性一般是用作拓展用途的，即标准的四种授权模式已经满足不了你的需求的时候，才会考虑使用这个。</li>
</ul>
<p><strong>配置授权端点的URL（Endpoint URLs）：</strong></p>
<p>AuthorizationServerEndpointsConfigurer 这个配置对象有一个叫做 pathMapping() 的方法用来配置端点URL链接，它有两个参数：</p>
<ul>
<li>第一个参数：String 类型的，这个端点URL的默认链接。</li>
<li>第二个参数：String 类型的，你要进行替代的URL链接。</li>
</ul>
<p>以上的参数都将以 “/“ 字符为开始的字符串，框架的默认URL链接如下列表，可以作为这个 pathMapping() 方法的第一个参数：</p>
<ul>
<li>/oauth/authorize：授权端点。</li>
<li>/oauth/token：令牌端点。</li>
<li>/oauth/confirm_access：用户确认授权提交端点。</li>
<li>/oauth/error：授权服务错误信息端点。</li>
<li>/oauth/check_token：用于资源服务访问的令牌解析端点。</li>
<li>/oauth/token_key：提供公有密匙的端点，如果你使用JWT令牌的话。</li>
</ul>
</blockquote>
<p><strong>将资源与角色的关系存redis中方便后面鉴权：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServiceImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ResourceMapper resourceMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; resourceRolesMap = resourceMapper.selectResourceMap();</span><br><span class="line">        <span class="keyword">if</span>(resourceRolesMap == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;资源未配置&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        redisUtil.hmset(<span class="string">&quot;auth:resourceRolesMap&quot;</span>, resourceRolesMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="oauth2-gateway"><a href="#oauth2-gateway" class="headerlink" title="oauth2-gateway"></a>oauth2-gateway</h4><p>接下来我们就可以搭建网关服务了，它将作为Oauth2的资源服务、客户端服务使用，对访问微服务的请求进行统一的校验认证和鉴权操作。</p>
<p><strong>依赖导入：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- webflux--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 网关--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-oauth2-resource-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 注册中心--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--hutool工具类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Redis依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Redis依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--fastjson依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- actuator--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- lombok--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>yaml配置：</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8004</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">oauth2-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">oauth2-auth-route</span> <span class="comment"># 路由ID，没有固定规则但是要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://security-test</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/auth/**</span> <span class="comment">#断言，路径相匹配的进行路由</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">oauth2-api-route</span> <span class="comment"># 路由ID，没有固定规则但是要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://service-provider</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/api/**</span> <span class="comment">#断言，路径相匹配的进行路由</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启从注册中心动态创建路由的功能</span></span><br><span class="line">          <span class="attr">lower-case-service-id:</span> <span class="literal">true</span> <span class="comment">#使用小写服务名，默认是大写</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment">#Redis服务器地址</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">1800000</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">secure:</span></span><br><span class="line">  <span class="attr">ignore:</span></span><br><span class="line">    <span class="attr">urls:</span> <span class="comment">#配置白名单路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/actuator/**&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/auth/oauth/token&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>对网关服务进行配置安全配置</strong></p>
<p>由于SpringCloud Gateway是基于webFlux的，跟SpringMVC传统方式是不兼容的：比如你在里面没法使用HttpServletRequest、HttpServletResponse，和HttpSession。</p>
<p>所以需要使用<code>@EnableWebFluxSecurity</code>注解开启</p>
<ol>
<li><p>白名单对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = false)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;secure.ignore&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IgnoreUrlsConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; urls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>两个异常处理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * 自定义返回结果：没有权限访问时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/12/6 21:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestfulAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title">ServerAccessDeniedHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">handle</span><span class="params">(ServerWebExchange exchange, AccessDeniedException denied)</span> </span>&#123;</span><br><span class="line">        ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.OK);</span><br><span class="line">        response.getHeaders().set(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">        response.getHeaders().set(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        response.getHeaders().set(<span class="string">&quot;Cache-Control&quot;</span>,<span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回错误状态类（这里简版省略）</span></span><br><span class="line">        String body= JSONUtil.toJsonStr(denied.getMessage());</span><br><span class="line">        DataBuffer buffer =  response.bufferFactory().wrap(body.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">return</span> response.writeWith(Mono.just(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wht</span></span><br><span class="line"><span class="comment"> * 自定义返回结果：没有登录或token过期时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/12/6 21:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestAuthenticationEntryPoint</span> <span class="keyword">implements</span> <span class="title">ServerAuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">commence</span><span class="params">(ServerWebExchange exchange, AuthenticationException e)</span> </span>&#123;</span><br><span class="line">        ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.OK);</span><br><span class="line">        response.getHeaders().set(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">        response.getHeaders().set(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        response.getHeaders().set(<span class="string">&quot;Cache-Control&quot;</span>,<span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">        <span class="comment">// 同样返回错误统一状态类</span></span><br><span class="line">        String body= JSONUtil.toJsonStr(e.getMessage());</span><br><span class="line">        DataBuffer buffer =  response.bufferFactory().wrap(body.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">return</span> response.writeWith(Mono.just(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>白名单过滤器：</p>
<p>去除白名单头部的jwt：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wht</span></span><br><span class="line"><span class="comment"> * 白名单路径访问时需要移除JWT请求头</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/12/6 21:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IgnoreUrlsRemoveJwtFilter</span> <span class="keyword">implements</span> <span class="title">WebFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IgnoreUrlsConfig ignoreUrlsConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, WebFilterChain chain)</span> </span>&#123;</span><br><span class="line">        ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">        URI uri = request.getURI();</span><br><span class="line">        PathMatcher pathMatcher = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line">        <span class="comment">//白名单路径移除JWT请求头</span></span><br><span class="line">        List&lt;String&gt; ignoreUrls = ignoreUrlsConfig.getUrls();</span><br><span class="line">        <span class="keyword">for</span> (String ignoreUrl : ignoreUrls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pathMatcher.match(ignoreUrl, uri.getPath())) &#123;</span><br><span class="line">                request = exchange.getRequest().mutate().header(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;&quot;</span>).build();</span><br><span class="line">                exchange = exchange.mutate().request(request).build();</span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>认证管理器：</p>
<p>进行jwt的解析，tokenStore保持与认证服务器中的一致并copy过来即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtAuthenticationManager</span> <span class="keyword">implements</span> <span class="title">ReactiveAuthenticationManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JwtAuthenticationManager</span><span class="params">(TokenStore tokenStore)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tokenStore = tokenStore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Authentication&gt; <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.justOrEmpty(authentication)</span><br><span class="line">                .filter(a -&gt; a <span class="keyword">instanceof</span> BearerTokenAuthenticationToken)</span><br><span class="line">                .cast(BearerTokenAuthenticationToken.class)</span><br><span class="line">                .map(BearerTokenAuthenticationToken::getToken)</span><br><span class="line">                .flatMap((accessToken -&gt; &#123;</span><br><span class="line">                    OAuth2AccessToken oAuth2AccessToken = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        oAuth2AccessToken = <span class="keyword">this</span>.tokenStore.readAccessToken(accessToken);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InvalidTokenException e)&#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;11111&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(oAuth2AccessToken == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> InvalidTokenException(<span class="string">&quot;无效的token！&quot;</span>));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oAuth2AccessToken.isExpired())&#123;</span><br><span class="line">                        <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> InvalidTokenException(<span class="string">&quot;token已过期！&quot;</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    OAuth2Authentication oAuth2Authentication = <span class="keyword">this</span>.tokenStore.readAuthentication(accessToken);</span><br><span class="line">                    <span class="keyword">if</span>(oAuth2Authentication == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> InvalidTokenException(<span class="string">&quot;无效的token！&quot;</span>));</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> Mono.just(oAuth2Authentication);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)).cast(Authentication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>权限管理器：</p>
<p>作用就是对令牌进行鉴权，如果该令牌无访问资源的权限，则不允通过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wht</span></span><br><span class="line"><span class="comment"> * 鉴权管理器，用于判断是否有资源的访问权限</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/12/6 19:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationManager</span> <span class="keyword">implements</span> <span class="title">ReactiveAuthorizationManager</span>&lt;<span class="title">AuthorizationContext</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IgnoreUrlsConfig ignoreUrlsConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;AuthorizationDecision&gt; <span class="title">check</span><span class="params">(Mono&lt;Authentication&gt; mono, AuthorizationContext authorizationContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取请求uri</span></span><br><span class="line">        ServerHttpRequest request = authorizationContext.getExchange().getRequest();</span><br><span class="line">        URI uri = request.getURI();</span><br><span class="line">        PathMatcher pathMatcher = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line">        <span class="comment">// 白名单路径直接放行</span></span><br><span class="line">        List&lt;String&gt; ignoreUrls = ignoreUrlsConfig.getUrls();</span><br><span class="line">        <span class="keyword">for</span> (String ignoreUrl : ignoreUrls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pathMatcher.match(ignoreUrl, uri.getPath())) &#123;</span><br><span class="line">                <span class="keyword">return</span> Mono.just(<span class="keyword">new</span> AuthorizationDecision(<span class="keyword">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对应跨域的预检请求直接放行</span></span><br><span class="line">        <span class="keyword">if</span>(request.getMethod()== HttpMethod.OPTIONS)&#123;</span><br><span class="line">            <span class="keyword">return</span> Mono.just(<span class="keyword">new</span> AuthorizationDecision(<span class="keyword">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进行校验权限</span></span><br><span class="line">        Map&lt;Object, Object&gt; resourceRolesMap = redisUtil.hmget(<span class="string">&quot;auth:resourceRolesMap&quot;</span>);</span><br><span class="line">        Iterator&lt;Object&gt; iterator = resourceRolesMap.keySet().iterator();</span><br><span class="line">        <span class="comment">// 获取该路径所需权限</span></span><br><span class="line">        List&lt;String&gt; authorities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            String pattern = (String) iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (pathMatcher.match(pattern, uri.getPath())) &#123;</span><br><span class="line">                authorities.addAll(Convert.toList(String.class, resourceRolesMap.get(pattern)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//认证通过且角色匹配的用户可访问当前路径</span></span><br><span class="line">        <span class="keyword">return</span> mono</span><br><span class="line">                <span class="comment">// 判断是否认证成功</span></span><br><span class="line">                .filter(Authentication::isAuthenticated)</span><br><span class="line">                <span class="comment">// 获取全部角色权限</span></span><br><span class="line">                .flatMapIterable(Authentication::getAuthorities)</span><br><span class="line">                .map(GrantedAuthority::getAuthority)</span><br><span class="line">                <span class="comment">// 判断是否包含</span></span><br><span class="line">                .any(authorities::contains)</span><br><span class="line">                .map(AuthorizationDecision::<span class="keyword">new</span>)</span><br><span class="line">                .defaultIfEmpty(<span class="keyword">new</span> AuthorizationDecision(<span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整配置(注意tokenStore复制之前认证服务器的要保证一致)：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wht</span></span><br><span class="line"><span class="comment"> * 网关安全服务配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/12/6 19:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFluxSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthorizationManager authorizationManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IgnoreUrlsConfig ignoreUrlsConfig;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestfulAccessDeniedHandler restfulAccessDeniedHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestAuthenticationEntryPoint restAuthenticationEntryPoint;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IgnoreUrlsRemoveJwtFilter ignoreUrlsRemoveJwtFilter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityWebFilterChain <span class="title">springSecurityFilterChain</span><span class="params">(ServerHttpSecurity http)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// http.oauth2ResourceServer().jwt().authenticationManager(getAuthenticationManager());</span></span><br><span class="line">        <span class="comment">//token管理器</span></span><br><span class="line">        ReactiveAuthenticationManager tokenAuthenticationManager = <span class="keyword">new</span> JwtAuthenticationManager(tokenStore);</span><br><span class="line">        <span class="comment">//认证过滤器</span></span><br><span class="line">        AuthenticationWebFilter authenticationWebFilter = <span class="keyword">new</span> AuthenticationWebFilter(tokenAuthenticationManager);</span><br><span class="line">        authenticationWebFilter.setServerAuthenticationConverter(<span class="keyword">new</span> ServerBearerTokenAuthenticationConverter());</span><br><span class="line">        <span class="comment">//oauth2认证过滤器</span></span><br><span class="line">        http.addFilterAt(authenticationWebFilter, SecurityWebFiltersOrder.AUTHENTICATION);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义处理JWT请求头过期或签名错误的结果</span></span><br><span class="line">        <span class="comment">// http.oauth2ResourceServer().authenticationEntryPoint(restAuthenticationEntryPoint);</span></span><br><span class="line">        <span class="comment">//对白名单路径，直接移除JWT请求头</span></span><br><span class="line">        http.addFilterBefore(ignoreUrlsRemoveJwtFilter, SecurityWebFiltersOrder.AUTHENTICATION);</span><br><span class="line">        http.authorizeExchange()</span><br><span class="line">                <span class="comment">//白名单配置</span></span><br><span class="line">                .pathMatchers(ArrayUtil.toArray(ignoreUrlsConfig.getUrls(),String.class)).permitAll()</span><br><span class="line">                <span class="comment">//鉴权管理器配置</span></span><br><span class="line">                .anyExchange().access(authorizationManager)</span><br><span class="line">                .and().exceptionHandling()</span><br><span class="line">                <span class="comment">//处理未授权</span></span><br><span class="line">                .accessDeniedHandler(restfulAccessDeniedHandler)</span><br><span class="line">                <span class="comment">//处理未认证</span></span><br><span class="line">                .authenticationEntryPoint(restAuthenticationEntryPoint)</span><br><span class="line">                .and().csrf().disable();</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>设置全局过滤器：</strong></p>
<p>当鉴权通过后将JWT令牌中的用户信息解析出来，然后存入请求的Header中，这样后续服务就不需要解析JWT令牌了，可以直接从请求的Header中获取到用户信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wht</span></span><br><span class="line"><span class="comment"> * 将登录用户的JWT转化成用户信息的全局过滤器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/12/6 21:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthGlobalFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(AuthGlobalFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        String token = exchange.getRequest().getHeaders().getFirst(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isEmpty(token)) &#123;</span><br><span class="line">            <span class="comment">// jwt为空直接放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从token中解析用户信息并设置到Header中去</span></span><br><span class="line">        String realToken = StrUtil.subAfter(token, <span class="string">&quot;Bearer &quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">        Claims body = Jwts.parser()</span><br><span class="line">                .setSigningKey(<span class="string">&quot;wht&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">                .parseClaimsJws(realToken)</span><br><span class="line">                .getBody();</span><br><span class="line">        String userStr = body.toString();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;AuthGlobalFilter.filter() user:&#123;&#125;&quot;</span>,userStr);</span><br><span class="line">        ServerHttpRequest request = exchange.getRequest().mutate().header(<span class="string">&quot;Authorization&quot;</span>, userStr).build();</span><br><span class="line">        exchange = exchange.mutate().request(request).build();</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="效果测试"><a href="#效果测试" class="headerlink" title="效果测试"></a>效果测试</h3><ol>
<li><p>访问网关获取token（使用密码模式）：</p>
<p><code>http://localhost:8004/auth/oauth/token</code></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221207223522234.png" alt="image-20221207223522234"></p>
</li>
<li><p>带着token去访问服务接口：</p>
<p><code>http://localhost:8004/api/user/currentUser</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>分布式权限认证</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>权限认证</tag>
      </tags>
  </entry>
  <entry>
    <title>开源协议</title>
    <url>/2023/12/05/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>开源协议是规定软件源代码如何被使用、修改和分发的法律文本。这些协议为开发者提供了在保持源代码开放的同时，规定了一些使用条件和责任。以下是一些常见的开源协议：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20231130103021079.png" alt="image-20231130103021079" style="zoom: 67%;" />

<h2 id="主流协议"><a href="#主流协议" class="headerlink" title="主流协议"></a>主流协议</h2><ol>
<li><strong>GNU通用公共许可证（GNU General Public License，GPL）：</strong><ul>
<li>特点：软件的使用是免费的，强调用户有权查看、修改和重新分发源代码。如果您修改了代码并重新分发，您的修改必须也是开源的。</li>
<li>版本：GPL有不同的版本，包括GPLv2和GPLv3。</li>
<li>场景：适用于二次或N次开发，那么发布时要带上源码，让其传播，所以它最终的版权是大众的，而非某一个人的，因此不用交钱就可以使用。</li>
</ul>
</li>
<li><strong>MIT许可证：</strong><ul>
<li>特点：目前限制最少的开源许可协议之一(比BSD和Apache的限制都少)，只要程序的开发者在修改后的源代码中保留原作者的许可信息即可，简单且自由度较高。允许在源代码中包含此许可证，允许任何人免费使用、修改和分发您的代码，只需保留原始许可证和版权声明。</li>
<li>场景：普遍被商业软件所使用。</li>
</ul>
</li>
<li><strong>Apache许可证：</strong><ul>
<li>特点：Apache协议具体为许可证版本（Apache License Version)协议，Apache和BSD类似，都适用于商业软件，用户拥有修改代码及再发布的自由。Hadoop、Apache HTTP Server、MongoDB等项目都是基于该许可协议研发的，程序开发人员在开发遵循该协议的软件时，要严格遵守下面的四个条件:<ul>
<li>该软件及其衍生品必须继续使用Apache许可协议。</li>
<li>如果修改了程序源代码，需要在文档中进行声明。</li>
<li>若软件是基于他人的源代码编写而成的，则需要保留原始代码的协议、商标、专利声明及其他原作者声明的内容信息。</li>
<li>如果再发布的软件中有声明文件，则需在此文件中标注Apache许可协议及其他许可协议。</li>
</ul>
</li>
</ul>
</li>
<li><strong>BSD许可证：</strong><ul>
<li>特点：BSD协议给予用户极大的权利，用户可以使用、修改和重新发布遵循该许可的软件，并且可以将软件作为商业软件发布和销售，前提是需要满足下面三个条件：<ul>
<li>如果再发布的软件中包含源代码，则源代码必须继续遵循BSD许可协议。</li>
<li>如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了BSD协议。</li>
<li>不允许用原始软件的名字、作者名字或机构名称等进行市场推广。</li>
</ul>
</li>
<li>场景：BSD对商业比较友好，很多公司在选用开源产品的时候都首选BSD 协议，因为可以完全控制这些第三方的代码，甚至在必要的时候可以修改或者二次开发。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>系统设计</category>
      </categories>
      <tags>
        <tag>开源协议</tag>
      </tags>
  </entry>
  <entry>
    <title>CICD</title>
    <url>/2023/03/10/DevOps/CICD/CICD/</url>
    <content><![CDATA[<h1 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="什么是CI"><a href="#什么是CI" class="headerlink" title="什么是CI"></a>什么是CI</h3><p>CI：Continuous integration持续集成</p>
<p>开发人员通常使用称为CI Server的工具来进行构建和集成。CI要求自检代码。这是用于自我测试以确保其按预期工作的代码，这些测试通常称为单元测试。集成代码后，当所有单元测试通过时，将得一个最新的的代码版本。这表明他们已经验证了自己的更改已成功集成到一起，并且代码按测试期望的那样工作。</p>
<h3 id="什么是CD"><a href="#什么是CD" class="headerlink" title="什么是CD"></a>什么是CD</h3><p>CD：Continuous deployment持续部署</p>
<p>在这种实践中，团队负责人所做的每一项更改都通过了所有测试阶段，并自动投入生产。要实现连续部署，团队负责人首先需要进行连续交付，因此在开始练习连续部署之前，先决定哪个对您更合适，持续交付都是为了增强整个业务的能力，因此至少您应该参与确定是否应该使用持续部署。</p>
<blockquote>
<p>CD还有个小号，叫持续交付，英文全称是Continuous delivery，缩写也是CD</p>
</blockquote>
<h3 id="为什么需要CI-CD"><a href="#为什么需要CI-CD" class="headerlink" title="为什么需要CI/CD"></a>为什么需要CI/CD</h3><p>持续集成（CI）是一种开发实践，其中开发人员经常（最好每天几次）将代码集成到共享存储库中。然后可以通过自动构建和自动测试来验证每个集成。尽管自动化测试不是严格意义上的CI的一部分，但通常隐含了它。定期集成的主要好处之一是，您可以快速检测到错误并更轻松地定位它们。由于引入的每个更改通常很小，因此可以快速查明引入缺陷的特定更改。<br>近年来，CI已成为软件开发的最佳实践，并遵循一系列关键原则。其中包括版本控制，构建自动化和自动化测试。此外，持续部署和持续交付已成为最佳实践，可让您随时随地部署应用程序，甚至在每次引入新更改时甚至将主代码库自动推入生产环境。这使您的团队可以快速行动，同时保持可以自动检查的高质量标准。</p>
<h3 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h3><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230131210254544.png" alt="image-20230131210254544" style="zoom: 80%;" />

<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><strong>环境落地：</strong></p>
<ul>
<li>代码仓库：GitLab（进行代码托管/合并/冲突）</li>
</ul>
<h3 id="GitLab搭建"><a href="#GitLab搭建" class="headerlink" title="GitLab搭建"></a>GitLab搭建</h3><p>官方网站：<a href="https://about.gitlab.com/">https://about.gitlab.com/</a></p>
<p>安装文档：<a href="https://gitlab.cn/install/?version=ce">https://gitlab.cn/install/?version=ce</a></p>
<blockquote>
<p>安装所需最小配置：内存至少要分配4G</p>
</blockquote>
<h4 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h4><h5 id="普通安装"><a href="#普通安装" class="headerlink" title="普通安装"></a>普通安装</h5><ol>
<li><p>创建一台内存大于5G的linux虚拟机</p>
</li>
<li><p>安装和配置必须的依赖项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y curl policycoreutils-python openssh-server perl</span><br><span class="line">sudo systemctl enable sshd</span><br><span class="line">sudo systemctl start sshd</span><br><span class="line">sudo firewall-cmd --permanent --add-service=http</span><br><span class="line">sudo firewall-cmd --permanent --add-service=https</span><br><span class="line">sudo systemctl reload firewalld</span><br></pre></td></tr></table></figure></li>
<li><p>配置镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://packages.gitlab.cn/repository/raw/scripts/setup.sh | /bin/bash</span><br></pre></td></tr></table></figure></li>
<li><p>开始安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo EXTERNAL_URL=&quot;自己的ip/域名&quot; yum install -y gitlab-jh</span><br></pre></td></tr></table></figure></li>
<li><p>访问：<a href="http://ip/">http://ip</a></p>
</li>
</ol>
<h5 id="Docker方式安装"><a href="#Docker方式安装" class="headerlink" title="Docker方式安装"></a>Docker方式安装</h5><ol>
<li><p>创建一台内存大于5G的linux虚拟机</p>
</li>
<li><p>安装docker（省略）</p>
</li>
<li><p>创建gitlab容器（会自动拉取镜像）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run --detach \</span><br><span class="line">  --hostname 本机ip \</span><br><span class="line">  --publish 443:443 --publish 80:80 --publish 22:22 \</span><br><span class="line">  --name gitlab \</span><br><span class="line">  --restart always \</span><br><span class="line">  --volume $GITLAB_HOME/config:/etc/gitlab \</span><br><span class="line">  --volume $GITLAB_HOME/logs:/var/log/gitlab \</span><br><span class="line">  --volume $GITLAB_HOME/data:/var/opt/gitlab \</span><br><span class="line">  --shm-size 256m \</span><br><span class="line">  registry.gitlab.cn/omnibus/gitlab-jh:latest</span><br></pre></td></tr></table></figure></li>
<li><p>运行容器：<code>docker start gitlab</code></p>
</li>
<li><p>访问：<a href="http://ip/">http://ip</a></p>
</li>
</ol>
<blockquote>
<p>除非您在安装过程中指定了自定义密码，否则将随机生成一个密码并存储在 /etc/gitlab/initial_root_password 文件中(出于安全原因，24 小时后，此文件会被第一次 <code>gitlab-ctl reconfigure</code> 自动删除，因此若使用随机密码登录，建议安装成功初始登录成功之后，立即修改初始密码）。使用此密码和用户名 <code>root</code> 登录。并且可以登录后在gitlab的管理中心-用户进行修改密码。</p>
<p>具体文档参考：<a href="https://docs.gitlab.cn/omnibus/installation/">https://docs.gitlab.cn/omnibus/installation/</a></p>
</blockquote>
<h4 id="GitLab常用命令："><a href="#GitLab常用命令：" class="headerlink" title="GitLab常用命令："></a>GitLab常用命令：</h4><ul>
<li>启动所有gitlab组件：<code>gitlab-ctl start</code></li>
<li>停止所有gitlab组件：<code>gitlab-ctl stop</code></li>
<li>重启所有gitlab组件：<code>gitlab-ctl restart</code></li>
<li>查看服务状态：<code>gitlab-ctl status</code></li>
<li>启动服务：<code>gitlab-ctl reconfigure</code></li>
<li>修改默认配置文件：<code>vi /etc/gitlab/gitlab.rb</code></li>
<li>查看日志：<code>gitlab-ctl tail</code></li>
</ul>
<h3 id="JenKins-安装"><a href="#JenKins-安装" class="headerlink" title="JenKins 安装"></a>JenKins 安装</h3><p>官方文档：<a href="https://www.jenkins.io/">https://www.jenkins.io</a></p>
<p>安装需求：</p>
<ul>
<li><p>最低推荐配置:</p>
<p>256MB可用内存</p>
<p>1GB可用磁盘空间(作为一个Docker容器运行jenkins的话推荐10GB)</p>
</li>
<li><p>为小团队推荐的硬件配置:</p>
<p>1GB+可用内存</p>
<p>50 GB+ 可用磁盘空间</p>
</li>
<li><p>软件配置:</p>
<p>Java 8—无论是Java运行时环境（JRE）还是Java开发工具包（JDK）都可以。</p>
</li>
</ul>
<blockquote>
<p>注意: 如果将Jenkins作为Docker 容器运行，这不是必需的</p>
</blockquote>
<h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><ol>
<li>下载<a href="https://www.jenkins.io/zh/download/">Jenkins</a>，并上传到虚拟机</li>
<li>安装JDK：<ol>
<li>检查可用包：<code>yum search java|grep jdk</code></li>
<li>安装JRE：<code>yum install java-1.8.0-openjdk</code></li>
<li>再安装JDK：<code>yum install -y java-devel</code></li>
</ol>
</li>
<li>运行Jenkins：<code>java -jar jenkins.war</code></li>
<li>访问Jenkins进行初始化并安装推荐插件：<a href="http://ip:8080/">http://ip:8080</a></li>
<li>安装maven（如果下载依赖慢可以配置国内仓库）：<ol>
<li>官方下载<a href="https://maven.apache.org/download.cgi">压缩包</a>，并上传到虚拟机</li>
<li>解压：<code>tar -zxvf apache-maven-3.8.7-bin.tar.gz</code></li>
<li>移动目录：<code>mv apache-maven-3.8.7 /usr/local/maven </code></li>
<li>查看版本：<code>/usr/local/maven/bin/mvn -v</code></li>
<li>修改maven配置文件修改仓库源为国内仓库</li>
</ol>
</li>
<li>安装Git：<code>yum install git</code></li>
</ol>
<h2 id="Jenkins简单使用"><a href="#Jenkins简单使用" class="headerlink" title="Jenkins简单使用"></a>Jenkins简单使用</h2><h3 id="配置Maven-Git自动构建jar包"><a href="#配置Maven-Git自动构建jar包" class="headerlink" title="配置Maven + Git自动构建jar包"></a>配置Maven + Git自动构建jar包</h3><ol>
<li><p>进入Jenkins</p>
</li>
<li><p>在Manage Jenkins 一栏中Plugin Manager安装Maven Integration插件</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230206194944348.png" alt="image-20230206194944348"></p>
</li>
<li><p>在首页点击构建Item新项目，选择构建一个Maven项目</p>
</li>
<li><p>项目配置：</p>
<ol>
<li>修改源码管理为Git，并填写URL（如果仓库为非公开需要配置凭证），修改分支</li>
<li>配置Build，在Global Tool Configuration中配置Maven（Name和Maven_Home）</li>
<li>配置POM路径（相对于仓库根目录，一般为项目名/pom.xml）</li>
</ol>
</li>
<li><p>首页选择刚创建的项目，点击右侧的开始Build按钮</p>
</li>
</ol>
<h3 id="配置将jar包自动部署在服务器"><a href="#配置将jar包自动部署在服务器" class="headerlink" title="配置将jar包自动部署在服务器"></a>配置将jar包自动部署在服务器</h3><ol>
<li><p>保证服务器上有Java环境</p>
</li>
<li><p>在Jenkins上安装Publish Over SSH插件</p>
</li>
<li><p>在Manage Jenkins一栏里的Configure System里配置Publish over SSH服务器</p>
<ol>
<li><p>设置服务器名Name</p>
</li>
<li><p>设置主机地址Hostname</p>
</li>
<li><p>设置账号Username</p>
</li>
<li><p>设置密码：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230206201849153.png" alt="image-20230206201849153"></p>
</li>
</ol>
</li>
<li><p>重新配置刚才的创建的项目</p>
<ol>
<li><p>配置Post Steps：</p>
<ol>
<li>点击下面按钮</li>
</ol>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230206201429060.png" alt="image-20230206201429060"></p>
<ol start="2">
<li><p>配置Source files路径（例如<code>**/项目名/target/*.jar</code>）</p>
</li>
<li><p>配置Remove prefix移除不需要的路径前缀</p>
</li>
<li><p>配置Remote directory发送到的地址（例如：<code>/usr/app/demo-1</code>)</p>
</li>
<li><p>配置送到服务器后需要执行的命令：<code>nohup java -jar jar包目录/demo*.jar &gt;mylog.log 2&gt;&amp;1 &amp; </code>(2&gt;&amp;1的意思就是不管正常错误都写入日志)</p>
</li>
<li><p>如果jar过大，可以配置超时时间</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230206204335299.png" alt="image-20230206204335299"></p>
</li>
</ol>
</li>
<li><p>配置Pre Steps（清理进程、jar包）：</p>
<ol>
<li>点击下面按钮</li>
</ol>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230206204533327.png" alt="image-20230206204533327"></p>
<ol start="2">
<li><p>编写shell脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">删除历史数据</span></span><br><span class="line">rm -rf 每次传过来的项目路径</span><br><span class="line">appname=$1</span><br><span class="line"><span class="meta">#</span><span class="bash">获取正在运行的jar包pid</span></span><br><span class="line">pid=`ps -ef | grep $appname | grep -v grep | awk &#x27;&#123;printf $2&#125;&#x27;`</span><br><span class="line"><span class="meta">#</span><span class="bash">杀死当前进行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果pid为空提示，否则执行<span class="built_in">kill</span></span></span><br><span class="line">if [ -z $pid ];</span><br><span class="line">	then</span><br><span class="line">		echo &quot;$appname no started&quot;</span><br><span class="line">    else</span><br><span class="line">    	kill -9 $pid</span><br><span class="line">    	echo &quot;$appname stopping..&quot;</span><br><span class="line">fi</span><br><span class="line">check=`ps -ef | grep -w $pid | grep java`</span><br><span class="line">if [ -z $check ];</span><br><span class="line">	then</span><br><span class="line">		echo &quot;$appname pid:$pid is stop&quot;</span><br><span class="line">    else</span><br><span class="line">    	echo &quot;$appname stop failed&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
<li><p>配置送到服务器前需要执行的命令：<code>./脚本名.sh 项目名</code></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="构建触发器"><a href="#构建触发器" class="headerlink" title="构建触发器"></a>构建触发器</h2><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230207194535764.png" alt="image-20230207194535764"></p>
<blockquote>
<p>cron网站：<a href="https://crontab.guru/">https://crontab.guru</a></p>
</blockquote>
<h3 id="自动化构建"><a href="#自动化构建" class="headerlink" title="自动化构建"></a>自动化构建</h3><p>如果gitlab上修改了代码，Jenkins就自动从gitlab中拉取并上传服务器。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li><p>在Jenkins的项目配置中配置构建触发器：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230207192850303.png" alt="image-20230207192850303"></p>
</li>
<li><p>在Jenkins里的Plugin Manager中安装Build Authorization Token Root插件（地址变为buildByToken/build?job=项目名&amp;toekn=令牌）</p>
</li>
<li><p>在gitlab上的设置里的webhooks配置自动调用Jenkins的回调：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230207193606795.png" alt="image-20230207193606795"></p>
<blockquote>
<p>如果出现<code>Url is blocked:Requests to the local network are not allowed</code>问题</p>
<p>点击左上角菜单，点管理员-&gt;设置-&gt;网络-&gt;出站请求</p>
<p>勾选允许来自web hooks 和服务对本地网络的请求</p>
</blockquote>
</li>
</ol>
<h2 id="将jar包部署到Docker中"><a href="#将jar包部署到Docker中" class="headerlink" title="将jar包部署到Docker中"></a>将jar包部署到Docker中</h2><ol>
<li><p>方式一：外挂目录</p>
<p>适用于小型项目，最开始就创建一个jdk的容器，并且映射jar包的目录在宿主主机上，这样就可以只用修改宿主主机的jar包再重启容器即可完成部署。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230208195346442.png" alt="image-20230208195346442" style="zoom:67%;" />
</li>
<li><p>方式二：jar包直接打包到镜像里</p>
<p>Jenkins发送dockerfile和相关项目jar包到docker服务器中，并且根据dockerfile生成新的镜像，创建相应容器并启动完成部署。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230208195537230.png" alt="image-20230208195537230" style="zoom:67%;" />
</li>
<li><p>方式三：生成新镜像，推送到docker私服中</p>
<p>适用于大型项目，并且整个项目都是使用k8s等云原生环境的场景。</p>
<p>Jenkins发送dockerfile和相关项目jar包到docker服务器中，并且根据dockerfile生成新的镜像，再将新的镜像推送到Harbor（docker私服）中，再由k8s集群去拉取镜像生成相应的docker容器。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230208195951246.png" alt="image-20230208195951246"></p>
</li>
</ol>
<h3 id="方式一外挂目录"><a href="#方式一外挂目录" class="headerlink" title="方式一外挂目录"></a>方式一外挂目录</h3><p><strong>实现步骤：</strong></p>
<ol>
<li><p>创建有docker环境的虚拟机</p>
</li>
<li><p>上传jar包</p>
</li>
<li><p>根据jdk镜像创建容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name demo-docker -v jar包路径:/app.jar openjdk:8 java -jar app.jar</span><br></pre></td></tr></table></figure></li>
<li><p>在Jenkins的Pre Steps中添加清除jar包命令，Post Steps中添加重启容器</p>
</li>
</ol>
<h3 id="方式二jar包直接打包到镜像里"><a href="#方式二jar包直接打包到镜像里" class="headerlink" title="方式二jar包直接打包到镜像里"></a>方式二jar包直接打包到镜像里</h3><p><strong>实现步骤：</strong></p>
<ol>
<li><p>创建有docker环境的虚拟机</p>
</li>
<li><p>上传jar包</p>
</li>
<li><p>编写dockerfile并存在java项目中并一起提交gitlab：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像使用java</span></span><br><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"><span class="comment"># 作者</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> wht</span><br><span class="line"><span class="comment"># WORKDIR 指定在创建容器后，终端默认登陆的进来工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br><span class="line"><span class="comment"># 将jar包添加到容器中并更名为springBoot_docker.jar</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> docker_boot*.jar /root/springBoot_docker.jar</span></span><br><span class="line"><span class="comment"># 运行jar包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> bash -c <span class="string">&#x27;touch /root/springBoot_docker.jar&#x27;</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/root/springBoot_docker.jar&quot;</span>]</span></span><br><span class="line"><span class="comment">#暴露8080端口作为微服务</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></li>
<li><p>在Jenkins的Pre Steps中添加清除jar包命令删除镜像、容器：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230208202331560.png" alt="image-20230208202331560"></p>
</li>
<li><p>Post Steps中添加编写的dockerfile并根据dockerfile创建镜像运行容器：</p>
<ul>
<li>构建镜像：<code>docker build -f Dockerfile -t springBoot_docker:1.6</code></li>
<li>运行容器：<code>docker run -d -p 8080:8080 springBoot_docker:1.6</code></li>
</ul>
</li>
</ol>
<h2 id="Jenkins集群-并发构建"><a href="#Jenkins集群-并发构建" class="headerlink" title="Jenkins集群/并发构建"></a>Jenkins集群/并发构建</h2><ul>
<li><p>首先准备多台安装了Jenkins、Maven、jdk的虚拟机</p>
</li>
<li><p>在主节点上进行配置：</p>
<ul>
<li><p>点击Manage Jenkins里的Manage Nodes and Clouds</p>
</li>
<li><p>点击新建多个节点，并配置远程工作目录、标签、用法、启动方式为ssh</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230209195352910.png" alt="image-20230209195352910"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230209195702888.png" alt="image-20230209195702888"></p>
</li>
<li><p>对Item项目进行配置：</p>
<ul>
<li>在General中勾选【在必要的时候并发构建】</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="流水线pipeline"><a href="#流水线pipeline" class="headerlink" title="流水线pipeline"></a>流水线pipeline</h2><p>流水线既能作为任务的本身，也能作为Jenkinsfile</p>
<p>使用流水线可以让我们的任务从ui手动操作，转换为代码化，像docker的dockerfile一样，从shell命令到配置文件，更适合大型项目，可以让团队其他开发者同时参与进来，同时也可以编辑开发Jenkinswebui不能完成的更复杂的构建逻辑，作为开发者可读性也更好。</p>
<h3 id="完整语法"><a href="#完整语法" class="headerlink" title="完整语法"></a>完整语法</h3><p>5个必备的组成部分</p>
<ul>
<li>pipeline：整条流水线</li>
<li>agent：指定执行器</li>
<li>stages：所有阶段</li>
<li>stage：某一阶段，可有多个</li>
<li>steps：阶段内的每一步，可执行命令</li>
</ul>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><ol>
<li><p>首页新建Pipeline项目</p>
</li>
<li><p>编写Pipeline脚本并保存</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230209201436239.png" alt="image-20230209201436239"></p>
</li>
<li><p>点击运行按钮</p>
</li>
</ol>
<blockquote>
<p>如果想比原生ui更加直观的话，可有在插件管理中安装blue ocean插件</p>
</blockquote>
<h3 id="使用pipeline自动打包Docker镜像"><a href="#使用pipeline自动打包Docker镜像" class="headerlink" title="使用pipeline自动打包Docker镜像"></a>使用pipeline自动打包Docker镜像</h3><ul>
<li><p>通过代码生成器，来通过ui生成pipeline脚本</p>
</li>
<li><p>编写pipeline脚本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line">	agent any</span><br><span class="line">	tools &#123;</span><br><span class="line">        maven <span class="string">&quot;maven3(Jekins里面配置的maven名称)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">	stages &#123;</span><br><span class="line">		stage(<span class="string">&quot;拉取代码&quot;</span>)&#123;</span><br><span class="line">			steps &#123;</span><br><span class="line">                git branch: <span class="string">&#x27;master&#x27;</span>, credentialsId: <span class="string">&#x27;gitlab&#x27;</span>, url: <span class="string">&#x27;http:/ /192.168.44.103/root/java-project.git&#x27;</span></span><br><span class="line">				echo <span class="string">&#x27;拉取成功&#x27;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        stage(<span class="string">&quot;执行构建&quot;</span>)&#123;</span><br><span class="line">			steps &#123;</span><br><span class="line">                sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                    cd demo-1</span></span><br><span class="line"><span class="string">                	mvn clean package</span></span><br><span class="line"><span class="string">                   &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">				echo  <span class="string">&#x27;构建成功&#x27;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        stage(<span class="string">&quot;清理工作&quot;</span>)&#123;</span><br><span class="line">			steps &#123;</span><br><span class="line">                ...这里由代码生成器生成ssh清理文件镜像容器的脚本代码省略</span><br><span class="line">				echo  <span class="string">&#x27;清理成功&#x27;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        stage(<span class="string">&quot;发送jar包到测试服务器&quot;</span>)&#123;</span><br><span class="line">			steps &#123;</span><br><span class="line">                ...这里由代码生成器生成的脚本代码省略</span><br><span class="line">				echo <span class="string">&#x27;发送成功并构建了相应容器&#x27;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>运行项目</p>
</li>
</ul>
<h2 id="创建gitlab多分支job"><a href="#创建gitlab多分支job" class="headerlink" title="创建gitlab多分支job"></a>创建gitlab多分支job</h2><p>大致流程：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230209204610486.png" alt="image-20230209204610486"></p>
<p><strong>简单使用：</strong></p>
<ol>
<li><p>在blue ocean里面点击创建流水线，点击Git创建Git连接</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230209204514131.png" alt="image-20230209204514131"></p>
</li>
<li><p>修改项目的gitlab凭证配置</p>
</li>
<li><p>修改项目的Jenkinsfile配置：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230209204738905.png" alt="image-20230209204738905"></p>
</li>
<li><p>给各个分支编写Jenkinsfile</p>
</li>
<li><p>让项目进行重新scan</p>
</li>
<li><p>点击分支查看：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230209204956745.png" alt="image-20230209204956745"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Devops</category>
        <category>CICD</category>
      </categories>
      <tags>
        <tag>CICD</tag>
        <tag>持续集成持续部署</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2022/09/28/DevOps/Linux/Linux/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>Linux 是一款操作系统，免费，开源， 安全，高效，稳定， 处理高并发非常强悍，现在很多的企业级的项目都部署到 Linux/unix 服务器运行。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>CentOS下载地址：<ul>
<li>官方：<a href="https://www.centos.org/download/">https://www.centos.org/download/</a></li>
<li>网易镜像:<a href="http://mirrors.163.comlcentos/6/isos/">http://mirrors.163.comlcentos/6/isos/</a></li>
<li>搜狐镜像:<a href="http://mirrors.sohu.comlcentos/6/isos">http://mirrors.sohu.comlcentos/6/isos</a></li>
</ul>
</li>
<li>安装VMware</li>
<li>创建虚拟机</li>
<li>安装Centos<ul>
<li>进行处理器配置（虚拟机总核心数不能超过主机核心数。若超出则会警告提醒。）</li>
<li>配置虚拟机内存</li>
<li>设置centos镜像文件</li>
<li>配置网络类型（一般选择NAT模式，桥接模式容易ip冲突）</li>
<li>选择语言、网络配置、安装相关环境等….（注意有需要可以选择安装<strong>GNOME Desktop</strong>图形界面）</li>
<li>进行磁盘分区（/boot区(大概1G)、swap交换分区(大概2G)、根分区/(剩余都是)）</li>
<li>等待开机即可</li>
</ul>
</li>
</ul>
<h2 id="Linux目录结果"><a href="#Linux目录结果" class="headerlink" title="Linux目录结果"></a>Linux目录结果</h2><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220719094340797.png" alt="image-20220719094340797"></p>
<p>以下是对这些目录的解释：</p>
<ul>
<li><p><strong>/bin</strong>：<br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</p>
</li>
<li><p><strong>/boot：</strong><br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p>
</li>
<li><p><strong>/dev ：</strong><br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p>
</li>
<li><p><strong>/etc：</strong><br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p>
</li>
<li><p><strong>/home</strong>：<br>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p>
</li>
<li><p><strong>/lib</strong>：<br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p>
</li>
<li><p><strong>/lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p>
</li>
<li><p><strong>/media</strong>：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p>
</li>
<li><p><strong>/mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</p>
</li>
<li><p><strong>/opt</strong>：<br>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p>
</li>
<li><p><strong>/proc</strong>：<br>proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</p>
</li>
<li><p><strong>/root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p>
</li>
<li><p><strong>/sbin</strong>：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p>
</li>
<li><p><strong>/selinux</strong>：<br>这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p>
</li>
<li><p><strong>/srv</strong>：<br>该目录存放一些服务启动之后需要提取的数据。</p>
</li>
<li><p><strong>/sys</strong>：</p>
<p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</p>
<p>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</p>
<p>该文件系统是内核设备树的一个直观反映。</p>
<p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p>
</li>
<li><p><strong>/tmp</strong>：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p>
</li>
<li><p><strong>/usr</strong>：<br>usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p>
</li>
<li><p><strong>/usr/bin：</strong><br>系统用户使用的应用程序。</p>
</li>
<li><p><strong>/usr/sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p>
</li>
<li><p><strong>/usr/src：</strong><br>内核源代码默认的放置目录。</p>
</li>
<li><p><strong>/var</strong>：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>
</li>
<li><p><strong>/run</strong>：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p>
</li>
</ul>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="关机-重启"><a href="#关机-重启" class="headerlink" title="关机/重启"></a>关机/重启</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sync 将数据由内存同步到硬盘中。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shutdown –h now 立马关机</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shutdown –h 20:25 系统会在今天20:25关机</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shutdown –h +10 十分钟后关机</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shutdown –r now 系统立马重启</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shutdown –r +10 系统十分钟后重启</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> reboot 就是重启，等同于 shutdown –r now</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> halt 关闭系统，等同于shutdown –h now 和 poweroff</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> shutdown -c <span class="comment">###要取消即将进行的关机</span></span></span><br></pre></td></tr></table></figure>
<h3 id="运行级别相关"><a href="#运行级别相关" class="headerlink" title="运行级别相关"></a>运行级别相关</h3><p>运行级别说明：</p>
<p>0 ：关机、1  ：单用户【找回丢失密码】、2：多用户状态没有网络服务、3：多用户状态有网络服务、4：系统未使用保留给用户、5：图形界面、6：系统重启（常用运行级别是 3 和 5）</p>
<ul>
<li>修改运行级别：<code>init 级别</code></li>
</ul>
<h3 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h3><ul>
<li>man：<code>man [命令或配置文件]</code></li>
<li>help：<code>help 命令 </code></li>
</ul>
<h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><ul>
<li><p>显示当前目录：<code>pwd</code></p>
</li>
<li><p>列出目录文件：<code>ls [ 选 项] [目录或是文件]</code></p>
<ul>
<li>选项：<ul>
<li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li>
<li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li>
<li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li>
</ul>
</li>
</ul>
</li>
<li><p>切换目录：<code>cd 目录</code></p>
</li>
<li><p>创建目录：<code>mkdir [-p] 目录名称</code></p>
<ul>
<li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来</li>
</ul>
</li>
<li><p>删除目录：<code> rmdir [-p] 目录名称</code>(文件必须为空)</p>
<ul>
<li>-p ：从该目录起，一次删除多级空目录</li>
</ul>
</li>
<li><p>复制文件或目录：<code>cp [选项] 即拷贝文件和目录。</code></p>
<ul>
<li>选项：<ul>
<li>-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li>
<li>-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li>
<li>-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li>
<li>-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身；</li>
<li>-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li>
<li>-r：递归持续复制，用於目录的复制行为；(常用)</li>
<li>-s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li>
</ul>
</li>
</ul>
</li>
<li><p>移除文件或目录：<code>rm [选项] 文件或目录</code></p>
<ul>
<li>选项：<ul>
<li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li>
<li>-i ：互动模式，在删除前会询问使用者是否动作</li>
<li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>
</ul>
</li>
</ul>
</li>
<li><p>移动文件与目录，或修改名称：<code>mv [-fiu] source destination</code>(-fiu同rm)</p>
</li>
<li><p>创建空文件：<code>touch 文件名</code></p>
</li>
<li><p>查看文件：<code>cat [-AbEnTv] 文件名</code>或者倒着显示<code>tac 文件名 </code> 或者一页页显示<code>more/less 文件名</code>或者取出文件前/后面几行<code>head/tail [-n 10] 文件名 </code></p>
<ul>
<li>选项：<ul>
<li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>
<li>-E ：将结尾的断行字节 $ 显示出来；</li>
<li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>
<li>-T ：将 [tab] 按键以 ^I 显示出来；</li>
<li>-v ：列出一些看不出来的特殊字符</li>
</ul>
</li>
<li>more/less的指令<ul>
<li>空白键  ：向下翻动一页；</li>
<li>[pagedown]：向下翻动一页；</li>
<li>[pageup] ：向上翻动一页；</li>
<li>/字串   ：向下搜寻『字串』的功能；</li>
<li>?字串   ：向上搜寻『字串』的功能；</li>
<li>n     ：重复前一个搜寻 (与 / 或 ? 有关！)</li>
<li>N     ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li>
<li>q     ：离开 less 这个程序；</li>
</ul>
</li>
</ul>
</li>
<li><p>输出指令：<code>&gt;  和 &gt;&gt;</code></p>
<ul>
<li>&gt; 输出重定向 : 会将原来的文件的内容覆盖</li>
</ul>
</li>
<li><p>&gt;&gt; 追加： 不会覆盖原来文件的内容，而是追加到文件的尾部</p>
</li>
<li><p>输出内容到控制台：<code>echo 指令</code></p>
</li>
<li><p>创建软链接：<code>ln -s [原文件或目录] [软链接名]</code></p>
</li>
<li><p>查看历史指令：<code>history</code></p>
</li>
<li><p>统计该目录的文件数：<code>ls -l[R(递归包括子文件)] 目录 | grep &quot;^以什么开头&quot; | wc -l</code></p>
</li>
<li><p>以树形展示该目录的文件：<code>tree</code></p>
</li>
</ul>
<h3 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h3><ul>
<li>展示当前时间<ul>
<li><code>date </code>（显示当前时间）</li>
<li><code>date +%Y</code>（显示当前年份）</li>
<li><code>date +%m</code>（显示当前月份）</li>
<li><code>date +%d</code>（显示当前是哪一天）</li>
<li><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code>（显示年月日时分秒）</li>
</ul>
</li>
<li>设置日期：<code>date  -s  字符串时间</code></li>
<li>显示日历：<code>cal</code></li>
</ul>
<h3 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h3><ul>
<li>查找文件：<code>find [搜索目录范围]  [选项]</code><ul>
<li>选项：<ul>
<li>-name ：按照指定文件名查找</li>
<li>-user：查找指定用户名所有的文件</li>
<li>-size：按照指定文件大小查找</li>
</ul>
</li>
</ul>
</li>
<li>定位文件：<code>locate 搜索文件</code>(第一次运行前，必须使用 updatedb 指令创建 locate 数据库)</li>
<li>查找文件内内容：<code>cat 文件名 | grep [选项] 查询内容</code><ul>
<li>选项：<ul>
<li>-n：显示行号</li>
<li>-i：忽略大小写</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h3><ul>
<li>gzip/gunzip 指令：<ul>
<li>压缩：<code>gzip 文件</code></li>
<li>解压：<code>gunzip 文件.gz</code></li>
</ul>
</li>
<li>zip/unzip指令：<ul>
<li>压缩：<code>zip [选项] XXX.zip</code></li>
<li>解压：<code>unzip   [选项] XXX.zip</code></li>
<li>选项：<ul>
<li>-r：递归压缩，即压缩目录</li>
<li>-d&lt;目录&gt; ：指定解压后文件的存放目录</li>
</ul>
</li>
</ul>
</li>
<li>tar指令：<ul>
<li><code>tar  [选项]  XXX.tar.gz</code></li>
<li>选项：<ul>
<li>-c：产生.tar打包文件</li>
<li>-v：显示详细住息</li>
<li>-f：指定压缩后的文件名</li>
<li>-z：打包同时压缩</li>
<li>-x：解包.tar文件</li>
</ul>
</li>
<li>实例：<ul>
<li>压缩多个文件或者目录：<code>tar -zcvf a.tar.gz a1.txt a2.txt 或者/home/</code> </li>
<li>解压：<code>tar -zxvf a.tar.gz -C 指定目录</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="用户登录注销"><a href="#用户登录注销" class="headerlink" title="用户登录注销"></a>用户登录注销</h3><ul>
<li>登录：<code>su 用户名</code>（从权限高的用户切换到权限低的用户，不需要输入密码，反之需要）</li>
<li>切换到原来的用户：<code>exit</code></li>
<li>注销：<code>logout</code>(如果当前为root用户使用注销回返回普通用户，如果是普通用户则直接退出系统)</li>
</ul>
<blockquote>
<p>logout 注销指令在图形运行级别无效，在 运行级别 3 下有效</p>
</blockquote>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>Linux 系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。并且Linux 的用户需要至少要属于一个组。</p>
<ul>
<li>添加用户：<code>useradd [选项] 用户名</code><ul>
<li>选项：<ul>
<li>-c comment ：指定一段注释性描述。</li>
<li>-d 目录 ：指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。（默认会在home下创建与用户同名的目录）</li>
<li>-g 用户组 指定用户所属的用户组。</li>
<li>-G 用户组，用户组 指定用户所属的附加组。</li>
<li>-s Shell文件 指定用户的登录Shell。</li>
<li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li>
</ul>
</li>
</ul>
</li>
<li>删除用户：<code>userdel [选项] 用户名</code><ul>
<li>选项：<ul>
<li>-r ：它的作用是把用户的主目录一起删除。</li>
</ul>
</li>
</ul>
</li>
<li>查询用户信息：<code>id 用户名</code></li>
<li>修改用户信息：<code>usermod 选项 用户名</code>（选项与useradd一样）</li>
<li>管理密码：<code>passwd 选项 用户</code><ul>
<li>选项：<ul>
<li>-l 锁定密码，即禁用账号。</li>
<li>-u 密码解锁。</li>
<li>-d 使账号无密码。</li>
<li>-f 强迫用户下次登录时修改密码。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h3><p>类似于角色，系统可以对有共性的多个用户进行统一的管理。</p>
<ul>
<li>添加用户组：<code>groupadd 选项 用户组</code><ul>
<li>选项：<ul>
<li>-g GID 指定新用户组的组标识号（GID）。</li>
<li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li>
</ul>
</li>
</ul>
</li>
<li>删除用户组：<code>groupdel 用户组</code></li>
<li>修改用户组：<code>groupmod 选项 用户组</code><ul>
<li>选项：<ul>
<li>-g GID 为用户组指定新的组标识号。</li>
<li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li>
<li>-n新用户组 将用户组的名字改为新名字</li>
</ul>
</li>
</ul>
</li>
<li>切换用户组：<code>newgrp 组名</code>（前提是用户同时属于多个用户组，并且用户组确实是该用户的主组或附加组）</li>
</ul>
<h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>在 linux 中每个文件有所有者、所在组、其它组的概念。</p>
<ul>
<li>相关概念<ul>
<li>所有者：一般为文件的创建者,谁创建了该文件，就自然的成为该文件的所有者。</li>
<li>所在组：所有者所在的用户组</li>
<li>其他组：所有者不在的用户组</li>
</ul>
</li>
<li>修改文件所有者：<code>chown [-R] 用户名 文件名</code>(-R递归)</li>
<li>修改文件所在组：<code>chgrp [-R] 组名 文件名</code>(-R 递归)</li>
<li>文件权限的查看：<code>ls -l</code>如：<code>dr-xr-xr-x   2 root root 4096 Dec 14  2012 bin</code><ul>
<li>Linux 中第一个字符代表这个文件是目录、文件或链接文件等等<ul>
<li>当为 <strong>d</strong> 则是目录</li>
<li>当为 <strong>-</strong> 则是文件；</li>
<li>若是 <strong>l</strong> 则表示为链接文档(link file)；</li>
<li>若是 <strong>b</strong> 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li>
<li>若是 <strong>c</strong> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li>
</ul>
</li>
<li>接下来的字符中，以三个为一组(所有者、所在组、其他组)，且均为 <strong>rwx</strong> 的三个参数的组合。其中， <strong>r</strong> 代表可读(read)、 <strong>w</strong> 代表可写(write)、 <strong>x</strong> 代表可执行(execute)。如果没有权限，就会出现减号 <strong>-</strong> </li>
</ul>
</li>
<li>修改文件权限：<code>chmod [-R] 777 文件或目录</code>或者<code>chmod u=rwx,g=rx,o=r</code></li>
</ul>
<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><p>Linux 磁盘管理常用三个命令为 <code>df</code>、<code>du</code> 和 <code>fdisk</code>。</p>
<ul>
<li>列出文件系统的整体磁盘使用量：<code>df [-ahikHTm] [目录或文件名]</code><ul>
<li>-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；</li>
<li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li>
<li>-i ：不用硬盘容量，而以 inode 的数量来显示</li>
<li>-k ：以 KBytes 的容量显示各文件系统；</li>
<li>-H ：以 M=1000K 取代 M=1024K 的进位方式；</li>
<li>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li>
<li>-m ：以 MBytes 的容量显示各文件系统；</li>
</ul>
</li>
<li>检查磁盘空间使用量：<code>du [-ahskm] 文件或目录名称</code><ul>
<li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li>
<li>-h ：以人们较易读的容量格式 (G/M) 显示；</li>
<li>-s ：列出总量而已，而不列出每个各别的目录占用容量；</li>
<li>-S ：不包括子目录下的总计，与 -s 有点差别。</li>
<li>-k ：以 KBytes 列出容量显示；</li>
<li>-m ：以 MBytes 列出容量显示；</li>
</ul>
</li>
<li>用于磁盘分区：<code>fdisk [-l] 装置名称</code><ul>
<li>-l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。</li>
</ul>
</li>
</ul>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ul>
<li>查看进程：<code>ps -选项/pstree -p</code>(pstree展示进程树)<ul>
<li>常用选项：<ul>
<li>-A 列出所有的进程</li>
<li>-w 显示加宽可以显示较多的资讯</li>
<li>-ef：显示父亲pid</li>
<li>-au 显示较详细的资讯</li>
<li>-aux 显示所有包含其他使用者的进程</li>
</ul>
</li>
<li>-aux输出格式：<ul>
<li><code>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</code><ul>
<li>USER: 行程拥有者</li>
<li>PID: pid</li>
<li>%CPU: 占用的 CPU 使用率</li>
<li>%MEM: 占用的记忆体使用率</li>
<li>VSZ: 占用的虚拟记忆体大小</li>
<li>RSS: 占用的记忆体大小</li>
<li>TTY: 终端的次要装置号码 (minor device number of tty)</li>
<li>STAT: 该行程的状态:<ul>
<li>D: 无法中断的休眠状态 (通常 IO 的进程)</li>
<li>R: 正在执行中</li>
<li>S: 静止状态</li>
<li>T: 暂停执行</li>
<li>Z: 不存在但暂时无法消除</li>
<li>W: 没有足够的记忆体分页可分配</li>
<li>&lt;: 高优先序的行程</li>
<li>N: 低优先序的行程</li>
<li>L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)</li>
</ul>
</li>
<li>START: 行程开始时间</li>
<li>TIME: 执行的时间</li>
<li>COMMAND:所执行的指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>杀掉进程：<code>kill [&lt;信息名称或编号&gt;][程序]/killall [选项]  name</code>(killall 与 kill 不同的是它会杀死指定名字的所有进程。)<ul>
<li>最常用的信号是：<ul>
<li>1 (HUP)：重新加载进程。</li>
<li>9 (KILL)：杀死一个进程。</li>
<li>15 (TERM)：正常停止一个进程。</li>
</ul>
</li>
<li>killall的选项<ul>
<li>-e | –exact ： 进程需要和名字完全相符</li>
<li>-I | –ignore-case ：忽略大小写</li>
<li>-g | –process-group ：结束进程组</li>
<li>-i | –interactive ：结束之前询问</li>
<li>-l | –list ：列出所有的信号名称</li>
<li>-q | –quite ：进程没有结束时，不输出任何信息</li>
<li>-r | –regexp ：将进程名模式解释为扩展的正则表达式。</li>
<li>-s | –signal ：发送指定信号</li>
<li>-u | –user ：结束指定用户的进程</li>
<li>-v | –verbose ：显示详细执行过程</li>
<li>-w | –wait ：等待所有的进程都结束</li>
<li>-V |–version ：显示版本信息</li>
<li>–help ：显示帮助信息</li>
</ul>
</li>
</ul>
</li>
<li>动态监控进程：<code>top [选项]</code>（可以进入之后输入u/k来显示某个用户的进程/杀死某个进程）<ul>
<li>d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s</li>
<li>q : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行</li>
<li>c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称</li>
<li>S : 累积模式，会将己完成或消失的子进程 ( dead child process ) 的 CPU time 累积起来</li>
<li>s : 安全模式，将交谈式指令取消, 避免潜在的危机</li>
<li>i : 不显示任何闲置 (idle) 或无用 (zombie) 的进程</li>
<li>n : 更新的次数，完成后将会退出 top</li>
<li>b : 批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内</li>
</ul>
</li>
</ul>
<h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><ul>
<li><p>查看服务：<code>chkconfig [--level 运行级别][服务名] --list</code></p>
</li>
<li><p>启动服务：<code>systemctl start 服务名</code></p>
</li>
<li><p>停止服务：<code>systemctl stop 服务名</code></p>
</li>
<li><p>重启服务：<code>systemctl restart 服务名</code></p>
</li>
<li><p>重新加载：<code>systemctl reload 服务名</code></p>
</li>
<li><p>查看服务状态：<code>systemctl status 服务名</code></p>
</li>
</ul>
<h3 id="管理网络状态"><a href="#管理网络状态" class="headerlink" title="管理网络状态"></a>管理网络状态</h3><ul>
<li>查看网络状态：<code>netstat [选项]</code><ul>
<li>-an  按一定顺序排列输出</li>
<li>-p  显示哪个进程在调用</li>
</ul>
</li>
</ul>
<h3 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h3><ul>
<li> 列出所有可更新的软件清单命令：<code>yum check-update</code></li>
<li> 更新所有软件命令：<code>yum update</code></li>
<li> 仅安装指定的软件命令：<code>yum install &lt;package_name&gt;</code></li>
<li> 仅更新指定的软件命令：<code>yum update &lt;package_name&gt;</code></li>
<li> 列出所有可安裝的软件清单命令：<code>yum list</code></li>
<li> 删除软件包命令：<code>yum remove &lt;package_name&gt;</code></li>
<li> 查找软件包命令：<code>yum search &lt;keyword&gt;</code></li>
</ul>
<h2 id="Vi-Vim编辑器"><a href="#Vi-Vim编辑器" class="headerlink" title="Vi/Vim编辑器"></a>Vi/Vim编辑器</h2><p>Vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>
<p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式</strong>，<strong>编辑模式</strong>和<strong>一般模式</strong>。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220719101949849.png" alt="image-20220719101949849"></p>
<h3 id="一般模式可用的光标移动、复制粘贴、搜索替换等"><a href="#一般模式可用的光标移动、复制粘贴、搜索替换等" class="headerlink" title="一般模式可用的光标移动、复制粘贴、搜索替换等"></a>一般模式可用的光标移动、复制粘贴、搜索替换等</h3><table>
<thead>
<tr>
<th align="left">移动光标的方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">h 或 向左箭头键(←)</td>
<td>光标向左移动一个字符</td>
</tr>
<tr>
<td align="left">j 或 向下箭头键(↓)</td>
<td>光标向下移动一个字符</td>
</tr>
<tr>
<td align="left">k 或 向上箭头键(↑)</td>
<td>光标向上移动一个字符</td>
</tr>
<tr>
<td align="left">l 或 向右箭头键(→)</td>
<td>光标向右移动一个字符</td>
</tr>
<tr>
<td align="left">[Ctrl] + [f]</td>
<td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td>
</tr>
<tr>
<td align="left">[Ctrl] + [b]</td>
<td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td>
</tr>
<tr>
<td align="left">[Ctrl] + [d]</td>
<td>屏幕『向下』移动半页</td>
</tr>
<tr>
<td align="left">[Ctrl] + [u]</td>
<td>屏幕『向上』移动半页</td>
</tr>
<tr>
<td align="left">+</td>
<td>光标移动到非空格符的下一行</td>
</tr>
<tr>
<td align="left">-</td>
<td>光标移动到非空格符的上一行</td>
</tr>
<tr>
<td align="left">n<space></td>
<td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td>
</tr>
<tr>
<td align="left">0 或功能键[Home]</td>
<td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td>
</tr>
<tr>
<td align="left">$ 或功能键[End]</td>
<td>移动到这一行的最后面字符处(常用)</td>
</tr>
<tr>
<td align="left">H</td>
<td>光标移动到这个屏幕的最上方那一行的第一个字符</td>
</tr>
<tr>
<td align="left">M</td>
<td>光标移动到这个屏幕的中央那一行的第一个字符</td>
</tr>
<tr>
<td align="left">L</td>
<td>光标移动到这个屏幕的最下方那一行的第一个字符</td>
</tr>
<tr>
<td align="left">G</td>
<td>移动到这个档案的最后一行(常用)</td>
</tr>
<tr>
<td align="left">nG</td>
<td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td>
</tr>
<tr>
<td align="left">gg</td>
<td>移动到这个档案的第一行，相当于 1G 啊！ (常用)</td>
</tr>
<tr>
<td align="left">n<Enter></td>
<td>n 为数字。光标向下移动 n 行(常用)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">删除、复制</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">x, X</td>
<td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td>
</tr>
<tr>
<td align="left">nx</td>
<td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td>
</tr>
<tr>
<td align="left">dd</td>
<td>剪切游标所在的那一整行(常用)，用 p/P 可以粘贴。</td>
</tr>
<tr>
<td align="left">ndd</td>
<td>n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p/P 可以粘贴。</td>
</tr>
<tr>
<td align="left">d1G</td>
<td>删除光标所在到第一行的所有数据</td>
</tr>
<tr>
<td align="left">dG</td>
<td>删除光标所在到最后一行的所有数据</td>
</tr>
<tr>
<td align="left">d$</td>
<td>删除游标所在处，到该行的最后一个字符</td>
</tr>
<tr>
<td align="left">d0</td>
<td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td>
</tr>
<tr>
<td align="left">yy</td>
<td>复制游标所在的那一行(常用)</td>
</tr>
<tr>
<td align="left">nyy</td>
<td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td>
</tr>
<tr>
<td align="left">y1G</td>
<td>复制游标所在行到第一行的所有数据</td>
</tr>
<tr>
<td align="left">yG</td>
<td>复制游标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td align="left">y0</td>
<td>复制光标所在的那个字符到该行行首的所有数据</td>
</tr>
<tr>
<td align="left">y$</td>
<td>复制光标所在的那个字符到该行行尾的所有数据</td>
</tr>
<tr>
<td align="left">p, P</td>
<td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td>
</tr>
<tr>
<td align="left">J</td>
<td>将光标所在行与下一行的数据结合成同一行</td>
</tr>
<tr>
<td align="left">c</td>
<td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td>
</tr>
<tr>
<td align="left">u</td>
<td>复原前一个动作。(常用)</td>
</tr>
<tr>
<td align="left">[Ctrl]+r</td>
<td>重做上一个动作。(常用)</td>
</tr>
<tr>
<td align="left">.</td>
<td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">搜索替换</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">/word</td>
<td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)</td>
</tr>
<tr>
<td align="left">?word</td>
<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>
</tr>
<tr>
<td align="left">n</td>
<td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td>
</tr>
<tr>
<td align="left">N</td>
<td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td>
</tr>
<tr>
<td align="left">:n1,n2s/word1/word2/g</td>
<td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用)</td>
</tr>
<tr>
<td align="left"><strong>:1,$s/word1/word2/g</strong> 或 <strong>:%s/word1/word2/g</strong></td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td>
</tr>
<tr>
<td align="left"><strong>:1,$s/word1/word2/gc</strong> 或 <strong>:%s/word1/word2/gc</strong></td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td>
</tr>
</tbody></table>
<h3 id="一般模式切换到指令行模式的可用的按钮说明"><a href="#一般模式切换到指令行模式的可用的按钮说明" class="headerlink" title="一般模式切换到指令行模式的可用的按钮说明"></a>一般模式切换到指令行模式的可用的按钮说明</h3><table>
<thead>
<tr>
<th align="left">指令行的储存、离开等指令</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">:w</td>
<td>将编辑的数据写入硬盘档案中(常用)</td>
</tr>
<tr>
<td align="left">:w!</td>
<td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td>
</tr>
<tr>
<td align="left">:q</td>
<td>离开 vi (常用)</td>
</tr>
<tr>
<td align="left">:q!</td>
<td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td>
</tr>
<tr>
<td align="left">:wq</td>
<td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td>
</tr>
<tr>
<td align="left">ZZ</td>
<td>这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)</td>
</tr>
<tr>
<td align="left">ZQ</td>
<td>不保存，强制退出。效果等同于 **:q!**。</td>
</tr>
<tr>
<td align="left">:w [filename]</td>
<td>将编辑的数据储存成另一个档案（类似另存新档）</td>
</tr>
<tr>
<td align="left">:r [filename]</td>
<td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td>
</tr>
<tr>
<td align="left">:n1,n2 w [filename]</td>
<td>将 n1 到 n2 的内容储存成 filename 这个档案。</td>
</tr>
<tr>
<td align="left">:! command</td>
<td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">vim 环境的变更</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">:set nu</td>
<td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td>
</tr>
<tr>
<td align="left">:set nonu</td>
<td>与 set nu 相反，为取消行号！</td>
</tr>
</tbody></table>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>在使用linux的时候，时不时会有需要定义处理程序的需求，这时就需要定时的任务调度。（任务调度是指系统在某个时间执行的特定的命令或程序）。</p>
<p>linux提供了设置定时任务的相关命令：</p>
<ul>
<li><code>crontab [选项]</code><ul>
<li>选项说明：<ul>
<li>-e：编辑crontab定时任务</li>
<li>-l：查询crontab任务</li>
<li>-r：删除当前用户所有的crontab任务</li>
</ul>
</li>
</ul>
</li>
<li><code>service crond restart</code> ：重启任务调度</li>
</ul>
<p>相关目录：</p>
<ul>
<li>/var/spool/cron/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名</li>
<li>/etc/crontab 这个文件负责调度各种管理和维护任务。</li>
<li>/etc/cron.d/ 这个目录用来存放任何要执行的crontab文件或脚本。</li>
</ul>
<p>步骤：</p>
<ol>
<li>进行编辑任务：<code>crontab -e</code></li>
<li>编辑任务：<code>*/1 * * * * ls –l  /etc/ &gt; /tmp/to.txt</code></li>
<li>保存退出，即可自动执行任务</li>
</ol>
<p>crontab的命令构成为 时间+动作，其时间有<strong>分、时、日、月、周</strong>五种</p>
<p>操作符有：</p>
<ul>
<li>***** 取值范围内的所有数字</li>
<li><strong>/</strong> 每过多少个数字</li>
<li><strong>-</strong> 从X到Z</li>
<li><strong>，</strong>散列数字</li>
</ul>
<p><a href="https://www.iamwawa.cn/crontab.html">在线自动生成工具</a></p>
<h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><p>虽然网络已经连通，但是以防每次重启虚拟机，linux的ip地址都动态的发生变化，还需要进行进一步网络配置</p>
<h3 id="配置虚拟网卡"><a href="#配置虚拟网卡" class="headerlink" title="配置虚拟网卡"></a>配置虚拟网卡</h3><ul>
<li><p>查看虚拟网卡：点击虚拟机左上角编辑—&gt;打开虚拟网络编辑器</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220725142839432.png" alt="image-20220725142839432" style="zoom:50%;" />
</li>
<li><p>查看网关</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220725143059013.png" alt="image-20220725143059013" style="zoom:50%;" />
</li>
<li><p>如果需要修改，可以点击更改设置进行修改</p>
</li>
</ul>
<h3 id="获取ip"><a href="#获取ip" class="headerlink" title="获取ip"></a>获取ip</h3><ul>
<li><p>设置自动连接：点击右上角网络图标，进入后选择你需要修改的网络点击设置</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220725143816818.png" alt="image-20220725143816818" style="zoom:50%;" />

<p>缺点：每次连接ip地址不一样</p>
</li>
<li><p>直接修改配置文件来指定ip</p>
<ul>
<li><p>进入进入目录/etc/sysconfig/network-scripts后用vim编辑ifcfg-ens33文件（版本为centos7）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220727090644394.png" alt="image-20220727090644394"></p>
</li>
</ul>
</li>
</ul>
<h2 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h2><p>在进行服务器集群管理、服务器的维护时，需要编写 Shell 程序来进行服务器管理比如编写一个定时备份数据库的脚本。</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用 Shell 来启动、挂起、停止甚至是编写一些程序。</p>
<p>Linux 的 Shell 种类众多，常见的有：</p>
<ul>
<li>Bourne Shell（/usr/bin/sh或/bin/sh）</li>
<li>Bourne Again Shell（/bin/bash）**(常用)**</li>
<li>C Shell（/usr/bin/csh）</li>
<li>K Shell（/usr/bin/ksh）</li>
<li>Shell for Root（/sbin/sh）</li>
</ul>
<h4 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h4><p>因为使用的是Bourne Again Shell，所以必须以<code>#!/bin/bash</code>开头,如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;Hello World !&quot;</span><br></pre></td></tr></table></figure>
<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><ul>
<li>定义变量：<code>变量名 = 值</code></li>
<li>使用变量：使用一个定义过的变量，只要在变量名前面加美元符号即可<ul>
<li><code>$&#123;变量名&#125;</code>(大括号可以省但不建议)</li>
</ul>
</li>
<li>设置变量只读(不能再次赋值)：<code>readonly 变量名</code></li>
<li>删除变量：<code>unset 变量名</code>（unset 命令不能删除只读变量）</li>
<li>将 shell 变量输出为环境变量：<code>export 变量名=变量值</code></li>
</ul>
<blockquote>
<p>变量名的命名须遵循如下规则：</p>
<ul>
<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li>
<li>中间不能有空格，可以使用下划线 <strong>_</strong>。</li>
<li>不能使用标点符号。</li>
<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li>
</ul>
</blockquote>
<h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。(expr 是一款表达式计算工具，使用它能完成表达式的求值操作)</p>
<ul>
<li>算术运算符：+ 、- 、* 、/ 、% 、= 、== 、 != <ul>
<li>使用：<code>expr $a + $b</code>以及<code>[ $a == $b ]</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>条件表达式要放在方括号之间，并且要有空格，例如: <strong>[$a==$b]</strong> 是错误的，必须写成 <strong>[ $a == $b ]</strong></p>
</blockquote>
<ul>
<li><p>关系运算符：<code>[ $a 运算符 $b ]</code></p>
<ul>
<li>是否想等：<code>-eq</code></li>
<li>是否不想等：<code>-ne</code></li>
<li>大于：<code>-gt</code></li>
<li>小于：<code>-lt</code></li>
<li>大于等于：<code>-ge</code></li>
<li>小于等于：<code>-le</code></li>
</ul>
</li>
<li><p>布尔运算符：例子<code>[ $a -lt 20 -o $b -gt 100 ]</code></p>
<ul>
<li>取反：<code>!</code></li>
<li>或运算：<code>-o</code></li>
<li>与运算：<code>-a</code></li>
</ul>
</li>
<li><p>逻辑运算符：例子：<code>[[ $a -lt 100 || $b -gt 100 ]]</code></p>
<ul>
<li>与：<code>&amp;&amp;</code></li>
<li>或：<code>||</code></li>
</ul>
</li>
<li><p>字符串运算符：例子<code>[ -n &quot;$a&quot; ]</code></p>
<ul>
<li>判断是否想等：<code>=</code></li>
<li>是否不想等：<code>!=</code></li>
<li>检查长度是否0：<code>-z</code></li>
<li>长度是否不为0：<code>-n</code></li>
<li>检查是否不为空：<code>$</code></li>
</ul>
</li>
<li><p>文件测试运算符：例子<code>[ -r $file]</code></p>
<ul>
<li>检测文件是否是块设备文件：<code>-b file</code></li>
<li>检测文件是否是字符设备文件：<code>-c file</code></li>
<li>检测文件是否是目录：<code>-d file</code></li>
<li>检测文件是否是普通文件：<code>-f file</code></li>
<li>检测文件是否设置了 SGID 位：<code>-g file</code></li>
<li>检测文件是否设置了粘着位(Sticky Bit)：<code>-k file</code></li>
<li>检测文件是否是有名管道：<code>-p file</code></li>
<li>检测文件是否设置了 SUID 位：<code>-u file</code></li>
<li>检测文件是否可读：<code>-r file</code></li>
<li>检测文件是否可写：<code>-w file</code></li>
<li>检测文件是否可执行：<code>-x file</code></li>
<li>检测文件是否为空：<code>-s file</code></li>
<li>检测文件（包括目录）是否存在：<code>-e file</code></li>
</ul>
</li>
</ul>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>字符串是shell编程中最常用最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号。</p>
<ul>
<li>字符串拼接：<code>greeting=&quot;hello, &quot;$&#123;your_name&#125;&quot; !&quot;</code>(不需要想java一样用+来拼接)</li>
<li>获取字符串长度：<code>string=&quot;abcd&quot; echo $&#123;#string&#125;</code></li>
<li>提取子串： <code>$&#123;str:1:4&#125;</code>输出从下标为1的字符开始的4个字符</li>
<li>查找子字符：<code>expr index &quot;$string&quot; i</code> 输出i的下标</li>
</ul>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><ul>
<li><p>定义：<code>数组名=(值1 值2 ... 值n)</code></p>
</li>
<li><p>取值：<code>$&#123;数组名[下标]&#125;</code>(@/*可以获取所有元素<code>echo $&#123;array_name[@]&#125;</code>)</p>
</li>
<li><p>获取长度：<code>length=$&#123;#array_name[@]&#125;</code></p>
</li>
<li><p>获取所有键：<code>$&#123;!array_name[@]&#125;</code></p>
</li>
<li><p>设置关联数组（类似于java的map）：<code>declare -A MAP_name</code></p>
<p>如：<code>declare -A map=([&quot;a&quot;]=&quot;1&quot;,[&quot;b&quot;]=&quot;2&quot;)</code></p>
</li>
</ul>
<h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><ul>
<li><p>单行注释：<code>#</code></p>
</li>
<li><p>多行注释：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h5 id="参数的传递"><a href="#参数的传递" class="headerlink" title="参数的传递"></a>参数的传递</h5></li>
<li><p>传参：<code>./test.sh 1 2 3</code>(执行的时候写在后面)</p>
</li>
<li><p>获取参数：<code>$n</code>(n为参数位置，n为0时获取的是文件名)</p>
</li>
<li><p>获取参数个数：<code>$#</code></p>
</li>
<li><p>以一个单字符串显示所有向脚本传递的参数：<code>$*/$@</code>($@会将参数用引号分隔)</p>
</li>
<li><p>脚本运行的当前进程ID号：<code>$$</code></p>
</li>
<li><p>后台运行的最后一个进程的ID号：<code>$!</code></p>
</li>
</ul>
<h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><ul>
<li>echo：用于字符串的输出<ul>
<li>-e：开启转义</li>
<li>输出日期等：echo <code>date</code></li>
</ul>
</li>
<li>printf：输出函数（与c语言的类似）<ul>
<li>格式：<code>printf  format-string  [arguments...]</code></li>
</ul>
</li>
</ul>
<h5 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h5><ul>
<li><p>条件判断：</p>
<ul>
<li><p><code>if 条件 then 执行语句 else 执行语句2 fi</code></p>
</li>
<li><p><code>if 条件 then 执行语句 elif 条件2 then 执行语句2 else 执行语句3 fi</code></p>
</li>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">elif [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 大于 b&quot;</span><br><span class="line">elif [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;没有符合的条件&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>for循环：</p>
<ul>
<li><p><code>for 变量 in 数组 do 执行语句 done </code></p>
</li>
<li><p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for loop in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">    echo &quot;The value is: $loop&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>while 语句</p>
<ul>
<li><p><code>while 条件 do 执行语句 done</code></p>
</li>
<li><p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">int=1</span><br><span class="line">while(( $int&lt;=5 ))</span><br><span class="line">do</span><br><span class="line">    echo $int</span><br><span class="line">    let &quot;int++&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>until循环</p>
<ul>
<li><p><code>until 条件 do 执行语句 done</code></p>
</li>
<li><p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=0</span><br><span class="line"></span><br><span class="line">until [ ! $a -lt 10 ]</span><br><span class="line">do</span><br><span class="line">   echo $a</span><br><span class="line">   a=`expr $a + 1`</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>多分支语句：</p>
<ul>
<li><p><code>case 值 in 值1) 执行语句 ;; 值2) 执行语句2 ;; *) 执行语句3 ;; esac</code></p>
</li>
<li><p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case $aNum in</span><br><span class="line">    1)  echo &#x27;你选择了 1&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo &#x27;你选择了 2&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo &#x27;你选择了 3&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo &#x27;你选择了 4&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo &#x27;你没有输入 1 到 4 之间的数字&#x27;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>跳出循环(与java一样)：</p>
<ul>
<li>break</li>
<li>continue</li>
</ul>
</li>
</ul>
<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><ul>
<li><p>定义：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ function ] funname()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    执行语句</span><br><span class="line"></span><br><span class="line">    [return int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用：<code>函数名</code></p>
</li>
<li><p>案例1(无参数)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">demoFun()&#123;</span><br><span class="line">    echo <span class="string">&quot;这是我的第一个 shell 函数!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">echo <span class="string">&quot;-----函数开始执行-----&quot;</span></span><br><span class="line">demoFun</span><br><span class="line">echo <span class="string">&quot;-----函数执行完毕-----&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>案例2(有参数)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">funWithReturn()&#123;</span><br><span class="line">    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;</span><br><span class="line">    echo &quot;输入第一个数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    echo &quot;输入第二个数字: &quot;</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line">echo &quot;输入的两个数字之和为 $? !&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>获得返回值：<code>$?</code></li>
<li>获取参数个数：<code>$#</code></li>
<li>获取当前进程id号：<code>$$</code></li>
<li>获取后台进行的最后一个进程号：<code>$!</code></li>
<li>以字符串形式展示参数：<code>$*/$@</code></li>
</ul>
</blockquote>
</li>
</ul>
<h5 id="引入外部shell文件"><a href="#引入外部shell文件" class="headerlink" title="引入外部shell文件"></a>引入外部shell文件</h5><ul>
<li>方式一：<code>. 文件路径</code></li>
<li>方式二：<code>source 文件路径</code></li>
</ul>
<h4 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h4><ol>
<li>方式一：<ul>
<li>使用户获得可执行权限：<code>chmod +x 脚本文件</code></li>
<li>直接输入脚本路径如：<code>./test.sh</code></li>
</ul>
</li>
<li>方式二：<ul>
<li><code>sh + 脚本路径</code></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Devops</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Class字节码文件</title>
    <url>/2023/04/14/Java/JVM/Class%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="Class字节码文件"><a href="#Class字节码文件" class="headerlink" title="Class字节码文件"></a>Class字节码文件</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java源代码的编译结果是字节码，那么肯定需要有一种编译器能够将Java源码编译为字节码，承担这个重要责任的就是配置在path环境变量中的javac编译器。javac是一种能够将Java源码编译为字节码的前端编译器。</p>
<p>源代码经过编译器编译之后便会生成一个字节码文件，字节码是一种二进制的类文件，它的内容是JVN的指令，而不像C、C+t经由编译器直接生成机器码。</p>
<p><strong>Java的跨平台性：</strong></p>
<p>Java虚拟机不和包括 Java 在内的任何语言绑定，它只与<strong>“Class 文件”</strong>这种特定的二进制文件格式所关联。无论使用何种语言进行软件开发，只要能将源文件编译为正确的Class文件，那么这种语言就可以在Java虚拟机上执行。</p>
<blockquote>
<p>class字节码文件可以通过JDK自带的javap命令来反编译查看</p>
</blockquote>
<h2 id="字节码文件结构"><a href="#字节码文件结构" class="headerlink" title="字节码文件结构"></a>字节码文件结构</h2><p>Class文件的总体结构如下：</p>
<ul>
<li><p>魔数</p>
<ul>
<li><p>类型：u4（4个字节的无符号整数）</p>
</li>
<li><p>名称：magic</p>
</li>
<li><p>说明：用于识别Class文件格式</p>
</li>
</ul>
</li>
<li><p>Class文件版本</p>
<ul>
<li><p>类型：u2+u2（4个字节的无符号整数）</p>
</li>
<li><p>名称：minor_version+major_version</p>
</li>
<li><p>说明：包含一个副版本号(minor_version)，在第5,6字节；一个主版本号(major_version)，在7,8字节</p>
</li>
</ul>
</li>
<li><p>常量池</p>
<p>常量池是class文件中内容最为丰富的区域之一。常量池对于Class文件中的字段和方法解析也有着至关重要的作用。</p>
<p><strong>常量池计数器：</strong></p>
<ul>
<li><p>类型：u2</p>
</li>
<li><p>名称：constant_pool_count</p>
</li>
<li><p>说明：由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值。(0项被空出来了)</p>
</li>
</ul>
<p><strong>常量池表：</strong></p>
<ul>
<li><p>类型：cp_info</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cp_info&#123;</span><br><span class="line">	<span class="comment">// 标识是什么类型的表项</span></span><br><span class="line">	u1 tag;</span><br><span class="line">	<span class="comment">// 具体内容</span></span><br><span class="line">	u1 info[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>名称：constant_pool</p>
</li>
<li><p>说明：常量池的映射表，用于存放编译时期生成的各种<strong>字面量</strong>和<strong>符号引用</strong>，这部分内容将在类加载后进入方法区的<strong>运行时常量池</strong>中存放</p>
</li>
</ul>
<blockquote>
<p>虚拟机在加载cClass文件时才会进行<strong>动态链接</strong>，也就是说，<strong>Class文件中不会保存各个方法和字段的最终内存布局信息</strong>，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行时，需要从常量池中获得对应的符号引用，再<strong>在类加载过程中的解析阶段将其替换为直接引用</strong>，并翻译到具体的内存地址中。</p>
</blockquote>
</li>
<li><p>访问标志</p>
<ul>
<li><p>类型：u2</p>
</li>
<li><p>名称：access_flag</p>
</li>
<li><p>说明：在常量池后，紧跟着访问标记。该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括:这个Class是类还是接口;是否定义为public类型，是否定义为 abstract类型;如果是类的话，是否被声明为 final等。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230405111137144.png" alt="image-20230405111137144"></p>
</li>
</ul>
</li>
<li><p>类索引，父类索引，接口索引集合</p>
<p><strong>类索引：</strong></p>
<ul>
<li><p>类型：u2</p>
</li>
<li><p>名称：this_ckass</p>
</li>
<li><p>说明：类索引用于确定这个类的全限定名</p>
</li>
</ul>
<p><strong>父类索引：</strong></p>
<ul>
<li><p>类型：u2</p>
</li>
<li><p>名称：super_class</p>
</li>
<li><p>说明：父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.0bject之外，所有的Java类都有父类，因此除了java.lang.Object 外，所有Java类的父类索引都不为0。</p>
</li>
</ul>
<p><strong>接口索引：</strong></p>
<ul>
<li><p>类型：u2+u2*interfaces_count</p>
</li>
<li><p>名称：interfaces_count+interfaces[interfaces_count]</p>
</li>
<li><p>说明：接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是extends 语句）接口顺序从左到右排列在接口索引集合中。</p>
</li>
</ul>
</li>
<li><p>字段表集合</p>
<p><strong>字段表计数器：</strong></p>
<ul>
<li>类型：u2</li>
<li>名称：fields_count</li>
<li>说明：fields_count的值表示当前class文件fields表的成员个数。</li>
</ul>
<p><strong>字段表集合：</strong></p>
<ul>
<li><p>结构：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230406142150976.png" alt="image-20230406142150976"></p>
</li>
<li><p>说明：用于描述接口或类中声明的变量。字段(field)包括类级变量以及实例级变量，但是不包括方法内部、代码块内部声明的局部变量。( local variables)</p>
</li>
</ul>
</li>
<li><p>方法表集合</p>
<p><strong>方法表计数器：</strong></p>
<ul>
<li>类型：u2</li>
<li>名称：methods_count</li>
<li>说明：methods_count的值表示当前class文件methods表的成员个数。</li>
</ul>
<p><strong>方法表集合：</strong></p>
<ul>
<li><p>结构：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230406142446016.png" alt="image-20230406142446016"></p>
</li>
<li><p>说明：指向常量池索引集合，它完整描述了每个方法的签名。</p>
</li>
</ul>
</li>
<li><p>属性表集合</p>
<p><strong>属性表计数器：</strong></p>
<ul>
<li>类型：u2</li>
<li>名称：attributes_count</li>
<li>说明：attributes_count的值表示当前class文件属性表的成员个数。</li>
</ul>
<p><strong>属性表集合：</strong></p>
<ul>
<li><p>结构：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230406143118124.png" alt="image-20230406143118124"></p>
</li>
<li><p>说明：方法表集合之后的属性表集合，指的是class文件所携带的辅助信息，比如该class 文件的源文件的名称。以及任何带有RetentionPolicy.CLASS或者RetentionPolicy.RUNTIME的注解。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM概述</title>
    <url>/2023/03/19/Java/JVM/JVM%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="JVM概述"><a href="#JVM概述" class="headerlink" title="JVM概述"></a>JVM概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><p>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制,其运行的Java字节码也未必由Java语言编译而成。</p>
</li>
<li><p>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</p>
</li>
<li><p>Java技术的核心就是Java虚拟机（JVM，Java virtual Machine) ,因为所有的Java程序都运行在Java虚拟机内部。</p>
</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
<h2 id="JVM所处位置"><a href="#JVM所处位置" class="headerlink" title="JVM所处位置"></a>JVM所处位置</h2><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230302163659737.png" alt="image-20230302163659737"></p>
<h2 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="JVM的整体结构"></a>JVM的整体结构</h2><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230302164345297.png" alt="image-20230302164345297"></p>
<p><strong>执行流程：</strong></p>
<ol>
<li>java程序编写</li>
<li>通过jiava编译器编译成class字节码文件</li>
<li>在JVM上进行解释执行<ol>
<li>类的加载</li>
<li>字节码校验</li>
<li>执行引擎对字节码进行解析编译执行</li>
</ol>
</li>
<li>在具体操作系统上执行</li>
</ol>
<h2 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java虚拟机的启动是通过引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的，这个类是由虚拟机的具体实现指定的。</p>
<h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ul>
<li>一个运行中的Java虚拟机有着一个清晰的任务:执行Java程序。</li>
<li>程序开始执行时他才运行，程序结束时他就停止。</li>
<li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</li>
</ul>
<h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p>有如下的几种情况:</p>
<ul>
<li>程序正常执行结束。</li>
<li>程序在执行过程中遇到了异常或错订而异常终止。</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止。</li>
<li>某线程调用Runtime类或system类的exit方法，或 Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</li>
<li>除此之外，JNI ( Java Native Interface)规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收</title>
    <url>/2023/04/09/Java/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>什么是垃圾（ Garbage）呢?</strong></p>
<p>垃圾是指在<strong>运行程序中没有任何指针指向</strong>的对象，这个对象就是需要被回收的垃圾。</p>
<p><strong>为什么需要GC</strong></p>
<p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</p>
<p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。</p>
<p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p>
<p><strong>Java自动内存管理</strong></p>
<p>Java自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险，自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发。</p>
<ul>
<li>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险让你头疼不已。</li>
</ul>
<p>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。</p>
<ul>
<li>Java堆是垃圾收集器的工作重点。</li>
</ul>
<p>从次数上讲：</p>
<ul>
<li>颊繁收集Young区</li>
<li>较少收集old区</li>
<li>基本不动方法区</li>
</ul>
<h2 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h2><p>Java语言提供了<strong>对象终止（finalization）机制</strong>来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p>
<p>当垃圾回收器发现没有引用指向一个对象，即:垃圾回收此对象之前，总会先调用这个对象的finaliz()方法。</p>
<p>finalize ( )方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>
<p><strong>永远不要主动调用某个对象的finalize()方法</strong>，应该交给垃圾回收机制调用。理由包括下面三点：</p>
<ul>
<li>在finalize ()时可能会导致对象复活。</li>
<li>finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize ()方法将没有执行机会。</li>
<li>一个糟糕的finalize()会严重影响GC的性能。</li>
</ul>
<p>由于finalize ()方法的存在，虚拟机中的对象一般处于<strong>三种可能的状态</strong>：</p>
<ul>
<li><strong>可触及的：</strong>从根节点开始，可以到达这个对象。</li>
<li><strong>可复活的：</strong>对象的所有引用都被释放，但是对象有可能在finalize ()中复活。</li>
<li><strong>不可触及的：</strong>对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。</li>
</ul>
<h2 id="相关算法"><a href="#相关算法" class="headerlink" title="相关算法"></a>相关算法</h2><h3 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h3><p>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</strong>。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</p>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>引用计数算法(Reference Counting)比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p>
<p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1;当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>
<p><strong>优点</strong></p>
<ul>
<li>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong>。</li>
<li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</li>
</ul>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</p>
<p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。<strong>这点也是导致GC进行时必须”Stop The World”的一个重要原因。</strong></p>
<p><strong>基本思路：</strong></p>
<ul>
<li><p>可达性分析算法是以根对象集合(GC Roots)为起始 点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达</strong>。</p>
</li>
<li><p>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain)。</p>
</li>
<li><p>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</p>
</li>
<li><p>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</p>
</li>
</ul>
<p><strong>GC Roots</strong></p>
<ul>
<li>虚拟机栈中引用的对象:<ul>
<li>比如:各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
</li>
<li>本地方法栈内JNI(通常说的本地方法)引用的对象</li>
<li>方法区中类静态属性引用的对象<ul>
<li>比如: Java类的引用类型静态变量</li>
</ul>
</li>
<li>方法区中常量引用的对象<ul>
<li>比如:字符串常量池(string Table）里的引用</li>
</ul>
</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>Java虚拟机内部的引用。<ul>
<li>基本数据类型对应的class对象，一些常驻的异常对象（如:NullPointerException、outOfMemoryError)，系统类加载器。</li>
</ul>
</li>
<li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
<h3 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>标记–清除算法（( Mark-Sweep ）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p>
<p><strong>清除过程：</strong></p>
<p>当堆中的有效内存空间(available memory)被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。</p>
<ul>
<li><strong>标记：</strong>Collector从引用根节点开始遍历，<strong>标记所有被引用的对象</strong>。一般是在对象的Header中记录为可达对象。</li>
<li><strong>清除：</strong>Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>思路简单基础</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>效率不算高</li>
<li>在进行GC的时候，需要停止整个应用程序，导致用户体验差</li>
<li>这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表</li>
</ul>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器。</p>
<p><strong>核心思想</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230328111444071.png" alt="image-20230328111444071" style="zoom:67%;" />

<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<p><strong>优点：</strong></p>
<ul>
<li>没有标记和清除过程，实现简单，运行高效</li>
<li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li>
<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li>
</ul>
<blockquote>
<p><strong>堆中新生代就是使用的复制算法进行垃圾回收</strong></p>
</blockquote>
<h4 id="标记-压缩算法"><a href="#标记-压缩算法" class="headerlink" title="标记-压缩算法"></a>标记-压缩算法</h4><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。<strong>因此，基于老年代垃圾回收的特性，需要使用其他的算法。</strong></p>
<p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。<strong>标记―压缩（Mark - compact）算法</strong>由此诞生。</p>
<p><strong>执行过程：</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230328134137370.png" alt="image-20230328134137370" style="zoom:80%;" />

<p>第一阶段和标记-清除算法一样,从根节点开始标记所有被引用对象</p>
<p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</p>
<p>之后，清理边界外所有的空间。</p>
<p><strong>优点：</strong></p>
<ul>
<li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法当中，内存减半的高额代价。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>从效率上来说，标记-整理算法要低于复制算法。</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。</li>
<li>移动过程中，需要全程暂停用户应用程序。即:STW</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230328135934053.png" alt="image-20230328135934053"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p><strong>年轻代：</strong></p>
<p>年轻代特点:区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p>
<p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p>
<p><strong>老年代：</strong></p>
<p>老年代特点:区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p>
<p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标祚</p>
<h3 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the world的状态。在stop the world 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了<strong>增量收集(Incremental collecting）算法</strong>的诞生。</p>
<p><strong>基本思路：</strong></p>
<p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。海次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>
<p><strong>缺点：</strong></p>
<p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>
<h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><p>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>
<p>分代算法将按照对象的生命周期长短划分成两个部分，<strong>分区算法将整个堆空间划分成连续的不同小区间。</strong></p>
<p><strong>每一个小区间都独立使用，独立回收。</strong>这种算法的好处是可以控制一次回收多少个小区间。</p>
<h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>程序执行时并非在所有地方都能停顿下来开始Gc，只有在特定的位置才能停顿下来开始Gc，这些位置称为“安全点(Safepoint) ”。</p>
<p>Safe Point的选择很重要，<strong>如果太少可能导致Gc等待的时间太长，如果太频繁可能导致运行时的性能问题</strong>。大部分指令的执行时间都非常短暂，通常会根据<strong>“是否具有让程序长时间执行的特征”</strong>为标准。比如:选择一些执行时间较长的指令作为Safe Point，<strong>如方法调用、循环跳转和异常跳转等。</strong></p>
<p><strong>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢?</strong></p>
<p><strong>主动式中断：</strong></p>
<p>设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</p>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的 Safepoint 。但是，程序“不执行”的时候呢？例如线程处于sleep状态或Blocked状态，这时候线程无法响应`JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域(safe Region）来解决。</p>
<p><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始Gc都是安全的</strong>。我们也可以把safe Region看做是被扩展了的safepoint。</p>
<h3 id="实际运行"><a href="#实际运行" class="headerlink" title="实际运行"></a>实际运行</h3><p>1、当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region,如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程。</p>
<p>2、当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可测安全离开Safe Region的信号为止。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收器</title>
    <url>/2023/04/11/Java/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</p>
<p>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。从不同角度分析垃圾收集器，可以将GC分为不同的类型。</p>
<h3 id="垃圾回收器分类："><a href="#垃圾回收器分类：" class="headerlink" title="垃圾回收器分类："></a>垃圾回收器分类：</h3><ul>
<li>按<strong>线程数</strong>分：可以分为串行垃圾回收器和并行垃圾回收器。</li>
<li>按<strong>工作模式</strong>分：可以分为并发式垃圾回收器和独占式垃圾回收器。<ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>
<li>独占式垃圾回收器(Stop the world)一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>
</ul>
</li>
<li>按<strong>碎片处理方式</strong>分：可分为压缩式垃圾回收器和非压缩式垃圾回收器。<ul>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。<ul>
<li>再分配对象空间使用：指针碰撞</li>
</ul>
</li>
<li>非压缩式的垃圾回收器不进行这步操作。<ul>
<li>再分配对象空间使用：空闲列表</li>
</ul>
</li>
</ul>
</li>
<li>按<strong>工作的内存区间</strong>分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</li>
</ul>
<blockquote>
<p>-XX:+PrinrCommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</p>
</blockquote>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul>
<li><strong>吞吐量：</strong>运行用户代码的时间占总运行时间的比例<ul>
<li>（总运行时间：程序的运行时间＋内存回收的时间）</li>
</ul>
</li>
<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li><strong>暂停时间：</strong>执行垃圾收集时，程序的工作线程被暂停的时间。</li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li>
<li><strong>内存占用：</strong>Java堆区所占的内存大小。</li>
<li>快速：一个对象从诞生到被回收所经历的时间。</li>
</ul>
<p>主要抓两点：</p>
<ul>
<li>吞吐量</li>
<li>暂停时间</li>
</ul>
<h2 id="Serial回收器"><a href="#Serial回收器" class="headerlink" title="Serial回收器"></a>Serial回收器</h2><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。<strong>Serial 收集器采用复制算法、串行回收和”Stop-the-world”机制的方式执行内存回收。</strong></p>
<p>serial old收集器同样也采用了串行回收和”Stop the world”机制，只不过内存回收算法使用的是标记-压缩算法。</p>
<ul>
<li>serial old是运行在client模式下默认的老年代的垃圾回收器</li>
<li>Serial old在server模式下主要有两个用途：<ul>
<li>与新生代的ParallelScavenge配合使用</li>
<li>作为老年代CMS收集器的后备垃圾收集方案</li>
</ul>
</li>
</ul>
<blockquote>
<p>通过-XX:+UseSerialGC参数来设置使用该垃圾回收器</p>
</blockquote>
<h2 id="ParNew回收器"><a href="#ParNew回收器" class="headerlink" title="ParNew回收器"></a>ParNew回收器</h2><p>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是serial收集器的多线程版本。但是只处理新生代。</p>
<p>ParNew收集器除了采用<strong>并行回收</strong>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”Stop-the-world”机制。</p>
<blockquote>
<p>ParNew是很多JVM运行在server模式下新生代的默认垃圾收集器。但是如果是单CPU并不适合。他还可以与CMS配合使用。</p>
</blockquote>
<h2 id="Parallel-Scavenge回收器"><a href="#Parallel-Scavenge回收器" class="headerlink" title="Parallel Scavenge回收器"></a>Parallel Scavenge回收器</h2><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop the world”机制。</p>
<p><strong>特点：</strong></p>
<ul>
<li>和ParNew收集器不同，Parallel scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为<strong>吞吐量优先</strong>的垃圾收集器。</li>
<li>自适应调节策略也是Parallel scavenge与ParNew一个重要区别。</li>
</ul>
<p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
<h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器: CMS (concurrentrMark-Sweep)收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的<strong>并发收集器</strong>，它第一次实现了让垃圾收集线程与用户线程同时工作。</p>
<p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。<strong>停顿时间越短（低延迟）</strong>就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>
<p>CMS整个过程比之前的收集器要复杂,整个过程分为4个主要阶段：</p>
<ul>
<li>初始标记阶段</li>
<li>并发标记阶段</li>
<li>重新标记阶段</li>
<li>并发清除阶段</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>会产生内存碎片</li>
<li>CMS收集器对CPU资源非常敏感</li>
<li>CMS收集器无法处理浮动垃圾。</li>
</ul>
<blockquote>
<p> CMS的垃圾收集算法采用标记-清除算法，并且也会”Stop-the-world”。配置-XX:+UseConcMarkSweepGC参数使用CMS垃圾收集器</p>
</blockquote>
<h2 id="G1回收器"><a href="#G1回收器" class="headerlink" title="G1回收器"></a>G1回收器</h2><p>G1 (Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以<strong>极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征</strong>。</p>
<p>G1是一个<strong>并行回收器</strong>，它把堆内存**分割为很多不相关的区域(Region)**（物理上不连续的)。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</p>
<p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的**价值大小(**回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p>
<p><strong>记忆集</strong></p>
<p>为了避免进行年轻代GC的时候需要对整个堆进行扫描，G1使用了记忆集来避免全局扫描。</p>
<p>每个Region都有一个对应的记忆集。每次引用类型写操作时，会产生一个<strong>写屏障</strong>暂时中断，判断指向的对象是否和这个引用为同一个Region，<strong>如果不是就会把该引用放入指向对象所在Region的记忆集中</strong>。</p>
<p>当进行垃圾收集时，在GC根节点的枚举范围加入记忆集的遍历，就可以保证不进行全局扫描，也不会有遗漏。</p>
<p><strong>G1收集器的特征：</strong></p>
<ol>
<li><p>主要关注吞吐量，即满足垃圾清理占用的时间在程序总运行时间中所占的比例足够小。</p>
</li>
<li><p>使用Region作为内存管理的单元</p>
</li>
<li><p>分代，即并非一次清理只面向某一个分代</p>
<p>三个阶段：年轻代GC、老年代并发标记过程、混合回收</p>
</li>
<li><p>基于标记压缩算法，不会产生内存碎片</p>
</li>
</ol>
<p><strong>缺点：</strong></p>
<ul>
<li>G1无论是为了垃圾收集产生的<strong>内存占用(Footprint）</strong>还是程序运行时的额外<strong>执行负载（Overload)**都要比CMS要高。所以</strong>只有在大内存应用上才能发挥出优势。**</li>
</ul>
<blockquote>
<p>在JDK9之前使用需要配置-XX:+UseG1GC</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230402100343123.png" alt="image-20230402100343123"></p>
<ul>
<li>如果你想要最小化地使用内存和并行开销，请选Serial GC;</li>
<li>如果你想要最大化应用程序的吞吐量，请选Parallel GC;</li>
<li>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</li>
</ul>
<blockquote>
<p>但是从JDK9到JDK17都默认使用的是G1回收器，后续的<strong>ZGC</strong>相当于是G1的优化版，响应速度更快。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>对象引用</title>
    <url>/2023/04/06/Java/JVM/%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，<strong>这4种引用强度依次逐渐减弱。</strong></p>
<ul>
<li><p><strong>强引用(Strong Reference) ：</strong></p>
<p>最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似”object obj=new object()”这种引用关系。无论任何情况下，<strong>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</strong></p>
</li>
<li><p><strong>软引用(Soft Reference)：</strong></p>
<p>在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</p>
</li>
<li><p><strong>弱引用(Weak Reference)：</strong></p>
<p>被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，<strong>无论内存空间是否足够，都会回收掉被弱引用关联的对象。</strong></p>
</li>
<li><p><strong>虚引用(Phantom Reference)：</strong></p>
<p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。<strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</strong></p>
</li>
</ul>
<p>相对的，<strong>软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的</strong>，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</p>
<h2 id="强引用（Strong-Reference）—-不回收"><a href="#强引用（Strong-Reference）—-不回收" class="headerlink" title="强引用（Strong Reference）— 不回收"></a>强引用（Strong Reference）— 不回收</h2><p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，<strong>也是默认的引用类型</strong>。</p>
<p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。<strong>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong></p>
<p><strong>回收时机：</strong></p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了。</p>
<p><strong>特点：</strong></p>
<ul>
<li>强引用可以直接访问目标对象。</li>
<li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li>
<li>强引用可能导致内存泄漏。</li>
</ul>
<h2 id="软引用（Soft-Reference）—-内存不足即回收"><a href="#软引用（Soft-Reference）—-内存不足即回收" class="headerlink" title="软引用（Soft Reference）— 内存不足即回收"></a>软引用（Soft Reference）— 内存不足即回收</h2><p>软引用是用来描述一些还有用，但非必需的对象。<strong>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对纂列进回收范围之中进行第二次回收</strong>，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<p><strong>运用场景：</strong></p>
<p>软引用通常用来实现内存敏感的缓存。比如:<strong>高速缓存</strong>就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<p><strong>回收时机：</strong></p>
<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列(Reference Queue) 。类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>
<p><strong>实现：</strong></p>
<p>在JDK 1.2版之后提供了java.lang.ref.softReference类来实现软引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 声明软引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf - <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line"><span class="comment">// 销毁强引用</span></span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>


<h2 id="弱引用（Weak-Reference）—发现即回收"><a href="#弱引用（Weak-Reference）—发现即回收" class="headerlink" title="弱引用（Weak Reference）—发现即回收"></a>弱引用（Weak Reference）—发现即回收</h2><p>弱引用也是用来描述那些非必需对象，<strong>被弱引用关联的对象只能生存到下一次垃圾收集发生为止</strong>。</p>
<p><strong>回收时机：</strong></p>
<p>在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>
<p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，<strong>弱引用对象可以存在较长的时间。</strong></p>
<p><strong>应用场景：</strong></p>
<p><strong>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。</strong>如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>
<blockquote>
<p>例如用WeakHashMap来存一些缓存数据</p>
</blockquote>
<p><strong>实现：</strong></p>
<p>在JDK 1.2版之后提供了java.lang.ref.WeakReference类来实现弱引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; wr = <span class="keyword">new</span> WeakReference&lt;Object&gt;(<span class="keyword">new</span> Object());</span><br></pre></td></tr></table></figure>
<h2 id="虚引用（Phantom-Reference）—对象回收跟踪"><a href="#虚引用（Phantom-Reference）—对象回收跟踪" class="headerlink" title="虚引用（Phantom Reference）—对象回收跟踪"></a>虚引用（Phantom Reference）—对象回收跟踪</h2><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null。</p>
<p><strong>回收时机：</strong></p>
<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
<p><strong>应用场景：</strong></p>
<p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如:能在这个对象被收集器回收时收到一个系统通知。</p>
<p><strong>实现：</strong>  </p>
<p>在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</p>
<p>虚引用必须和引用队列一起使用。<strong>虚引用在创建时必须提供一个引用队列作为参数</strong>。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReferenceQueue phantomQueue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(<span class="keyword">new</span> Object()，phantomQueue);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p>
</blockquote>
<h2 id="终结器引用-Final-reference"><a href="#终结器引用-Final-reference" class="headerlink" title="终结器引用(Final reference)"></a>终结器引用(Final reference)</h2><p>它用以实现对象的finalize ()方法，也可以称为终结器引用。</p>
<p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize ()方法，第二次GC时才能回收被引用对象。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>对象的实例化</title>
    <url>/2023/03/28/Java/JVM/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h1><h2 id="对象创建的方式"><a href="#对象创建的方式" class="headerlink" title="对象创建的方式"></a>对象创建的方式</h2><ol>
<li>new对象<ul>
<li>常规直接new</li>
<li>XXX的静态方法</li>
<li>XXXBuilder/XXXFactory的静态方法</li>
</ul>
</li>
<li>Class的newInstance()：反射的方式，只能调用空参的构造器，权限必须是public</li>
<li>Constructor的newInstance(Xxx)：反射的方式，可以调用空参、带参的构造器，权限没有要求</li>
<li>使用clone()：不调用任何构造器，当前类需要实现Cloneable接口，实现clone()</li>
<li>使用反序列化:从文件中、从网络中获取—个对象的二进制流</li>
</ol>
<h2 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h2><p><strong>1.判断对象对应的类是否加载、链接、初始化</strong></p>
<p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。(即判断类元信息是否存在)。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛)出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象</p>
<p><strong>2.为对象分配内存</strong></p>
<p>首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。</p>
<ul>
<li>如果内存规整：使用指针碰撞法，顺序依次往后放</li>
<li>如果内存不规整：需要维护一个空闲列表。</li>
</ul>
<p><strong>3.处理并发安全问题</strong></p>
<ul>
<li>采用CAS失败重试、区域加锁保证更新的原子性</li>
<li>每个线程预先分配一块TLAB：通过-XX:+/-UseTLAB参数来设定</li>
</ul>
<p><strong>4.初始化分配到的空间</strong></p>
<p>所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用</p>
<p><strong>5.设置对象的对象头</strong></p>
<p>将对象的所属类（即类的元数据信息)、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
<p><strong>6.执行init方法进行初始化</strong></p>
<p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法,并把堆内对象的首地址赋值给引用变量。</p>
<p>因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>对象的内存布局包含：对象头、实例数据、对齐填充三个部分</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230320165813213.png" alt="image-20230320165813213"></p>
<h3 id="对象头："><a href="#对象头：" class="headerlink" title="对象头："></a>对象头：</h3><p><strong>运行时元数据（ Mark Word )</strong></p>
<ul>
<li>哈希值( HashCode )</li>
<li>GC分代年龄</li>
<li>锁状态标志</li>
<li>锁状态标志</li>
<li>偏向线程ID</li>
<li>偏向时间戳</li>
</ul>
<p><strong>类型指针</strong></p>
<ul>
<li>指向类元数据InstanceKlass，确定该对象所属的类型</li>
</ul>
<blockquote>
<p>如果是数组，则还需要记录数组的长度</p>
</blockquote>
<h3 id="实例数据："><a href="#实例数据：" class="headerlink" title="实例数据："></a>实例数据：</h3><p>它是对急真正存储的有效信息，包括程序代码中定义的各种类型的字段(包括从父类继承下来的和本身拥有的字段)</p>
<h3 id="对齐填充："><a href="#对齐填充：" class="headerlink" title="对齐填充："></a>对齐填充：</h3><p>不是必须的，也没特别含义，仅仅起到占位符的作用</p>
<h2 id="访问定位"><a href="#访问定位" class="headerlink" title="访问定位"></a>访问定位</h2><p>对象访问方式主要有两种：</p>
<ol>
<li><p>句柄访问</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230320195329825.png" alt="image-20230320195329825"></p>
</li>
</ol>
<ul>
<li><p>好处：</p>
<p>reference中存储稳定句柄地址，对象被移动(垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改。</p>
</li>
</ul>
<ol>
<li>直接指针（Hotspot采用）</li>
</ol>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230320195444947.png" alt="image-20230320195444947"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>执行引擎</title>
    <url>/2023/04/04/Java/JVM/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是<strong>物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的</strong>，而虚拟机的执行引擎则是由软件自行实现的，因此可以<strong>不受物理条件制约地定制指令集</strong>与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p>
<p>执行引擎(Execution Engine)的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</p>
<h2 id="编译和执行的过程"><a href="#编译和执行的过程" class="headerlink" title="编译和执行的过程"></a>编译和执行的过程</h2><p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230321103315873.png" alt="image-20230321103315873"></p>
<ul>
<li>JIT编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</li>
<li>解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li>
</ul>
<p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p>
<ul>
<li>-Xint：完全采用解释器模式执行程序。</li>
<li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。</li>
<li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li>
</ul>
<p>在HotSpot VM中内嵌有两个JIT编译器，分别为client Compiler和serverCompiler，但大多数情况下我们简称为c1编译器和c2编译器。</p>
<ul>
<li>-client：指定Java虚拟机运行在client模式下，并使用c1编译器。c1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。</li>
<li>-server：指定Java虚拟机运行在server模式下并使用C2编译器。C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。</li>
</ul>
<blockquote>
<p>Java是半编译半解释型语言。现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。因为解释器相对来说比较低效，为了提高性能使用JIT编译器，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。来缓存热点代码。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM执行引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>类的加载过程</title>
    <url>/2023/03/23/Java/JVM/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h1><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><p><strong>结构：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230303154124856.png" alt="image-20230303154124856"></p>
<p><strong>作用：</strong></p>
<ul>
<li>类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识。</li>
<li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由ExecutionEngine决定。</li>
<li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射)</li>
</ul>
<h2 id="类的加载过程-1"><a href="#类的加载过程-1" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><h3 id="Loading阶段"><a href="#Loading阶段" class="headerlink" title="Loading阶段"></a>Loading阶段</h3><p><strong>主要功能：</strong></p>
<p>1．通过一个类的全限定名获取定义此类的二进制字节流<br>2．将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br>3．在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据的访问入口</p>
<h3 id="Linking阶段"><a href="#Linking阶段" class="headerlink" title="Linking阶段"></a>Linking阶段</h3><p><strong>主要功能：</strong></p>
<ol>
<li>验证：<ul>
<li>目的在子确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</li>
<li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li>
</ul>
</li>
<li>准备：<ul>
<li>为类变量分配内存并且设置该类变量的默认初始值，即零值。</li>
<li>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化。</li>
<li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li>
</ul>
</li>
<li>解析：<ul>
<li>将常量池内的符号引用转换为直接引用的过程。</li>
<li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</li>
<li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、cONSTANT_Methodref_info等</li>
</ul>
</li>
</ol>
<h3 id="Initialization阶段"><a href="#Initialization阶段" class="headerlink" title="Initialization阶段"></a>Initialization阶段</h3><p>初始化阶段就是执行类构造器方法<clinit> ()的过程。此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</p>
<p>若该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit> ()已经执行完毕。虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁。</p>
<h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader)。</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</p>
<p><strong>分类：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230303162342533.png" alt="image-20230303162342533"></p>
<h3 id="Bootstrap-Class-Loader"><a href="#Bootstrap-Class-Loader" class="headerlink" title="Bootstrap Class Loader"></a>Bootstrap Class Loader</h3><p>启动类加载器（引导类加载器，Bootstrap classLoader)，Java的核心类库都是使用引导类加载器进行加载的。</p>
<ul>
<li><p>这个类加载使用C/C++语言实现的，嵌套在JVM内部。它用来加载Java的核心库（JAVA_HOME/jre/ lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类。并不继承自java.lang.classLoader，没有父加载器。</p>
</li>
<li><p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p>
</li>
<li><p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类。</p>
</li>
</ul>
<h3 id="Extension-Class-Loader"><a href="#Extension-Class-Loader" class="headerlink" title="Extension Class Loader"></a>Extension Class Loader</h3><p>扩展类加载器（Extension classLoader)，由Java语言编写，由sun.misc.Launcher$ExtClassLoader实现，派生于classLoader类，父类加载器为启动类加载器。</p>
<ul>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的re/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li>
</ul>
<h3 id="System-Class-Loader"><a href="#System-Class-Loader" class="headerlink" title="System Class Loader"></a>System Class Loader</h3><p>应用程序类加载器（系统类加载器，AppclassLoader)，java语言编写，由sun.misc.Launcher$AppclassLoader实现，派生于classLoader类。</p>
<ul>
<li><p>父类加载器为扩展类加载器，它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库，该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载。</p>
</li>
<li><p>通过classLoader#getSystemClassLoader ()方法可以获取到该类加载器</p>
</li>
</ul>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>Java虚拟机对class穿件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理,它是一种任务委派模式。  </p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li><p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行;</p>
</li>
<li><p>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归,请求最终将到达顶层的启动类加载器;</p>
</li>
<li><p>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230307103006756.png" alt="image-20230307103006756"></p>
</li>
</ol>
<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>自定义string类，但是在加载自定义string类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件(rt.jar包中java \lang\string.clasls )，报错信息说没有main方法就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230307103811221.png" alt="image-20230307103811221"></p>
<h2 id="类的主动使用与被动使用"><a href="#类的主动使用与被动使用" class="headerlink" title="类的主动使用与被动使用"></a>类的主动使用与被动使用</h2><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件:</p>
<ul>
<li>类的完整类名必须一致，包括包名。</li>
<li>加载这个类的classLoader(指classLoader实例对象)必须相同。</li>
</ul>
<p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。<strong>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。</strong>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>
<p><strong>主动使用情况：</strong></p>
<ol>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（比如:class.forName ( “com.wht.Test”) )</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK 7开始提供的动态语言支持:java . lang.invoke.MethodHandle实例的解析结果REF_getstatic、REF_putstatic、REF_invokestatic句柄对应的类没有初始化，则初始化</li>
</ol>
<p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 学习路线</title>
    <url>/2021/02/21/Java/Java%E5%9F%BA%E7%A1%80/Java%20%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="个人-Java学习路线"><a href="#个人-Java学习路线" class="headerlink" title="个人 Java学习路线"></a>个人 Java学习路线</h1><p>很喜欢学完一个东西就去看看其他人的学习路线，所以也看了很多，总结出了这个学习路线。</p>
<p>建议学习过程中多记笔记，写完后可以找项目练练手巩固复习一下所学技术(以免有所忘记)。</p>
<h2 id="1-编程基础部分"><a href="#1-编程基础部分" class="headerlink" title="1.编程基础部分"></a>1.编程基础部分</h2><ul>
<li>计算机组成原理</li>
<li>操作系统</li>
<li>计算机网络</li>
<li>数据结构与算法(这个尤为的重要，但也需要很长时间的积累)</li>
</ul>
<h2 id="2-JavaSE部分"><a href="#2-JavaSE部分" class="headerlink" title="2.JavaSE部分"></a>2.JavaSE部分</h2><ul>
<li>java语法基础</li>
<li>面向对象 (一种思想 封装继承多态)</li>
<li>接口</li>
<li>集合</li>
<li>多线程</li>
<li>异常</li>
<li>I/O</li>
<li>注解</li>
<li>反射</li>
</ul>
<h2 id="3-数据库基础"><a href="#3-数据库基础" class="headerlink" title="3.数据库基础"></a>3.数据库基础</h2><ul>
<li>MySQL/Oracle (建议先学mysql) </li>
<li>JDBC</li>
</ul>
<h2 id="4-web部分"><a href="#4-web部分" class="headerlink" title="4.web部分"></a>4.web部分</h2><ul>
<li>前端三剑客<ul>
<li>HTML</li>
<li>CSS</li>
<li>JS</li>
</ul>
</li>
<li>javaWeb<ul>
<li>Servlet</li>
<li>jsp(了解即可)</li>
<li>Cookie/Session</li>
<li>Filter/Listener</li>
<li>AJAX</li>
<li>JSON</li>
</ul>
</li>
</ul>
<h2 id="4-学习框架前的准备"><a href="#4-学习框架前的准备" class="headerlink" title="4.学习框架前的准备"></a>4.学习框架前的准备</h2><ul>
<li>设计模式</li>
<li>项目管理工具：Maven</li>
<li>版本控制工具：Git</li>
</ul>
<h2 id="5-基础框架"><a href="#5-基础框架" class="headerlink" title="5.基础框架"></a>5.基础框架</h2><ul>
<li><p>Spring</p>
</li>
<li><p> SpringMVC </p>
</li>
<li><p>MyBatis </p>
<p>  (个人建议先学Spring然后学SpringMVC再学MyBatis)</p>
</li>
<li><p>ssm整合</p>
<p>  (学完ssm可以找一个小的CRUD项目复习巩固一下,当然时间充裕可以在github上找大的开源项目)</p>
</li>
</ul>
<h2 id="6-Java开发核心基础部分"><a href="#6-Java开发核心基础部分" class="headerlink" title="6.Java开发核心基础部分"></a>6.Java开发核心基础部分</h2><ul>
<li><p>SpringBoot </p>
</li>
<li><p>SpringSecurity安全框架 </p>
<ul>
<li>有时间可以学oauth2、sso单点登录</li>
</ul>
</li>
<li><p>Vue + elementUi （学习前端方便后续与SpringBoot项目整合）</p>
</li>
</ul>
<h2 id="7-Java开发核心进阶部分"><a href="#7-Java开发核心进阶部分" class="headerlink" title="7.Java开发核心进阶部分"></a>7.Java开发核心进阶部分</h2><ul>
<li><p>Swagger2（RESTful风格的api文档框架）</p>
</li>
<li><p>Nginx服务器（有时间可以学完下面知识利用Nginx搭建相应集群）</p>
</li>
<li><p>日志处理</p>
<ul>
<li>SLF4j（门面）+ Logback（实现）</li>
</ul>
</li>
<li><p>Redis缓存</p>
</li>
<li><p>消息队列</p>
<ul>
<li>RabbitMQ（基础常用）</li>
<li>Kafka</li>
<li>RocketMQ</li>
</ul>
</li>
<li><p>搜索引擎：</p>
<ul>
<li>ElasticStack<ul>
<li>elasticsearch（搜索引擎）</li>
<li>logstash（日志收集工具）</li>
<li>kibana（日志可视化查看工具）</li>
</ul>
</li>
</ul>
</li>
<li><p>NoSql数据库</p>
<ul>
<li>MongoDB</li>
</ul>
<blockquote>
<p>这里也可以可以基于SpringBoot+SpringSecurity+Redis+RabbitMQ+Elasticsearch+Vue做一套后台管理系统（体现权限）</p>
</blockquote>
</li>
<li><p>项目部署（CI/CD:持续集成，持续部署）</p>
<ul>
<li>Docker容器</li>
<li>K8s</li>
<li>Jenkins</li>
</ul>
</li>
<li><p>微服务学习，基本上就是Alibaba一套（这边时间不够可以先学，时间够可以先学中间件等加分技术）</p>
<ul>
<li>SpringCloud</li>
<li>Nacos</li>
<li>OpenFeign</li>
<li>Sentinel</li>
<li>Gateway</li>
<li>Seata</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>运行时数据区</title>
    <url>/2023/04/01/Java/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>大致结构图：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230307105503822.png" alt="image-20230307105503822"></p>
<p><strong>详细内存划分图：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230307105633957.png" alt="image-20230307105633957"></p>
<p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p>
<ul>
<li>每个线程：独立包括程序计数器、栈、本地栈。</li>
<li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存)</li>
</ul>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230318152537997.png" alt="image-20230318152537997"  />

<blockquote>
<p>Runtime类：每个JVM只有一个Runtime实例。即为运行时环境，相当于内存结构的中间的那个框框:运行时环境。</p>
</blockquote>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>JVM中的程序计数寄存器（Program counter Register)中， Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。</p>
<p>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切(也称为程序钩子)，并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p>
<p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p>
<p><strong>作用：</strong></p>
<p>PC寄存器用来存储指向下一条指令的地址,也即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<p><strong>常见面试题：</strong></p>
<ol>
<li><p>使用PC寄存器存储字节码指令地址有什么用呢?/为什么使用PC寄存器记录当前线程的执行地址呢?</p>
<p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p>
</li>
<li><p>PC寄存器为什么会被设定为线程私有?</p>
<p>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个Pc寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互千扰的情况.。</p>
</li>
</ol>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。</p>
<p>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Java虚拟机栈（Java Virtual Machine stack)，早期也叫lava栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(stack Frame) ，对应着一次次的Java方法调用。</p>
<p><strong>生命周期：</strong></p>
<p>生命周期和线程一致。</p>
<p><strong>作用：</strong></p>
<p>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p>
<p><strong>异常：</strong>  </p>
<p>对于栈来说不存在垃圾回收问题，但是会有内存问题异常。</p>
<p><strong>StackOverflowError异常：</strong>如果采用固定大小的栈，如果线程请求分配的校容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常。</p>
<p><strong>OutOfMemoryError异常：</strong>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法中请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈,Java虚拟机将会抛出一个OutOfMemoryError异常。</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p><strong>栈的整体结构：</strong></p>
<ul>
<li>每个线程都有自己的栈，栈中的数据都是以栈帧（stack Frame）的格式存在。</li>
<li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame) 。</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li>
</ul>
<p><strong>栈的内部结构：</strong></p>
<ul>
<li><p>局部变量表（Local variables)</p>
<p>定义为一个数字数组，基本的存储单元是Slot，主要用于存储方法参数和定义在方法体内的局部变量，局部变量表所需的容量大小是在编译期确定下来的。（对象的引用this会存在index为0的slot处 ）。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
</li>
<li><p>操作数栈（operand stack)</p>
<p>一个后进先出的栈，实现方式是数组。</p>
</li>
<li><p>动态链接(Dynamic Linking)</p>
<p>指向运行时常量池的方法引用。（在Java源文件被编谨到字节码文件中时，所有的变量和方法引用都作为符号引用(symbolic Reference）保存在class文件的常量池里。）</p>
</li>
<li><p>方法返回地址(Return Address）</p>
<p>存放调用该方法的pc寄存器的值。无论通过正常方式还是异常方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表。</p>
</li>
<li><p>一些附加信息</p>
<p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。</p>
</li>
</ul>
<blockquote>
<p>动态链接+方法返回地址+附加信息=桢数据区</p>
</blockquote>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。本地方法栈，同样也是线程私有的。</p>
<p>它的具体做法是Native Method stack中登记native方法，在Execution Engine执行时加载本地方法库。</p>
<blockquote>
<p>本地方法：</p>
<p>简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法:该方法的实现由非Java语言实现，比如[c。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “c”告知C++编译器去调用一个c的函数。</p>
<p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p>
</blockquote>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p>
<p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。并且所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区。</p>
<p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
<p>堆是cc ( Garbage collection，垃圾收集器）执行垃圾回收的重点区域。在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p>
<blockquote>
<p>可以用-Xms大小设置起始内存 和-Xmx大小来设置堆的最大内存，-XX·:+PrintGCDetails 打印堆空间细节；</p>
<p>开发中建议将初始堆内存和最大的堆内存设置成相同的值。</p>
</blockquote>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p>具体空间的细分主要分为Java7以前和Java8之后：其实不分代完全可以，分代的唯一理由就是优化GC性能。</p>
<ul>
<li>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</li>
<li><strong>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间</strong></li>
</ul>
<p>在Java8之后只有新生区和养老区在堆空间里面，元空间移除到方法区中了。</p>
<ul>
<li><p>新生区：有Eden、两块大小相同的survivor (又称为from/to，s0/s1)构成，to总为空。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230316213949606.png" alt="image-20230316213949606"></p>
</li>
<li><p>养老区：存放新生代中经历多次Gc仍然存活的对象。</p>
</li>
</ul>
<blockquote>
<p>新生区和养老区默认比例为1:2。</p>
</blockquote>
<p>结构变化：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230316203107674.png" alt="image-20230316203107674"></p>
<blockquote>
<p> <strong>TLAB：</strong></p>
<p> 从内存模型而不是垃圾收集的角度对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域,它包含在Eden空间内。</p>
<p> 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略。</strong></p>
<p> 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<strong>JVM确实是将TLAB作为内存分配的首选</strong>。一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制</strong>确保数据操作的原子性，从而直接在Eden空间中分配内存。</p>
</blockquote>
<h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<p><strong>过程：</strong></p>
<ol>
<li>new的对象先放伊甸园区。此区有大小限制。</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。</li>
<li>然后将伊甸园中的剩余对象移动到幸存者0区。</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li>
<li>啥时候能去养老区呢?可以设置次数。默认是15次。</li>
</ol>
<ul>
<li>可以设置参数:-XX:MaxTenuringThreshold=<N>进行设置</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230317144918647.png" alt="image-20230317144918647"></p>
<p><strong>完整过程：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230317155658091.png" alt="image-20230317155658091"></p>
<blockquote>
<p>只有在新生区满了才会触发YGC/Minor GC，幸存者区满了不会，只是对新生区垃圾回收的同时会对幸存者区进行回收。</p>
<p>垃圾收集分类：</p>
<ul>
<li>部分收集：<ul>
<li>新生代收集(Minor GC / Young GC）:只是新生代的垃圾收集</li>
<li>老年代收集(Major GC/ old GC) :只是老年代的垃圾收集。</li>
<li>混合收集(Mixed GC):收集整个新生代以及部分老年代的垃圾收集。</li>
</ul>
</li>
<li>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。</li>
</ul>
</blockquote>
<h3 id="相关参数："><a href="#相关参数：" class="headerlink" title="相关参数："></a>相关参数：</h3><ul>
<li>-XX:+PrintFlagsInitial ：查看所有的参数的默认初始值</li>
<li>-XX:+PrintFlagsFinal ：查看所有的参数的最终值（可能会存在修改，不再是初始值)|</li>
<li>-Xms:初始堆空间内存（默认为物理内存的1/64)</li>
<li>-Xmx:最大堆空间内存（默认为物理内存的1/4)</li>
<li>-Xmn:设置新生代的大小。〈初始值及最大值)</li>
<li>-XX: NewRatio:配置新生代与老年代在堆结构的占比</li>
<li>-XX: SurvivorRatio:设置新生代中Eden和S0/s1空间的比例</li>
<li>-XX:MaxTenuringThreshold:设置新生代垃圾的最大年龄</li>
<li>打印gc简要信息:-XX:+PrintGC</li>
<li>-XX: HandlePromotionFailure:是否设置空间分配担保</li>
</ul>
<blockquote>
<p>官方说明地址：https: //docs.oracle.com/javase/8/docs/technotes/tools/unix/java. html</p>
</blockquote>
<h3 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h3><p><strong>堆是分配对象存储的唯一选择吗?</strong></p>
<p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过<strong>逃逸分析(Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的  堆外存储技术。</p>
<p><strong>逃逸分析的基本行为：分析对象动态作用域</strong></p>
<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。使用栈上分配。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。分配在堆中。</li>
</ul>
<h3 id="相关代码优化"><a href="#相关代码优化" class="headerlink" title="相关代码优化"></a>相关代码优化</h3><p><strong>一、栈上分配</strong></p>
<p>将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p>
<p><strong>二、栈上分配</strong></p>
<p>如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
<blockquote>
<p>在动态编译同步块的时候，JIT编译器可以借助<strong>逃逸分析</strong>来判断同步块所使用的锁对象是否只能够被一个线程访问而<strong>没有被发布到其他线程</strong>。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。<strong>这个取消同步的过程就叫同步省略，也叫锁消除。</strong></p>
</blockquote>
<p><strong>三、分离对象或标量替换</strong></p>
<p>有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在cPU寄存器中。</p>
<blockquote>
<p>在JIT阶段，如果经过<strong>逃逸分析</strong>，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是<strong>标量替换</strong>。</p>
</blockquote>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>方法区(Method Area）与Java堆一样，是各个线程共享的内存区域。</p>
<p>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</p>
<p>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</p>
<p>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误: java.lang. outofMemoryError: Metaspace，并且关闭JVM才会释放这个区域的内存。</p>
<blockquote>
<p>方法区使用的是本地内存，可以使用-XX:MetaspaceSize大小设置元空间大小</p>
</blockquote>
<h3 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h3><p>方法区用于存储已被虚拟机加载的类型信息、域信息、方法信息、运行时常量池、即时编译器（JIT）编译后的代码缓存。</p>
<p><strong>JDK8方法区详细结构：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230319110542138.png" alt="image-20230319110542138"></p>
<blockquote>
<p><strong>变化点：</strong></p>
<ol>
<li><p>字符串常量池移入堆中：</p>
<p>如果放在方法区中就会导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致内存不足。放到堆里，能及时回收内存。</p>
</li>
<li><p>静态变量移入堆中：静态变量的引用和实例都会放在堆中。</p>
</li>
<li><p>永久代替换为元空间：</p>
<p>因为永久代的大小难以控制，如果使用系统内存就可以在不超过系统要求下不受限；并且永久代的GC问题难以调优。</p>
</li>
</ol>
<p>方法区的垃圾收集主要回收两部分内容:常量池中废弃的常量和不再使用的类型。</p>
</blockquote>
<p><strong>类型信息：</strong></p>
<p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation) ，JVM必须在方法区中存储以下类型信息：</p>
<ul>
<li>这个类型的完整有效名称(全名=包名.类名)</li>
<li>这个类型直接父类的完整有效名(对于interface或是java.lang.object，都没有父类)</li>
<li>这个类型的修饰符(public,abstract,final的某个子集)</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
<p><strong>域信息：</strong></p>
<p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序：</p>
<ul>
<li>域名称、类型、修饰符</li>
</ul>
<p><strong>方法信息：</strong></p>
<p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ul>
<li>方法名称、返回类型、参数的数量和类型、修饰符</li>
<li>方法的字节码、操作数栈、局部变量表以及大小</li>
<li>异常表</li>
</ul>
<p><strong>运行时常量池：</strong></p>
<p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表(Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用。这部分内容将在类加载后存放到方法区的运行时常量池中，并会将符号地址转换为真实的地址，并且相较于classs文件常量池具有动态性。</p>
<blockquote>
<p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池这个字节码包含了指向常量池的引用。</p>
</blockquote>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
<p><strong>方法区的垃圾收集主要回收两部分内容:常量池中废弃的常量和不再使用的类型。</strong></p>
<ol>
<li><p>常量池：</p>
<p>Hotspot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
</li>
<li><p>类型回收：</p>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件:</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li>该类对应的java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p>
</li>
</ol>
<h2 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h2><p><strong>关系图：</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230318153016041.png" alt="image-20230318153016041" style="zoom:80%;" />

<p><strong>例子：</strong></p>
<p><code>User user = new User();</code></p>
<ul>
<li>首先User对象的class文件存在方法区的元空间中</li>
<li>然后user局部变量存在虚拟机栈中</li>
<li>最后new出来的User对象存在堆中</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JVM内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础编程优化</title>
    <url>/2023/09/20/Java/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Java基础编程调优"><a href="#Java基础编程调优" class="headerlink" title="Java基础编程调优"></a>Java基础编程调优</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JDK 是 Java 语言的基础库，熟悉 JDK 中各个包中的工具类，可以帮助你编写出高性能代码。但是一些基本类不正确使用会有个别的性能问题，需要去注意去调优。</p>
<h2 id="字符串的性能调优"><a href="#字符串的性能调优" class="headerlink" title="字符串的性能调优"></a>字符串的性能调优</h2><p>String 对象是我们使用最频繁的一个对象类型，但它的性能问题却是最容易被忽略的。</p>
<p><strong>结果变化：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230605134359364.png" alt="image-20230605134359364"></p>
<blockquote>
<p>每次更新就都是为了能够节约内存，提高性能</p>
</blockquote>
<p><strong>不可变性：</strong></p>
<p> String 类被 final 关键字修饰了，而且变量 char 数组也被 final 修饰了。而 char[] 被 final+private 修饰，代表了 String 对象<strong>不可被更改</strong>。</p>
<p><strong>这样的好处是为了能够将创建过的字符串缓存在字符串常量池中，以提供给后面的相同字符串引用。</strong></p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><ul>
<li><p><strong>多使用StringBuilder和StringBuffer：</strong></p>
<p>例如：<code>String str= &quot;ab&quot; + &quot;cd&quot; + &quot;ef&quot;;</code></p>
<p>理论上首先会生成 ab 对象，再生成 abcd 对象，最后生成 abcdef 对象，但是编译器底层做了优化：</p>
<p>使用StringBuilder来进行拼接，但是会每次创建一个新的StringBuilder，所以<strong>在有字符串操作的场景最好自己手动使用StringBuilder和StringBuffer</strong>。</p>
</li>
<li><p><strong>使用 String.intern() 节省内存：</strong></p>
<p>在每次赋值的时候使用 String 的 intern 方法，<strong>如果常量池中有相同值，就会重复使用该对象，返回对象引用</strong>，这样一开始的对象就可以被回收掉。这种方式可以使重复性非常高的信息储存大小降低很多。</p>
</li>
<li><p><strong>字符串的分割：</strong></p>
<p>Split() 方法使用了正则表达式实现了其强大的分割功能，而正则表达式的性能是非常不稳定的，使用不恰当会<strong>引起回溯问题</strong>，很可能导致 CPU 居高不下。</p>
<p>解决方案：</p>
<ul>
<li>可以用 String.indexOf() 方法代替 Split() 方法完成字符串的分割</li>
<li>如果只能使用正则：<ul>
<li>利用在贪婪模式的字符后面加<code>?</code>来开启懒惰模式</li>
<li>利用在贪婪模式的字符后面加<code>+</code>来开启独占模式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h2><p>ArrayList和LinkedList，一个最最最基本的区别是<strong>ArrayList 是基于动态数组实现，LinkedList 是基于双向链表实现。</strong>这也是两个集合类各种操作区别的关键点。 </p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList 实现了 List 接口，继承了 AbstractList 抽象类，底层是数组实现的，并且实现了<strong>自增扩容数组大小</strong>。并且<strong>支持克隆和序列化</strong>。还实现了 RandomAccess 接口，表示<strong>可以随机访问</strong>。</p>
<ul>
<li><p><strong>关键属性：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认初始化容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 对象数组,transient不是表示不能整个List序列化而是禁止外部自己序列化，ArrayList提供了专门的writeObject以及readObject来实现序列化和反序列化</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"><span class="comment">// 数组长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>构造函数：</strong></p>
<p>支持传入初试大小，如果不传入则默认是10；</p>
<p>我们在初始化 ArrayList 时，可以通过第一个构造函数合理指定数组初始大小，这样有助于减少数组的扩容次数，从而提高系统性能。</p>
</li>
<li><p><strong>新增元素：</strong></p>
<p>ArrayList 新增元素的方法有两种，一种是直接将元素加到数组的末尾，另外一种是添加元素到任意位置。</p>
<ul>
<li>加到数组的末尾：速度很快</li>
<li>添加元素到任意位置：会导致在该位置后的所有元素都需要重新排列</li>
</ul>
<blockquote>
<p>如果容量不够了，会进行1.5倍的大小进行扩容</p>
</blockquote>
</li>
<li><p><strong>删除元素：</strong></p>
<p>在每一次有效的删除元素操作之后，都要进行数组的重组，并且删除的元素位置越靠前，数组重组的开销就越大。</p>
</li>
<li><p><strong>遍历元素：</strong></p>
<p>由于 ArrayList 是基于数组实现的，所以在获取元素的时候是非常快捷的。</p>
</li>
</ul>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList 是基于双向链表数据结构实现的，LinkedList 定义了一个 Node 结构，Node 结构中包含了 3 个部分：元素内容 item、前指针 prev 以及后指针 next。</p>
<p>LinkedList 类实现了 List 接口、Deque 接口，同时继承了 AbstractSequentialList 抽象类，LinkedList 既<strong>实现了 List 类型又有 Queue 类型</strong>的特点；LinkedList 也实现了 Cloneable 和 Serializable 接口，同 ArrayList 一样，<strong>可以实现克隆和序列化。</strong></p>
<ul>
<li><p><strong>关键属性：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前大小</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>新增元素：</strong></p>
<p>LinkedList 添加元素的实现很简洁，但添加的方式却有很多种。</p>
<ul>
<li>加到链表的末尾头/尾：速度很快</li>
<li>添加元素到任意位置：需要从头/尾节点进行遍历</li>
</ul>
</li>
<li><p><strong>删除元素：</strong></p>
<p>首先要通过循环找到要删除的元素，如果要删除的位置处于 List 的前半段，就从前往后找；若其位置处于后半段，就从后往前找。</p>
</li>
<li><p><strong>遍历元素：</strong></p>
<p>LinkedList 的获取元素操作实现跟 LinkedList 的删除元素操作基本类似，通过分前后半段来循环查找到对应的元素。</p>
<p>所以在 LinkedList 循环遍历时，我们可以使用 iterator 方式迭代循环，直接拿到我们的元素，而不需要通过循环查找 List。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>新增元素：</strong><ul>
<li>从集合头部位置新增元素：ArrayList&gt;LinkedList</li>
<li>从集合中间位置新增元素：ArrayList&lt;LinkedList</li>
<li>从集合尾部位置新增元素：ArrayList&lt;LinkedList</li>
</ul>
</li>
<li><strong>删除元素：</strong><ul>
<li>从集合头部位置删除元素：ArrayList&gt;LinkedList</li>
<li>从集合中间位置删除元素：ArrayList&lt;LinkedList</li>
<li>从集合尾部位置删除元素：ArrayList&lt;LinkedList</li>
</ul>
</li>
<li><strong>遍历：</strong><ul>
<li>for(;;) 循环：ArrayList&lt;LinkedList</li>
<li>迭代器迭代循环：ArrayList≈LinkedList</li>
</ul>
</li>
</ul>
<h2 id="Steam优化"><a href="#Steam优化" class="headerlink" title="Steam优化"></a>Steam优化</h2><p>Java8 中添加了一个新的接口类 Stream，他和我们之前接触的字节流概念不太一样，Java8 集合中的 Stream 相当于高级版的 Iterator，他可以通过 Lambda 表达式对集合进行各种<strong>非常便利、高效的聚合操作（Aggregate Operation）</strong>，或者**大批量数据操作 (Bulk Data Operation)**。</p>
<p><strong>例如：</strong>过滤分组一所中学里身高在 160cm 以上的男女同学</p>
<p>利用Stream来进行统计：</p>
<ul>
<li><p>串行：</p>
<p><code>Map&lt;String, List&lt;Student&gt;&gt; stuMap = stuList.stream().filter((Student s) -&gt; s.getHeight() &gt; 160) .collect(Collectors.groupingBy(Student ::getSex)); </code></p>
</li>
<li><p>并行：（底层利用了ForkJoin 进行分片计算）</p>
<p><code>Map&lt;String, List&lt;Student&gt;&gt; stuMap = stuList.parallelStream().filter((Student s) -&gt; s.getHeight() &gt; 160) .collect(Collectors.groupingBy(Student ::getSex)); </code></p>
</li>
</ul>
<h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230607150503780.png" alt="image-20230607150503780" style="zoom: 67%;" />

<p> Stream 中的操作分为两大类：</p>
<ul>
<li><strong>中间操作（Intermediate operations）</strong>：只对操作进行了记录，即只会返回一个流。<ul>
<li><strong>无状态（Stateless）</strong>：元素的处理不受之前元素的影响。</li>
<li><strong>有状态（Stateful）</strong>：操作只有拿到所有元素之后才能继续下去。</li>
</ul>
</li>
<li><strong>终结操作（Terminal operations）</strong>：实现了计算操作。<ul>
<li><strong>短路（Short-circuiting）</strong>：遇到某些符合条件的元素就可以得到最终结果。</li>
<li><strong>非短路（Unshort-circuiting）</strong>：必须处理完所有元素才能得到最终结果。</li>
</ul>
</li>
</ul>
<h3 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h3><p>对常规的迭代、Stream 串行迭代以及 Stream 并行迭代进行<strong>性能测试对比</strong>：</p>
<ul>
<li>多核 CPU 服务器配置环境下，对比长度 100 的 int 数组的性能；</li>
<li>多核 CPU 服务器配置环境下，对比长度 1.00E+8 的 int 数组的性能；</li>
<li>多核 CPU 服务器配置环境下，对比长度 1.00E+8 对象数组过滤分组的性能；</li>
<li>单核 CPU 服务器配置环境下，对比长度 1.00E+8 对象数组过滤分组的性能。</li>
</ul>
<p><strong>迭代使用时间</strong>：</p>
<ul>
<li>常规的迭代 &lt;Stream 并行迭代 &lt;Stream 串行迭代</li>
<li>Stream 并行迭代 &lt; 常规的迭代 &lt;Stream 串行迭代</li>
<li>Stream 并行迭代 &lt; 常规的迭代 &lt;Stream 串行迭代</li>
<li>常规的迭代 &lt;Stream 串行迭代 &lt;Stream 并行迭代</li>
</ul>
<p>其实使用 Stream 未必可以使系统性能更佳，还是要<strong>结合应用场景进行选择</strong>，也就是合理地使用 Stream。</p>
<h2 id="I-O优化"><a href="#I-O优化" class="headerlink" title="I/O优化"></a>I/O优化</h2><p>I/O 是机器获取和交换信息的主要渠道，而流是完成 I/O 操作的主要方式。在<strong>NIO</strong>出来之前一直使用的是Java 的 I/O 操作类在包 java.io 下的字节流和字符流。</p>
<p>但是传统I/O会有性能瓶颈问题：</p>
<ul>
<li><p><strong>多次内存复制：</strong></p>
<p>数据先从外部设备复制到内核空间，再从内核空间复制到用户空间，这就发生了两次内存复制操作。这种操作会导致不必要的<strong>数据拷贝</strong>和<strong>上下文切换</strong>，从而降低 I/O 的性能。</p>
</li>
<li><p><strong>阻塞：</strong></p>
<p>如果没有数据就绪，这个读取操作将会一直被挂起，用户线程将会处于阻塞状态。一旦发生线程阻塞，这些线程将会<strong>不断地抢夺 CPU 资源</strong>，从而导致大量的 CPU 上下文切换，增加系统的性能开销。</p>
</li>
</ul>
<h3 id="利用NIO进行优化"><a href="#利用NIO进行优化" class="headerlink" title="利用NIO进行优化"></a>利用NIO进行优化</h3><p>JDK1.4 发布了 java.nio 包（new I/O 的缩写），NIO 的发布优化了<strong>内存复制</strong>以及<strong>阻塞</strong>导致的严重性能问题。JDK1.7 又发布了 NIO2，提出了从操作系统层面实现的异步 I/O。</p>
<ol>
<li>使用缓冲区优化读写流操作</li>
<li>使用 DirectBuffer 减少内存复制</li>
<li>避免阻塞，优化 I/O 操作</li>
</ol>
<blockquote>
<p>具体使用参考<a href="https://iooooot.github.io/2023/03/13/Java/NIO/NIO/">NIO</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/2023/09/28/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JMM即 Java Memory Model，它定义了主存、工作内存抽象概念。</p>
<p>底层对应着复杂的优化：</p>
<ul>
<li>CPU 增加了缓存，以均衡与内存的速度差异；</li>
<li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；</li>
<li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。</li>
</ul>
<p>引发的问题体现在以下几个方面：</p>
<ul>
<li><strong>原子性：</strong>保证指令不会受到线程上下文切换的影响</li>
<li><strong>可见性：</strong>保证指令不会受cpu缓存的影响</li>
<li><strong>有序性：</strong>保证指令不会受cpu指令并行优化的影响</li>
</ul>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性是指一个操作或者多次操作是不可中断的。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
<p><strong>例如：</strong>两个线程对同一个变量进行修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 原子性 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> t = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(t);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(t);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题：</strong>出现错误数据</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230414223911287.png" alt="image-20230414223911287"></p>
<p><strong>解决：</strong>对临界区代码进行加锁（也是我们之前一直通过synchronized和各种Lock解决的事情）。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>由于cpu缓存的影响，有时候线程对变量的修改，并不会让其他线程看见。</p>
<p><strong>例如：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    run = <span class="keyword">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>原因：</strong></p>
<p>Java内存主要是分为主内存和线程独有的工作内存；</p>
<ol>
<li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</li>
<li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</li>
<li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li>
</ol>
<p><strong>解决：</strong></p>
<p>给需要保证可见性的变量加上volatile（易变关键字，只能保证可见性，它最原始的意义就是禁用 CPU 缓存）</p>
<ul>
<li><p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</p>
<blockquote>
<p>volatile的底层实现原理是<strong>内存屏障</strong>，Memory Barrier (Memory Fence)</p>
<ul>
<li>对volatile变量的写指令后会加入<strong>写屏障</strong><ul>
<li>写屏障(sfence)保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li>
</ul>
</li>
<li>对volatile变量的读指令前会加入<strong>读屏障</strong><ul>
<li>读屏障(lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</li>
</ul>
</li>
</ul>
<p>能够保证的有序性也正是，写屏障会让指令不会出现在屏障后面，读屏障会让指令不会在屏障前面。但是不能解决指令的交错问题还是得用synchronized等解决。</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li>用synchronized锁住需要保证可见性的变量代码，因为synchronized同样可以保证变量的可见性，但比较重量级（例如使用System.out.println()同样也可以保证可见性，因为底层也是synchronized）</li>
</ol>
<p><strong>happens-before规则</strong></p>
<p>happens-before规定了<strong>对共享变量的写操作对其它线程的读操作可见，即前面的一个操作的结果对后续操作是可见的</strong>，它是可见性与有序性的一套规则总结，抛开以下happens-before规则，JMM并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见。</p>
<ul>
<li>synchronized锁中对共享变量的读写是能够保证可见性的。</li>
<li>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见。</li>
<li>线程 start 前对变量的写，对该线程开始后对该变量的读可见。</li>
<li>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待<br>它结束）</li>
<li>interrupted打断之前对共享变量的修改是对其他线程可见的。</li>
<li>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</li>
<li>具有传递性，volatile变量赋值前其他变量的赋值也会被同步到主存中，对于其他线程也是可见的。</li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>JVM会在不影响正确性的前提下，可以调整语句的执行顺序。这种特性称之为<strong>『指令重排』</strong>，但是多线程下<strong>『指令重排』</strong>会影响正确性。</p>
<p><strong>在多线程下的指令重排序机制问题：</strong></p>
<p>使用两个线程执行两种方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span></span><br><span class="line"><span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 线程1 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(Result r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">    	r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(Result r)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果JVM进行指令重排序，让actor2的两条语句颠倒，就会得到r.r1=0的错误结果。</p>
<p><strong>解决：</strong>给禁止重排序的变量加上volatile，这样在该变量上面的代码就不会重排序。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发工具</title>
    <url>/2023/10/11/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h1><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对于线程池与数据库连接池一样，都利用了池化技术来<strong>优化频繁创建线程/连接所带来的性能损耗</strong>。并且可以控制线程数来减小上下文切换的性能消耗。</p>
<p>线程池有两个比较重要的参数：<strong>coreThreadCount</strong> 和 <strong>maxThreadCount</strong></p>
<ul>
<li>coreThreadCount：线程池中的核心线程数。</li>
<li>maxThreadCount：最大线程数。</li>
</ul>
<p>分配策略：</p>
<ul>
<li>如果线程池中的线程数少于 coreThreadCount 时，会创建新的线程处理，并将线程放入线程池；</li>
<li>如果线程数大于 coreThreadCount 则把任务丢到一个队列里面，由当前空闲的线程执行；</li>
<li>当队列中的任务堆积满了的时候，则继续创建线程，直到达到 maxThreadCount；</li>
<li>当线程数达到 maxTheadCount 时还有新的任务提交，那么我们就不得不将它们丢弃了。</li>
</ul>
<p>可以看出JDK 原生的线程池当线程数大于 coreThreadCount 不会立马创建线程，而是放入队列；因此只需要创建和 CPU 核心数相当的线程就好了，多了反而会造成线程上下文切换，降低任务执行效率。（但是这是对于CPU 密集型的任务，对于IO操作多的任务来说立马创建线程分配可以大大提高系统的吞吐量）</p>
<blockquote>
<p><strong>注意事项：</strong></p>
<ul>
<li>coreThreadCount 和 maxThreadCount 不宜设置得比较小，会导致任务在线程池里面大量的堆积</li>
<li>一定记住不要使用无界队列（即没有设置固定大小的队列），大量的任务堆积会占用大量的内存空间，一旦内存空间被占满就会频繁地触发 Full GC，造成服务不可用</li>
</ul>
<p><strong>问题：</strong></p>
<p>但是，我们平时开发的 Web 系统通常都有大量的 IO 操作，比方说查询数据库、查询缓存等等。任务在执行 IO 操作的时候 CPU 就空闲了下来，这时如果增加执行任务的线程数而不是把任务暂存在队列中，就可以在单位时间内执行更多的任务，大大提高了任务执行的吞吐量。</p>
<p>所以Tomcat 使用的线程池就不是 JDK 原生的线程池，而是做了一些改造，当线程数超过 coreThreadCount 之后会<strong>优先创建线程</strong>，直到线程数到达 maxThreadCount，这样就比较适合于 Web 系统大量 IO 操作的场景了</p>
</blockquote>
<h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><p>基本结构：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230420212402982.png" alt="image-20230420212402982"></p>
<ul>
<li><p>阻塞队列：任务队列放置任务等待空闲线程执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.用双端链表定义任务队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.锁，防止多个线程取走/放置同一个任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.生产者条件变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Condition fullWaitSet = lock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.消费者条件变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Condition emptyWaitSet = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 队列为空，等待</span></span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> queue.removeFirst();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带超时的阻塞获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">            <span class="comment">// 队列为空，等待</span></span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 防止虚假唤醒</span></span><br><span class="line">                    <span class="keyword">if</span>(nanos &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = emptyWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> queue.removeFirst();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞添加</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T element)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 队列满了，等待</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.addLast(element);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 带超时时间阻塞添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(T task, <span class="keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> nanos = timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = fullWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>线程池：用于存放线程，并消费阻塞队列中的任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span>&#123;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程集合</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务的超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line">    <span class="comment">// 超时时间单位</span></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行</span></span><br><span class="line">        <span class="comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (workers)&#123;</span><br><span class="line">            <span class="comment">// 需要保证workers的线程安全</span></span><br><span class="line">            <span class="keyword">if</span>(workers.size() &lt; coreSize)&#123;</span><br><span class="line">                <span class="comment">// 创建线程进行处理</span></span><br><span class="line">                Worker worker = <span class="keyword">new</span> Worker(task);</span><br><span class="line">                <span class="comment">// 并且添加到线程池中</span></span><br><span class="line">                workers.add(worker);</span><br><span class="line">                <span class="comment">// 执行任务</span></span><br><span class="line">                worker.start();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                taskQueue.put(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">long</span> timeout, TimeUnit timeUnit,<span class="keyword">int</span> queueCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="keyword">this</span>.taskQueue = <span class="keyword">new</span> BlockingQueue&lt;&gt;(queueCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            <span class="comment">// 当task不为空，执行该任务</span></span><br><span class="line">            <span class="comment">// 当task执行完毕，从任务队列获取任务</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = taskQueue.take()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果需要加线程空闲时间while (task != null || (task = taskQueue.poll(timeout,timeUit)) != null)&#123;</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (workers)&#123;</span><br><span class="line">                workers.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadPool threadPool = <span class="keyword">new</span> ThreadPool(<span class="number">2</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>改进：</strong>当任务队列满了的时候，会有很多方案，例如：死等、超时等待、放弃执行、自己开线程执行等；如果放在线程池中一一实现就不灵活。不如给调用者提供一个拒绝策略接口让其自己选择方案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RejectPolicy</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue,T task)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span>&#123;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程集合</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务的超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line">    <span class="comment">// 超时时间单位</span></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line">    <span class="comment">// 拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行</span></span><br><span class="line">        <span class="comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (workers)&#123;</span><br><span class="line">            <span class="comment">// 需要保证workers的线程安全</span></span><br><span class="line">            <span class="keyword">if</span>(workers.size() &lt; coreSize)&#123;</span><br><span class="line">                <span class="comment">// 创建线程进行处理</span></span><br><span class="line">                Worker worker = <span class="keyword">new</span> Worker(task);</span><br><span class="line">                <span class="comment">// 并且添加到线程池中</span></span><br><span class="line">                workers.add(worker);</span><br><span class="line">                <span class="comment">// 执行任务</span></span><br><span class="line">                worker.start();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// taskQueue.put(task);</span></span><br><span class="line">                <span class="comment">// 尝试获取，如果满了执行相应拒绝策略</span></span><br><span class="line">                taskQueue.tryPut(rejectPolicy,task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">long</span> timeout, TimeUnit timeUnit,<span class="keyword">int</span> queueCapacity,RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="keyword">this</span>.taskQueue = <span class="keyword">new</span> BlockingQueue&lt;&gt;(queueCapacity);</span><br><span class="line">        <span class="keyword">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            <span class="comment">// 当task不为空，执行该任务</span></span><br><span class="line">            <span class="comment">// 当task执行完毕，从任务队列获取任务</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = taskQueue.take()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (workers)&#123;</span><br><span class="line">                workers.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.用双端链表定义任务队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.锁，防止多个线程取走/放置同一个任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.生产者条件变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Condition fullWaitSet = lock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.消费者条件变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Condition emptyWaitSet = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockingQueue</span><span class="params">(<span class="keyword">int</span> queueCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = queueCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 队列为空，等待</span></span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> queue.removeFirst();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带超时的阻塞获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">            <span class="comment">// 队列为空，等待</span></span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 防止虚假唤醒</span></span><br><span class="line">                    <span class="keyword">if</span>(nanos &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = emptyWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> queue.removeFirst();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞添加</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T element)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 队列满了，等待</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.addLast(element);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时时间阻塞添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(T task, <span class="keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> nanos = timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = fullWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断队列是否已经满了</span></span><br><span class="line">            <span class="keyword">if</span>(queue.size() == capacity)&#123;</span><br><span class="line">                rejectPolicy.reject(<span class="keyword">this</span>,task);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 有空闲</span></span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyWaitSet.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPool threadPool = <span class="keyword">new</span> ThreadPool(<span class="number">2</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">10</span>,(queue,task) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 死等</span></span><br><span class="line">            <span class="comment">// queue.put(task);</span></span><br><span class="line">            <span class="comment">// 超时等待</span></span><br><span class="line">            <span class="comment">// queue.offer(task,500,TimeUnit.MILLISECONDS);</span></span><br><span class="line">            <span class="comment">// 放弃执行即不调用任何处理方法</span></span><br><span class="line">            <span class="comment">// System.out.println(&quot;放弃&quot;);</span></span><br><span class="line">            <span class="comment">// 抛异常</span></span><br><span class="line">            <span class="comment">// throw new RuntimeException(&quot;执行失败&quot;);</span></span><br><span class="line">            <span class="comment">// 自己执行</span></span><br><span class="line">            task.run();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(j);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>ThreadPoolExecutor是一个ExecutorService，是JDK提供的线程池，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。</p>
<p><strong>线程池状态：</strong></p>
<p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p>
<table>
<thead>
<tr>
<th>状态名</th>
<th>高 3位</th>
<th>接收新任务</th>
<th>处理阻塞队列任务</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>111</td>
<td>Y</td>
<td>Y</td>
<td>正常执行</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>000</td>
<td>N</td>
<td>Y</td>
<td>不会接收新任务，但会处理阻塞队列剩余任务</td>
</tr>
<tr>
<td>STOP</td>
<td>001</td>
<td>N</td>
<td>N</td>
<td>会中断正在执行的任务，并抛弃阻塞队列任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>010</td>
<td>-</td>
<td>-</td>
<td>任务全执行完毕，活动线程为 0 即将进入终结</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>011</td>
<td>-</td>
<td>-</td>
<td>终结状态</td>
</tr>
</tbody></table>
<p><strong>构造方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">    TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">    RejectedExecutionHandler handler</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>corePoolSize：核心线程数目 (最多保留的线程数)</li>
<li>maximumPoolSize：最大线程数目 = 核心线程数+救急线程数</li>
<li>keepAliveTime：生存时间 - 针对救急线程的存活时间</li>
<li>unit：时间单位 -生存时间的时间单位</li>
<li>workQueue： 阻塞队列，即任务队列</li>
<li>threadFactory： 线程工厂 - 用于线程的创建</li>
<li>handler： 拒绝策略</li>
</ul>
<p><strong>拒绝策略：</strong></p>
<p>拒绝策略jdk提供了4种实现</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230424194254094.png" alt="image-20230424194254094"></p>
<ul>
<li>DiscardPolicy：放弃本次任务</li>
<li>DiscardOldestPolicy：放弃队列中最早的任务，本任务取而代之</li>
<li>AbortPolicy：让调用者抛出RejectedExecutionException异常，这是默认策略</li>
<li>CallerRunsPolicy：让调用者运行任务</li>
</ul>
<p><strong>提交任务：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line"><span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line"><span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line"><span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br></pre></td></tr></table></figure>
<p><strong>关闭线程池：</strong></p>
<ul>
<li>shutdown：将线程池状态变为 SHUTDOWN，不会接收新任务，但已提交任务会执行完，此方法不会阻塞调用线程的执行。</li>
<li>shutdownNow：将线程池状态变为 STOP，不会接收新任务，会将队列中的任务返回，用 interrupt 的方式中断正在执行的任务。</li>
</ul>
<p><strong>其他方法：</strong></p>
<ul>
<li>isShutdown()：如果状态不是RUNNING，此方法就返回 true。</li>
<li>isTerminated()：判断线程池状态是否是 TERMINATED。</li>
<li>awaitTermination：调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待。</li>
</ul>
<h3 id="Executor创建线程池"><a href="#Executor创建线程池" class="headerlink" title="Executor创建线程池"></a>Executor创建线程池</h3><ol>
<li><p>newFixedThreadPool：</p>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>特点：<ul>
<li>核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间</li>
<li>阻塞队列是无界的，可以放任意数量的任务</li>
</ul>
</li>
<li>适用场景：适用于任务量已知，相对耗时的任务</li>
</ul>
</li>
<li><p>newCachedThreadPool</p>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>特点：<ul>
<li>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，并且可以无线创建</li>
<li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的</li>
</ul>
</li>
<li>适用场景：适合任务数比较密集，但每个任务执行时间较短的情况</li>
</ul>
</li>
<li><p>newSingleThreadExecutor</p>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>特点：<ul>
<li>线程数固定为 1，任务数多于 1 时，会放入无界队列排队。</li>
<li>任务执行完毕，这唯一的线程也不会被释放。</li>
</ul>
</li>
<li>适用场景：希望多个任务排队执行。</li>
</ul>
</li>
<li><p>ScheduledThreadPoolExecutor</p>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用schedule方法提交任务</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>特点：</p>
<ul>
<li>一个任务调度的线程池，继承于<code>ThreadPoolExecutor</code>，实现了<code>ScheduledExecutorService </code>接口。</li>
</ul>
</li>
<li><p>适用场景：用于处理延时/定时任务。</p>
</li>
<li><p>使用</p>
<ul>
<li><p>提交延时任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务1，执行时间：&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    <span class="comment">// 这里的异常还可以返回Future对象来获取异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">&#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure></li>
<li><p>提交定时任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数任务、第二个参数延迟时间、第三个参数间隔时间、第四个时间单位</span></span><br><span class="line"><span class="comment">// 这个方法第三个参数可能会被任务里面的延迟吞没比如sleep了2秒，这样就不会再推迟一秒执行而是直接执行</span></span><br><span class="line">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">    pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 这个方法第三个参数间隔时间就不会被任务的sleep等时间所吞没</span></span><br><span class="line">pool.scheduleWithFixedRate(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程池大小问题：</p>
<ul>
<li>过小会导致程序不能充分地利用系统资源、容易导致饥饿</li>
<li>过大会导致更多的线程上下文切换，占用更多内存</li>
</ul>
<p>计算方法：</p>
<ul>
<li><p>CPU密集型运算：</p>
<p>CPU核数+1</p>
</li>
<li><p>I/O密集型运算：</p>
<p><code>线程数 = 核数 * 期望CPU利用率 * 总时间(CPU计算时间 + 等待时间) / CPU计算时间</code></p>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h3><p>Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种<strong>分治思想</strong>，适用于能够进行任务拆分的 <strong>CPU 密集型</strong><br><strong>运算</strong>。Fork/Join 在<strong>分治的基础上加入了多线程</strong>，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率（Fork/Join 默认会创建与 CPU核心数大小相同的线程池）。</p>
<p><strong>基本使用：</strong></p>
<ul>
<li><p>创建任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要返回值就继承RecursiveTask&lt;T&gt;,不会要就继承RecursiveAction</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要将任务分解为递归任务</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拆分为子任务</span></span><br><span class="line">        MyTask t1 = <span class="keyword">new</span> MyTask(n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// fork让线程去执行子任务</span></span><br><span class="line">        t1.fork();</span><br><span class="line">        <span class="comment">// join获取结果</span></span><br><span class="line">        <span class="keyword">return</span> n + t1.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>利用线程池来执行任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认线程数和CPU核心数一样</span></span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">// 执行任务,求和</span></span><br><span class="line">        System.out.println(pool.invoke(<span class="keyword">new</span> MyTask(<span class="number">100</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2></li>
</ul>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS全称是AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架，后面很多并发工具类都是基于AQS来实现的。</p>
<p><strong>特点：</strong></p>
<ul>
<li>用state属性来表示资源的状态(分独占模式和共享模式)，子类需要定义如何维护这个状态，控制如何获取锁和释放锁<ul>
<li>getState：获取state状态</li>
<li>setState：设置state状态</li>
<li>compareAndSetState：利用乐观锁机制设置state状态</li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
</ul>
</li>
<li>提供了基于FIFO的等待队列，类似于Monitor的 EntryList</li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于Monitor的WaitSet</li>
</ul>
<p><strong>使用：</strong></p>
<p>使用子类继承它并按需实现下列方法：</p>
<ul>
<li>tryAcquire：获取独占锁</li>
<li>tryRelease：释放独占锁</li>
<li>tryAcquireShared：获取共享锁</li>
<li>tryReleaseShared：获取独占锁</li>
<li>isHeldExclusively：释放持有锁</li>
</ul>
<p><strong>具体实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义锁（不可重入锁）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义同步器，用来给这个自定义锁进行所有的锁操作</span></span><br><span class="line">    <span class="comment">// 独占锁</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MySync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 利用cas来修改state</span></span><br><span class="line">            <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">// 设置owner持有线程为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 因为这个state加了volatile写屏障，所以要放后面</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否持有独占锁</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建条件变量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MySync sync = <span class="keyword">new</span> MySync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁（不成功进入等待队列）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加锁可打断</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试加锁（一次）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试加锁带超时时间</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 会释放锁并且唤醒等待线程</span></span><br><span class="line">        sync.release(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建条件变量</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>ReentrantReadWriteLock是一种读写锁，类似于数据库的共享锁/排他锁，当读操作远远高于写操作时，这时候使用 读写锁让<code>读-读</code> 可以并发，提高性能。</p>
<p><strong>特点：</strong></p>
<ul>
<li>读锁不支持条件变量，写锁支持条件变量。</li>
<li>重入时不支持升级：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待。</li>
<li>重入时降级支持：即持有写锁的情况下去获取读锁。</li>
</ul>
<p><strong>简单使用：</strong></p>
<p>编写一个数据容器类，内部分别使用读锁保护数据的 <strong>read()</strong> 方法，写锁保护数据的 <strong>write()</strong> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rw = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.ReadLock r = rw.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.WriteLock w = rw.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取读锁...&quot;</span>);</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读取&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;释放读锁...&quot;</span>);</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取写锁...&quot;</span>);</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;写入&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;释放写锁...&quot;</span>);</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>该类自JDK 8加入，是为了进一步<strong>优化读性能</strong>（因为每次读读并发的时候都需要利用CAS去修改状态），它的特点是在使用读锁、写锁时都必须配合<strong>【戳】</strong>使用。</p>
<p><strong>使用</strong></p>
<ul>
<li><p>加解读锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.readLock();</span><br><span class="line">lock.unlockRead(stamp) ;</span><br></pre></td></tr></table></figure></li>
<li><p>加解写锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.writeLock();</span><br><span class="line">lock.unlockwrite(stamp) ;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>乐观读锁</strong>，StampedLock支持tryoptimisticRead()方法（乐观读)，读取完毕后需要做一次戳校验如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.tryoptimisticRead();</span><br><span class="line"><span class="comment">//验戳</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123;</span><br><span class="line">	<span class="comment">// 锁升级 加读锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>StampedLock不支持条件变量</li>
<li>StampedLock不支持可重入</li>
</ul>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore是JDK提供的一种信号量的实现，用来限制能同时访问共享资源的线程上限；例如对有限共享资源的使用限制。</p>
<p>使用Semaphore限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机线程数量，并且仅是限制线程数，而不是限制资源数，除了资源就是由一个线程持有的例如数据库连接池。</p>
<p><strong>简单使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建 semaphore对象, 参数一限制的线程数，第二个参数是否公平性</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 2. 让10个线程同时运行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 获取信号量</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;running&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放信号量</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230511210254682.png" alt="image-20230511210254682"></p>
<h3 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h3><p><strong>用来进行线程同步协作，等待所有线程完成倒计时</strong>。其中构造参数用来初始化等待计数值，等待的线程就调用await()用来等待计数归零，其他线程调用countDown()用来让计数减一，计数为零时等待线程开始执行。类似于Join()但是比其更加高级，并且适用于线程池中的线程。</p>
<p><strong>简单使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建countDownLatch，设置等待计数</span></span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  begin..&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">// 让计数减一</span></span><br><span class="line">                latch.countDown();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  end..&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  begin..&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">// 让计数减一</span></span><br><span class="line">                latch.countDown();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  end..&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  watting...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待计数减为零</span></span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  watting end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Cyclicbarrier"><a href="#Cyclicbarrier" class="headerlink" title="Cyclicbarrier"></a>Cyclicbarrier</h3><p>循环栅栏，<strong>用来进行线程协作，等待线程满足某个计数</strong>。构造时设置<strong>『计数个数』</strong>，每个线程执行到某个需要“同步”的时刻调用await()方法进行等待，当等待的线程数满足<strong>『计数个数』</strong>时，继续执行。与CountdownLatch的区别在于<strong>这个工具类是可以重用的，可以重置为最开始的值。</strong></p>
<p><strong>简单使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicbarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 创建循环栅栏，参数二为当计数为0时执行的动作</span></span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>,() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task1 task2 end....&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 循环执行3次，CyclicBarrier计数会自动重置为初始值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            service.submit(() -&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;task1 begin....&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="comment">// 将计数减一，若不为0则阻塞</span></span><br><span class="line">                    barrier.await();</span><br><span class="line">                    System.out.println(<span class="string">&quot;task1 end...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            service.submit(() -&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;task2 begin....&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    <span class="comment">// 将计数减一，若不为0则阻塞</span></span><br><span class="line">                    barrier.await();</span><br><span class="line">                    System.out.println(<span class="string">&quot;task2 end...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程安全集合类"><a href="#线程安全集合类" class="headerlink" title="线程安全集合类"></a>线程安全集合类</h2><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230516194049286.png" alt="image-20230516194049286"></p>
<p>线程安全集合类可以分为三大类：</p>
<ul>
<li><p><strong>遗留的线程安全集合如：</strong></p>
<ul>
<li>Hashtable</li>
<li>Vector</li>
<li>Stack</li>
</ul>
<blockquote>
<p>都是用synchronized修饰的线程安全方法，所以性能不好，目前已经不推荐使用了。</p>
</blockquote>
</li>
<li><p><strong>使用 <code>Collections </code>装饰的线程安全集合：</strong></p>
<ul>
<li>Collections.synchronizedCollection</li>
<li>Collections.synchronizedList</li>
<li>Collections.synchronizedMap</li>
<li>Collections.synchronizedSet</li>
<li>Collections.synchronizedNavigableMap</li>
<li>Collections.synchronizedNavigableSet</li>
<li>Collections.synchronizedSortedMap</li>
<li>Collections.synchronizedSortedSet</li>
</ul>
<blockquote>
<p>利用<strong>装饰器模式的思想</strong>，通过Collections中的同步包装方法来包装成线程安全的集合，其实底层就是用synchronized修饰原来集合的方法。</p>
<p>注意单次操作时线程安全的，但是如果是<strong>组合操作很有可能会发生竞态条件</strong></p>
</blockquote>
</li>
<li><p><strong><code>java.util.concurrent.*</code>下的线程安全集合类：</strong></p>
<p>这些都是基于JUC实现的安全集合类，重点推荐使用的线程安全集合。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230605224311912.png" alt="image-20230605224311912"></p>
<ul>
<li><p><strong>CopyOnWrite类：</strong>利用写时复制来避免多线程带来的并发安全问题，适用于读多写特别少的场景，因为修改/写开销相对较重，并且会有短暂的数据不一致问题</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230605224521561.png" alt="image-20230605224521561" style="zoom:67%;" />

<p>CopyOnWrite类遍历操作一直都是基于原 array 执行，而写操作则是基于新 array 进行。</p>
</li>
<li><p><strong>Concurrent类：</strong>带Concurrent的集合类，内部很多操作使用 cas 优化，一般可以提供较高吞吐量，但是会有弱一致性问题。</p>
<ul>
<li>ConcurrentHashMap：无序线程安全的Map，不支持key和value为空。</li>
<li>ConcurrentSkipListMap：有序线程安全的Map，不支持key和value为空，底层使用了跳表，插入、删除、查询操作平均的时间复杂度是 O(log n)。</li>
<li>ConcurrentSkipListSet：有序线程安全的Set。</li>
</ul>
</li>
<li><p><strong>Queue：</strong>以下两个维度来分类。一个维度是<strong>阻塞与非阻塞</strong>，另一个维度是<strong>单端与双端</strong>。</p>
<ul>
<li><strong>单端阻塞队列</strong>：<ul>
<li>ArrayBlockingQueue：以数组为队列的实现的阻塞队列。</li>
<li>LinkedBlockingQueue：以链表为队列的实现的阻塞队列。</li>
<li>SynchronousQueue：同步队列，每一个插入操作必须等待一个相应的删除操作，用于同步的数据交换。</li>
<li>LinkedTransferQueue：融合 LinkedBlockingQueue 和 SynchronousQueue 的功能，性能比 LinkedBlockingQueue 更好。</li>
<li>PriorityBlockingQueue：支持按照优先级出队。</li>
<li>DelayQueue：可以支持延迟出队。</li>
</ul>
</li>
<li><strong>双端阻塞队列</strong>：<ul>
<li>LinkedBlockingDeque：双端阻塞，以双向链表为队列实现。</li>
</ul>
</li>
<li><strong>单端非阻塞队列</strong>：<ul>
<li>ConcurrentLinkedQueue</li>
</ul>
</li>
<li><strong>双端非阻塞队列</strong>：<ul>
<li>ConcurrentLinkedDeque</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意点：</strong></p>
<ul>
<li><p>Java 并发包里<strong>阻塞队列都用 Blocking 关键字标识，单端队列使用 Queue 标识，双端队列使用 Deque 标识</strong>。</p>
</li>
<li><p>类似阻塞队列之类的，大部分实现基于<strong>锁</strong>，并提供用来阻塞的方法。而非阻塞队列是基于<strong>CAS</strong>来是实现的无锁机制。</p>
</li>
<li><p>上面我们提到的这些 Queue 中，只有 ArrayBlockingQueue 和 LinkedBlockingQueue 是支持有界的，所以<strong>在使用其他无界队列时，一定要充分考虑是否存在导致 OOM 的隐患</strong>。</p>
</li>
<li><p>Java 容器有一个快速失败机制（Fail-Fast）：是指在多线程环境下，当多个线程同时对同一个容器进行修改操作时，如果<strong>检测到容器的结构发生了变化就会抛出ConcurrentModificationException 异常</strong>，从而快速失败。</p>
<p>在编写多线程程序时，仍然需要通过其他手段来保证线程安全，例如使用同步机制（如 synchronized）或并发容器（如 ConcurrentHashMap）等。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p>CompletableFuture是Java 在 1.8 版本提供的来支持<strong>异步编程</strong>的强大工具类。</p>
<p><strong>优点：</strong></p>
<ul>
<li>无需手工维护线程，没有繁琐的手工维护线程的工作，给任务分配线程的工作也不需要我们关注。</li>
<li>代码更简练并且专注于业务逻辑，几乎所有代码都是业务逻辑相关的。</li>
<li>语义更清晰。</li>
</ul>
<h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><p>CompletableFuture如果构造的时候不指定线程池，默认使用公共的ForkJoinPool 线程池，线程数是CPU核心数；但是这个线程池适用于CPU密集型计算，所以很多时候需要自己传入线程池，<strong>根据不同的业务类型创建不同的线程池，以避免互相干扰</strong>。</p>
<h4 id="创建CompletableFuture对象："><a href="#创建CompletableFuture对象：" class="headerlink" title="创建CompletableFuture对象："></a>创建CompletableFuture对象：</h4><ul>
<li><p>runAsync(Runnable runnable)/runAsync(Runnable runnable, Executor executor)：</p>
<p>这个方法是不需要有返回值的，可以直接传一个Runnable进去异步执行。</p>
</li>
<li><p>supplyAsync(Supplier<U> supplier)/supplyAsync(Supplier<U> supplier, Executor executor) ：</p>
<p>这个方法支持有返回值的异步任务。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用默认线程池</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span></span><br><span class="line"><span class="function"><span class="comment">//可以指定线程池  </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span>  </span></span><br></pre></td></tr></table></figure>
<h4 id="描述串行方法关系："><a href="#描述串行方法关系：" class="headerlink" title="描述串行方法关系："></a>描述串行方法关系：</h4><ul>
<li>thenApply()：这个方法既能接收参数也支持返回值。</li>
<li>thenAccept()：这个方法虽然支持参数，但却不支持回值。</li>
<li>thenRun()：方法里 action 的参数是 Runnable，所以 action 既不能接收参数也不支持返回值。</li>
<li>thenCompose()：这个系列的方法会新创建出一个子流程，最终结果和 thenApply 系列是相同的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加了Async表示异步去执行，不加则是同步</span></span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">thenApply</span><span class="params">(fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">thenApplyAsync</span><span class="params">(fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAccept</span><span class="params">(consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenRun</span><span class="params">(action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">thenCompose</span><span class="params">(fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">thenComposeAsync</span><span class="params">(fn)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="描述AND汇聚关系方法："><a href="#描述AND汇聚关系方法：" class="headerlink" title="描述AND汇聚关系方法："></a>描述AND汇聚关系方法：</h4><ul>
<li>thenCombine()：描述的就是一种and汇聚关系，该任务依赖于f1和f2</li>
<li>thenAcceptBoth()：不支持返回值，支持传参</li>
<li>runAfterBoth：不支持返回值，不支持传参</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加了Async表示异步去执行，不加则是同步</span></span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">thenCombine</span><span class="params">(other, fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">thenCombineAsync</span><span class="params">(other, fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBoth</span><span class="params">(other, consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(other, consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">runAfterBoth</span><span class="params">(other, action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">runAfterBothAsync</span><span class="params">(other, action)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="描述-OR-汇聚关系方法："><a href="#描述-OR-汇聚关系方法：" class="headerlink" title="描述 OR 汇聚关系方法："></a>描述 OR 汇聚关系方法：</h4><ul>
<li>applyToEither()：这个方法既能接收参数也支持返回值。</li>
<li>acceptEither()：这个方法虽然支持参数，但却不支持回值。</li>
<li>runAfterEither()：既不能接收参数也不支持返回值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加了Async表示异步去执行，不加则是同步</span></span><br><span class="line"><span class="function">CompletionStage <span class="title">applyToEither</span><span class="params">(other, fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage <span class="title">applyToEitherAsync</span><span class="params">(other, fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage <span class="title">acceptEither</span><span class="params">(other, consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage <span class="title">acceptEitherAsync</span><span class="params">(other, consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage <span class="title">runAfterEither</span><span class="params">(other, action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage <span class="title">runAfterEitherAsync</span><span class="params">(other, action)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="异常处理："><a href="#异常处理：" class="headerlink" title="异常处理："></a>异常处理：</h4><ul>
<li>exceptionally()：非常类似于 try{}catch{}中的 catch{}</li>
<li>whenComplete()：类似于 try{}finally{}中的 finally{}，无论是否发生异常都会执行，支持传参</li>
<li>handle()：类似于 try{}finally{}中的 finally{}，无论是否发生异常都会执行，但不支持传参</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CompletionStage <span class="title">exceptionally</span><span class="params">(fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">whenComplete</span><span class="params">(consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">whenCompleteAsync</span><span class="params">(consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">handle</span><span class="params">(fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">handleAsync</span><span class="params">(fn)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>同样使用烧水泡茶的例子：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230614113847499.png" alt="image-20230614113847499"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//任务1：洗水壶-&gt;烧开水</span></span><br><span class="line">CompletableFuture&lt;Void&gt; f1 = </span><br><span class="line">  CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;T1:洗水壶...&quot;</span>);</span><br><span class="line">  sleep(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">  System.out.println(<span class="string">&quot;T1:烧开水...&quot;</span>);</span><br><span class="line">  sleep(<span class="number">15</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//任务2：洗茶壶-&gt;洗茶杯-&gt;拿茶叶</span></span><br><span class="line">CompletableFuture&lt;String&gt; f2 = </span><br><span class="line">  CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;T2:洗茶壶...&quot;</span>);</span><br><span class="line">  sleep(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">  System.out.println(<span class="string">&quot;T2:洗茶杯...&quot;</span>);</span><br><span class="line">  sleep(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">  System.out.println(<span class="string">&quot;T2:拿茶叶...&quot;</span>);</span><br><span class="line">  sleep(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;龙井&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//任务3：任务1和任务2完成后执行：泡茶</span></span><br><span class="line">CompletableFuture&lt;String&gt; f3 = </span><br><span class="line">  f1.thenCombine(f2, (__, tf)-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;T1:拿到茶叶:&quot;</span> + tf);</span><br><span class="line">    System.out.println(<span class="string">&quot;T1:泡茶...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;上茶:&quot;</span> + tf;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">//等待任务3执行结果</span></span><br><span class="line">System.out.println(f3.join());</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> t, TimeUnit u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    u.sleep(t);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h2><p>CompletionService（完成服务）是Java中的一个接口，它可以用于<strong>管理异步任务</strong>的执行和<strong>获取结果</strong>。CompletionService接口是Executor框架的一部分，提供了一种方便的方式来<strong>处理一批异步任务</strong>，并<strong>按照它们完成的顺序获取结果</strong>。</p>
<p>CompletionService 的实现原理也是内部维护了一个阻塞队列，当任务执行结束就把任务的执行结果加入到阻塞队列中，不同的是 CompletionService 是把任务执行结果的 Future 对象加入到阻塞队列中。</p>
<h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><p><strong>构造函数：</strong></p>
<ul>
<li>ExecutorCompletionService(Executor executor)：需要传入一个线程池，默认使用无界的 LinkedBlockingQueue。</li>
<li>ExecutorCompletionService(Executor executor, BlockingQueue&lt;Future<V>&gt; completionQueue)：支持传入线程池和阻塞队列。</li>
</ul>
<p><strong>提交任务：</strong></p>
<ul>
<li><p>Future<T> submit(Runnable task)：传入需要执行的任务</p>
</li>
<li><p>Future<T> submit(Runnable task, T result)：传入需要执行的任务，以及返回的值</p>
</li>
</ul>
<p><strong>队列相关方法：</strong></p>
<ul>
<li>take()：从队列中获取并移除元素，队列为空则阻塞</li>
<li>poll()：从队列中获取并移除元素，队列为空则返回null</li>
<li>poll(long timeout, TimeUnit unit)：支持超时时间的获取方法</li>
</ul>
<h3 id="简单使用-1"><a href="#简单使用-1" class="headerlink" title="简单使用"></a>简单使用</h3><p>模拟电商询价问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line">ExecutorService executor = </span><br><span class="line">  Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 创建CompletionService</span></span><br><span class="line">CompletionService&lt;Integer&gt; cs = <span class="keyword">new</span> </span><br><span class="line">  ExecutorCompletionService&lt;&gt;(executor);</span><br><span class="line"><span class="comment">// 异步向电商S1询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS1());</span><br><span class="line"><span class="comment">// 异步向电商S2询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS2());</span><br><span class="line"><span class="comment">// 异步向电商S3询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS3());</span><br><span class="line"><span class="comment">// 将询价结果异步保存到数据库</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">  Integer r = cs.take().get();</span><br><span class="line">  executor.execute(()-&gt;save(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java进程线程</title>
    <url>/2023/10/05/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p><strong>并发（concurrent）：</strong>是同一时间应对（dealing with）多件事情的能力<br><strong>并行（parallel）：</strong>是同一时间动手做（doing）多件事情的能力</p>
<p><strong>同步：</strong>需要等待结果返回，才能继续运行</p>
<p><strong>异步：</strong>不需要等待结果返回，就能继续运行</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</li>
<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li>
<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐等）。</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li>一个进程之内可以分为一到多个线程。</li>
<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li>
<li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器北</li>
<li>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></li>
</ul>
<h3 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h3><ol>
<li><p>直接使用Thread</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure></li>
<li><p>使用 Runnable 配合 Thread</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread( runnable );</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
<p>把线程和任务分开了更灵活，更容易与线程池等高级 API 配合</p>
</li>
<li><p>FutureTask 配合 Thread</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="keyword">new</span> Thread(task, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class="line">Integer result = task.get();</span><br></pre></td></tr></table></figure>
<p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p>
</li>
<li><p>使用线程池获取线程</p>
</li>
</ol>
<h3 id="重点方法"><a href="#重点方法" class="headerlink" title="重点方法"></a>重点方法</h3><ul>
<li>Sleep(n)：让当前线程Running 进入 Timed Waiting 状态，并且不释放锁（阻塞）<ul>
<li>其它线程可以使用这个线程的interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出InterruptedException</li>
<li>睡眠结束后，会进入就绪状态等待cpu调度</li>
<li>相比于<code>Thread.sleep(n)</code>来说<code>TimeUnit.SECONDS.sleep(n)</code>可读性更好</li>
</ul>
</li>
<li>yield()：调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</li>
<li>join([long n])：等待线程运行结束,最多等待 n毫秒（该参数可选）<ul>
<li>例如：<code>t1.join()</code>主要是让本线程与t1同步，等待其执行完毕</li>
</ul>
</li>
<li>interrupt()：打断线程的阻塞状态并让其抛出InterruptedException，并且打断标记（在sleep、wait、join状态下记为false，正常运行状态的线程会从false变为true）<ul>
<li>isInterrupted()：判断是否被打断，不会清除打断标记</li>
<li>interrupted()：判断是否被打断，会清除打断标记</li>
</ul>
</li>
<li>setDaemon(true)：设置线程为守护线程，守护线程只要其它非守<br>护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</li>
<li>LockSuport.park()/LockSuport.unpark(线程对象)：暂停当前线程/恢复某个线程（unpark可以放在park之前同样能恢复，<strong>原理是</strong>因为底层每个线程关联了一个Parker对象，里面有一个_counter，调用unpark让其变为1，只要其为1,park之后线程任然会被恢复）</li>
</ul>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230331211517778.png" alt="image-20230331211517778"></p>
<ul>
<li><strong>初始状态：</strong>仅是在语言层面创建了线程对象，还未与操作系统线程关联</li>
<li><strong>可运行状态：</strong>（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li>
<li><strong>运行状态：</strong>指获取了 CPU 时间片运行中的状态，当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li>
<li><strong>阻塞状态：</strong>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入<strong>阻塞状态</strong>，等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至<strong>可运行状态</strong></li>
<li><strong>终止状态：</strong>表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li>
</ul>
<blockquote>
<p>Java中有6种状态：</p>
<ul>
<li><strong>NEW</strong> 线程刚被创建，但是还没有调用 start() 方法</li>
<li><strong>RUNNABLE</strong> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的<br>【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li>
<li><strong>BLOCKED ， WAITING ， TIMED_WAITING</strong> 都是 Java API 层面对【阻塞状态】的细分</li>
<li><strong>TERMINATED</strong> 当线程代码运行结束</li>
</ul>
<p>转换流程：</p>
<ul>
<li><p><code>NEW --&gt; RUNNABLE</code>：调用 t.start() 方法</p>
</li>
<li><p><code>RUNNABLE &lt;--&gt; WAITING</code>：</p>
<ul>
<li><p>wait()/notify()[notifyAll()、interrupt()]</p>
<ul>
<li>wait()：<code>RUNNABLE --&gt; WAITING</code></li>
<li>notify()[notifyAll()、interrupt()]：如果竞争锁成功则<code>WAITING --&gt; RUNNABLE</code>，否则<code>WAITING --&gt; BLOCKED</code></li>
</ul>
</li>
<li><p>join()：调用<strong>join()**时状态变为<code>RUNNABLE --&gt; WAITING</code>，当</strong>线程结束<strong>或者调用</strong>interrupt()**会从 <code>WAITING --&gt; RUNNABLE</code></p>
</li>
<li><p>LockSupport.park()/LockSupport.unpark(目标线程)：</p>
<ul>
<li>LockSupport.park()：<code>RUNNABLE --&gt; WAITING</code></li>
<li>LockSupport.unpark(目标线程)/interrupt()：<code>WAITING --&gt;RUNNABLE</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>RUNNABLE &lt;--&gt; TIMED_WAITING</code>：</p>
<ul>
<li>obj.wait(long n)</li>
<li>t.join(long n)</li>
<li>Thread.sleep(long n)</li>
<li>LockSupport.parkUntil(long millis) </li>
</ul>
<p>其中wait会释放锁，sleep和park不会</p>
</li>
<li><p><code>RUNNABLE &lt;--&gt; BLOCKED</code>：竞争锁失败<code>RUNNABLE --&gt; BLOCKED</code>，反之<code>BLOCKED --&gt; RUNNABLE</code></p>
</li>
<li><p><code>RUNNABLE &lt;--&gt; TERMINATED</code>：当前线程所有代码运行完毕或者异常中断，进入TERMINATED</p>
</li>
</ul>
</blockquote>
<h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><ul>
<li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li>
<li>进程拥有共享的资源，如内存空间等，供其内部的线程共享</li>
<li>进程间通信较为复杂<ul>
<li>同一台计算机的进程通信称为 IPC（Inter-process communication）</li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li>
</ul>
</li>
<li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li>
</ul>
<h2 id="查看进程线程的方法"><a href="#查看进程线程的方法" class="headerlink" title="查看进程线程的方法"></a>查看进程线程的方法</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><ul>
<li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li>
<li><code>tasklist | findstr (进程名，例如java)</code> 查看进程  或者 <code>netstat -aon|findstr &quot;8080&quot;</code> 查看端口</li>
<li><code>taskkill /pid 进程号 -t -f</code>杀死进程</li>
</ul>
<h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><ul>
<li>ps -fe 查看所有进程</li>
<li>ps -fT -p <PID> 查看某个进程（PID）的所有线程</li>
<li>kill 杀死进程</li>
<li>top 按大写 H 切换是否显示线程</li>
<li>top -H -p <PID> 查看某个进程（PID）的所有线程</li>
</ul>
<blockquote>
<p>专门查看Java进程：</p>
<ul>
<li>jps 命令查看所有 Java 进程</li>
<li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</li>
<li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li>
</ul>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用cpu ，不至于一个线程总占用 cpu，别的线程没法干活。</li>
<li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的：<ul>
<li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分。</li>
<li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义。</li>
</ul>
</li>
<li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230329210336024.png" alt="image-20230329210336024"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java进程线程</tag>
      </tags>
  </entry>
  <entry>
    <title>共享问题</title>
    <url>/2023/10/09/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="共享问题"><a href="#共享问题" class="headerlink" title="共享问题"></a>共享问题</h1><h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><p>一个程序运行多个线程本身是没有问题的，问题出在多个线程访问共享资源</p>
<ul>
<li>多个线程读共享资源其实也没有问题</li>
<li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li>
</ul>
<p><strong>临界区：</strong></p>
<p>一段代码块内如果存在对<strong>共享资源</strong>的多线程读写操作，称这段代码块为<strong>临界区</strong></p>
<p><strong>竞态条件：</strong></p>
<p>多个线程在临界区内执行，由于代码的<strong>执行序列不同</strong>而导致结果无法预测即<strong>程序的执行结果依赖线程执行的顺序</strong>，称之为发生了竞态条件</p>
<h2 id="线程安全分析"><a href="#线程安全分析" class="headerlink" title="线程安全分析"></a>线程安全分析</h2><h3 id="Java变量的线程安全问题"><a href="#Java变量的线程安全问题" class="headerlink" title="Java变量的线程安全问题"></a>Java变量的线程安全问题</h3><ul>
<li><strong>成员变量和静态变量是否线程安全？</strong><ul>
<li>如果它们没有共享，则线程安全</li>
<li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
</li>
<li><strong>局部变量是否线程安全？</strong><ul>
<li>局部变量是线程安全的</li>
<li>但局部变量引用的对象则未必<ul>
<li>如果该对象没有逃离方法的作用访问，它是线程安全的</li>
<li>如果该对象逃离方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="常见的线程安全类"><a href="#常见的线程安全类" class="headerlink" title="常见的线程安全类"></a>常见的线程安全类</h3><ul>
<li>String</li>
<li>Integer</li>
<li>StringBuffer</li>
<li>Random</li>
<li>Vector</li>
<li>Hashtable</li>
<li>java.util.concurrent 包下的类</li>
</ul>
<p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。它们的每个方法是原子的，<strong>但注意它们多个方法的组合不是原子的</strong>。（其中String和Integer由于不可变性保证的线程安全）</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p>
<ul>
<li><strong>阻塞式的解决方案：</strong>synchronized，Lock</li>
<li><strong>非阻塞式的解决方案：</strong>原子变量</li>
<li><strong>线程封闭：</strong>使用局部变量，仅在单线程内访问数据</li>
</ul>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>Synchronized即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p>
<p><strong>使用：</strong></p>
<ul>
<li><p>同步代码块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) <span class="comment">// 线程1获   得锁，则线程2(blocked)</span></span><br><span class="line">&#123;</span><br><span class="line">	临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>同步方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123; <span class="comment">// 默认锁的是this对象，static方法锁的是类对象</span></span><br><span class="line">    临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4></li>
</ul>
<p>Monitor被翻译为<strong>监视器</strong>或<strong>管程</strong>，每个Java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向Monitor对象的指针。</p>
<p>结构图如下：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230404203853400.png" alt="image-20230404203853400"></p>
<ul>
<li>刚开始 Monitor 中 Owner 为 null</li>
<li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，<strong>Monitor中只能有一</strong><br><strong>个 Owner</strong></li>
<li>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入<br>EntryList BLOCKED</li>
<li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的<br>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程</li>
</ul>
<blockquote>
<p><strong>管程：</strong></p>
<p>信号量机制存在的问题：编写程序困难、易出错。管程就是一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松。类似于java的synchronized。</p>
<p>管程的基本特征：</p>
<ol>
<li><p>局部于管程的数据只能被局部于管程的过程所访问;</p>
</li>
<li><p>一个进程只有通过调用管程内的过程才能进入管程访问共享数据;</p>
</li>
<li><p>每次仅允许一个进程在管程内执行某个内部过程。</p>
</li>
</ol>
</blockquote>
<h4 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h4><p>用于防止条件不满足的线程一直占用锁的一种方式。（前提是必须拥有锁）</p>
<p><strong>工作原理：</strong></p>
<ul>
<li>Owner线程发现条件不满足，调用wait方法，即可进入WaitSet变为WAITING状态</li>
<li>BLOCKED和WAITING的线程都处于阻塞状态，不占用CPU时间片</li>
<li>BLOCKED线程会在Owner线程释放锁时唤醒</li>
<li>WAITING线程会在Owner线程调用notify或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList重新竞争</li>
</ul>
<p><strong>相关API：</strong></p>
<ul>
<li><code>obj.wait() </code>/<code>obj.wait(n)</code>：让进入 object 监视器的线程到 waitSet 等待</li>
<li><code>obj.notify() </code>：在 object 上正在 waitSet 等待的线程中挑一个唤醒</li>
<li><code>obj.notifyAll() </code>：让 object 上正在 waitSet 等待的线程全部唤醒</li>
</ul>
<blockquote>
<p>尽量多使用notifyAll()而不是notify()，虽然只需要一个线程去获取锁，但是notify()会导致某些线程永远不会被叫醒。</p>
<p>那什么时候可以使用 notify() 呢？需要满足以下三个条件：</p>
<ol>
<li>所有等待线程拥有相同的等待条件；</li>
<li>所有等待线程被唤醒后，执行相同的操作；</li>
<li>只需要唤醒一个线程。</li>
</ol>
</blockquote>
<p><strong>具体使用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不成立)&#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一个线程</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    lock.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>与sleep的区别：</p>
<ul>
<li>sleep是 Thread方法，而wait是 Object的方法</li>
<li>sleep不需要强制和synchronized配合使用，但wait需要和synchronized一起用</li>
<li>sleep在睡眠的同时，不会释放对象锁的，但wait在等待的时候会释放对象锁。</li>
</ul>
</blockquote>
<h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><p>对于锁的演化过程，会经历如下阶段</p>
<ol>
<li>无锁</li>
<li>偏向锁</li>
<li>轻量级锁</li>
<li>重量级锁</li>
</ol>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>轻量级锁的使用场景:如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争)，那么可以使用轻量级锁来优化。</p>
<p>同样使用Synchronized关键字，会首先使用轻量级锁加锁，如果加锁失败了才会使用重量级锁加锁。</p>
<p><strong>加锁过程：</strong></p>
<ul>
<li><p>创建锁记录(Lock Record)）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230404210055463.png" alt="image-20230404210055463"></p>
</li>
<li><p>让锁记录中Object reference指向锁对象，并尝试用CAS替换Object的Mark Word，将Mark Word的值存入锁记录</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230404210124560.png" alt="image-20230404210124560"></p>
</li>
<li><p>如果CAS替换成功，对象头中存储了锁记录地址和状态 00，表示由该线程给对象加锁</p>
<ul>
<li><p>如果CAS失败了，有两种情况</p>
<ul>
<li><p>如果是其它线程已经持有了该Object的轻量级锁，这时表明有竞争，进入锁膨胀过程</p>
</li>
<li><p>如果是自己执行了synchronized锁重入，那么再添加一条Lock Record作为重入的计数</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230404210148821.png" alt="image-20230404210148821"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>当退出 synchronized代码块（解锁时）如果有取值为null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230404210302051.png" alt="image-20230404210302051"></p>
</li>
<li><p>当退出 synchronized 代码块（解锁时）锁记录的值不为null，这时使用CAS将Mark Word的值恢复给对象头</p>
<ul>
<li>成功，则解锁成功</li>
<li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>重入锁：</strong></p>
<p>可重入锁是进程可以多次声明锁而不会自行阻塞的锁。 </p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">     <span class="comment">// 同步块1</span></span><br><span class="line">     t2();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t2</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">     <span class="comment">// 同步块2</span></span><br><span class="line">     t3();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t3</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">     <span class="comment">// 同步块3</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>锁膨胀：</strong></p>
</blockquote>
<p>如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁(有竞争)，这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p>
<ul>
<li><p>当Thread-1进行轻量级加锁时，Thread-0已经对该对象加了轻量级锁</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230404210654882.png" alt="image-20230404210654882"></p>
</li>
<li><p>这时Thread-1加轻量级锁失败，进入锁膨胀流程</p>
<ul>
<li>即为object对象申请Monitor锁，让Object指向重量级锁地址</li>
<li>然后自己进入Monitor的EntryList BLOCKED</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230404210831628.png" alt="image-20230404210831628"></p>
</li>
<li><p>当Thread-0退出同步块解锁时，使用CAS将Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照Monitor地址找到Monitor对象，设置Owner为null，唤醒EntryList中 BLOCKED线程</p>
</li>
</ul>
<h5 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h5><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功(即这时候持锁线程已经退出了同步块，释放了锁)，这时当前线程就可以避免阻塞。</p>
<ul>
<li>自旋的优势在于避免了线程上下文切换的消耗，但是<strong>自旋优化适用于多核cpu的环境下</strong>。</li>
</ul>
<blockquote>
<p>在Java 6之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次;反之，就少自旋甚至不自旋，总之，比较智能。</p>
</blockquote>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行CAS操作。</p>
<p>Java 6中引入了偏向锁来做进一步优化：</p>
<ul>
<li>只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS。以后只要不发生竞争，这个对象就归该线程所有，如果另一个线程也尝试获取该偏向锁，这种情况会对偏向锁进行撤销变为轻量锁（如果使用wait/notify同样会撤销为重量锁）。</li>
<li>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程T1的对象仍有机会重新偏向T2（偏向次数超过阈值），重偏向会重置对象的Thread ID；如果撤销偏向锁的次数达到更高的阈值，则会直接将所有偏向锁撤销为轻量锁整个类的所有对象都不再偏向。</li>
</ul>
<blockquote>
<p>使用-XX:+/-UseBiasedLocking 启用/禁用偏向锁</p>
</blockquote>
<h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p><strong>锁消除</strong>即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是<strong>线程安全</strong>的，不必要加锁。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(o)&#123;</span><br><span class="line">        <span class="comment">//同步代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>JVM若发现前后相邻的synchronized块使用的是同一个锁对象，那么它就会把这几个synchronized块给合并为一个较大的同步块，这样做的好处在于线程在执行这些代码时，就无需频繁申请与释放锁了，从而达到申请与释放锁一次，就可以执行完全部的同步代码块，从而提升了性能。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">    	system.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">    	System.out.println( <span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock是Java的一个锁类，实现了Lock接口。与synchronized不同的是ReentrantLock是基于api层面实现的，依赖于 Unsafe类的线程挂起和恢复功能。</p>
<p>相对于 synchronized 它具备如下特点（与其一样可以支持可重入）</p>
<ul>
<li><p>可中断：</p>
<p>使用<code>lock.lockInterruptibly();</code>方法表示可以被其他线程调用<code>interrupt();</code>所打断；如果直接使用<code>lock()</code>则不可打断。</p>
</li>
<li><p>可以设置超时时间：</p>
<p>使用<code>lock.tryLock([n])</code>方法去尝试获取锁，如果带了参数则是尝试的超时时间。</p>
</li>
<li><p>可以设置为公平锁：</p>
<p>默认不设置公平性，如果要设置在构造函数中传入true；但是公平锁一般没有必要，会降低并发度。</p>
</li>
<li><p>支持多个条件变量：</p>
<p>synchronized中也有条件变量，就是我们讲原理时那个waitSet休息室，当条件不满足时进入waitSet等待，ReentrantLock的条件变量比synchronized 强大之处在于，它是支持多个条件变量的。</p>
<p>使用要点：</p>
<ul>
<li>await 前需要获得锁</li>
<li>await 执行后，会释放锁，进入 conditionObject 等待</li>
<li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li>
<li>竞争 lock 锁成功后，从 await 后继续执行</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 条件变量 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 条件变量</span></span><br><span class="line">    <span class="keyword">static</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">static</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> f1 = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> f2 = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!f1) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 不满足条件一，进入等待</span></span><br><span class="line">                        condition1.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;满足条件1&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!f2) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        condition2.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;满足条件2&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">        getF1();</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">        getF2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getF2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 满足条件2唤醒他</span></span><br><span class="line">            f2 = <span class="keyword">true</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getF1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 满足条件1唤醒他</span></span><br><span class="line">            f1 = <span class="keyword">true</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁<br>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p>
</blockquote>
</li>
</ul>
<p><strong>基本语法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">	reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS 全称是 compare and swap，是一种用于在多线程环境下实现同步功能的机制、是基于乐观锁的思想。</p>
<p>它<strong>必须是原子操作</strong>（CAS 的底层依赖Unsafe类来实现的，Unsafe中也基本上是本地方法依赖的是 <code>lock cmpxchg </code>指令（<strong>这个指令由硬件保证原子性，所谓不可再分的CPU同步原语，并且就在用户态执行不会切换到内核态</strong>），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。）。</p>
<p><strong>与加锁相比，不会发生上下文切换，进入阻塞即无锁并发、无阻塞并发。但是同样有可能会因为没有分配到时间片而发生上下文切换。</strong>（所以适用于线程数少，多核CPU的场景下）</p>
<p><strong>CAS 的实现逻辑：</strong></p>
<p>是将主内存位置处的数值与预期数值想比较，若相等，则将主内存的值替换为新值。若不相等，则不做任何操作。</p>
<p>正是由于CAS需要获取主内存中最新的值，所以必须借助volatile能读取到共享变量的最新值来实现【比较并交换】的效果。</p>
<blockquote>
<p>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</p>
</blockquote>
<p><strong>具体实现：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230607160532386.png"></p>
<ul>
<li><p>原子整数</p>
<ul>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicLong</li>
</ul>
</li>
<li><p>原子引用</p>
<ul>
<li>AtomicReference</li>
<li>AtomicMarkableReference（比AtomicReference多了修改标记位，能感知是否修改）</li>
<li>AtomicStampedReference（比AtomicReference多了一个版本号，能感知追踪其他线程的修改即使修改的值不变，解决ABA问题）</li>
</ul>
</li>
<li><p>原子数组</p>
<ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
</li>
<li><p>原子更新器：</p>
<p>利用原子更新器，可以针对对象的某个域(Field)进行原子操作，<strong>只能配合volatile修饰的字段使用</strong>，否则会出现异常</p>
<ul>
<li>AtomicReferenceFieldUpdater </li>
<li>AtomicIntegerFieldUpdater</li>
<li>AtomicLongFieldUpdater</li>
</ul>
</li>
<li><p>原子累加器：</p>
<p>JDK1.8新增的累加器，性能比原子整数更好。性能提升的原因很简单，<strong>就是在有竞争时，设置多个累加单元</strong>，Therad-0累加Cell[0]，而 Thread-1累加Cell[1]；最后将结果汇总，这样它们在累加时操作的不同的Cell变量，因此减少了CAS重试失败，从而提高性能。但是<strong>不支持 compareAndSet() 方法</strong>。</p>
<ul>
<li>LongAdder</li>
<li>LongAccumulator</li>
<li>DoubleAdder</li>
<li>DoubleAccumulator</li>
</ul>
</li>
</ul>
<p><strong>例子：</strong></p>
<ul>
<li><p>一个取钱的函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger balance;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要不断尝试，直到成功为止</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 比如拿到了旧值 1000</span></span><br><span class="line">            <span class="keyword">int</span> prev = balance.get();</span><br><span class="line">            <span class="comment">// 在这个基础上 1000-10 = 990</span></span><br><span class="line">            <span class="keyword">int</span> next = prev - amount;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            compareAndSet 正是做这个检查，在 set 前先比较 prev 与当前值</span></span><br><span class="line"><span class="comment">            - 不一致了，next 作废，返回 false 表示失败</span></span><br><span class="line"><span class="comment">            - 一致，以 next 设置为新值，返回 true 表示成功</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>利用CAS实现自旋锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread currentThread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span>(!owner.compareAndSet(<span class="keyword">null</span>, currentThread))&#123;  </span><br><span class="line">            <span class="comment">// owner == null ，则compareAndSet返回true，否则为false。</span></span><br><span class="line">            <span class="comment">//拿不到owner的线程，不断的在死循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        owner.set(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>资源共享问题</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程设计模式</title>
    <url>/2023/10/13/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="同步模式—保护性暂停"><a href="#同步模式—保护性暂停" class="headerlink" title="同步模式—保护性暂停"></a>同步模式—保护性暂停</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>保护性暂停即Guarded Suspension，用在一个线程等待另一个线程的执行结果，因为要等待另一方的结果，因此归类到同步模式。</p>
<p><strong>要点：</strong></p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个GuardedObject，JDK中，join的实现、Future的实现，采用的就是此模式。</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者)</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230406202511942.png" alt="image-20230406202511942"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>单个线程相互等待：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GuardedObject guardedObject = <span class="keyword">new</span> GuardedObject();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 等待结果</span></span><br><span class="line">            Object o = guardedObject.get();</span><br><span class="line">            System.out.println(o.toString());</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 传输结果</span></span><br><span class="line">            guardedObject.complete(<span class="string">&quot;产生的结果&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuardedObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结果</span></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="comment">// 获取结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="comment">// 没有结果,就需要等待</span></span><br><span class="line">            <span class="keyword">while</span> (response == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 限制时间获取结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> passedTime = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 没有结果,就需要等待</span></span><br><span class="line">            <span class="keyword">while</span> (response == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">long</span> waitTime = timeout - passedTime;</span><br><span class="line">                <span class="comment">// 等待时间超时则退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(waitTime &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait(waitTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 等待时间</span></span><br><span class="line">                passedTime = System.currentTimeMillis() - begin;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 产生结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Object response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.response = response;</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个线程相互等待</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boxes</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer,GuardedObject&gt; boxes = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 产生唯一id</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">generateId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title">createGuardedObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        GuardedObject guardedObject = <span class="keyword">new</span> GuardedObject(generateId());</span><br><span class="line">        boxes.put(guardedObject.getId(),guardedObject);</span><br><span class="line">        <span class="keyword">return</span> guardedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title">getIds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.keySet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title">getGuarObject</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuardedObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 唯一表示</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">// 结果</span></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GuardedObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GuardedObject</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="comment">// 没有结果,就需要等待</span></span><br><span class="line">            <span class="keyword">while</span> (response == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> passedTime = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 没有结果,就需要等待</span></span><br><span class="line">            <span class="keyword">while</span> (response == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">long</span> waitTime = timeout - passedTime;</span><br><span class="line">                <span class="comment">// 等待时间超时则退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(waitTime &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait(waitTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 等待时间</span></span><br><span class="line">                passedTime = System.currentTimeMillis() - begin;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 产生结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Object response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.response = response;</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="同步模式—顺序控制"><a href="#同步模式—顺序控制" class="headerlink" title="同步模式—顺序控制"></a>同步模式—顺序控制</h2><p>有时候需要控制线程的执行顺序，例如下面的例子要保证t2线程在t1线程前执行</p>
<h3 id="wait-notify方式"><a href="#wait-notify方式" class="headerlink" title="wait/notify方式"></a>wait/notify方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 顺序控制 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 表示t2是否允许过</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                System.out.println(<span class="number">2</span>);</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种方式与ReentrantLock的await和signal一致</p>
</blockquote>
<h3 id="park-unpark方式"><a href="#park-unpark方式" class="headerlink" title="park/unpark方式"></a>park/unpark方式</h3><p>同样例子：要让t2线程在t1线程前执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 顺序控制 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="number">2</span>);</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异步模式—生产者-消费者"><a href="#异步模式—生产者-消费者" class="headerlink" title="异步模式—生产者/消费者"></a>异步模式—生产者/消费者</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>与前面的保护性暂停中的GuardObject 不同，不需要产生结果和消费结果的线程一一对应，并且是异步的不会立刻对消息进行处理消费；JDK中各种阻塞队列，采用的就是这种模式。</p>
<p><strong>要点：</strong></p>
<ul>
<li>消费队列可以用来平衡生产和消费的线程资源</li>
<li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li>
<li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230406214542777.png" alt="image-20230406214542777"></p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xfz</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = <span class="keyword">new</span> MessageQueue(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                queue.put(<span class="keyword">new</span> Message(id,<span class="string">&quot;值&quot;</span>+id ));</span><br><span class="line">            &#125;,<span class="string">&quot;生成者&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(queue.take());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列类，java线程之间通信</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列集合</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capcity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageQueue</span><span class="params">(<span class="keyword">int</span> capcity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capcity = capcity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">take</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 检测队列是否为空</span></span><br><span class="line">        <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">            <span class="keyword">while</span>(list.isEmpty())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从头部获取消息</span></span><br><span class="line">            Message message = list.removeFirst();</span><br><span class="line">            list.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存入消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">            <span class="keyword">while</span>(list.size() == capcity)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;队列已满！！&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从尾部加入消息</span></span><br><span class="line">            list.addLast(message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">int</span> id, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Message&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="交替执行"><a href="#交替执行" class="headerlink" title="交替执行"></a>交替执行</h2><p>该模式主要是用于让多线程按照一定的顺序交替执行，案例：让a，b，c线程按照顺序交替执行</p>
<h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h3><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 交替输出01 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaitNotify waitNotify = <span class="keyword">new</span> WaitNotify(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;aaaa&quot;</span>,<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;bbbb&quot;</span>,<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;cccc&quot;</span>,<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;c&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span></span>&#123;</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str,<span class="keyword">int</span> waitFlag,<span class="keyword">int</span> nextFlag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span> (flag != waitFlag)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                flag = nextFlag;</span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaitNotify</span><span class="params">(<span class="keyword">int</span> flag, <span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230412195258676.png" alt="image-20230412195258676"></p>
<h3 id="await-signal"><a href="#await-signal" class="headerlink" title="await/signal"></a>await/signal</h3><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 交替输出02 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AwaitSignal awaitSignal = <span class="keyword">new</span> AwaitSignal(<span class="number">5</span>);</span><br><span class="line">        Condition conditionA = awaitSignal.newCondition();</span><br><span class="line">        Condition conditionB = awaitSignal.newCondition();</span><br><span class="line">        Condition conditionC = awaitSignal.newCondition();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;aaaa&quot;</span>,conditionA, conditionB);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;bbbb&quot;</span>,conditionB, conditionC);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;cccc&quot;</span>,conditionC, conditionA);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        awaitSignal.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;开始...&quot;</span>);</span><br><span class="line">            conditionA.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitSignal.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwaitSignal</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AwaitSignal</span><span class="params">(<span class="keyword">int</span> loopNumber)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str,Condition current,Condition next)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                current.await();</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                next.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230412200705388.png" alt="image-20230412200705388"></p>
<h3 id="park-unpark"><a href="#park-unpark" class="headerlink" title="park/unpark"></a>park/unpark</h3><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 交替输出03 </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Thread a;</span><br><span class="line">    <span class="keyword">static</span> Thread b;</span><br><span class="line">    <span class="keyword">static</span> Thread c;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ParkUnpark parkUnpark = <span class="keyword">new</span> ParkUnpark(<span class="number">5</span>);</span><br><span class="line">        a = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;aaaa&quot;</span>,b);</span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        b = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;bbbb&quot;</span>,c);</span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        c = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;cccc&quot;</span>,a);</span><br><span class="line">        &#125;,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">        <span class="comment">// 先唤醒a</span></span><br><span class="line">        LockSupport.unpark(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParkUnpark</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, Thread next)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.print(str);</span><br><span class="line">            LockSupport.unpark(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParkUnpark</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230412201218785.png" alt="image-20230412201218785"></p>
<h2 id="两阶段终止模式"><a href="#两阶段终止模式" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h2><p>两阶段终止模式是指能够优雅的结束线程，能够进行完善的善后工作。</p>
<p><span style="color:red">终止线程的错误想法：</span></p>
<ul>
<li>使用stop()，stop方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁，所以该方法已经被废弃！同样的还有suspend()、resume()</li>
<li>使用System.exit(0)：这样会让整个程序都停止</li>
</ul>
<h3 id="打断标记法实现"><a href="#打断标记法实现" class="headerlink" title="打断标记法实现"></a>打断标记法实现</h3><p>利用调用interrupt()方法会让线程抛出InterruptedException异常，这样可以捕获标记打断标记，被标记后会进行善后工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Termination</span></span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Thread monitor;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 启动监控线程</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">     monitor = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">             <span class="comment">// 判断是否被打断</span></span><br><span class="line">             Thread current = Thread.currentThread();</span><br><span class="line">             <span class="keyword">if</span>(current.isInterrupted())&#123;</span><br><span class="line">                 System.out.println(<span class="string">&quot;线程结束中....&quot;</span>+current.isInterrupted());</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                 System.out.println(<span class="string">&quot;执行监控..&quot;</span>);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">                 <span class="comment">// 如果在sleep中被打断会把标记设置为false，这里重置为true</span></span><br><span class="line">                 current.interrupt();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     monitor.start();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 停止监控线程</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">     monitor.interrupt();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用volatile优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Termination</span></span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Thread monitor;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 启动监控线程</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">     monitor = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">             <span class="comment">// 判断是否被打断</span></span><br><span class="line">             <span class="keyword">if</span>(stop)&#123;</span><br><span class="line">                 System.out.println(<span class="string">&quot;线程结束中....&quot;</span>);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                 System.out.println(<span class="string">&quot;执行监控..&quot;</span>);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               </span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     monitor.start();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 停止监控线程</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">     stop = <span class="keyword">true</span>;</span><br><span class="line">     <span class="comment">// 打断睡眠</span></span><br><span class="line">     monitor.interrupt();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="避免共享"><a href="#避免共享" class="headerlink" title="避免共享"></a>避免共享</h2><p>如果避免了共享，同样可以解决多线程并发问题，已经知道通过局部变量可以做到避免共享，还可以使用Java 语言提供的<strong>线程本地存储（ThreadLocal）</strong></p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal 的目标是让不同的线程有不同的变量 V，所以其内部维护了一个Map，叫做 ThreadLocalMap，不过持有 ThreadLocalMap 的不是 ThreadLocal，而是 Thread。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230618104558134.png" alt="image-20230618104558134"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="comment">//内部持有ThreadLocalMap</span></span><br><span class="line">  ThreadLocal.ThreadLocalMap </span><br><span class="line">    threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先获取线程持有的</span></span><br><span class="line">    <span class="comment">//ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map =</span><br><span class="line">      Thread.currentThread()</span><br><span class="line">        .threadLocals;</span><br><span class="line">    <span class="comment">//在ThreadLocalMap中</span></span><br><span class="line">    <span class="comment">//查找变量</span></span><br><span class="line">    Entry e = </span><br><span class="line">      map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> e.value;  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span></span>&#123;</span><br><span class="line">    <span class="comment">//内部是数组而不是Map</span></span><br><span class="line">    Entry[] table;</span><br><span class="line">    <span class="comment">//根据ThreadLocal查找Entry</span></span><br><span class="line">    <span class="function">Entry <span class="title">getEntry</span><span class="params">(ThreadLocal key)</span></span>&#123;</span><br><span class="line">      <span class="comment">//省略查找逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Entry定义</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">    <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt;</span>&#123;</span><br><span class="line">      Object value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>将Map放在每个Thread里面的好处：</strong></p>
<ul>
<li><p>ThreadLocal 仅仅是一个代理工具类，内部并不持有任何与线程相关的数据，所有和线程相关的数据都存储在 Thread 里面，这样的设计容易理解。</p>
</li>
<li><p>这样不容易造成内存泄漏，防止Map 中的 Thread 对象就永远不会被回收。（但是如果是线程池使用了就有可能会导致内存泄漏；原因就出在线程池中线程的存活时间太长，往往都是和程序同生共死的，这就意味着 Thread 持有的 ThreadLocalMap 一直都不会被回收）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService es;</span><br><span class="line">ThreadLocal tl;</span><br><span class="line">es.execute(()-&gt;&#123;</span><br><span class="line">  <span class="comment">//ThreadLocal增加变量</span></span><br><span class="line">  tl.set(obj);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 省略业务逻辑代码</span></span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//手动清理ThreadLocal </span></span><br><span class="line">    tl.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h2 id="Balking（犹豫）模式"><a href="#Balking（犹豫）模式" class="headerlink" title="Balking（犹豫）模式"></a>Balking（犹豫）模式</h2><p>Balking (犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回。例如<strong>线程安全的单例模式</strong>中的双重检查就是利用的这个模式。</p>
<p>例如：尽管start了多次，始终只有一个线程在执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 犹豫模式 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Termination termination = <span class="keyword">new</span> Termination();</span><br><span class="line">        termination.start();</span><br><span class="line">        termination.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Termination</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否正在执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> starting = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="comment">// 这里需要加锁保证验证的原子性</span></span><br><span class="line">            <span class="keyword">if</span>(starting)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            starting = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        monitor = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">// 判断是否被打断</span></span><br><span class="line">                Thread current = Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span>(stop)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程结束中....&quot;</span>);</span><br><span class="line">                    starting = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行监控..&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 打断睡眠</span></span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>多线程设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>线程活跃性问题</title>
    <url>/2023/10/07/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B4%BB%E8%B7%83%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="线程活跃性问题"><a href="#线程活跃性问题" class="headerlink" title="线程活跃性问题"></a>线程活跃性问题</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>理想情况下，我们希望线程能一直处于运行（Runnable）状态，但是会由于一些因素。这些由于资源稀缺或者程序自身问题导致线程无法一直处于 Runnable 状态运行下去，又或者因为线程处于 Runnable 状态但是其要执行的任务一直无法进展的现象就被称为<strong>线程活跃性问题</strong>或<strong>活性故障</strong>。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p><strong>例如：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object lockA = <span class="keyword">new</span> Object();</span><br><span class="line">    Object lockB = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取了A锁&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;尝试获取B锁...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取了B锁&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;尝试获取A锁...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>死锁的四个条件：</p>
<ul>
<li>互斥：共享资源 X 和 Y 只能被一个线程占用；</li>
<li>占有且等待：线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；</li>
<li>不可抢占：其他线程不能强行抢占线程 T1 占有的资源；</li>
<li>循环等待：线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。</li>
</ul>
<p>破坏死锁：即破坏死锁的条件之一</p>
<ul>
<li><p>互斥：没办法去破坏，因为这是程序必须要保证的。</p>
</li>
<li><p>对于“<strong>占用且等待</strong>”这个条件：我们可以一次性申请所有的资源，这样就不存在等待了。</p>
</li>
<li><p>对于“<strong>不可抢占</strong>”这个条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</p>
</li>
<li><p>对于“<strong>循环等待</strong>”这个条件：可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</p>
</li>
</ul>
<blockquote>
<p>检测死锁可以使用jconsole工具，或者使用jps定位进程id，再用jstack定位死锁。</p>
<ul>
<li>jps查看进程</li>
<li>利用jstack id定位死锁</li>
</ul>
</blockquote>
<h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束。(可以添加随机睡眠时间来解决)</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLiveLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sleep(<span class="number">100</span>);</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                sleep(<span class="number">200</span>);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h2><p>饥饿指的是一个线程由于某种原因<strong>始终得不到CPU调度执行</strong>，也不能够结束。</p>
<p><strong>原因：</strong></p>
<ul>
<li>原因之一是不同线程或线程组之间的线程优先级不正确。</li>
<li>另一个可能的原因可能是使用非终止循环（无限循环）或在特定资源上等待过多时间，同时保留了其他线程所需的关键锁。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li><strong>通常建议尽量避免修改线程优先级</strong>，因为这是导致线程饥饿的主要原因。一旦开始使用线程优先级调整应用程序，它就会与特定平台紧密耦合，并且还会带来线程匮乏的风险。</li>
<li>利用公平锁公平地分配资源。</li>
<li>保证资源充足。</li>
<li>避免持有锁的线程长时间执行。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>线程活跃性问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java文件操作工具类</title>
    <url>/2023/05/31/Java/NIO/Java%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="Java文件操作工具类"><a href="#Java文件操作工具类" class="headerlink" title="Java文件操作工具类"></a>Java文件操作工具类</h1><h2 id="Paths"><a href="#Paths" class="headerlink" title="Paths"></a>Paths</h2><p>jdk7 引入了 Path 和 Paths 类</p>
<ul>
<li>Path 用来表示文件路径</li>
<li>Paths 是工具类，用来获取 Path 实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path source = Paths.get(<span class="string">&quot;1.txt&quot;</span>); <span class="comment">// 相对路径 使用 user.dir 环境变量来定位 1.txt</span></span><br><span class="line"></span><br><span class="line">Path source = Paths.get(<span class="string">&quot;d:\\1.txt&quot;</span>); <span class="comment">// 绝对路径 代表了  d:\1.txt</span></span><br><span class="line"></span><br><span class="line">Path source = Paths.get(<span class="string">&quot;d:/1.txt&quot;</span>); <span class="comment">// 绝对路径 同样代表了  d:\1.txt</span></span><br><span class="line"></span><br><span class="line">Path projects = Paths.get(<span class="string">&quot;d:\\data&quot;</span>, <span class="string">&quot;projects&quot;</span>); <span class="comment">// 代表了  d:\data\projects</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>.</code> 代表了当前路径</li>
<li><code>..</code> 代表了上一级路径</li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;d:\\data\\projects\\a\\..\\b&quot;</span>);</span><br><span class="line">System.out.println(path);</span><br><span class="line">System.out.println(path.normalize()); <span class="comment">// 正常化路径</span></span><br></pre></td></tr></table></figure>
<p>会输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d:\data\projects\a\..\b</span><br><span class="line">d:\data\projects\b</span><br></pre></td></tr></table></figure>
<h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p><code>Files</code> 是 Java 中用于操作文件和目录的工具类之一。它提供了许多静态方法，用于执行文件和目录的创建、复制、移动、删除等操作。</p>
<h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><p><strong>检查文件是否存在</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line">System.out.println(Files.exists(path));</span><br></pre></td></tr></table></figure>


<p><strong>创建一级目录</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;helloword/d1&quot;</span>);</span><br><span class="line">Files.createDirectory(path);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果目录已存在，会抛异常 FileAlreadyExistsException</li>
<li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li>
</ul>
<p><strong>创建多级目录用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;helloword/d1/d2&quot;</span>);</span><br><span class="line">Files.createDirectories(path);</span><br></pre></td></tr></table></figure>


<p><strong>拷贝文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path source = Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line">Path target = Paths.get(<span class="string">&quot;helloword/target.txt&quot;</span>);</span><br><span class="line">Files.copy(source, target);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果文件已存在，会抛异常 FileAlreadyExistsException</li>
</ul>
<blockquote>
<p>如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制</p>
<p><code>Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</code></p>
</blockquote>
<p><strong>移动文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path source = Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line">Path target = Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);</span><br></pre></td></tr></table></figure>
<ul>
<li>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</li>
</ul>
<p><strong>删除文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path target = Paths.get(<span class="string">&quot;helloword/target.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果文件不存在，会抛异常 NoSuchFileException</li>
</ul>
<p><strong>删除目录</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path target = Paths.get(<span class="string">&quot;helloword/d1&quot;</span>);</span><br><span class="line"></span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果目录还有内容，会抛异常 DirectoryNotEmptyException</li>
</ul>
<p><strong>遍历目录文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Path path = Paths.get(<span class="string">&quot;C:\\Program Files\\Java\\jdk1.8.0_91&quot;</span>);</span><br><span class="line">    AtomicInteger dirCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    AtomicInteger fileCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    Files.walkFileTree(path, <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            System.out.println(dir);</span><br><span class="line">            dirCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            fileCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(dirCount); <span class="comment">// 133</span></span><br><span class="line">    System.out.println(fileCount); <span class="comment">// 1479</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>统计 jar 的数目</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;C:\\Program Files\\Java\\jdk1.8.0_91&quot;</span>);</span><br><span class="line">AtomicInteger fileCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">Files.walkFileTree(path, <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (file.toFile().getName().endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">            fileCount.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(fileCount); <span class="comment">// 724</span></span><br></pre></td></tr></table></figure>


<p><strong>删除多级目录</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;d:\\a&quot;</span>);</span><br><span class="line">Files.walkFileTree(path, <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Files.delete(file);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Files.delete(dir);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.postVisitDirectory(dir, exc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p><strong>拷贝多级目录</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">String source = <span class="string">&quot;D:\\Snipaste-1.16.2-x64&quot;</span>;</span><br><span class="line">String target = <span class="string">&quot;D:\\Snipaste-1.16.2-x64aaa&quot;</span>;</span><br><span class="line"></span><br><span class="line">Files.walk(Paths.get(source)).forEach(path -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String targetName = path.toString().replace(source, target);</span><br><span class="line">        <span class="comment">// 是目录</span></span><br><span class="line">        <span class="keyword">if</span> (Files.isDirectory(path)) &#123;</span><br><span class="line">            Files.createDirectory(Paths.get(targetName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是普通文件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Files.isRegularFile(path)) &#123;</span><br><span class="line">            Files.copy(path, Paths.get(targetName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(end - start);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>NIO</category>
        <category>文件操作工具类</category>
      </categories>
      <tags>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>Reactor模式</title>
    <url>/2023/09/26/Java/NIO/Reactor%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230624110659064.png" alt="image-20230624110659064" style="zoom: 33%;" />

<p>针对传统阻塞 I/O 服务模型的 2 个缺点：</p>
<ul>
<li>当并发数很大，就会创建大量的线程，占用很大系统资源</li>
<li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在 Handler对象中的<code>read</code> 操作，导致上面的处理线程资源浪费</li>
</ul>
<p>Reactor 模式的解决方案：本质就是I/O多路复用</p>
<ul>
<li>多个连接共用一个阻塞对象<code>ServiceHandler</code>，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。</li>
<li>当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Reactor 模式也叫 <code>Dispatcher</code> 模式，即 <strong>I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个线程</strong>。</p>
<p><strong>核心组件：</strong></p>
<ul>
<li><p>Reactor（也就是那个ServiceHandler）：</p>
<p><code>Reactor</code> 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理线程来对 <code>IO</code> 事件做出反应。</p>
</li>
<li><p>Handlers（处理线程EventHandler）：</p>
<p>处理线程执行 <code>I/O</code> 事件要完成的实际事件。</p>
</li>
</ul>
<p><strong>分类：</strong></p>
<ul>
<li>单 <code>Reactor</code> 单线程</li>
<li>单 <code>Reactor</code> 多线程</li>
<li>主从 <code>Reactor</code> 多线程</li>
</ul>
<h2 id="单Reactor单线程"><a href="#单Reactor单线程" class="headerlink" title="单Reactor单线程"></a>单Reactor单线程</h2><p>通过单一Reactor调用select来监听网络的连接请求，收到事件后通过 <code>Dispatch</code> 进行分发。</p>
<ul>
<li>如果是建立连接请求事件，则由 <code>Acceptor</code> 通过 <code>Accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理连接完成后的后续业务处理</li>
<li>如果不是建立连接事件，则 <code>Reactor</code> 会分发调用连接对应的 <code>Handler</code> 来响应</li>
</ul>
<p><strong>结构图：</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230624111254368.png" alt="image-20230624111254368" style="zoom:50%;" />

<p><strong>缺点：</strong></p>
<p>性能问题，只有一个线程，无法完全发挥多核 <code>CPU</code> 的性能。<code>Handler</code>在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈、甚至导致整个节点故障。</p>
<p> <strong>Netty对应的代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventLoopGroup eventGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">serverBootstrap serverBootstrap = <span class="keyword">new</span> serverBootstrap();</span><br><span class="line">serverBootstrap.group(eventGroup);</span><br></pre></td></tr></table></figure>
<h2 id="单-Reactor多线程"><a href="#单-Reactor多线程" class="headerlink" title="单 Reactor多线程"></a>单 Reactor多线程</h2><p>同样是通过单一Reactor调用select来监听网络的连接请求，收到事件后通过 <code>Dispatch</code> 进行分发。</p>
<ul>
<li>如果是建立连接请求事件，则由 <code>Acceptor</code> 通过 <code>Accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理连接完成后的后续业务处理。</li>
<li>如果不是连接请求，则由 <code>Reactor</code> 分发调用连接对应的 <code>handler</code> 来处理，<strong>但是这里<code>handler</code>只负责响应事件，不负责处理事件，而是交由<code>Worker</code>线程来进行业务处理。</strong></li>
</ul>
<p><strong>结构图：</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230624153915017.png" alt="image-20230624153915017" style="zoom: 50%;" />

<p><strong>缺点：</strong></p>
<ul>
<li>单一的<code>Reactor</code>承担了所有时间监听，性能瓶颈明显，多线程数据共享和访问比较复杂。</li>
</ul>
<p> <strong>Netty对应的代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认2倍核心数</span></span><br><span class="line">EventLoopGroup eventGroup = <span class="keyword">new</span> NioEventLoopfroup();</span><br><span class="line">ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">serverBootstrap.group(eventGroup);</span><br></pre></td></tr></table></figure>
<h2 id="主从-Reactor-多线程"><a href="#主从-Reactor-多线程" class="headerlink" title="主从 Reactor 多线程"></a>主从 Reactor 多线程</h2><p>优化了前两种方案的单一<code>Reactor</code>性能瓶颈问题，这个方案让<code>Reactor</code>以主从的多线程方式运行。</p>
<ul>
<li><code>Reactor</code> 主线程 <code>MainReactor</code> 对象通过 <code>select</code> 监听连接事件，收到事件后，通过 <code>Acceptor</code> 处理连接事件。</li>
<li>当 <code>Acceptor</code> 处理连接事件后，<code>MainReactor</code> 将连接分配给 <code>SubReactor</code>，<code>SubReactor</code>再将对应事件交由<code>handler</code>处理。</li>
<li><code>handler</code>再分发给后面的<code>worker</code> 线程处理。</li>
</ul>
<p><strong>结构图：</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230624154445226.png" alt="image-20230624154445226" style="zoom:50%;" />

<p> <strong>Netty对应的代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">serverBootstrap.group(bossGroup, workerGroup);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>零拷贝</title>
    <url>/2023/09/22/Java/NIO/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>所谓的【<strong>零拷贝</strong>】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中。</p>
<p>零拷贝的优点有：</p>
<ul>
<li>更少的用户态与内核态的切换</li>
<li>不利用 cpu 计算，减少 cpu 缓存伪共享</li>
<li>零拷贝适合小文件传输</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>传统的IO操作，例如一个文件的传输：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;data.txt&quot;</span>), <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">file.read(buf);</span><br><span class="line"><span class="comment">// 以流的形式进行网络传输</span></span><br><span class="line">socket.getOutputStream().write(buf);</span><br></pre></td></tr></table></figure>
<p><strong>数据拷贝流程：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230617153006900.png" alt="image-20230617153006900"></p>
<ol>
<li><p>java 本身并不具备 IO 读写能力，需要利用操作系统来完成，因此 read 方法调用后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户<strong>线程阻塞</strong>，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu。</p>
<blockquote>
<p>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO。</p>
</blockquote>
</li>
<li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA。</p>
</li>
<li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区</strong>，cpu 会参与拷贝。</p>
</li>
<li><p>接下来要向网卡写数据，这项能力 java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu。</p>
</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li>用户态与内核态的切换发生了 3 次，这个操作比较重量级。</li>
<li>数据拷贝了共 4 次。</li>
</ul>
<h2 id="零拷贝优化"><a href="#零拷贝优化" class="headerlink" title="零拷贝优化"></a>零拷贝优化</h2><h3 id="NIO优化"><a href="#NIO优化" class="headerlink" title="NIO优化"></a>NIO优化</h3><p>NIO中有一个DirectByteBuf缓冲区，DirectByteBuffer是ByteBuffer的一种<strong>特殊类型</strong>，它与普通的HeapByteBuffer有所不同。HeapByteBuffer是在Java堆上分配内存的，而DirectByteBuffer是在操作系统的<strong>内存中直接分配的</strong>，通常称为直接内存。</p>
<p><strong>流程：</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230617153614491.png" alt="image-20230617153614491" style="zoom:67%;" />

<p>这样利用这个直接内存，这样用户态和内核态都能共用一个缓冲区，减少了一次数据的拷贝问题。并且这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写。</p>
<p><strong>总结：</strong></p>
<ul>
<li>用户态与内核态的切换还是发生了 3 次</li>
<li>数据拷贝了 3 次</li>
</ul>
<h3 id="linux-2-1优化"><a href="#linux-2-1优化" class="headerlink" title="linux 2.1优化"></a>linux 2.1优化</h3><p>linux 2.1 后提供的 sendFile 方法，java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据。这个方法能够不需要多次切换内核状态，直接在内核状态下完成数据拷贝。</p>
<p><strong>流程：</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230617153923882.png" alt="image-20230617153923882" style="zoom:67%;" />

<ol>
<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>。</li>
<li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，cpu 会参与拷贝。</li>
<li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu。</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li>只发生了一次用户态与内核态的切换</li>
<li>数据拷贝了 3 次</li>
</ul>
<h3 id="linux-2-4优化"><a href="#linux-2-4优化" class="headerlink" title="linux 2.4优化"></a>linux 2.4优化</h3><p>linux2.4版本后，对sendfile 系统调用进行优化,配合硬件DMA，可以直接从内核空间缓冲区中将数据拷贝到网卡,彻底省去了CPU拷贝。</p>
<p><strong>流程：</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230617154412615.png" alt="image-20230617154412615" style="zoom:67%;" />

<ol>
<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>。</li>
<li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗。</li>
<li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡。</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li>完全没有使用cpu进行数据拷贝。</li>
<li>只发生了一次用户态与内核态的切换。</li>
<li>数据拷贝了 2 次。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>NIO</category>
        <category>原生NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>NIO</title>
    <url>/2023/03/13/Java/NIO/NIO/</url>
    <content><![CDATA[<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>non-blocking io 非阻塞 IO</p>
<h2 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h2><h3 id="Channel-amp-Buffer"><a href="#Channel-amp-Buffer" class="headerlink" title="Channel &amp; Buffer"></a>Channel &amp; Buffer</h3><p>channel 有一点类似于 stream，它就是读写数据的<strong>双向通道</strong>，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221214201629860.png" alt="image-20221214201629860"></p>
<p>常用的 <code>Channel</code> 类有：<code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和 <code>SocketChannel</code></p>
<ul>
<li><p><code>FileChannel</code> ：用于文件的数据读写</p>
</li>
<li><p><code>DatagramChannel</code> ：用于 <code>UDP</code> 的数据读写</p>
</li>
<li><p><code>ServerSocketChannel</code> 和 <code>SocketChannel</code>： 用于 <code>TCP</code> 的数据读写</p>
</li>
</ul>
<p>常用的<code>Buffer</code>类有：</p>
<ul>
<li><p><code>ByteBuffer</code>：存储字节数据到缓冲区</p>
</li>
<li><p><code>ShortBuffer</code>：存储字符串数据到缓冲区</p>
</li>
<li><p><code>CharBuffer</code>：存储字符数据到缓冲区</p>
</li>
<li><p><code>IntBuffer</code>：存储整数数据到缓冲区</p>
</li>
<li><p><code>LongBuffer</code>：存储长整型数据到缓冲区</p>
</li>
<li><p><code>DoubleBuffer</code>：存储小数到缓冲区</p>
</li>
<li><p><code>FloatBuffer</code>：存储小数到缓冲区</p>
</li>
<li><p><code>MappedByteBuffer</code>：可以让文件直接在内存（堆外的内存）中进行修改</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数 1:FileChannel.MapMode.READ_WRITE 使用的读写模式</span></span><br><span class="line"><span class="comment"> * 参数 2：0：可以直接修改的起始位置</span></span><br><span class="line"><span class="comment"> * 参数 3:5: 是映射到内存的大小（不是索引位置），即将 1.txt 的多少个字节映射到内存</span></span><br><span class="line"><span class="comment"> * 可以直接修改的范围就是 0-5</span></span><br><span class="line"><span class="comment"> * 实际类型 DirectByteBuffer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">mappedByteBuffer.put(<span class="number">0</span>, (<span class="keyword">byte</span>) <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">mappedByteBuffer.put(<span class="number">3</span>, (<span class="keyword">byte</span>) <span class="string">&#x27;9&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3></li>
</ul>
<p><code>Selector</code> 的作用就是配合一个线程来管理多个 <code>Channel</code> ，获取这些<code>Channel</code> 上发生的事件，这些<code>Channel</code> 工作在非阻塞模式下，不会让线程吊死在一个<code>Channel</code>  上。适合连接数特别多，但流量低的场景（low traffic）</p>
<p><code>Selector</code> 能够检测多个注册的通道上是否有事件发生（注意：多个 <code>Channel</code> 以事件的方式可以注册到同一个 <code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221214202241254.png" alt="image-20221214202241254"></p>
<ol>
<li><code>Selector</code>相关方法说明：<ul>
<li><code>selector.select();</code> //阻塞</li>
<li><code>selector.select(1000);</code> //阻塞 1000 毫秒，在 1000 毫秒后返回</li>
<li><code>selector.wakeup();</code> //唤醒 selector</li>
<li><code>selector.selectNow();</code> //不阻塞，立马返还</li>
</ul>
</li>
</ol>
<h2 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h2><p><code>ByteBuffer</code>是一个字节流缓冲区类，用于在内存中创建缓冲区，可以用来读取、写入和操作原始数据。它提供了一种有效的方式来处理二进制数据。</p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li>向 buffer 写入数据，例如调用 channel.read(buffer)</li>
<li>调用 flip() 切换至<strong>读模式</strong></li>
<li>从 buffer 读取数据，例如调用 buffer.get()</li>
<li>调用 clear() 或 compact() 切换至<strong>写模式</strong></li>
<li>重复 1~4 步骤</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByteBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(FileChannel channel = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;data.txt&quot;</span>).getChannel()) &#123;</span><br><span class="line">            <span class="comment">// 准备缓冲区</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">// 从channel中读取数据</span></span><br><span class="line">                <span class="keyword">int</span> len = channel.read(buffer);</span><br><span class="line">                <span class="keyword">if</span>(len == -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 打印buffer内容</span></span><br><span class="line">                buffer.flip();<span class="comment">// 切换至读模式</span></span><br><span class="line">                <span class="keyword">while</span>(buffer.hasRemaining())&#123;</span><br><span class="line">                    <span class="keyword">byte</span> b = buffer.get();</span><br><span class="line">                    System.out.println((<span class="keyword">char</span>) b);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 切换为写模式</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>ByteBuffer 有以下重要属性</p>
<ul>
<li>capacity</li>
<li>position</li>
<li>limit</li>
</ul>
<p>一开始</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/0021.png"></p>
<p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/0018.png"></p>
<p>flip 动作发生后，position 切换为读取位置，limit 切换为读取限制</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/0019.png"></p>
<p>读取 4 个字节后，状态</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/0020.png"></p>
<p>clear 动作发生后，状态</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/0021.png"></p>
<p>compact 方法，是把未读完的部分向前压缩，然后切换至写模式</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/0022.png"></p>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="非阻塞-vs-阻塞"><a href="#非阻塞-vs-阻塞" class="headerlink" title="非阻塞 vs 阻塞"></a>非阻塞 vs 阻塞</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul>
<li><p>阻塞模式下，相关方法都会导致线程暂停</p>
<ul>
<li><code>ServerSocketChannel.accept()</code> 会在没有连接建立时让线程暂停</li>
<li><code>SocketChannel.read()</code> 会在没有数据可读时让线程暂停</li>
</ul>
<blockquote>
<p>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</p>
</blockquote>
</li>
<li><p>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</p>
</li>
<li><p>但多线程下，有新的问题，体现在以下方面</p>
<ul>
<li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li>
<li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li>
</ul>
</li>
</ul>
<p>服务器端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 nio 来理解阻塞模式, 单线程</span></span><br><span class="line"><span class="comment">// 0. ByteBuffer</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 1. 创建了服务器</span></span><br><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 连接集合</span></span><br><span class="line">List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class="line">    log.debug(<span class="string">&quot;connecting...&quot;</span>);</span><br><span class="line">    SocketChannel sc = ssc.accept(); <span class="comment">// 阻塞方法，线程停止运行</span></span><br><span class="line">    log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class="line">    channels.add(sc);</span><br><span class="line">    <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">        <span class="comment">// 5. 接收客户端发送的数据</span></span><br><span class="line">        log.debug(<span class="string">&quot;before read... &#123;&#125;&quot;</span>, channel);</span><br><span class="line">        channel.read(buffer); <span class="comment">// 阻塞方法，线程停止运行</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        debugRead(buffer);</span><br><span class="line">        buffer.clear();</span><br><span class="line">        log.debug(<span class="string">&quot;after read...&#123;&#125;&quot;</span>, channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SocketChannel sc = SocketChannel.open();</span><br><span class="line">sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br></pre></td></tr></table></figure>


<h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><ul>
<li><p>非阻塞模式下，相关方法都会不会让线程暂停</p>
<ul>
<li>在 <code>ServerSocketChannel.accept() </code>在没有连接建立时，会返回 null，继续运行</li>
<li><code>SocketChannel.read() </code>在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 <code>SocketChannel.read()</code> 或是去执行 <code>ServerSocketChannel.accept()</code></li>
</ul>
<blockquote>
<p>写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去</p>
</blockquote>
</li>
<li><p>但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu</p>
</li>
<li><p>数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）</p>
</li>
</ul>
<p>服务器端，客户端代码不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 nio 来理解非阻塞模式, 单线程</span></span><br><span class="line"><span class="comment">// 0. ByteBuffer</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 1. 创建了服务器</span></span><br><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">ssc.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line"><span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"><span class="comment">// 3. 连接集合</span></span><br><span class="line">List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class="line">    SocketChannel sc = ssc.accept(); <span class="comment">// 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null</span></span><br><span class="line">    <span class="keyword">if</span> (sc != <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class="line">        sc.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line">        channels.add(sc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">        <span class="comment">// 5. 接收客户端发送的数据</span></span><br><span class="line">        <span class="keyword">int</span> read = channel.read(buffer);<span class="comment">// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            debugRead(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">            log.debug(<span class="string">&quot;after read...&#123;&#125;&quot;</span>, channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p>
<ul>
<li>多路复用仅针对网络 IO、普通文件 IO 没法利用多路复用</li>
<li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul>
<li>有可连接事件时才去连接</li>
<li>有可读事件才去读取</li>
<li>有可写事件才去写入<ul>
<li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221219195259007.png" alt="image-20221219195259007"></p>
<p>多路复用的好处：</p>
<ul>
<li>一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功</li>
<li>让这个线程能够被充分利用</li>
<li>节约了线程的数量</li>
<li>减少了线程上下文切换</li>
</ul>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><ol>
<li><p>创建Selector：<code>Selector selector = Selector.open();</code></p>
</li>
<li><p>绑定事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置为非阻塞</span></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line">SelectionKey key = channel.register(selector, 绑定事件);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>绑定的事件类型可以有</p>
<ul>
<li>connect - 客户端连接成功时触发</li>
<li>accept - 服务器端成功接受连接时触发</li>
<li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li>
<li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li>
</ul>
</blockquote>
</li>
<li><p>监听 Channel 事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1，阻塞直到绑定事件发生</span></span><br><span class="line"><span class="keyword">int</span> count = selector.select();</span><br><span class="line"><span class="comment">// 方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）</span></span><br><span class="line"><span class="keyword">int</span> count = selector.select(<span class="keyword">long</span> timeout);</span><br><span class="line"><span class="comment">// 方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</span></span><br><span class="line"><span class="keyword">int</span> count = selector.selectNow();</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
</li>
</ol>
<p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelDemo6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocketChannel channel = ServerSocketChannel.open()) &#123;</span><br><span class="line">            channel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">            System.out.println(channel);</span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line"><span class="comment">//                int count = selector.selectNow();</span></span><br><span class="line">                log.debug(<span class="string">&quot;select count: &#123;&#125;&quot;</span>, count);</span><br><span class="line"><span class="comment">//                if(count &lt;= 0) &#123;</span></span><br><span class="line"><span class="comment">//                    continue;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取所有事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历所有事件，逐一处理</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iter.next();</span><br><span class="line">                    <span class="comment">// 判断事件类型</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        ServerSocketChannel c = (ServerSocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 必须处理</span></span><br><span class="line">                        SocketChannel sc = c.accept();</span><br><span class="line">                        sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                        sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                        log.debug(<span class="string">&quot;连接已建立: &#123;&#125;&quot;</span>, sc);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                        <span class="keyword">int</span> read = sc.read(buffer);</span><br><span class="line">                        <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="comment">// cancel会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</span></span><br><span class="line">                            key.cancel();</span><br><span class="line">                            sc.close();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            debug(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 处理完毕，必须将事件移除,避免重复处理</span></span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>)) &#123;</span><br><span class="line">            System.out.println(socket);</span><br><span class="line">            socket.getOutputStream().write(<span class="string">&quot;world&quot;</span>.getBytes());</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="处理消息的边界"><a href="#处理消息的边界" class="headerlink" title="处理消息的边界"></a>处理消息的边界</h4><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/0023.png"></p>
<ul>
<li>一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽</li>
<li>另一种思路是按分隔符拆分，缺点是效率低</li>
<li>TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量<ul>
<li>Http 1.1 是 TLV 格式</li>
<li>Http 2.0 是 LTV 格式</li>
</ul>
</li>
</ul>
<p><strong>完整实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(ByteBuffer source)</span> </span>&#123;</span><br><span class="line">    source.flip();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class="line">        <span class="comment">// 找到一条完整消息</span></span><br><span class="line">        <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> length = i + <span class="number">1</span> - source.position();</span><br><span class="line">            <span class="comment">// 把这条完整消息存入新的 ByteBuffer</span></span><br><span class="line">            ByteBuffer target = ByteBuffer.allocate(length);</span><br><span class="line">            <span class="comment">// 从 source 读，向 target 写</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                target.put(source.get());</span><br><span class="line">            &#125;</span><br><span class="line">            debugAll(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    source.compact(); <span class="comment">// 0123456789abcdef  position 16 limit 16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建 selector, 管理多个 channel</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 2. 建立 selector 和 channel 的联系（注册）</span></span><br><span class="line">    <span class="comment">// SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件</span></span><br><span class="line">    SelectionKey sscKey = ssc.register(selector, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// key 只关注 accept 事件</span></span><br><span class="line">    sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">    log.debug(<span class="string">&quot;sscKey:&#123;&#125;&quot;</span>, sscKey);</span><br><span class="line">    ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行</span></span><br><span class="line">        <span class="comment">// select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理</span></span><br><span class="line">        selector.select();</span><br><span class="line">        <span class="comment">// 4. 处理事件, selectedKeys 内部包含了所有发生的事件</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator(); <span class="comment">// accept, read</span></span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            SelectionKey key = iter.next();</span><br><span class="line">            <span class="comment">// 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题</span></span><br><span class="line">            iter.remove();</span><br><span class="line">            log.debug(<span class="string">&quot;key: &#123;&#125;&quot;</span>, key);</span><br><span class="line">            <span class="comment">// 5. 区分事件类型</span></span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123; <span class="comment">// 如果是 accept</span></span><br><span class="line">                ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line">                SocketChannel sc = channel.accept();</span><br><span class="line">                sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>); <span class="comment">// attachment</span></span><br><span class="line">                <span class="comment">// 将一个 byteBuffer 作为附件关联到 selectionKey 上</span></span><br><span class="line">                SelectionKey scKey = sc.register(selector, <span class="number">0</span>, buffer);</span><br><span class="line">                scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sc);</span><br><span class="line">                log.debug(<span class="string">&quot;scKey:&#123;&#125;&quot;</span>, scKey);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123; <span class="comment">// 如果是 read</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel(); <span class="comment">// 拿到触发事件的channel</span></span><br><span class="line">                    <span class="comment">// 获取 selectionKey 上关联的附件</span></span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="keyword">int</span> read = channel.read(buffer); <span class="comment">// 如果是正常断开，read 的方法的返回值是 -1</span></span><br><span class="line">                    <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123;</span><br><span class="line">                        key.cancel();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        split(buffer);</span><br><span class="line">                        <span class="comment">// 需要扩容</span></span><br><span class="line">                        <span class="keyword">if</span> (buffer.position() == buffer.limit()) &#123;</span><br><span class="line">                            ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity() * <span class="number">2</span>);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            newBuffer.put(buffer); <span class="comment">// 0123456789abcdef3333\n</span></span><br><span class="line">                            key.attach(newBuffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    key.cancel();  <span class="comment">// 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一次无法写完例子"><a href="#一次无法写完例子" class="headerlink" title="一次无法写完例子"></a>一次无法写完例子</h4><ul>
<li>非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）</li>
<li>用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略<ul>
<li>当消息处理器第一次写入消息时，才将 channel 注册到 selector 上</li>
<li>selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册</li>
<li>如果不取消，会每次可写均会触发 write 事件</li>
</ul>
</li>
</ul>
<p><strong>完整实现</strong></p>
<p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line"></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    SocketChannel sc = ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    SelectionKey sckey = sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">// 1. 向客户端发送内容</span></span><br><span class="line">                    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000000</span>; i++) &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString());</span><br><span class="line">                    <span class="keyword">int</span> write = sc.write(buffer);</span><br><span class="line">                    <span class="comment">// 3. write 表示实际写了多少字节</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;实际写入字节:&quot;</span> + write);</span><br><span class="line">                    <span class="comment">// 4. 如果有剩余未读字节，才需要关注写事件</span></span><br><span class="line">                    <span class="keyword">if</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        <span class="comment">// read 1  write 4</span></span><br><span class="line">                        <span class="comment">// 在原有关注事件的基础上，多关注 写事件</span></span><br><span class="line">                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);</span><br><span class="line">                        <span class="comment">// 把 buffer 作为附件加入 sckey</span></span><br><span class="line">                        sckey.attach(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">                    SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="keyword">int</span> write = sc.write(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;实际写入字节:&quot;</span> + write);</span><br><span class="line">                    <span class="keyword">if</span> (!buffer.hasRemaining()) &#123; </span><br><span class="line">                        <span class="comment">// 写完了取消关注写事件</span></span><br><span class="line">                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);</span><br><span class="line">                        key.attach(<span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        SocketChannel sc = SocketChannel.open();</span><br><span class="line">        sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);</span><br><span class="line">        sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">                    System.out.println(sc.finishConnect());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">                    count += sc.read(buffer);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    System.out.println(count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="利用多线程优化"><a href="#利用多线程优化" class="headerlink" title="利用多线程优化"></a>利用多线程优化</h4><p>前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？</p>
<p>分两组选择器</p>
<ul>
<li>单线程配一个选择器，专门处理 accept 事件</li>
<li>创建 cpu 核心数的线程，每个线程配一个选择器，轮流处理 read 事件</li>
</ul>
<p><strong>完整实现</strong></p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelDemo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BossEventLoop().register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BossEventLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Selector boss;</span><br><span class="line">        <span class="keyword">private</span> WorkerEventLoop[] workers;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> start = <span class="keyword">false</span>;</span><br><span class="line">        AtomicInteger index = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">                ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">                ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                boss = Selector.open();</span><br><span class="line">                SelectionKey ssckey = ssc.register(boss, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">                ssckey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">                workers = initEventLoops();</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">this</span>, <span class="string">&quot;boss&quot;</span>).start();</span><br><span class="line">                log.debug(<span class="string">&quot;boss start...&quot;</span>);</span><br><span class="line">                start = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> WorkerEventLoop[] initEventLoops() &#123;</span><br><span class="line"><span class="comment">//        EventLoop[] eventLoops = new EventLoop[Runtime.getRuntime().availableProcessors()]; </span></span><br><span class="line">            <span class="comment">// Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数,这个问题直到 jdk10 才修复</span></span><br><span class="line">            WorkerEventLoop[] workerEventLoops = <span class="keyword">new</span> WorkerEventLoop[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workerEventLoops.length; i++) &#123;</span><br><span class="line">                workerEventLoops[i] = <span class="keyword">new</span> WorkerEventLoop(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> workerEventLoops;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    boss.select();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iter.next();</span><br><span class="line">                        iter.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            ServerSocketChannel c = (ServerSocketChannel) key.channel();</span><br><span class="line">                            SocketChannel sc = c.accept();</span><br><span class="line">                            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            log.debug(<span class="string">&quot;&#123;&#125; connected&quot;</span>, sc.getRemoteAddress());</span><br><span class="line">                            workers[index.getAndIncrement() % workers.length].register(sc);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerEventLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Selector worker;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> start = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentLinkedQueue&lt;Runnable&gt; tasks = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WorkerEventLoop</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                worker = Selector.open();</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">this</span>, <span class="string">&quot;worker-&quot;</span> + index).start();</span><br><span class="line">                start = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tasks.add(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SelectionKey sckey = sc.register(worker, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">                    sckey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    worker.selectNow();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            worker.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    worker.select();</span><br><span class="line">                    Runnable task = tasks.poll();</span><br><span class="line">                    <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Set&lt;SelectionKey&gt; keys = worker.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iter.next();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="keyword">int</span> read = sc.read(buffer);</span><br><span class="line">                                <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">                                    key.cancel();</span><br><span class="line">                                    sc.close();</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    buffer.flip();</span><br><span class="line">                                    log.debug(<span class="string">&quot;&#123;&#125; message:&quot;</span>, sc.getRemoteAddress());</span><br><span class="line">                                    debugAll(buffer);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                                key.cancel();</span><br><span class="line">                                sc.close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        iter.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>NIO</category>
        <category>原生NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring_2</title>
    <url>/2021/04/25/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring/Spring-2/</url>
    <content><![CDATA[<h1 id="Spring-学习笔记（二）"><a href="#Spring-学习笔记（二）" class="headerlink" title="Spring 学习笔记（二）"></a>Spring 学习笔记（二）</h1><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><ul>
<li>概述：</li>
</ul>
<p>​        在软件业，AOP为Aspect Oriented Programming的缩写，意为：<strong>面向切面编程</strong>，通过<strong>预编译</strong>方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是<strong>OOP</strong>的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是<strong>函数式编程</strong>的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的<strong>耦合度</strong>降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p>​        简单的说就是把我们程序重复的代码抽取出来，在需要执行的时候，使用<strong>动态代理</strong>的技术，在不修改源码的基础上，对我们的已有方法进行增强。</p>
<ul>
<li>作用：<ul>
<li>在程序运行期间，不修改源码对已有方法进行加强</li>
</ul>
</li>
<li>优势<ul>
<li>减少重复代码</li>
<li>提高开发效率</li>
<li>维护方便</li>
</ul>
</li>
</ul>
<h3 id="2-AOP相关术语"><a href="#2-AOP相关术语" class="headerlink" title="2.AOP相关术语"></a>2.AOP相关术语</h3><ul>
<li>Joinpoint(连接点): 所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点。 </li>
<li>Pointcut(切入点): 所谓切入点是指我们要对哪些Joinpoint进行拦截的定义。</li>
<li>Advice(通知/增强):  所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。 </li>
<li>通知的类型：<ul>
<li>前置通知</li>
<li>后置通知</li>
<li>异常通知</li>
<li>最终通知</li>
<li>环绕通知。</li>
</ul>
</li>
<li>Introduction(引介):  引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field。</li>
<li>Target(目标对象):  代理的目标对象。</li>
<li>Weaving(织入):  是指把增强应用到目标对象来创建新的代理对象的过程。 spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。</li>
<li>Proxy（代理）:  一个类被AOP织入增强后，就产生一个结果代理类。 </li>
<li>Aspect(切面):  是切入点和通知（引介）的结合。</li>
</ul>
<h3 id="3-Spring-AOP的使用"><a href="#3-Spring-AOP的使用" class="headerlink" title="3.Spring AOP的使用"></a>3.Spring AOP的使用</h3><h4 id="1-基于bean-xml的使用"><a href="#1-基于bean-xml的使用" class="headerlink" title="1.基于bean.xml的使用"></a>1.基于bean.xml的使用</h4> <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置spring的Ioc，把service对象配置进来--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wht.service.Impl.AccountServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- spring中基于xml的aop配置步骤</span></span><br><span class="line"><span class="comment">         1.把通知Bean也交给spring来管理</span></span><br><span class="line"><span class="comment">         2.使用aop:config标签表明开始AOP的配置</span></span><br><span class="line"><span class="comment">         3.使用aop：aspect标签表明配置切面</span></span><br><span class="line"><span class="comment">                id属性：是给切面提供一个唯一标识</span></span><br><span class="line"><span class="comment">                ref属性：是指定通知类bean的id</span></span><br><span class="line"><span class="comment">         4.在aop：aspect标签的内部使用对应标签来配置通知的类型</span></span><br><span class="line"><span class="comment">                通知类型：</span></span><br><span class="line"><span class="comment">                    前置通知：在切入点方法执行之前执行</span></span><br><span class="line"><span class="comment">                        aop:before:表示配置前置通知</span></span><br><span class="line"><span class="comment">                            method属性：用于指定Logger类中哪个方法是前置通知</span></span><br><span class="line"><span class="comment">                            pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层哪些方法进行增强</span></span><br><span class="line"><span class="comment">                    后置通知：在切入点正常执行之后执行</span></span><br><span class="line"><span class="comment">                        after-returning:表示配置后置通知</span></span><br><span class="line"><span class="comment">                            method属性：用于指定Logger类中哪个方法是后置通知</span></span><br><span class="line"><span class="comment">                            pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层哪些方法进行增强</span></span><br><span class="line"><span class="comment">                    异常通知：在切入点执行产生异常之后执行</span></span><br><span class="line"><span class="comment">                        aop:after-throwing:表示配置异常通知</span></span><br><span class="line"><span class="comment">                            method属性：用于指定Logger类中哪个方法是异常通知</span></span><br><span class="line"><span class="comment">                            pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层哪些方法进行增强</span></span><br><span class="line"><span class="comment">                    最终通知：无论切入方法是否正常执行都会在其后面执行</span></span><br><span class="line"><span class="comment">                        aop:after :表示配置最终通知</span></span><br><span class="line"><span class="comment">                            method属性：用于指定Logger类中哪个方法是最终通知</span></span><br><span class="line"><span class="comment">                            pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层哪些方法进行增强</span></span><br><span class="line"><span class="comment">                    环绕通知：无论切入方法是否正常执行都会在其后面执行</span></span><br><span class="line"><span class="comment">                        aop:around :表示配置环绕通知</span></span><br><span class="line"><span class="comment">                            method属性：用于指定Logger类中哪个方法是环绕通知</span></span><br><span class="line"><span class="comment">                            pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层哪些方法进行增强</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                aop:pointcut 切入点表达式标签 可以在通知标签中使用 pointcut-ref引用</span></span><br><span class="line"><span class="comment">                    此标签写在aop:aspect标签中，只能当前切面使用</span></span><br><span class="line"><span class="comment">                    写在aop:aspect外面，就可以让所有切面使用，但是必须在所有aop:aspect标签之前</span></span><br><span class="line"><span class="comment">                    id属性：用于指定表达式的唯一标识</span></span><br><span class="line"><span class="comment">                    expression:用于表达式内容</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                切入表达式的写法：</span></span><br><span class="line"><span class="comment">                    关键字：execution(表达式)</span></span><br><span class="line"><span class="comment">                    表达式：</span></span><br><span class="line"><span class="comment">                        访问修饰符 返回值 包名.包名.包名...类名.方法名(参数列表)</span></span><br><span class="line"><span class="comment">                        访问修饰符可以省略</span></span><br><span class="line"><span class="comment">                        返回值可以使用通配符，表示任意返回值</span></span><br><span class="line"><span class="comment">                        包名可以使用通配符，表示任意包</span></span><br><span class="line"><span class="comment">                            也可以使用..表示当前包及其子包</span></span><br><span class="line"><span class="comment">                        类名和方法名都可以使用通配符表示</span></span><br><span class="line"><span class="comment">                        参数列表：</span></span><br><span class="line"><span class="comment">                            可以直接写数据类型：</span></span><br><span class="line"><span class="comment">                                基本类型直接写名称： int..</span></span><br><span class="line"><span class="comment">                                引用类型写包名.类名的方式： java.lang.String</span></span><br><span class="line"><span class="comment">                             可以使用通配符表示任意类型，但是必须有参数</span></span><br><span class="line"><span class="comment">                             可以使用..表示有无参数均可</span></span><br><span class="line"><span class="comment">                    全通配写法：</span></span><br><span class="line"><span class="comment">                        * *..*.*(...)</span></span><br><span class="line"><span class="comment">                    标准写法：</span></span><br><span class="line"><span class="comment">                        public void com.wht.service.Impl.AccountService.saveAccount()</span></span><br><span class="line"><span class="comment">                    通常写法：</span></span><br><span class="line"><span class="comment">                        * com.wht.service.impl.*.*(..)</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    配置Logger类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logger&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wht.utils.Loogger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置aop --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logger&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置通知类型，并建立通知方法和切入方法的关联 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;printLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.wht.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-基于注解的使用"><a href="#2-基于注解的使用" class="headerlink" title="2.基于注解的使用"></a>2.基于注解的使用</h4><p>xml的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        配置spring创建容器时要扫描的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.wht&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置spring开启注解AOP的支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;logger&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">//表示这是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Loogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.wht.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//@Before(&quot;pt1()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">beforePrintLog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知Logger类中的beforePrintLog方法开始记录日志了。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//@AfterReturning(&quot;pt1()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">afterReturningPrintLog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知Logger类中的afterReturningPrintLog方法开始记录日志了。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//@AfterThrowing(&quot;pt1()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">afterThrowingPrintLog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最终通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//@After(&quot;pt1()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">afterPrintLog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终通知Logger类中的afterPrintLog方法开始记录日志了。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * 问题：</span></span><br><span class="line"><span class="comment">     *      当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。</span></span><br><span class="line"><span class="comment">     * 分析：</span></span><br><span class="line"><span class="comment">     *      通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。</span></span><br><span class="line"><span class="comment">     * 解决：</span></span><br><span class="line"><span class="comment">     *      Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。</span></span><br><span class="line"><span class="comment">     *      该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * spring中的环绕通知：</span></span><br><span class="line"><span class="comment">     *      它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;pt1()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundPringLog</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">        Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Object[] args = pjp.getArgs();<span class="comment">//得到方法执行所需的参数</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Logger类中的aroundPringLog方法开始记录日志了。。。前置&quot;</span>);</span><br><span class="line"></span><br><span class="line">            rtValue = pjp.proceed(args);<span class="comment">//明确调用业务层方法（切入点方法）</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Logger类中的aroundPringLog方法开始记录日志了。。。后置&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> rtValue;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Logger类中的aroundPringLog方法开始记录日志了。。。异常&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(t);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Logger类中的aroundPringLog方法开始记录日志了。。。最终&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring-JdbcTemplate"><a href="#Spring-JdbcTemplate" class="headerlink" title="Spring JdbcTemplate"></a>Spring JdbcTemplate</h2><h3 id="1-JdbcTemplate的作用"><a href="#1-JdbcTemplate的作用" class="headerlink" title="1.JdbcTemplate的作用"></a>1.JdbcTemplate的作用</h3><p>它就是用于和数据库交互，实现对表的CRUD操作</p>
<h3 id="2-JdbcTemplate的使用"><a href="#2-JdbcTemplate的使用" class="headerlink" title="2.JdbcTemplate的使用"></a>2.JdbcTemplate的使用</h3><ul>
<li>bean.xml的配置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context-3.2.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置JdbcTemplate--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf-8<span class="symbol">&amp;amp;</span>useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone = GMT&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>CRUD操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wht</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取容器</span></span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//获取对象</span></span><br><span class="line">        JdbcTemplate jdbcTemplate = ac.getBean(<span class="string">&quot;jdbcTemplate&quot;</span>, JdbcTemplate.class);</span><br><span class="line">        <span class="comment">//执行操作</span></span><br><span class="line">        <span class="comment">//保存</span></span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;insert into account(name,money) values(?,?)&quot;</span>,<span class="string">&quot;fff&quot;</span>,<span class="number">1000f</span>);</span><br><span class="line">        <span class="comment">//更新</span></span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;update account set name =?,money=? where id = ?&quot;</span>,<span class="string">&quot;fff&quot;</span>,<span class="number">2000f</span>,<span class="number">7</span>);</span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;delete from account where id = ?&quot;</span>,<span class="number">7</span>);</span><br><span class="line">        <span class="comment">//查询所有或查询一个</span></span><br><span class="line">        List&lt;Account&gt; query = jdbcTemplate.query(<span class="string">&quot;select * from account where money &gt; ?&quot;</span>, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account.class), <span class="number">100</span>);</span><br><span class="line">        <span class="comment">//查询返回一行一列</span></span><br><span class="line">        Integer integer = jdbcTemplate.queryForObject(<span class="string">&quot;select count(*) from account&quot;</span>, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Integer&gt;(Integer.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Spring中的事务控制"><a href="#Spring中的事务控制" class="headerlink" title="Spring中的事务控制"></a>Spring中的事务控制</h2><h3 id="1-基于xml的事务"><a href="#1-基于xml的事务" class="headerlink" title="1.基于xml的事务"></a>1.基于xml的事务</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">           https://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context/spring-context-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">           https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置JdbcTemplate--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf-8<span class="symbol">&amp;amp;</span>useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone = GMT&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置事务通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        配置事务属性</span></span><br><span class="line"><span class="comment">            isolation:指定事务的隔离级别，默认值是DEFAULT,表示使用数据库的默认级别</span></span><br><span class="line"><span class="comment">            no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时回滚。没有默认值，表示任何异常都回滚。</span></span><br><span class="line"><span class="comment">            propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择，查询方法可以选择SUPPORTS</span></span><br><span class="line"><span class="comment">            read-only：用于指定事务是否只读，只有查询方法才能设置true默认值为false。</span></span><br><span class="line"><span class="comment">            rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时不回滚。没有默认值，表示任何异常都回滚。</span></span><br><span class="line"><span class="comment">            timeout：指定事务超时时间，默认值是-1，表示永不超时，如果指定了数值，以秒为单位。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置增删改--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置查询--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置aop --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 切入点通用表达式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.wht.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 建立切入点表达式和事务通知的对应关系--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-基于注解的事务"><a href="#2-基于注解的事务" class="headerlink" title="2.基于注解的事务"></a>2.基于注解的事务</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">           https://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context/spring-context-3.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">           https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.wht&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    配置JdbcTemplate--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf-8<span class="symbol">&amp;amp;</span>useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone = GMT&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    开启spring对注解事务的支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    最后在只需要在需要事务支持的地方使用@Transactional即可</span></span><br><span class="line"><span class="comment">        若需修改属性：则可以写成如下：</span></span><br><span class="line"><span class="comment">        @Transactional(propagation = Propagation.SUPPORTS,readOnly = true)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Spring全家桶</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring_1</title>
    <url>/2021/04/15/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring/Spring-1/</url>
    <content><![CDATA[<h1 id="Spring学习笔记-一"><a href="#Spring学习笔记-一" class="headerlink" title="Spring学习笔记(一)"></a>Spring学习笔记(一)</h1><h1 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h1><ul>
<li><p>目的：</p>
<ul>
<li>解决企业应用开发的复杂性</li>
</ul>
</li>
<li><p>范围：任何java的应用</p>
</li>
<li><p>重点：</p>
<ul>
<li>**IoC(控制反转)**：促进了松耦合,对象初始化时不等对象请求就主动将依赖传递</li>
<li>**AOP(面向切面编程)**：允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li><p>Spring是一个开源<strong>容器</strong>。</p>
</li>
<li><p>从大小与开销两方面而言Spring都是轻量的框架</p>
</li>
<li><p>所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。</p>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>配置太过于繁琐！(SpringBoot会很好的解决这个问题)</li>
</ul>
</li>
<li><p>总结：反正无敌！！就是学:smile:!</p>
</li>
</ul>
<h1 id="Spring的7大模块"><a href="#Spring的7大模块" class="headerlink" title="Spring的7大模块"></a>Spring的7大模块</h1><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20210217201434565.png" alt="image-20210217201434565"></p>
<h2 id="1-Spring-Code"><a href="#1-Spring-Code" class="headerlink" title="1.Spring Code"></a>1.Spring Code</h2><p>这是Spring框架最基础的部分，它提供了依赖注入（DependencyInjection）特征来实现容器对Bean的管理。这里最基本的概念是BeanFactory，它是任何Spring应用的核心。</p>
<h2 id="2-Sping-AOP"><a href="#2-Sping-AOP" class="headerlink" title="2.Sping AOP"></a>2.Sping AOP</h2><p>Spring在它的AOP模块中提供了对面向切面编程的丰富支持。这个模块是在Spring应用中实现切面编程的基础。它的目标是通过定义一组共同的接口和组件来促进AOP的使用以及不同的AOP实现之间的互用性。</p>
<h2 id="3-Spring-Context"><a href="#3-Spring-Context" class="headerlink" title="3.Spring Context"></a>3.Spring Context</h2><p>核心模块的BeanFactory使Spring成为一个容器，而上下文模块使它成为一个框架。另外，这个模块提供了许多企业服务，例如电子邮件、JNDI访问、EJB集成、远程以及时序调度（scheduling）服务。也包括了对模版框架例如Velocity和FreeMarker集成的支持。</p>
<h2 id="4-Spring-DAO"><a href="#4-Spring-DAO" class="headerlink" title="4.Spring DAO"></a>4.Spring DAO</h2><p>使用JDBC经常导致大量的重复代码，取得连接、创建语句、处理结果集，然后关闭连接。Spring的JDBC和DAO模块抽取了这些重复代码，因此你可以保持你的数据库访问代码干净简洁，并且可以防止因关闭数据库资源失败而引起的问题。另外，这个模块还使用了Spring的AOP模块为Spring应用中的对象提供了事务管理服务。</p>
<h2 id="5-Spring-ORM"><a href="#5-Spring-ORM" class="headerlink" title="5.Spring ORM"></a>5.Spring ORM</h2><p>对那些更喜欢使用对象/关系映射工具而不是直接使用JDBC的人，Spring提供了ORM模块。Spring并不试图实现它自己的ORM解决方案，而是为几种流行的ORM框架提供了集成方案</p>
<h2 id="6-Spring-Web"><a href="#6-Spring-Web" class="headerlink" title="6.Spring Web"></a>6.Spring Web</h2><p>Web上下文模块建立于应用上下文模块之上，提供了一个适合于Web应用的上下文。</p>
<h2 id="7-Spring-MVC"><a href="#7-Spring-MVC" class="headerlink" title="7.Spring MVC"></a>7.Spring MVC</h2><p>Spring为构建Web应用提供了一个功能全面的MVC框架，Spring的MVC框架使用IoC对控制逻辑和业务对象提供了完全的分离。</p>
<h1 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h1><h2 id="1-什么是IOC"><a href="#1-什么是IOC" class="headerlink" title="1.什么是IOC"></a>1.什么是IOC</h2><p>控制反转模式（也称作依赖性注入）的基本概念是：不创建对象，但是描述创建它们的方式。在代码中不直接与对象和服务连接，但在配置文件中描述哪一个组件需要哪一项服务。容器 （在 Spring 框架中是 IOC 容器） 负责将这些联系在一起。在典型的 IOC 场景中，容器创建了所有对象，并设置必要的属性将它们连接在一起，决定什么时间调用方法。</p>
<h3 id="1-1个人理解："><a href="#1-1个人理解：" class="headerlink" title="1.1个人理解："></a>1.1个人理解：</h3><p>就类似于工厂模式里面的工厂，对程序进行了一定的<strong>解耦</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20210218215731762.png" alt="image-20210218215731762">    !<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20210218215750870.png" alt="image-20210218215750870"></p>
<p>这样降低了app对资源的依赖，直接对工厂要。<strong>这样app对资源的控制权进行放弃转而为让第三方(框架)控制资源所以IOC被称为控制反转</strong></p>
<h3 id="1-2作用："><a href="#1-2作用：" class="headerlink" title="1.2作用："></a>1.2作用：</h3><p>削减计算机程序的耦合(解除我们代码中的依赖关系)</p>
<p>简而言之：对象由spring 来创建，管理，装配！就只需要改成xml来实现不同操作！</p>
<h2 id="Spring-IoC容器的使用"><a href="#Spring-IoC容器的使用" class="headerlink" title="Spring IoC容器的使用"></a>Spring IoC容器的使用</h2><p>​        org.springframework.beans和org.springframework.context是Spring框架中IoC容器的基础，BeanFactory接口提供一种高级的配置机制能够管理任何类型的对象。</p>
<h2 id="1-Spring-的主要maven依赖"><a href="#1-Spring-的主要maven依赖" class="headerlink" title="1.Spring 的主要maven依赖"></a>1.Spring 的主要maven依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-初步的使用"><a href="#2-初步的使用" class="headerlink" title="2.初步的使用"></a>2.初步的使用</h2><h3 id="2-1创建bean-xml文件"><a href="#2-1创建bean-xml文件" class="headerlink" title="2.1创建bean.xml文件"></a>2.1创建bean.xml文件</h3> <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">	http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    把对象的创建交给spring来管理--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    把需要管理的对象放在bean标签中--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                    id:使用时的唯一标识--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                    class:通过反射创建对象时需要用到的全限定类名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wht.service.impl.AccountServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wht.dao.impl.AccountDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2获取对象"><a href="#2-2获取对象" class="headerlink" title="2.2获取对象"></a>2.2获取对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取spring的Ioc核心容器，并根据id获取对象</span></span><br><span class="line"><span class="comment">     * ApplicationContext的三个常用实现类</span></span><br><span class="line"><span class="comment">     *      ClassPathXmlApplicationContext: 它只能加载类路径下的配置文件</span></span><br><span class="line"><span class="comment">     *      FileSystemXmlApplicationContext: 它可以加载任意路径下的配置文件(必须有访问权限，并不常有)</span></span><br><span class="line"><span class="comment">     *      AnnotationConfigApplicationContext: 它用于读取注解创建容器</span></span><br><span class="line"><span class="comment">     *  核心容器的两个接口引发出的问题</span></span><br><span class="line"><span class="comment">     *      ApplicationContext: 多数才用此接口，因为spring会自动根据配置来选择合适的接口</span></span><br><span class="line"><span class="comment">     *          它在构建核心容器时,创建对象的策略是立即加载的方式，就是当容器读了配置文件后对象已经被创建。(单例对象适用)</span></span><br><span class="line"><span class="comment">     *      BeanFactory：</span></span><br><span class="line"><span class="comment">     *          它在构建核心容器时，创建对象的策略是延迟加载的方式，就是当什么时候根据id获取时才创建。(反之多例适用)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取核心容器对象</span></span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//根据id获取对象</span></span><br><span class="line">        <span class="comment">//方式1 需要自己强转</span></span><br><span class="line">        AccountService as = (AccountService) ac.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">        <span class="comment">//方式2</span></span><br><span class="line">        AccountDao adao = ac.getBean(<span class="string">&quot;accountDao&quot;</span>, AccountDao.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Spring对bean的管理细节"><a href="#3-Spring对bean的管理细节" class="headerlink" title="3.Spring对bean的管理细节"></a>3.Spring对bean的管理细节</h2><h3 id="3-1-创建bean的三种方式"><a href="#3-1-创建bean的三种方式" class="headerlink" title="3.1 创建bean的三种方式"></a>3.1 创建bean的三种方式</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    spring创建bean的三种方式</span></span><br><span class="line"><span class="comment">        方式一：使用默认构造函数创建。</span></span><br><span class="line"><span class="comment">            在spring配置文件中使用bean标签，配置id和class之后，且没有其他属性标签时。采用的此方法，若没有无参构造则无法创建。</span></span><br><span class="line"><span class="comment">        方式二：使用普通工厂中的方法创建对象(使用某个类中的方法创建对象,并存入spring容器)</span></span><br><span class="line"><span class="comment">        方式三：使用工厂中的静态方法创建对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    方式一：</span></span><br><span class="line"><span class="comment">            id:使用时的唯一标识</span></span><br><span class="line"><span class="comment">            class:通过反射创建对象时需要用到的全限定类名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wht.service.impl.AccountServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wht.dao.impl.AccountDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   方式二：</span></span><br><span class="line"><span class="comment">            id:使用时的唯一标识</span></span><br><span class="line"><span class="comment">            factory-bean:工厂类使用的id</span></span><br><span class="line"><span class="comment">            factory-method：工厂创建该对象所使用的方法</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;instanceFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wht.Factory.InstanceFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;instanceFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getAccountService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--   方式三：</span></span><br><span class="line"><span class="comment">            id:使用时的唯一标识</span></span><br><span class="line"><span class="comment">            class:该工厂的全限定类名</span></span><br><span class="line"><span class="comment">            factory-method：工厂创建该对象所使用的方法</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wht.Factory.StaticFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getAccountService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-2-bean对象的作用范围"><a href="#3-2-bean对象的作用范围" class="headerlink" title="3.2 bean对象的作用范围"></a>3.2 bean对象的作用范围</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--       </span></span><br><span class="line"><span class="comment"> 				bean的作用范围调整</span></span><br><span class="line"><span class="comment">            bean标签的scope属性：</span></span><br><span class="line"><span class="comment">              取值：</span></span><br><span class="line"><span class="comment">                  singleton：单例(默认值)</span></span><br><span class="line"><span class="comment">                  prototype：多例</span></span><br><span class="line"><span class="comment">                  request：作用于web应用的请求范围</span></span><br><span class="line"><span class="comment">                  session：作用于web应用的会话范围</span></span><br><span class="line"><span class="comment">                  global-session：作用于集群环境的会划范围，当不是集群范围时他就是session</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="3-3-bean对象的生命周期"><a href="#3-3-bean对象的生命周期" class="headerlink" title="3.3 bean对象的生命周期"></a>3.3 bean对象的生命周期</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    </span></span><br><span class="line"><span class="comment">			bean对象的生命周期</span></span><br><span class="line"><span class="comment">            单例对象</span></span><br><span class="line"><span class="comment">                出生： 当容器创建时对象出生</span></span><br><span class="line"><span class="comment">                活着：只要容器还在，对象就存活</span></span><br><span class="line"><span class="comment">                死亡：容器销毁，对象死亡</span></span><br><span class="line"><span class="comment">            多例对象</span></span><br><span class="line"><span class="comment">                出生：当我们使用对象时才创建</span></span><br><span class="line"><span class="comment">                活着：使用过程中一直活着</span></span><br><span class="line"><span class="comment">                死亡：当对象长时间不用，且没有别的对象引用时，由java的垃圾回收器回收</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-依赖注入"><a href="#4-依赖注入" class="headerlink" title="4.依赖注入"></a>4.依赖注入</h2><p>依赖关系的管理：<br>    以后都交给spring来维护在当前类需要用到其他类的对象，由spring为我们提供，只需要配置文件中说明.<br>    依赖关系的维护就叫做依赖注入。</p>
<h3 id="4-1能注入的类型"><a href="#4-1能注入的类型" class="headerlink" title="4.1能注入的类型"></a>4.1能注入的类型</h3><ol>
<li>基本类型和String</li>
<li>其他bean类型(在配置文件中或者注解配置过得bean)</li>
<li>复杂类型/集合类型</li>
</ol>
<h3 id="4-2-注入的方式"><a href="#4-2-注入的方式" class="headerlink" title="4.2 注入的方式"></a>4.2 注入的方式</h3><h4 id="4-2-1使用构造函数注入"><a href="#4-2-1使用构造函数注入" class="headerlink" title="4.2.1使用构造函数注入"></a>4.2.1使用构造函数注入</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        构造函数注入：</span></span><br><span class="line"><span class="comment">            使用标签：constructor-arg</span></span><br><span class="line"><span class="comment">            标签出现的位置：bean标签的内部</span></span><br><span class="line"><span class="comment">            标签中的属性</span></span><br><span class="line"><span class="comment">                type：用于指定注入的数据的数据类型，</span></span><br><span class="line"><span class="comment">                index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值，从0开始</span></span><br><span class="line"><span class="comment">                name：用于指定给构造函数中指定名称的参数赋值  (常用)</span></span><br><span class="line"><span class="comment">                =========以上用于指定构造函数中哪个赋值============</span></span><br><span class="line"><span class="comment">                value：用于提供基本类型和String类型的数据</span></span><br><span class="line"><span class="comment">                ref：用于指定其他的bean类型数据</span></span><br><span class="line"><span class="comment">            优点：</span></span><br><span class="line"><span class="comment">               在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。</span></span><br><span class="line"><span class="comment">            缺点：</span></span><br><span class="line"><span class="comment">                改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wht.service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;now&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;now&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="4-2-2-使用set方法注入"><a href="#4-2-2-使用set方法注入" class="headerlink" title="4.2.2 使用set方法注入"></a>4.2.2 使用set方法注入</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        set方法注入：    更常用</span></span><br><span class="line"><span class="comment">            使用标签：property</span></span><br><span class="line"><span class="comment">            标签出现的位置：bean标签的内部</span></span><br><span class="line"><span class="comment">            标签中的属性</span></span><br><span class="line"><span class="comment">                name：用于指定注入时set方法名称</span></span><br><span class="line"><span class="comment">                value：用于提供基本类型和String类型的数据</span></span><br><span class="line"><span class="comment">                ref：用于指定其他的bean类型数据</span></span><br><span class="line"><span class="comment">            优点：</span></span><br><span class="line"><span class="comment">               创建对象时没有明确的限制，可以直接使用默认构造函数</span></span><br><span class="line"><span class="comment">            缺点：</span></span><br><span class="line"><span class="comment">                如果某个成员必须有值，则set方法没法保证一定注入</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wht.service.impl.AccountServiceImpl2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;now&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="4-2-3-复杂类型的注入"><a href="#4-2-3-复杂类型的注入" class="headerlink" title="4.2.3 复杂类型的注入"></a>4.2.3 复杂类型的注入</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       复杂数据的注入：</span></span><br><span class="line"><span class="comment">         用于给list结构集合注入的标签：</span></span><br><span class="line"><span class="comment">             list array set</span></span><br><span class="line"><span class="comment">         用于Map结构集合注入的标签：</span></span><br><span class="line"><span class="comment">             map props</span></span><br><span class="line"><span class="comment">         结构相同，标签可以互换</span></span><br><span class="line"><span class="comment">         所以常用 list map</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wht.service.impl.AccountServiceImpl3&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myStrs&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mySet&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myMap&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;TestA&quot;</span> <span class="attr">value</span>=<span class="string">&quot;aaa&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;TestB&quot;</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myProps&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;testC&quot;</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;testD&quot;</span>&gt;</span>ddd<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="4-2-4-使用注解注入"><a href="#4-2-4-使用注解注入" class="headerlink" title="4.2.4 使用注解注入"></a>4.2.4 使用注解注入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *曾经的xml配置</span></span><br><span class="line"><span class="comment"> * &lt;bean id=&quot;accountService2&quot; class=&quot;com.wht.service.impl.AccountServiceImpl&quot;</span></span><br><span class="line"><span class="comment"> *          scope=&quot;&quot; init-method=&quot;&quot; destroy-method=&quot;&quot; &gt;</span></span><br><span class="line"><span class="comment"> *         &lt;property name=&quot;&quot; value=&quot;&quot; | ref = &quot;&quot;&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *&lt;/bean&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.用于创建对象的注解</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@component</span></span></span><br><span class="line"><span class="comment"> *      作用：用于把当前类存入spring容器中</span></span><br><span class="line"><span class="comment"> *      属性：</span></span><br><span class="line"><span class="comment"> *          value：用于指定bean的id。默认类名首字母小写</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Controller</span>：</span></span><br><span class="line"><span class="comment"> *      一般用于表现层</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Service</span>：</span></span><br><span class="line"><span class="comment"> *      一般用于业务层</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Repository</span></span></span><br><span class="line"><span class="comment"> *      一般用于持久层</span></span><br><span class="line"><span class="comment"> *  以上三个注解他们的作用和属性与Component是一模一样。</span></span><br><span class="line"><span class="comment"> *  他们三个事spring框架为我们提供明确的三层使用的注解，使我们的三层对象更加清晰</span></span><br><span class="line"><span class="comment"> * 2.用于注入数据的注解</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Autowired</span>:</span></span><br><span class="line"><span class="comment"> *      作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配就可以注入成功。</span></span><br><span class="line"><span class="comment"> *           如果ioc容器没有任何bean对象相匹配就注入失败</span></span><br><span class="line"><span class="comment"> *           如果ioc容器中有多个类型匹配时</span></span><br><span class="line"><span class="comment"> *              会以对象名称作为id来寻找bean对象，若没有该id就注入失败，反之就注入成功</span></span><br><span class="line"><span class="comment"> *      出现位置：</span></span><br><span class="line"><span class="comment"> *          可以是变量上，也可以方法上。</span></span><br><span class="line"><span class="comment"> *      细节：</span></span><br><span class="line"><span class="comment"> *          在使用注解注入时，set方法就不是必须的了。</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Qualifier</span>:</span></span><br><span class="line"><span class="comment"> *      作用：在按照类型注入的基础上再按照名称注入，它在给类成员注入时不能单独使用。但是在给方法参数注入时可以</span></span><br><span class="line"><span class="comment"> *      属性：</span></span><br><span class="line"><span class="comment"> *          value：用于注定注入bean的id</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Resource</span>:</span></span><br><span class="line"><span class="comment"> *      作用：直接按照bean的id注入。它可以独立使用</span></span><br><span class="line"><span class="comment"> *      属性：</span></span><br><span class="line"><span class="comment"> *          name：用于指定bean的id</span></span><br><span class="line"><span class="comment"> *   以上三个注入只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。</span></span><br><span class="line"><span class="comment"> *   另外集合类型的注入只能通过XML来实现</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Value</span></span></span><br><span class="line"><span class="comment"> *      作用：用于注入基本类型和String类型的数据</span></span><br><span class="line"><span class="comment"> *      属性：</span></span><br><span class="line"><span class="comment"> *          value：用于指定数据的值，可以使用SpEL表达式</span></span><br><span class="line"><span class="comment"> *                 SpEL的写法：$&#123;表达式&#125;</span></span><br><span class="line"><span class="comment"> * 3.用于改变作用范围的</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Scope</span>:</span></span><br><span class="line"><span class="comment"> *      作用：用于指定bean的作用范围</span></span><br><span class="line"><span class="comment"> *      属性：</span></span><br><span class="line"><span class="comment"> *          value：指定范围取值。常用：singleton prototype</span></span><br><span class="line"><span class="comment"> * 4.和生命周期相关的</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@PreDestroy</span></span></span><br><span class="line"><span class="comment"> *      作用：用于指定销毁方法</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@PostConstruct</span></span></span><br><span class="line"><span class="comment"> *      作用：用于指定初始化方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    @Qualifier(&quot;accountDao&quot;)</span></span><br><span class="line">    <span class="meta">@Resource(name=&quot;accountDao&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao =<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用java类作为配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个配置类，它的作用和bean.xml是一样的</span></span><br><span class="line"><span class="comment"> * Spring中的新注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span></span></span><br><span class="line"><span class="comment"> *      作用：指定当前类是一个配置类</span></span><br><span class="line"><span class="comment"> *      细节：当配置作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ComponentScan</span></span></span><br><span class="line"><span class="comment"> *      作用：用于通过注解指定spring在创建容器时要扫描的包,和base-package一样</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment"> *      作用：用于把当前方法的返回值作为bean对象存入spring的ioc容器中</span></span><br><span class="line"><span class="comment"> *      属性：</span></span><br><span class="line"><span class="comment"> *          name：用于指定bean的id。当不写时，默认值是当前方法名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Import</span></span></span><br><span class="line"><span class="comment"> *      作用:用于导入其他的配置类</span></span><br><span class="line"><span class="comment"> *      属性：</span></span><br><span class="line"><span class="comment"> *          value：用于指定其他配置类的字节码</span></span><br><span class="line"><span class="comment"> *                  当我们使用import的注解之后，有import注解的类就是主配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@PropertySource</span></span></span><br><span class="line"><span class="comment"> *      作用：用于指定properties文件的位置</span></span><br><span class="line"><span class="comment"> *      属性：</span></span><br><span class="line"><span class="comment"> *          value：指定文件的名称和路径</span></span><br><span class="line"><span class="comment"> *              关键字：classpath：表示类路劲下</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableTransactionManagement</span></span></span><br><span class="line"><span class="comment"> *      作用：用于指定开始事务支持</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.wht&quot;)</span></span><br><span class="line"><span class="meta">@Import(JdbcConfig.class)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbcConfig.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-spring整合junit"><a href="#5-spring整合junit" class="headerlink" title="5.spring整合junit"></a>5.spring整合junit</h2><h3 id="5-1导入spring整合junit的依赖"><a href="#5-1导入spring整合junit的依赖" class="headerlink" title="5.1导入spring整合junit的依赖"></a>5.1导入spring整合junit的依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-相关注解的使用"><a href="#5-2-相关注解的使用" class="headerlink" title="5.2 相关注解的使用"></a>5.2 相关注解的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * spring集合junit的配置</span></span><br><span class="line"><span class="comment"> *      1.导入spring整合junit的依赖</span></span><br><span class="line"><span class="comment"> *      2.使用junit提供的一个注解把原有的main方法替换了，替换成spring提供的</span></span><br><span class="line"><span class="comment"> *          <span class="doctag">@Runwith</span></span></span><br><span class="line"><span class="comment"> *      3.告知spring的运行器，spring和ioc创建是基于xml还是注解的，并且说明位置</span></span><br><span class="line"><span class="comment"> *          <span class="doctag">@ContextConfiguration</span></span></span><br><span class="line"><span class="comment"> *              locations:指定xml文件的位置，加上classpath关键字，表示在类路径下</span></span><br><span class="line"><span class="comment"> *              classes:指定注解类所在的位置</span></span><br><span class="line"><span class="comment"> *      当我们使用spring 5.x版本，需要junit的版本必须是4.12及以上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService as = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Before</span></span><br><span class="line"><span class="comment">//    public void init()&#123;</span></span><br><span class="line"><span class="comment">//        ac = new AnnotationConfigApplicationContext(SpringConfig.class);</span></span><br><span class="line"><span class="comment">//        as = ac.getBean(&quot;accountService&quot;, AccountService.class);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Account&gt; allAccount = as.findAllAccount();</span><br><span class="line">        System.out.println(allAccount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Account accountById = as.findAccountById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(accountById);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span></span>&#123;</span><br><span class="line">        as.saveAccount(<span class="keyword">new</span> Account(<span class="keyword">null</span>,<span class="string">&quot;李倩&quot;</span>,<span class="number">10000</span>));</span><br><span class="line">    &#125;<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        as.updateAccount(<span class="keyword">new</span> Account(<span class="number">1</span>,<span class="string">&quot;666&quot;</span>,<span class="number">10000</span>));</span><br><span class="line">    &#125;<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        as.deleteAccount(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Spring全家桶</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot参数校验</title>
    <url>/2022/09/19/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SpringBoot/SpringBoot%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h1><p>在日常开发中，经常需要对前端传过来的数据进行，非空等有效校验。但是如果使用<code>if (username == null)</code>的方式进行手动判断，会十分麻烦并且每次都需要校验；</p>
<p>于是Validator框架应运而生，提供了很多方便的校验注解（非空、邮箱是否有效、长度限制等）</p>
<h2 id="详细使用"><a href="#详细使用" class="headerlink" title="详细使用"></a>详细使用</h2><p>一般SpringBoot的项目会使用<strong>Spring Validation</strong>，它是对Hibernate Validation的二次封装。在SpringMVC模块中添加了自动校验。并将校验信息封装到特定的类中。</p>
<h3 id="提供的校验注解："><a href="#提供的校验注解：" class="headerlink" title="提供的校验注解："></a>提供的校验注解：</h3><ul>
<li><code>@Null</code> 被注释的元素必须为null</li>
<li><code>@NotNull </code>被注释的元素必须不为null</li>
<li><code>@AssertTrue</code> 被注释的元素必须为true</li>
<li><code>@AssertFalse </code>被注释的元素必须为false</li>
<li><code>@Min(value) </code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li><code>@Max(value) </code>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li><code>@DecimalMin(value)</code> 被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li><code>@DecimalMax(value) </code>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li><code>@Size(max, min) </code>被注释的元素的大小必须在指定的范围内</li>
<li><code>@Digits (integer, fraction)</code> 被注释的元素必须是一个数字，其值必须在可接受的范围内</li>
<li><code>@Past </code>被注释的元素必须是一个过去的日期</li>
<li><code>@Future </code>被注释的元素必须是一个将来的日期</li>
<li><code>@Pattern(value) </code>被注释的元素必须符合指定的正则表达式</li>
<li><code>@NotBlank(message =)</code> 验证字符串非 null，且长度必须大于 0</li>
<li><code>@Email</code> 被注释的元素必须是电子邮箱地址</li>
<li><code>@Length(min=,max=)</code> 被注释的字符串的大小必须在指定的范围内</li>
<li><code>@NotEmpty</code> 被注释的字符串的必须非空</li>
<li><code>@Range(min=,max=,message=)</code> 被注释的元素必须在合适的范围内</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="首先导入依赖"><a href="#首先导入依赖" class="headerlink" title="首先导入依赖"></a>首先导入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringBoot有专门的启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="给需要校验的实体类添加校验注解"><a href="#给需要校验的实体类添加校验注解" class="headerlink" title="给需要校验的实体类添加校验注解"></a>给需要校验的实体类添加校验注解</h4><p>TestDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Email;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotBlank;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Size;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;id必须非空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户名不能为空,并且长度必须大于0&quot;)</span></span><br><span class="line">    <span class="meta">@Size(min = 6, max = 11, message = &quot;用户名长度必须是6-11个字符&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户密码不能为空,并且长度必须大于0&quot;)</span></span><br><span class="line">    <span class="meta">@Size(min = 6, max = 16, message = &quot;密码长度必须是6-16个字符&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式错误&quot;)</span></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;邮箱不能为空,并且长度必须大于0&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 嵌套校验需要加<span class="doctag">@Valid</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> Test02 test02;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Test02：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;id必须非空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试校验"><a href="#测试校验" class="headerlink" title="测试校验"></a>测试校验</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意需要给要校验的对象添加@Validated或者@valid</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/insert&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">insertTestUser</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated</span> TestDemo testUser, BindingResult bindingResult)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果有参数校验失败，会将错误信息封装成对象组装在BindingResult里</span></span><br><span class="line">    <span class="keyword">for</span> (ObjectError error : bindingResult.getAllErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> error.getDefaultMessage();</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;用户名&#123;&#125;的邮箱为&#123;&#125;&quot;</span>, testUser.getUsername(),testUser.getEmail());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@Valid注解与@Validated注解功能差不多</p>
<p>不同点在于：</p>
<ul>
<li>@Valid属于javax包下，而@Validated属于Spring下</li>
<li>@Valid支持嵌套校验、而@Validated不支持</li>
<li>@Validated支持分组，而@Valid不支持</li>
</ul>
</blockquote>
<h3 id="自定义校验注解"><a href="#自定义校验注解" class="headerlink" title="自定义校验注解"></a>自定义校验注解</h3><h4 id="定义自定义注解"><a href="#定义自定义注解" class="headerlink" title="定义自定义注解"></a>定义自定义注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(</span></span><br><span class="line"><span class="meta">    validatedBy = PhoneValidator.class</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Phone &#123;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> &quot;手机格式不正确!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义该注解的校验器"><a href="#定义该注解的校验器" class="headerlink" title="定义该注解的校验器"></a>定义该注解的校验器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidator;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidatorContext;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">Phone</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String phoneNum, ConstraintValidatorContext constraintValidatorContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1: 如果用户没输入直接返回不校验，因为空的判断交给@NotNull去做就行了</span></span><br><span class="line">        <span class="keyword">if</span> (phoneNum == <span class="keyword">null</span> &amp;&amp; phoneNum.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;^(13[0-9]|14[5|7|9]|15[0|1|2|3|5|6|7|8|9]|17[0|1|6|7|8]|18[0-9])\\d&#123;8&#125;$&quot;</span>);</span><br><span class="line">        <span class="comment">// 2：如果校验通过就返回true,否则返回false;</span></span><br><span class="line">        Matcher matcher = p.matcher(phoneNum);</span><br><span class="line">        <span class="keyword">return</span> matcher.matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h3><p>比如当更新时需要带用户id，但当插入时不需要，这个时候就需要分组校验来处理</p>
<h4 id="定义分组"><a href="#定义分组" class="headerlink" title="定义分组"></a>定义分组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.groups.Default;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Update</span> <span class="keyword">extends</span> <span class="title">Default</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指定分组"><a href="#指定分组" class="headerlink" title="指定分组"></a>指定分组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 只有当为Update分组时才会进行校验</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotNull(message = &quot;id必须非空&quot;,groups =&#123;Update.class&#125;)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure>
<h4 id="测试使用"><a href="#测试使用" class="headerlink" title="测试使用"></a>测试使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/insert&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">insertTestUser</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(value = Update.class)</span> TestDemo testUser, BindingResult bindingResult)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果有参数校验失败，会将错误信息封装成对象组装在BindingResult里</span></span><br><span class="line">    <span class="keyword">for</span> (ObjectError error : bindingResult.getAllErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> error.getDefaultMessage();</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;用户名&#123;&#125;的邮箱为&#123;&#125;&quot;</span>, testUser.getUsername(),testUser.getEmail());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip：当不使用BindingResult时，校验失败会引发MethodArgumentNotValidException异常，这样就正好可以使用<a href="">SpringBoot全局异常处理</a></p>
</blockquote>
<h3 id="快速失败（failFast）"><a href="#快速失败（failFast）" class="headerlink" title="快速失败（failFast）"></a>快速失败（failFast）</h3><p>SpringValidation框架默认是关闭快速失败的，也就是说当一个参数校验不通过的时候它不会直接停止，而是会继续校验剩余的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidatorConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Validator <span class="title">validator</span><span class="params">(AutowireCapableBeanFactory springFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ValidatorFactory factory = Validation.byProvider(HibernateValidator.class)</span><br><span class="line">                .configure()</span><br><span class="line">                <span class="comment">// 快速失败</span></span><br><span class="line">                .failFast(<span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">// 解决 SpringBoot 依赖注入问题</span></span><br><span class="line">                .constraintValidatorFactory(<span class="keyword">new</span> SpringConstraintValidatorFactory(springFactory))</span><br><span class="line">                .buildValidatorFactory()) &#123;</span><br><span class="line">            <span class="keyword">return</span> factory.getValidator();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/340620501">【项目实践】SpringBoot三招组合拳，手把手教你打出优雅的后端接口</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring全家桶</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2022/09/15/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SpringBoot/SpringBoot/</url>
    <content><![CDATA[<h1 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h1><p>​        SpringBoot本质就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置，能迅速的开发web应用。不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化了Spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决。</p>
<ul>
<li>特点：</li>
</ul>
<p>（1）可以创建独立的Spring应用程序，并且基于其Maven或Gradle插件，可以创建可执行的JARs和WARs；</p>
<p>（2）内嵌Tomcat或Jetty等Servlet容器；</p>
<p>（3）提供自动配置的“starter”项目对象模型（POMS）以简化Maven配置；</p>
<p>（4）自动配置Spring以及第三方功能；</p>
<p>（5）提供生产级别的监控、健康检查及外部化配置；</p>
<p>（6）无代码生成、无需编写XML；</p>
<h1 id="SpringBoot的使用"><a href="#SpringBoot的使用" class="headerlink" title="SpringBoot的使用"></a>SpringBoot的使用</h1><h2 id="SpringBoot的入门使用"><a href="#SpringBoot的入门使用" class="headerlink" title="SpringBoot的入门使用"></a>SpringBoot的入门使用</h2><h5 id="一、Maven方式创建"><a href="#一、Maven方式创建" class="headerlink" title="一、Maven方式创建"></a>一、Maven方式创建</h5><ol>
<li><p>创建一个maven工程</p>
</li>
<li><p>导入maven依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springBoot_01<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--父项目做依赖管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!--开发导入starter场景启动器</span></span><br><span class="line"><span class="comment">          1、见到很多 spring-boot-starter-* ： *就某种场景</span></span><br><span class="line"><span class="comment">      2、只要引入starter，这个场景的所有常规需要的依赖我们都自动引入</span></span><br><span class="line"><span class="comment">      3、SpringBoot所有支持的场景</span></span><br><span class="line"><span class="comment">      https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter</span></span><br><span class="line"><span class="comment">      4、见到的  *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。</span></span><br><span class="line"><span class="comment">      5、所有场景启动器最底层的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 把项目打成jar包，直接在目标服务器执行即可。--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建主程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wht.boot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@SpringBootApplication</span>告诉springboot这是个springboot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>编写业务层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wht.boot.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handler01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span><span class="string">&quot;hello ,spring boot 2!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<p>直接运行main方法</p>
</li>
</ol>
<h5 id="二、通过idea直接创建SpringBoot工程"><a href="#二、通过idea直接创建SpringBoot工程" class="headerlink" title="二、通过idea直接创建SpringBoot工程"></a>二、通过idea直接创建SpringBoot工程</h5><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220718151148104.png" alt="image-20220718151148104"></p>
<h2 id="SpringBoot的自动配置"><a href="#SpringBoot的自动配置" class="headerlink" title="SpringBoot的自动配置"></a>SpringBoot的自动配置</h2><ul>
<li><p>自动配好Tomcat</p>
</li>
<li><p>引入Tomcat依赖。</p>
<p>配置Tomcat</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;scope&gt;compile&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>自动配好SpringMVC</p>
<ul>
<li><p>引入SpringMVC全套组件</p>
</li>
<li><p>自动配好SpringMVC常用组件（功能）</p>
</li>
</ul>
</li>
<li><p>自动配好Web常见功能，如：字符编码问题</p>
</li>
<li><p>SpringBoot帮我们配置好了所有web开发的常见场景</p>
</li>
<li><p>默认的包结构</p>
<ul>
<li><p>主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来</p>
</li>
<li><p>无需以前的包扫描配置</p>
</li>
<li><p>想要改变扫描路径，@SpringBootApplication(scanBasePackages=<strong>“com.wht”</strong>)</p>
</li>
<li><p>或者@ComponentScan 指定扫描路径</p>
<p>@SpringBootApplication是合成注解<br>等同于<br>@SpringBootConfiguration<br>@EnableAutoConfiguration<br>@ComponentScan(“com.wht.boot”)</p>
</li>
</ul>
</li>
<li><p>各种配置拥有默认值</p>
<ul>
<li><p>默认配置最终都是映射到某个类上，如：MultipartProperties</p>
</li>
<li><p>配置文件的值最终会绑定每个类上，这个类会在容器中创建对象</p>
</li>
</ul>
</li>
<li><p>按需加载所有自动配置项</p>
<ul>
<li><p>非常多的starter</p>
</li>
<li><p>引入了哪些场景这个场景的自动配置才会开启</p>
</li>
<li><p>SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面</p>
</li>
</ul>
</li>
</ul>
<h2 id="SpringBoot相关注解"><a href="#SpringBoot相关注解" class="headerlink" title="SpringBoot相关注解"></a>SpringBoot相关注解</h2><h3 id="1、-Configuration"><a href="#1、-Configuration" class="headerlink" title="1、@Configuration"></a>1、@Configuration</h3><ul>
<li><p>基本使用</p>
</li>
<li><p><strong>Full模式与Lite模式</strong></p>
<ul>
<li><p>配置 类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断</p>
</li>
<li><p>配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、配置类里面使用<span class="doctag">@Bean</span>标注在方法上给容器注册组件，默认也是单实例的</span></span><br><span class="line"><span class="comment"> * 2、配置类本身也是组件</span></span><br><span class="line"><span class="comment"> * 3、proxyBeanMethods：代理bean的方法</span></span><br><span class="line"><span class="comment"> *      Full(proxyBeanMethods = true)、【保证每个<span class="doctag">@Bean</span>方法被调用多少次返回的组件都是单实例的】</span></span><br><span class="line"><span class="comment"> *      Lite(proxyBeanMethods = false)【每个<span class="doctag">@Bean</span>方法被调用多少次返回的组件都是新创建的】</span></span><br><span class="line"><span class="comment"> *      组件依赖必须使用Full模式默认。其他默认是否Lite模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User zhangsan = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//user组件依赖了Pet组件</span></span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tom&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">tomcatPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、-Bean、-Component、-Controller、-Service、-Repository"><a href="#2、-Bean、-Component、-Controller、-Service、-Repository" class="headerlink" title="2、@Bean、@Component、@Controller、@Service、@Repository"></a>2、@Bean、@Component、@Controller、@Service、@Repository</h3><p>与spring用法相同</p>
<h3 id="3、-ComponentScan、-Import"><a href="#3、-ComponentScan、-Import" class="headerlink" title="3、@ComponentScan、@Import"></a>3、@ComponentScan、@Import</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 4、@Import(&#123;User.class, DBHelper.class&#125;)</span></span><br><span class="line"><span class="comment"> *      给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Import(&#123;User.class, DBHelper.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、-Conditional"><a href="#4、-Conditional" class="headerlink" title="4、@Conditional"></a>4、@Conditional</h3><p>条件装配：满足Conditional指定的条件，则进行组件注入</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/1354552/1602835786727-28b6f936-62f5-4fd6-a6c5-ae690bd1e31d.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_YXRndWlndS5jb20g5bCa56GF6LC3,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> </span><br><span class="line"><span class="meta">@ConditionalOnBean(name = &quot;tom&quot;)</span><span class="comment">//给类上加，只有当条件满足这个类中的所有bean才会注册到容器中</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;tom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User zhangsan = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//user组件依赖了Pet组件</span></span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="meta">@ConditionalOnBean(name = &quot;tom&quot;)</span><span class="comment">//给方法加，只有当条件满足这个bean才会注册到容器中</span></span><br><span class="line">    <span class="meta">@Bean(&quot;tom22&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">tomcatPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">        String[] names = run.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> tom = run.containsBean(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;容器中Tom组件：&quot;</span>+tom);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> user01 = run.containsBean(<span class="string">&quot;user01&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;容器中user01组件：&quot;</span>+user01);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> tom22 = run.containsBean(<span class="string">&quot;tom22&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;容器中tom22组件：&quot;</span>+tom22);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="5、原生配置文件引入-ImportResource"><a href="#5、原生配置文件引入-ImportResource" class="headerlink" title="5、原生配置文件引入  @ImportResource"></a>5、原生配置文件引入  @ImportResource</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;haha&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.boot.bean.User&quot;</span>&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;hehe&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.boot.bean.Pet&quot;</span>&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;tomcat&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ImportResource(&quot;classpath:beans.xml&quot;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">    ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">    String[] names = run.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">      System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> haha = run.containsBean(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">  <span class="keyword">boolean</span> hehe = run.containsBean(<span class="string">&quot;hehe&quot;</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;haha：&quot;</span>+haha);<span class="comment">//true</span></span><br><span class="line">  System.out.println(<span class="string">&quot;hehe：&quot;</span>+hehe);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h3 id="6、配置绑定"><a href="#6、配置绑定" class="headerlink" title="6、配置绑定"></a>6、配置绑定</h3><h4 id="1、-Component-ConfigurationProperties"><a href="#1、-Component-ConfigurationProperties" class="headerlink" title="1、@Component + @ConfigurationProperties"></a>1、@Component + @ConfigurationProperties</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有在容器中的组件，才会拥有SpringBoot提供的强大功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span><span class="comment">//绑定yml配置文件 prefix为在yml文件中的前缀名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(Integer price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Car&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;brand=&#x27;&quot;</span> + brand + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、-EnableConfigurationProperties-ConfigurationProperties"><a href="#2、-EnableConfigurationProperties-ConfigurationProperties" class="headerlink" title="2、@EnableConfigurationProperties + @ConfigurationProperties"></a>2、@EnableConfigurationProperties + @ConfigurationProperties</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableConfigurationProperties(Car.class)</span><br><span class="line">&#x2F;&#x2F;1、开启Car配置绑定功能</span><br><span class="line">&#x2F;&#x2F;2、把这个Car这个组件自动注册到容器中</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7、使用外部properties文件-PropertySource-value"><a href="#7、使用外部properties文件-PropertySource-value" class="headerlink" title="7、使用外部properties文件@PropertySource+@value"></a>7、使用外部properties文件@PropertySource+@value</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:db.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driverClassName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.initialSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> initialSize;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DruidDataSource ds = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        ds.setDriverClassName(driverClassName);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(username);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        ds.setInitialSize(initialSize);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="各种插件"><a href="#各种插件" class="headerlink" title="各种插件"></a>各种插件</h2><h4 id="Lombok插件"><a href="#Lombok插件" class="headerlink" title="Lombok插件"></a>Lombok插件</h4><p>简化javaBean的编写</p>
<ol>
<li><p>依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span> <span class="comment">//空参构造</span></span><br><span class="line"><span class="comment">//@AllArgsConstructor 全参构造</span></span><br><span class="line"><span class="meta">@Slf4j</span> <span class="comment">//日志</span></span><br><span class="line"><span class="meta">@Data</span> <span class="comment">//设置get/set</span></span><br><span class="line"><span class="meta">@ToString</span> <span class="comment">//重写toString</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span> <span class="comment">//重写equals和hashCode</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name,Integer age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        log.info(<span class="string">&quot;构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dev-tool"><a href="#dev-tool" class="headerlink" title="dev-tool"></a>dev-tool</h4></li>
</ol>
<p>对项目进行热部署</p>
<ol>
<li><p>依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<p>导入依赖后，每次修改后使用Ctrl+F重新build项目</p>
</li>
</ol>
<h4 id="配置提示插件"><a href="#配置提示插件" class="headerlink" title="配置提示插件"></a>配置提示插件</h4><p>将自定义的类的属性在配置文件中进行提示</p>
<ol>
<li><p>依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<p>属性绑定后，在配置文件中就会有提示</p>
</li>
</ol>
<h2 id="配置文件YAML"><a href="#配置文件YAML" class="headerlink" title="配置文件YAML"></a>配置文件YAML</h2><ul>
<li><p>key: value kv之间有空格</p>
</li>
<li><p>大小写敏感</p>
</li>
<li><p>使用缩进表示层级关系</p>
</li>
<li><p>缩进不允许使用tab，只允许空格</p>
</li>
<li><p>缩进的空格数不重要，只要相同层级的元素左对齐即可</p>
</li>
<li><p>‘#’表示注释</p>
</li>
<li><p>字符串无需加引号，如果要加，’’与””表示字符串内容 会被 转义/不转义</p>
</li>
<li><p>字面量：单个的、不可再分的值。date、boolean、string、number、null</p>
<ul>
<li>k：v</li>
</ul>
</li>
<li><p>对象：键值对的集合。map、hash、set、object </p>
<ul>
<li>行内写法：  k: {k1:v1,k2:v2,k3:v3}</li>
<li>k: <pre><code>k1: v1
k2: v2
k3: v3
</code></pre>
</li>
</ul>
</li>
<li><p>数组：一组按次序排列的值。array、list、queue</p>
<ul>
<li>行内写法：  k: [v1,v2,v3]</li>
<li>k:<ul>
<li>v1</li>
<li>v2</li>
<li>v3</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>多配置文件：</p>
<ul>
<li>我们在配置文件编写的时候，文件名可以是 application-{profile}.properties/yml用来指定多个环境版本如：<ul>
<li>application-test.properties 代表测试环境配置</li>
<li>application-dev.properties 代表开发环境配置</li>
</ul>
</li>
<li>并在默认<code>application.properties</code>主配置文件中配置：<code>spring.profiles.active=dev</code></li>
</ul>
</blockquote>
<h2 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h2><h4 id="1、静态资源目录"><a href="#1、静态资源目录" class="headerlink" title="1、静态资源目录"></a>1、静态资源目录</h4><p>只要静态资源放在类路径下： called /static (or /public or /resources or /META-INF/resources</p>
<ul>
<li><p>访问 ： 当前项目根路径/ + 静态资源名 </p>
</li>
<li><p>原理：请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面</p>
</li>
<li><p>改变默认的静态资源路径</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">static-locations:</span> [<span class="string">classpath:/haha/</span>]</span><br></pre></td></tr></table></figure>
<h4 id="2、欢迎页以及错误页面"><a href="#2、欢迎页以及错误页面" class="headerlink" title="2、欢迎页以及错误页面"></a>2、欢迎页以及错误页面</h4></li>
<li><p>静态资源路径下  index.html<br>○ 可以配置静态资源路径<br>○ 但是不可以配置静态资源的访问前缀。否则导致 index.html不能被默认访问</p>
</li>
<li><p>错误页面：静态资源路径下创建/error文件夹下4xx.html，5xx.html，springboot会被自动解析(需要有模板引擎thymeleaf等)</p>
</li>
</ul>
<h4 id="3、自定义Favicon"><a href="#3、自定义Favicon" class="headerlink" title="3、自定义Favicon"></a>3、自定义Favicon</h4><p>favicon.ico 放在静态资源目录下即可，会自动展示</p>
<h4 id="4、使用Restful风格请求"><a href="#4、使用Restful风格请求" class="headerlink" title="4、使用Restful风格请求"></a>4、使用Restful风格请求</h4><ul>
<li><p>配置请求方式过滤器：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">hiddenmethod:</span></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment">#开启页面表单的Rest功能</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意表单要添加**_method=GET/PUT/POST..**的隐藏input</p>
</li>
<li><p>配置请求映射：<code>@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)</code></p>
</li>
</ul>
<h4 id="5、相关注解"><a href="#5、相关注解" class="headerlink" title="5、相关注解"></a>5、相关注解</h4><ol>
<li>@PathVariable：获取路径参数<code>/car/&#123;id&#125;</code></li>
<li>@RequestHeader：获取请求头</li>
<li>@RequestParam：获取请求参数</li>
<li>@MatrixVariable：获取矩阵变量如<code>/car/sell;low=34;brand=byd</code>(但需要在webMvcConfigurer进行配置开启)</li>
<li>@CookieValue：获取cookie</li>
<li>@RequestBody：获取请求体的内容</li>
<li>@ResponseBody：可以配合json的三方依赖如：fastJson等来实现直接将响应对象转换为json传给前端</li>
<li>……同SpringMVC</li>
</ol>
<h4 id="6、注入web原生组件（Servlet、Filter、Listener）"><a href="#6、注入web原生组件（Servlet、Filter、Listener）" class="headerlink" title="6、注入web原生组件（Servlet、Filter、Listener）"></a>6、注入web原生组件（Servlet、Filter、Listener）</h4><ul>
<li><p>Servlet</p>
<p>创建servlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理get请求</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Hello MyServlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册servlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">myServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletRegistrationBean register = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> MyServlet(), <span class="string">&quot;/myServlet&quot;</span>);</span><br><span class="line">        <span class="comment">// 可以在这里设置相关配置</span></span><br><span class="line">        register.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> register;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Filter</p>
<p>创建Filter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyFilter process...&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册Filter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean register = <span class="keyword">new</span> FilterRegistrationBean(<span class="keyword">new</span> MyFilter());</span><br><span class="line">        register.setUrlPatterns(Arrays.asList(<span class="string">&quot;/myServlet&quot;</span>,<span class="string">&quot;/&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> register;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Listener</p>
<p>创建Listener</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyListener.contextInitialized -- web应用启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyListener.contextDestroyed -- web应用关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册Listener</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletListenerRegistrationBean <span class="title">myServletContextListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServletListenerRegistrationBean(<span class="keyword">new</span> MyServletContextListener());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2></li>
</ul>
<ol>
<li><p>创建拦截器（实现<strong>HandlerInterceptor 接口</strong>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标方法执行之前</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String requestURI = request.getRequestURI();</span><br><span class="line">        log.info(<span class="string">&quot;preHandle拦截的请求路径是&#123;&#125;&quot;</span>,requestURI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//登录检查逻辑</span></span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        Object loginUser = session.getAttribute(<span class="string">&quot;loginUser&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(loginUser != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拦截住。未登录。跳转到登录页</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;请先登录&quot;</span>);</span><br><span class="line">		<span class="comment">//re.sendRedirect(&quot;/&quot;);重定向</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/&quot;</span>).forward(request,response);<span class="comment">//请求转发</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标方法执行完成以后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelAndView</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;postHandle执行&#123;&#125;&quot;</span>,modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 页面渲染以后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;afterCompletion执行异常&#123;&#125;&quot;</span>,ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在web配置类中添加拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、编写一个拦截器实现HandlerInterceptor接口</span></span><br><span class="line"><span class="comment"> * 2、拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors）</span></span><br><span class="line"><span class="comment"> * 3、指定拦截规则【如果是拦截所有，静态资源也会被拦截】</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminWebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LoginInterceptor())            									.addPathPatterns(<span class="string">&quot;/**&quot;</span>)   <span class="comment">//所有请求都被拦截包括静态资源      </span></span><br><span class="line">            .excludePathPatterns(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/images/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>); <span class="comment">//放行的请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2></li>
</ol>
<p>Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库</p>
<p>如果要继续使用JUnit 4需要导入vintage的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> SpringBoot中JUnit 5的使用：</p>
<ul>
<li><p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建测试类：</p>
<p>现在的Junit类具有Spring的功能，@Autowired、比如 @Transactional 标注测试方法，测试完成后自动回滚</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Junit5的常用注解：</p>
<ul>
<li><code>@Test</code> :表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试</li>
<li><code>@ParameterizedTest </code>:表示方法是参数化测试，下方会有详细介绍</li>
<li><code>@RepeatedTest</code> :表示方法可重复执行，下方会有详细介绍</li>
<li><code>@DisplayName</code> :为测试类或者测试方法设置展示名称</li>
<li><code>@BeforeEach </code>:表示在每个单元测试之前执行</li>
<li><code>@AfterEach</code> :表示在每个单元测试之后执行</li>
<li><code>@BeforeAll</code> :表示在所有单元测试之前执行</li>
<li><code>@AfterAll</code> :表示在所有单元测试之后执行</li>
<li><code>@Tag</code> :表示单元测试类别，类似于JUnit4中的@Categories</li>
<li><code>@Disabled </code>:表示测试类或测试方法不执行，类似于JUnit4中的@Ignore</li>
<li><code>@Timeout </code>:表示测试方法运行如果超过了指定时间将会返回错误</li>
<li><code>@ExtendWith</code> :为测试类或测试方法提供扩展类引用</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring全家桶</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot日志</title>
    <url>/2022/11/08/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SpringBoot/SpringBoot%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="SpringBoot日志"><a href="#SpringBoot日志" class="headerlink" title="SpringBoot日志"></a>SpringBoot日志</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>日志文件：日志文件是用于记录系统操作事件的文件集合，可分为调试日志和系统日志。具有处理历史数据、诊断问题的追踪以及理解系统的活动等重要作用。<ul>
<li>调试日志文件：软件开发中，我们经常需要去调试程序，做一些信息，状态的输出便于我们查询程序的运行状况，调试日志就可以帮我们记录下来方便查看</li>
<li>系统日志：系统日志是记录系统中硬件、软件和系统问题的信息，同时还可以监视系统中发生的事件。用户可以通过它来检查错误发生的原因，或者寻找受到攻击时攻击者留下的痕迹。系统日志包括系统日志、应用程序日志和安全日志。</li>
</ul>
</li>
</ul>
<h2 id="日志框架介绍"><a href="#日志框架介绍" class="headerlink" title="日志框架介绍"></a>日志框架介绍</h2><h3 id="日志门面："><a href="#日志门面：" class="headerlink" title="日志门面："></a>日志门面：</h3><ul>
<li>JCL</li>
<li>SLF4j</li>
</ul>
<h3 id="日志实现："><a href="#日志实现：" class="headerlink" title="日志实现："></a>日志实现：</h3><ul>
<li>JUL</li>
<li>Logback</li>
<li>Log4j</li>
<li>Log4j2</li>
</ul>
<blockquote>
<p>日志门面就是在日志框架和应用程序之间架设一个沟通的桥梁(如JDBC),主要是为了给Java日志访问提供一套标准、规范的API框架。但是日志的配置文件还是写日志实现自身的配置文件</p>
</blockquote>
<p>常用选择（SpringBoot底层也是这样的搭配）：SLF4j（门面）+ Logback（实现）</p>
<h3 id="SLF4j使用"><a href="#SLF4j使用" class="headerlink" title="SLF4j使用"></a>SLF4j使用</h3><h4 id="最基本的使用"><a href="#最基本的使用" class="headerlink" title="最基本的使用"></a>最基本的使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//级别由低到高</span></span><br><span class="line">        <span class="comment">//可以调整输出的日志级别，这样就只会打印等于或大于该级别的日志</span></span><br><span class="line">        log.trace(<span class="string">&quot;trace级别&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;debug级别&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;info级别&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;warning级别&quot;</span>);</span><br><span class="line">        log.error(<span class="string">&quot;error级别&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220725102611083.png" alt="image-20220725102611083"></p>
<blockquote>
<p>SpringBoot默认是INFO级别</p>
</blockquote>
<h4 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h4><ul>
<li>修改级别：<code>logging.level.包名=级别</code></li>
<li>输出日志文件：可以配置<code>logging.file=文件名/路径</code>或者<code>logging.path=目录</code></li>
<li>修改输出日志的格式：<code>logging.pattern.console/file=格式</code></li>
<li>如果需要指定完整的配置，可以将logback的配置文件(logback.xml/logback-spring.xml)放在类路径下</li>
</ul>
<h4 id="通过AOP来打日志"><a href="#通过AOP来打日志" class="headerlink" title="通过AOP来打日志"></a>通过AOP来打日志</h4><p>如果一个一个接口的自己手动打日志相当麻烦，完全就可以通过<strong>注解+AOP</strong>的方式来打日志，这样也比较灵活方便，只需要给想打日志的方法上加上注解，aop会自动对方法进行代理增强，切入日志进来</p>
<h5 id="自定义的日志注解"><a href="#自定义的日志注解" class="headerlink" title="自定义的日志注解"></a>自定义的日志注解</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 日志标志注解(加了该注解会使用aop打印日志)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wht</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SystemLog &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *业务的简单描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">businessName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="配置切面类"><a href="#配置切面类" class="headerlink" title="配置切面类"></a>配置切面类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.wht.annotation.SystemLog)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pt</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">printLog</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object res;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handleBefore(joinPoint);</span><br><span class="line">            res = joinPoint.proceed();</span><br><span class="line">            handleAfter(res);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;=======END=======&quot;</span>+System.lineSeparator());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法执行后的日志</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleAfter</span><span class="params">(Object res)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;Response       :&#123;&#125;&quot;</span>,JSON.toJSONString(res));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行前的日志</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBefore</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = requestAttributes.getRequest();</span><br><span class="line"></span><br><span class="line">        SystemLog systemLog = getSystemLog(joinPoint);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;=======Start=======&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印请求 URL</span></span><br><span class="line">        log.info(<span class="string">&quot;URL            : &#123;&#125;&quot;</span>,request.getRequestURI());</span><br><span class="line">        <span class="comment">// 打印描述信息</span></span><br><span class="line">        log.info(<span class="string">&quot;BusinessName   : &#123;&#125;&quot;</span>,systemLog.businessName());</span><br><span class="line">        <span class="comment">// 打印 Http method</span></span><br><span class="line">        log.info(<span class="string">&quot;HTTP Method    : &#123;&#125;&quot;</span>,request.getMethod() );</span><br><span class="line">        <span class="comment">// 打印调用 controller 的全路径以及执行方法</span></span><br><span class="line">        log.info(<span class="string">&quot;Class Method   : &#123;&#125;.&#123;&#125;&quot;</span>, joinPoint.getSignature().getDeclaringTypeName(),((MethodSignature) joinPoint.getSignature()).getName());</span><br><span class="line">        <span class="comment">// 打印请求的 IP</span></span><br><span class="line">        log.info(<span class="string">&quot;IP             : &#123;&#125;&quot;</span>,request.getRemoteHost());</span><br><span class="line">        <span class="comment">// 打印请求入参</span></span><br><span class="line">        log.info(<span class="string">&quot;Request Args   : &#123;&#125;&quot;</span>, JSON.toJSONString(joinPoint.getArgs()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SystemLog <span class="title">getSystemLog</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        SystemLog systemLog = methodSignature.getMethod().getAnnotation(SystemLog.class);</span><br><span class="line">        <span class="keyword">return</span> systemLog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意需要导入AOP依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AOP的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SystemLog(businessName = &quot;测试校验&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/insert&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">insertTestUser</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated</span> TestDemo testUser)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220726095213742.png" alt="image-20220726095213742"></p>
]]></content>
      <categories>
        <category>Spring全家桶</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot的异常处理</title>
    <url>/2022/09/20/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SpringBoot/SpringBoot%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="SpringBoot的异常处理"><a href="#SpringBoot的异常处理" class="headerlink" title="SpringBoot的异常处理"></a>SpringBoot的异常处理</h1><h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><p>对整个项目的异常进行自动拦截处理，方便以后抛出自定义异常</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">MethodArgumentNotValidExceptionHandler</span><span class="params">(MethodArgumentNotValidException e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从异常对象中拿到ObjectError对象</span></span><br><span class="line">        ObjectError objectError = e.getBindingResult().getAllErrors().get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 然后提取错误提示信息进行返回</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.failed(objectError.getDefaultMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">exceptionHandler</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">        <span class="comment">//打印异常信息</span></span><br><span class="line">        log.error(<span class="string">&quot;出现了异常！ &#123;&#125;&quot;</span>,e);</span><br><span class="line">        <span class="comment">//从异常对象中获取提示信息封装返回</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.failed(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p>@RestControllerAdvice表示该类为异常处理类，rest是对ControllerAdvice的增强同RestController</p>
</li>
<li><p>@ExceptionHandler指定你需要处理的异常类</p>
</li>
</ul>
</blockquote>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>方便携带更多的错误信息如状态码等..</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span> <span class="comment">//只要getter方法，无需setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APIException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">APIException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(XXX, <span class="string">&quot;接口错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">APIException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(XXX, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">APIException</span><span class="params">(<span class="keyword">int</span> code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>交给全局异常处理解决：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(APIException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">APIExceptionHandler</span><span class="params">(APIException e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//打印异常信息</span></span><br><span class="line">    log.error(<span class="string">&quot;出现了异常！ &#123;&#125;&quot;</span>,e);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.failed(e.getMsg());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ResponseEntity为<a href="">统一的响应实体</a>方便与前端联调</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://longda.wang/post/a9ecfbba.html">Spring Boot 统一异常处理</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/340620501">【项目实践】SpringBoot三招组合拳，手把手教你打出优雅的后端接口</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring全家桶</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot统一响应处理</title>
    <url>/2022/09/21/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SpringBoot/SpringBoot%E7%BB%9F%E4%B8%80%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="SpringBoot统一响应处理"><a href="#SpringBoot统一响应处理" class="headerlink" title="SpringBoot统一响应处理"></a>SpringBoot统一响应处理</h1><p>目前很多项目都是前后端分离，在这样的大趋势下，后端向前端的响应结果规范格外地重要。</p>
<h2 id="自定义响应结果"><a href="#自定义响应结果" class="headerlink" title="自定义响应结果"></a>自定义响应结果</h2><h3 id="响应实体"><a href="#响应实体" class="headerlink" title="响应实体"></a>响应实体</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseEntityDemo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求处理成功且不需要返回数据时使用的工具方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;Type&gt; <span class="function">ResponseEntityDemo&lt;Type&gt; <span class="title">successWithoutData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntityDemo&lt;Type&gt;(ResultCode.SUCCESS, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求处理成功且需要返回数据时使用的工具方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 要返回的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;Type&gt; <span class="function">ResponseEntityDemo&lt;Type&gt; <span class="title">successWithData</span><span class="params">(Type data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntityDemo&lt;Type&gt;(ResultCode.SUCCESS, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求处理失败后使用的工具方法（需要传错误信息）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 失败的错误消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;Type&gt; <span class="function">ResponseEntityDemo&lt;Type&gt; <span class="title">failed</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntityDemo&lt;Type&gt;(ResultCode.FAILED.getCode(), message, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 请求处理失败后使用的工具方法（需要传状态码以及错误信息）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;Type&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;Type&gt; <span class="function">ResponseEntityDemo&lt;Type&gt; <span class="title">failed</span><span class="params">(ResultCode resultCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntityDemo&lt;Type&gt;(resultCode, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 请求处理失败后使用的工具方法（使用默认错误信息）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;Type&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;Type&gt; <span class="function">ResponseEntityDemo&lt;Type&gt; <span class="title">failed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntityDemo&lt;Type&gt;(ResultCode.FAILED, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ResponseEntityDemo</span><span class="params">(ResultCode resultCode, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = resultCode.getCode();</span><br><span class="line">        <span class="keyword">this</span>.message = resultCode.getMsg();</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ResultCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SUCCESS(<span class="number">200</span>, <span class="string">&quot;操作成功&quot;</span>),</span><br><span class="line"></span><br><span class="line">    FAILED(<span class="number">1001</span>, <span class="string">&quot;响应失败&quot;</span>),</span><br><span class="line"></span><br><span class="line">    VALIDATE_FAILED(<span class="number">1002</span>, <span class="string">&quot;参数校验失败&quot;</span>),</span><br><span class="line"></span><br><span class="line">    ERROR(<span class="number">5000</span>, <span class="string">&quot;未知错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code; <span class="comment">//状态码</span></span><br><span class="line">    <span class="keyword">private</span> String msg; <span class="comment">//响应信息</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="响应数据的统一处理"><a href="#响应数据的统一处理" class="headerlink" title="响应数据的统一处理"></a>响应数据的统一处理</h2><p>先创建一个类加上注解使其成为全局处理类并使用同异常处理的全局处理所使用的@RestControllerAdvice注解。然后继承<code>ResponseBodyAdvice</code>接口重写其中的方法，即可对我们的<code>controller</code>进行增强操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice(basePackages = &#123;&quot;com.wht.houtaidemo.controller&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseControllerAdvice</span> <span class="keyword">implements</span> <span class="title">ResponseBodyAdvice</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果接口返回的类型本身就已经包装好了直接返回就行，返回false不用执行beforeBodyWrite进行后续处理</span></span><br><span class="line">        <span class="keyword">return</span> !returnType.getParameterType().equals(ResponseEntityDemo.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">beforeBodyWrite</span><span class="params">(Object result, MethodParameter methodParameter, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对数据进行包装</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntityDemo.successWithData(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip：ResponseBodyAdvice中<code>supports</code>方法要返回为<code>true</code>才会执行<code>beforeBodyWrite</code>方法</p>
<p>上述写法会有一个小问题：</p>
<ul>
<li><p>如果返回类型为String的话会报类型转换异常，所以需要进行特判</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220723112607503.png" alt="image-20220723112607503"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String类型不能直接包装,会被其他转换器识别，所以要进行些特别的处理</span></span><br><span class="line"><span class="keyword">if</span> (returnType.getGenericParameterType().equals(String.class)) &#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将数据包装在ResponseEntity里后，再转换为json字符串响应给前端</span></span><br><span class="line">        <span class="keyword">return</span> objectMapper.writeValueAsString(ResponseEntityDemo.successWithData(result));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        <span class="comment">//返回自定义异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> APIException(<span class="string">&quot;返回String类型错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h4 id="完整版本"><a href="#完整版本" class="headerlink" title="完整版本"></a>完整版本</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice(basePackages = &#123;&quot;com.wht.houtaidemo.controller&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseControllerAdvice</span> <span class="keyword">implements</span> <span class="title">ResponseBodyAdvice</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果接口返回的类型本身就已经包装好了直接返回就行，返回false不用执行beforeBodyWrite进行后续处理</span></span><br><span class="line">        <span class="keyword">return</span> !(returnType.getParameterType().equals(ResponseEntityDemo.class)||returnType.getParameterType().equals(ResponseEntity.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">beforeBodyWrite</span><span class="params">(Object result, MethodParameter returnType, MediaType mediaType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结果为空也返回错误</span></span><br><span class="line">        <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntityDemo.failed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String类型不能直接包装，所以要进行些特别的处理</span></span><br><span class="line">        <span class="keyword">if</span> (returnType.getGenericParameterType().equals(String.class)) &#123;</span><br><span class="line">            ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将数据包装在ResponseEntity里后，再转换为json字符串响应给前端</span></span><br><span class="line">                <span class="keyword">return</span> objectMapper.writeValueAsString(ResponseEntityDemo.successWithData(result));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">                <span class="comment">//返回自定义异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> APIException(<span class="string">&quot;返回String类型错误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果返回false返回错误</span></span><br><span class="line">        <span class="keyword">if</span>(returnType.getGenericParameterType().equals(Boolean.class) &amp;&amp; (Boolean)result == <span class="keyword">false</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntityDemo.failed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对数据进行包装</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntityDemo.successWithData(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>直接返回数据不进行响应包装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/getDemo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TestDemo <span class="title">getTestDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TestDemo demo = <span class="keyword">new</span> TestDemo();</span><br><span class="line">    demo.setId(<span class="number">1L</span>);</span><br><span class="line">    demo.setUsername(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> demo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p>​    <img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220723123942747.png" alt="image-20220723123942747" style="zoom:50%;" /></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://longda.wang/post/ccf439cc.html">Spring Boot 统一响应处理</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/340620501">【项目实践】SpringBoot三招组合拳，手把手教你打出优雅的后端接口</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring全家桶</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot配置FastJson</title>
    <url>/2022/09/16/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SpringBoot/SpringBoot%E9%85%8D%E7%BD%AEFastJson/</url>
    <content><![CDATA[<h1 id="配置FastJSON"><a href="#配置FastJSON" class="headerlink" title="配置FastJSON"></a>配置FastJSON</h1><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.33&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="将fastJson转换器注入容器"><a href="#将fastJson转换器注入容器" class="headerlink" title="将fastJson转换器注入容器"></a>将fastJson转换器注入容器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntercaptorConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用<span class="doctag">@Bean</span>注入fastJsonHttpMessageConvert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpMessageConverter <span class="title">fastJsonHttpMessageConverters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要定义一个Convert转换消息的对象</span></span><br><span class="line">        FastJsonHttpMessageConverter fastConverter = <span class="keyword">new</span> FastJsonHttpMessageConverter();</span><br><span class="line">        <span class="comment">// 添加fastjson的配置信息，比如 是否要格式化返回json数据</span></span><br><span class="line">        FastJsonConfig fastJsonConfig = <span class="keyword">new</span> FastJsonConfig();</span><br><span class="line">        fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);</span><br><span class="line">        fastJsonConfig.setDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">		<span class="comment">//解决long转换精度丢失等问题</span></span><br><span class="line">        SerializeConfig.globalInstance.put(Long.class, ToStringSerializer.instance);</span><br><span class="line"></span><br><span class="line">        fastJsonConfig.setSerializeConfig(SerializeConfig.globalInstance);</span><br><span class="line">        <span class="comment">// 在convert中添加配置信息.</span></span><br><span class="line">        fastConverter.setFastJsonConfig(fastJsonConfig);</span><br><span class="line">        </span><br><span class="line">        HttpMessageConverter&lt;?&gt; converter = fastConverter;</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将convert添加到converters当中.</span></span><br><span class="line">        converters.add(fastJsonHttpMessageConverters());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果对转换格式等不满意，可以在字段上加@JSONField</p>
<p>注解属性：</p>
<ul>
<li>name 指定JSON序列化的字段名称</li>
<li>format 指定字段的格式，对日期格式有用</li>
<li>serialize 是否序列化</li>
<li>serializerFeature 通过SerializerFeature对生成的json格式的数据进行一些定制，比如可以输入的格式更好看，使用单引号而非双引号等，是使用SerializerFeature枚举中的指定序列化方式</li>
<li>parseFeatures 决定了解析器是否将自动关闭那些不属于parser自己的输入源 ，见Feature</li>
<li>label 给属性打上标签， 相当于给属性进行了分组</li>
<li>jsonDirect 你有⼀个字段是字符串类型，⾥⾯是json格式数据，你希望直接输⼊，⽽不是经过转义之后再输出 将这个值置为true。</li>
</ul>
</blockquote>
<h4 id="SerializerFeature常用属性"><a href="#SerializerFeature常用属性" class="headerlink" title="SerializerFeature常用属性"></a>SerializerFeature常用属性</h4><table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>QuoteFieldNames</td>
<td>输出key时<strong>是否使用双引号</strong>,默认为true</td>
<td></td>
</tr>
<tr>
<td>UseSingleQuotes</td>
<td>使用单引号而不是双引号,默认为false</td>
<td></td>
</tr>
<tr>
<td>WriteMapNullValue</td>
<td><strong>是否输出值为null的字段</strong>,默认为false</td>
<td></td>
</tr>
<tr>
<td>WriteNullListAsEmpty</td>
<td>List字段如果为null,输出为[],而非null</td>
<td></td>
</tr>
<tr>
<td>WriteNullStringAsEmpty</td>
<td>字符类型字段如果为null,输出为”“,而非null</td>
<td></td>
</tr>
<tr>
<td>WriteNullNumberAsZero</td>
<td>数值字段如果为null,输出为0,而非null</td>
<td></td>
</tr>
<tr>
<td>WriteNullBooleanAsFalse</td>
<td>Boolean字段如果为null,输出为false,而非null</td>
<td></td>
</tr>
<tr>
<td>PrettyFormat</td>
<td><strong>结果是否格式化</strong>,默认为false</td>
<td></td>
</tr>
<tr>
<td>WriteClassName</td>
<td><strong>序列化时写入类型信息，默认为false</strong>。反序列化是需用到</td>
<td></td>
</tr>
<tr>
<td>BeanToArray</td>
<td>将对象转为array输出</td>
<td></td>
</tr>
<tr>
<td>DisableCheckSpecialChar</td>
<td>一个对象的字符串属性中<strong>如果有特殊字符如双引号，将会在转成json时带有反斜杠转移符</strong>。如果不需要转义，可以使用这个属性。默认为false</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Spring全家桶</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC_1</title>
    <url>/2021/04/27/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SpringMVC/SpringMVC-1/</url>
    <content><![CDATA[<h1 id="SpringMVC-学习笔记"><a href="#SpringMVC-学习笔记" class="headerlink" title="SpringMVC 学习笔记"></a>SpringMVC 学习笔记</h1><h2 id="MVC设计模型"><a href="#MVC设计模型" class="headerlink" title="MVC设计模型"></a>MVC设计模型</h2><ul>
<li><p>M : model 模型 —–&gt;JavaBean</p>
</li>
<li><p>V  :  View 视图 ——&gt; JSP</p>
</li>
<li><p>C  :   Controller控制器 —–&gt; Servlet</p>
</li>
</ul>
<h4 id="MVC职责分析"><a href="#MVC职责分析" class="headerlink" title="MVC职责分析"></a>MVC职责分析</h4><ul>
<li><p>Controller</p>
<ol>
<li>取得表单数据</li>
<li>调用业务逻辑</li>
<li>转向指定的页面</li>
</ol>
</li>
<li><p>Model</p>
<ol>
<li>业务逻辑</li>
<li>保存数据的状态</li>
</ol>
</li>
<li><p>View</p>
<ol>
<li>显示页面</li>
</ol>
</li>
</ul>
<h2 id="SpringMVC概述"><a href="#SpringMVC概述" class="headerlink" title="SpringMVC概述"></a>SpringMVC概述</h2><p>​    SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架，属于 Spring FrameWork 的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。</p>
<p>​    SpringMVC已经成为目前最主流的 MVC 框架之一，并且随着Spring3.0的发布，全面超越 Struts2，成为最优秀的 MVC 框架。 它通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful编程风格的请求。</p>
<h2 id="SpringMVC在三层架构的位置"><a href="#SpringMVC在三层架构的位置" class="headerlink" title="SpringMVC在三层架构的位置"></a>SpringMVC在三层架构的位置</h2><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20210301144834860.png" alt="image-20210301144834860"></p>
<h2 id="SpringMVC详细的执行流程"><a href="#SpringMVC详细的执行流程" class="headerlink" title="SpringMVC详细的执行流程"></a>SpringMVC详细的执行流程</h2><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20210302203740236.png" alt="image-20210302203740236"></p>
<p>前端控制器的配置(配置在web.xml中)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其余配置在xml中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.wht&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 文件位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 文件后缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启SpringMVC框架的注解支持并创建处理器映射器和处理器适配器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="SpringMVC-相关注解的讲解"><a href="#SpringMVC-相关注解的讲解" class="headerlink" title="SpringMVC 相关注解的讲解"></a>SpringMVC 相关注解的讲解</h2><ul>
<li><p>@RequestMapping():</p>
<ul>
<li>作用：与前端请求建立映射关联</li>
<li>作用位置：<ul>
<li>方法上</li>
<li>类上</li>
</ul>
</li>
<li>属性：<ul>
<li>path：用于指定请求的URL</li>
<li>value：就等同于path</li>
<li>method：用于指定请求方式(get/post等)</li>
<li>params：用于指定限制请求参数的条件<ul>
<li>例如：<ul>
<li>params = {“username”}表示必须有username属性</li>
<li>params = {“username !root”}表示必须有username属性并值不为root</li>
</ul>
</li>
</ul>
</li>
<li>headers：用于指定发送的请求中必须包含的请求头</li>
</ul>
</li>
</ul>
</li>
<li><p>@RequestParam():</p>
<ul>
<li><p>作用：把请求中的指定名称的参数传递给控制器中的形参赋值</p>
</li>
<li><p>作用位置：</p>
<ul>
<li>方法参数</li>
</ul>
</li>
<li><p>属性：</p>
<ul>
<li>value：就等同于path</li>
<li>required：请求参数中是否必须提供此参数，默认值是true，必须提供</li>
</ul>
</li>
</ul>
</li>
<li><p>@RequestBody():</p>
<ul>
<li><p>作用：用于获取请求体的内容（注意：get方法不可以）</p>
</li>
<li><p>作用位置：</p>
<ul>
<li>方法参数</li>
</ul>
</li>
<li><p>属性：</p>
<ul>
<li>required：是否必须有请求体，默认值是true</li>
</ul>
</li>
</ul>
</li>
<li><p>@PathVariable():</p>
<ul>
<li><p>作用：拥有绑定url中的占位符的。例如：url中有/delete/{id}，{id}就是占位符</p>
</li>
<li><p>作用位置：</p>
<ul>
<li>方法参数</li>
</ul>
</li>
<li><p>属性：</p>
<ul>
<li>value：指定url中的占位符名称</li>
</ul>
</li>
</ul>
</li>
<li><p>@RequestHeader():</p>
<ul>
<li><p>作用：获取指定请求头的值</p>
</li>
<li><p>作用位置：</p>
<ul>
<li>方法参数</li>
</ul>
</li>
<li><p>属性：</p>
<ul>
<li>value：请求头的名称</li>
</ul>
</li>
</ul>
</li>
<li><p>@CookieValue():</p>
<ul>
<li><p>作用：用于获取指定cookie的名称的值</p>
</li>
<li><p>作用位置：</p>
<ul>
<li>方法参数</li>
</ul>
</li>
<li><p>属性：</p>
<ul>
<li>value：cookie的名称</li>
</ul>
</li>
</ul>
</li>
<li><p>@ModelAttribute():</p>
<ul>
<li><p>作用：1.出现在方法上：表示当前方法会在控制器方法执行前线执行。</p>
<p>  ​            2. 出现在参数上：获取指定的数据给参数赋值。</p>
</li>
<li><p>作用位置：</p>
<ul>
<li>方法</li>
<li>方法参数</li>
</ul>
</li>
<li><p>使用场景：</p>
<ul>
<li>当提交表单数据不是完整的实体数据时，保证没有提交的字段使用数据库原来的数据。</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li>```java<br>  /**<ul>
<li>作用在方法，先执行</li>
<li>@param name</li>
<li>@return</li>
<li>/<br>@ModelAttribute<br>public User showUser(String name) {<pre><code>   System.out.println(&quot;showUser执行了...&quot;);
</code></pre>
   // 模拟从数据库中查询对象<br>   User user = new User();<br>   user.setName(“哈哈”);<br>   user.setPassword(“123”);<br>   user.setMoney(100d);<br>   return user;<br>}<br>/**</li>
<li>修改用户的方法</li>
<li>@param cookieValue</li>
<li>@return</li>
<li>/<br>@RequestMapping(path=”/updateUser”)<br>public String updateUser(User user) {<pre><code> System.out.println(user);
 return &quot;success&quot;;
</code></pre>
}<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;java</span><br><span class="line">	&#x2F;**</span><br><span class="line">	* 作用在方法，先执行</span><br><span class="line">	* @param name</span><br><span class="line">	* @return</span><br><span class="line">	*&#x2F;</span><br><span class="line">	@ModelAttribute</span><br><span class="line">	public void showUser(String name,Map&lt;String, User&gt; map) &#123;</span><br><span class="line">	      System.out.println(&quot;showUser执行了...&quot;);</span><br><span class="line">	      &#x2F;&#x2F; 模拟从数据库中查询对象</span><br><span class="line">	      User user &#x3D; new User();</span><br><span class="line">	      user.setName(&quot;哈哈&quot;);</span><br><span class="line">	      user.setPassword(&quot;123&quot;);</span><br><span class="line">	      user.setMoney(100d);</span><br><span class="line">	      map.put(&quot;abc&quot;, user);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	* 修改用户的方法</span><br><span class="line">	* @param cookieValue</span><br><span class="line">	* @return</span><br><span class="line">	*&#x2F;</span><br><span class="line">	@RequestMapping(path&#x3D;&quot;&#x2F;updateUser&quot;)</span><br><span class="line">	public String updateUser(@ModelAttribute(value&#x3D;&quot;abc&quot;) User user) &#123;</span><br><span class="line">	      System.out.println(user);</span><br><span class="line">	      return &quot;success&quot;;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>@SessionAttributes():</p>
<ul>
<li><p>作用：用于多次执行控制器方法间的参数共享</p>
</li>
<li><p>作用位置：</p>
<ul>
<li>类上</li>
</ul>
</li>
<li><p>属性：</p>
<ul>
<li>value：指定存入属性的名称</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li>```java<br>  @Controller<br>  @RequestMapping(path=”/user”)<br>  @SessionAttributes(value= {“username”,”password”,”age”},types=<br>  {String.class,Integer.class}) // 把数据存入到session域对象中<br>  public class HelloController {<br>  /**<ul>
<li>向session中存入值</li>
<li>@return</li>
<li>/<br>@RequestMapping(path=”/save”)<br>public String save(Model model) {<pre><code> System.out.println(&quot;向session域中保存数据&quot;);
 model.addAttribute(&quot;username&quot;, &quot;root&quot;);
 model.addAttribute(&quot;password&quot;, &quot;123&quot;);
 model.addAttribute(&quot;age&quot;, 20);
 return &quot;success&quot;;
</code></pre>
}<br>/**</li>
<li>从session中获取值</li>
<li>@return</li>
<li>/<br>@RequestMapping(path=”/find”)<br>public String find(ModelMap modelMap) {<pre><code> String username = (String) modelMap.get(&quot;username&quot;);
 String password = (String) modelMap.get(&quot;password&quot;);
 Integer age = (Integer) modelMap.get(&quot;age&quot;);
 System.out.println(username + &quot; : &quot;+password +&quot; : &quot;+age);
 return &quot;success&quot;;
</code></pre>
}<br>/**</li>
<li>清除值</li>
<li>@return</li>
<li>/<br>@RequestMapping(path=”/delete”)<br>public String delete(SessionStatus status) {<pre><code> status.setComplete();
 return &quot;success&quot;;
</code></pre>
}<br>}<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">		- </span><br><span class="line"></span><br><span class="line">## SpringMVC请求参数的绑定</span><br><span class="line"></span><br><span class="line">1. 请求参数的绑定说明</span><br><span class="line"></span><br><span class="line">	1. 绑定机制</span><br><span class="line"></span><br><span class="line">		1. 表单提交的数据都是k&#x3D;v格式的 username&#x3D;haha&amp;password&#x3D;123</span><br><span class="line">		2. SpringMVC的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的</span><br><span class="line">		3. 要求：提交表单的name和参数的名称是相同的</span><br><span class="line"></span><br><span class="line">	2. 支持的数据类型</span><br><span class="line"></span><br><span class="line">		1. 基本数据类型和字符串类型</span><br><span class="line">		2. 实体类型（JavaBean）</span><br><span class="line">		3. 集合数据类型（List、map集合等）</span><br><span class="line"></span><br><span class="line">		注意事项：</span><br><span class="line"></span><br><span class="line">		  1. 基本数据类型和字符串类型</span><br><span class="line"></span><br><span class="line">			1. 提交表单的name和参数的名称是相同的</span><br><span class="line"></span><br><span class="line">			  2. 区分大小写</span><br><span class="line"></span><br><span class="line">		   2. 实体类型（JavaBean）</span><br><span class="line"></span><br><span class="line">			1. 提交表单的name和JavaBean中的属性名称需要一致</span><br><span class="line">				2. 如果一个JavaBean类中包含其他的引用类型，那么表单的name属性需要编写成：对象.属性 例如：address.name</span><br><span class="line"></span><br><span class="line">​		3.给集合属性数据封装</span><br><span class="line"></span><br><span class="line">​				1.JSP页面编写方式：list[0].属性  ，map[&#39;key&#39;].属性</span><br><span class="line"></span><br><span class="line">## SpringMVC中文乱码的解决</span><br><span class="line"></span><br><span class="line">1. 处理post请求乱码</span><br><span class="line"></span><br><span class="line">	在web.xml中配置Spring提供的过滤器类</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;xml</span><br><span class="line">&lt;!-- 配置过滤器，解决中文乱码的问题 --&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">		&lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filterclass&gt;</span><br><span class="line">&lt;!-- 指定字符集 --&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;init-param&gt;	</span><br><span class="line">  	&lt;!-- 顺手处理响应乱码 --&gt;</span><br><span class="line">  	&lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;forceEncoding&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;true&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;init-param&gt;	</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>处理get请求乱码</p>
<p> 在tomcat的server.xml中在8080端口处加 URIEncoding=”UTF-8”</p>
</li>
<li><p>处理响应乱码：</p>
<p> 添加response.setContentType(“text/html;charset=utf-8”);</p>
</li>
</ol>
<h2 id="SpringMVC自定义类型转换器"><a href="#SpringMVC自定义类型转换器" class="headerlink" title="SpringMVC自定义类型转换器"></a>SpringMVC自定义类型转换器</h2><ol>
<li>表单提交的任何数据类型全部都是字符串类型，但是后台定义Integer类型，数据也可以封装上，说明<br> Spring框架内部会默认进行数据类型转换。</li>
<li>如果想自定义数据类型转换，可以实现Converter的接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;请您传入数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> df.parse(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;数据类型转换出现错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>注册自定义类型转换器，在springmvc.xml配置文件中编写配置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册自定义类型转换器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span><span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.utils.StringToDateConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启Spring对MVC注解的支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="控制器中使用原生的ServletAPI对象"><a href="#控制器中使用原生的ServletAPI对象" class="headerlink" title="控制器中使用原生的ServletAPI对象"></a>控制器中使用原生的ServletAPI对象</h2><p>只需要在控制器的方法参数定义HttpServletRequest和HttpServletResponse对象</p>
]]></content>
      <categories>
        <category>Spring全家桶</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC_2</title>
    <url>/2021/04/29/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SpringMVC/SpringMVC-2/</url>
    <content><![CDATA[<h1 id="SpringMVC-学习笔记（二）"><a href="#SpringMVC-学习笔记（二）" class="headerlink" title="SpringMVC 学习笔记（二）"></a>SpringMVC 学习笔记（二）</h1><h3 id="1-发送ajax请求"><a href="#1-发送ajax请求" class="headerlink" title="1. 发送ajax请求"></a>1. 发送ajax请求</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面加载</span></span><br><span class="line"><span class="comment">// 页面加载</span></span><br><span class="line">$(function()&#123;</span><br><span class="line">    <span class="comment">// 绑定点击事件</span></span><br><span class="line">    $(<span class="string">&quot;#btn&quot;</span>).click(function()&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url:<span class="string">&quot;user/testJson&quot;</span>,</span><br><span class="line">        contentType:<span class="string">&quot;application/json;charset=UTF-8&quot;</span>,</span><br><span class="line">        data:<span class="string">&#x27;&#123;&quot;addressName&quot;:&quot;aa&quot;,&quot;addressNum&quot;:100&#125;&#x27;</span>,</span><br><span class="line">        dataType:<span class="string">&quot;json&quot;</span>,</span><br><span class="line">        type:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">        success:function(data)&#123;</span><br><span class="line">                alert(data);</span><br><span class="line">                alert(data.addressName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="2-接收响应数据"><a href="#2-接收响应数据" class="headerlink" title="2. 接收响应数据"></a>2. 接收响应数据</h3><p>json字符串和JavaBean对象互相转换的过程中，需要使用jackson的jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>接收到json并转换为javaBean对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取请求体的数据</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> body</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testJson&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJson</span><span class="params">(<span class="meta">@RequestBody</span> Address address)</span> </span>&#123;</span><br><span class="line">		System.out.println(address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用@ResponseBody注解把JavaBean对象转换成json字符串，直接响应</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testJson&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">Address <span class="title">testJson</span><span class="params">(<span class="meta">@RequestBody</span> Address address)</span> </span>&#123;</span><br><span class="line">    System.out.println(address);</span><br><span class="line">    address.setAddressName(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-SpringMVC实现文件上传"><a href="#3-SpringMVC实现文件上传" class="headerlink" title="3.SpringMVC实现文件上传"></a>3.SpringMVC实现文件上传</h3><p>前提：</p>
<ul>
<li><p> A form表单的enctype取值必须是：multipart/form-data (默认值是:application/x-www-form-urlencoded) enctype:是表单请求正文的类型 </p>
</li>
<li><p> B method属性取值必须是Post </p>
</li>
<li><p> C 提供一个文件选择域<input type="file" /></p>
</li>
<li><p> maven依赖：</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="传统的文件上传"><a href="#传统的文件上传" class="headerlink" title="传统的文件上传"></a>传统的文件上传</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 文件上传</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/fileupload&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">fileupload</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 先获取到要上传的文件目录</span></span><br><span class="line">    String path = request.getSession().getServletContext().getRealPath(<span class="string">&quot;/uploads&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建File对象，一会向该路径下上传文件</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="comment">// 判断路径是否存在，如果不存在，创建该路径</span></span><br><span class="line">    <span class="keyword">if</span>(!file.exists()) &#123;</span><br><span class="line">    		file.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建磁盘文件项工厂</span></span><br><span class="line">    DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">    ServletFileUpload fileUpload = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line">    <span class="comment">// 解析request对象</span></span><br><span class="line">    List&lt;FileItem&gt; list = fileUpload.parseRequest(request);</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (FileItem fileItem : list) &#123;</span><br><span class="line">      <span class="comment">// 判断文件项是普通字段，还是上传的文件</span></span><br><span class="line">      <span class="keyword">if</span>(fileItem.isFormField()) &#123;</span><br><span class="line">        </span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 上传文件项</span></span><br><span class="line">          <span class="comment">// 获取到上传文件的名称</span></span><br><span class="line">          String filename = fileItem.getName();</span><br><span class="line">          <span class="comment">// 上传文件</span></span><br><span class="line">          fileItem.write(<span class="keyword">new</span> File(file, filename));</span><br><span class="line">          <span class="comment">// 删除临时文件</span></span><br><span class="line">          fileItem.delete();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SpringMVC的文件上传"><a href="#SpringMVC的文件上传" class="headerlink" title="SpringMVC的文件上传"></a>SpringMVC的文件上传</h4><ul>
<li><p>配置文件解析器对象</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置文件解析器对象，要求id名称必须是multipartResolver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10485760&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>代码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* SpringMVC方式的文件上传</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/fileupload2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">fileupload2</span><span class="params">(HttpServletRequest request,MultipartFile upload)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">  Exception </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;SpringMVC方式的文件上传...&quot;</span>);</span><br><span class="line">      <span class="comment">// 先获取到要上传的文件目录</span></span><br><span class="line">      String path = request.getSession().getServletContext().getRealPath(<span class="string">&quot;/uploads&quot;</span>);</span><br><span class="line">      <span class="comment">// 创建File对象，一会向该路径下上传文件</span></span><br><span class="line">      File file = <span class="keyword">new</span> File(path);</span><br><span class="line">      <span class="comment">// 判断路径是否存在，如果不存在，创建该路径</span></span><br><span class="line">      <span class="keyword">if</span>(!file.exists()) &#123;</span><br><span class="line">      		file.mkdirs();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取到上传文件的名称</span></span><br><span class="line">      String filename = upload.getOriginalFilename();</span><br><span class="line">      String uuid = UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).toUpperCase();</span><br><span class="line">      <span class="comment">// 把文件的名称唯一化</span></span><br><span class="line">      filename = uuid+<span class="string">&quot;_&quot;</span>+filename;</span><br><span class="line">      <span class="comment">// 上传文件</span></span><br><span class="line">      upload.transferTo(<span class="keyword">new</span> File(file，filename));</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="SpringMVC跨服务器文件上传"><a href="#SpringMVC跨服务器文件上传" class="headerlink" title="SpringMVC跨服务器文件上传"></a>SpringMVC跨服务器文件上传</h4><p>导入需要的jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jersey<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jersey-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jersey<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jersey-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>文件上传的JSP页面</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;h3&gt;跨服务器的文件上传&lt;/h3&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;user/fileupload3&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">      选择文件：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;upload&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">      &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;上传文件&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>编写控制器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* SpringMVC跨服务器方式的文件上传</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/fileupload3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">fileupload3</span><span class="params">(MultipartFile upload)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;SpringMVC跨服务器方式的文件上传...&quot;</span>);</span><br><span class="line">      <span class="comment">// 定义图片服务器的请求路径</span></span><br><span class="line">      String path = <span class="string">&quot;http://localhost:9090/day02_springmvc5_02image/uploads/&quot;</span>;</span><br><span class="line">      <span class="comment">// 获取到上传文件的名称</span></span><br><span class="line">      String filename = upload.getOriginalFilename();</span><br><span class="line">      String uuid = UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).toUpperCase();</span><br><span class="line">      <span class="comment">// 把文件的名称唯一化</span></span><br><span class="line">      filename = uuid+<span class="string">&quot;_&quot;</span>+filename;</span><br><span class="line">      <span class="comment">// 向图片服务器上传文件</span></span><br><span class="line">      <span class="comment">// 创建客户端对象</span></span><br><span class="line">      Client client = Client.create();</span><br><span class="line">      <span class="comment">// 连接图片服务器</span></span><br><span class="line">      WebResource webResource = client.resource(path+filename);</span><br><span class="line">      <span class="comment">// 上传文件</span></span><br><span class="line">      webResource.put(upload.getBytes());</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-SpringMVC异常处理"><a href="#4-SpringMVC异常处理" class="headerlink" title="4.SpringMVC异常处理"></a>4.SpringMVC异常处理</h3><p>异常处理思路：</p>
<p>​    Controller调用service，service调用dao，异常都是向上抛出的，最终有DispatcherServlet找异常处理器进<br>​    行异常的处理。</p>
<p>自定义异常类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.exception;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4055945147128016300L</span>;</span><br><span class="line">      <span class="comment">// 异常提示信息</span></span><br><span class="line">      <span class="keyword">private</span> String message;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> message;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.message = message;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">SysException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.message = message;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置异常处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 异常处理器</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> rt</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 跳转到具体的错误页面的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,Exception ex)</span> </span>&#123;</span><br><span class="line">      ex.printStackTrace();</span><br><span class="line">      SysException e = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 获取到异常对象</span></span><br><span class="line">      <span class="keyword">if</span>(ex <span class="keyword">instanceof</span> SysException) &#123;</span><br><span class="line">      e = (SysException) ex;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      e = <span class="keyword">new</span> SysException(<span class="string">&quot;请联系管理员&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">      <span class="comment">// 存入错误的提示信息</span></span><br><span class="line">      mv.addObject(<span class="string">&quot;message&quot;</span>, e.getMessage());</span><br><span class="line">      <span class="comment">// 跳转的Jsp页面</span></span><br><span class="line">      mv.setViewName(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置异常处理器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置异常处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sysExceptionResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.exception.SysExceptionResolver&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-SpringMVC拦截器"><a href="#5-SpringMVC拦截器" class="headerlink" title="5.SpringMVC拦截器"></a>5.SpringMVC拦截器</h3><ol>
<li>SpringMVC框架中的拦截器用于对处理器进行预处理和后处理的技术。</li>
<li>可以定义拦截器链，连接器链就是将拦截器按着一定的顺序结成一条链，在访问被拦截的方法时，拦截器链<br> 中的拦截器会按着定义的顺序执行。</li>
<li>拦截器和过滤器的功能比较类似，有区别<ol>
<li>过滤器是Servlet规范的一部分，任何框架都可以使用过滤器技术。</li>
<li>拦截器是SpringMVC框架独有的。</li>
<li>过滤器配置了/*，可以拦截任何资源。</li>
<li>拦截器只会对控制器中的方法进行拦截。</li>
</ol>
</li>
<li>拦截器也是AOP思想的一种实现方式</li>
<li>想要自定义拦截器，需要实现HandlerInterceptor接口或者继承HandlerInterceptorAdapter这个类就可以自定义实现其方法。</li>
</ol>
<p>HandlerInterceptor接口的方法：</p>
<ol>
<li>preHandle方法是controller方法执行前拦截的方法<ol>
<li>可以使用request或者response跳转到指定的页面</li>
<li>return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。</li>
<li>return false不放行，不会执行controller中的方法。</li>
</ol>
</li>
<li>postHandle是controller方法执行后执行的方法，在JSP视图执行前。<ol>
<li>可以使用request或者response跳转到指定的页面</li>
<li>如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。</li>
</ol>
</li>
<li>postHandle方法是在JSP执行后执行<ol>
<li>request或者response不能再跳转页面了</li>
</ol>
</li>
</ol>
<p>自定义拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自定义拦截器1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span></span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * controller方法执行前，进行拦截的方法</span></span><br><span class="line"><span class="comment">  * return true放行</span></span><br><span class="line"><span class="comment">  * return false拦截</span></span><br><span class="line"><span class="comment">  * 可以使用转发或者重定向直接跳转到指定的页面。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">  Object handler)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;拦截器执行了...&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置拦截器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 哪些方法进行拦截 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/user/*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 哪些方法不进行拦截</span></span><br><span class="line"><span class="comment">        &lt;mvc:exclude-mapping path=&quot;&quot;/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注册拦截器对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.demo1.MyInterceptor1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring全家桶</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security</title>
    <url>/2022/11/03/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SpringSecurity/Spring-Security/</url>
    <content><![CDATA[<h1 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性(两方面)的完整解决方案。目前比较主流的用法也是Spring Boot/Spring Cloud + Spring Security</p>
<p>Web 应用的安全性包括：<strong>用户认证（Authentication）</strong>和<strong>用户授权（Authorization）</strong>两个部分，这两点也是Spring Security重要核心功能。</p>
<blockquote>
<p><strong>认证</strong>：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户(一般采用用户名和密码的形式)</p>
<p><strong>授权</strong>：经过认证后判断当前用户是否有权限进行某个操作</p>
</blockquote>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ul>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建启动类、controller</p>
</li>
<li><p>启动项目，需要输入账号密码（用户名user密码随机生成在日志中）</p>
</li>
</ul>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220802182044471.png" alt="image-20220802182044471" style="zoom:67%;" />

<blockquote>
<p>可以在配置文件中修改账号密码（或者使用配置类）：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.security.user.name</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.security.user.password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h2><p>对于用户认证，SpringSecurity提供了多种认证方式</p>
<ul>
<li>HTTP BASIC authentication headers：基于IETF RFC 标准。</li>
<li>HTTP Digest authentication headers：基于IETF RFC 标准。</li>
<li>HTTP X.509 client certificate exchange：基于IETF RFC 标准。</li>
<li>LDAP：跨平台身份验证。</li>
<li>Form-based authentication：基于表单的身份验证。</li>
<li>Run-as authentication：用户用户临时以某一个身份登录。</li>
<li>OpenID authentication：去中心化认证。</li>
<li>Jasig Central Authentication Service：单点登录。</li>
<li>Automatic “remember-me” authentication：记住我登录（允许一些非敏感操作）。</li>
<li>Anonymous authentication：匿名登录。</li>
<li>….等</li>
</ul>
<h3 id="基本登录验证"><a href="#基本登录验证" class="headerlink" title="基本登录验证"></a>基本登录验证</h3><h5 id="设置配置类"><a href="#设置配置类" class="headerlink" title="设置配置类"></a>设置配置类</h5><ul>
<li><p>首先进行密码加密配置（在 Spring Security 中，BCryptPasswordEncoder 就自带了盐，处理起来非常方便）</p>
<ul>
<li><p>BCryptPasswordEncoder 就是 PasswordEncoder 接口的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PasswordEncoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法用来对明文密码进行加密，返回加密之后的密文。</span></span><br><span class="line">	<span class="function">String <span class="title">encode</span><span class="params">(CharSequence rawPassword)</span></span>; </span><br><span class="line">	<span class="comment">//方法是一个密码校对方法，在用户登录的时候，将用户传来的明文密码和数据库中保存的密文密码作为参数，传入到这个方法中去，根据返回的 Boolean 值判断用户密码是否输入正确。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span></span>; </span><br><span class="line">    <span class="comment">//是否还要进行再次加密，这个一般来说就不用了</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">upgradeEncoding</span><span class="params">(String encodedPassword)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在内存中存入用户：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="string">&quot;admin&quot;</span>)  <span class="comment">//用户名</span></span><br><span class="line">                .password(<span class="string">&quot;123&quot;</span>).roles(<span class="string">&quot;admin&quot;</span>); <span class="comment">//密码和角色</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置忽略静态资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//web.ignoring() 用来配置忽略掉的 URL 地址，一般对于静态文件，我们可以采用此操作</span></span><br><span class="line">    web.ignoring().antMatchers(<span class="string">&quot;/js/**&quot;</span>, <span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/images/**&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自定义表单页面（仅适用于前后端不分离）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated() <span class="comment">//任何接口都需要进行认证</span></span><br><span class="line">            .and() <span class="comment">//以and进行配置分割</span></span><br><span class="line">        	 <span class="comment">//登录</span></span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginPage(<span class="string">&quot;/login.html&quot;</span>)  <span class="comment">//所使用的登录页面（该配置即是页面也是接口）</span></span><br><span class="line">        	.loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)  <span class="comment">//配置登录参数提交接口</span></span><br><span class="line">        	.usernameParameter(<span class="string">&quot;name&quot;</span>)      <span class="comment">//修改表单参数名</span></span><br><span class="line">			.passwordParameter(<span class="string">&quot;passwd&quot;</span>)    <span class="comment">//修改表单参数名</span></span><br><span class="line">        	.defaultSuccessUrl(<span class="string">&quot;/index&quot;</span>)   <span class="comment">//登录成功跳转接口</span></span><br><span class="line">        	.failureForwardUrl(<span class="string">&quot;/error&quot;</span>) <span class="comment">//登录失败跳转接口</span></span><br><span class="line">            .permitAll()  <span class="comment">//表示登录相关的页面/接口不要被拦截</span></span><br><span class="line">        	.and()</span><br><span class="line">        	 <span class="comment">//注销</span></span><br><span class="line">            .logout()</span><br><span class="line">            .logoutRequestMatcher(<span class="keyword">new</span> AntPathRequestMatcher(<span class="string">&quot;/logout&quot;</span>,<span class="string">&quot;POST&quot;</span>)) </span><br><span class="line">            .logoutSuccessUrl(<span class="string">&quot;/login&quot;</span>)<span class="comment">//注销成功跳转的接口</span></span><br><span class="line">            .deleteCookies() <span class="comment">//清楚cookie</span></span><br><span class="line">            .clearAuthentication(<span class="keyword">true</span>) <span class="comment">//清除认证信息，默认可以不用配置会自动清楚</span></span><br><span class="line">            .invalidateHttpSession(<span class="keyword">true</span>) <span class="comment">//使 HttpSession 失效，默认可以不用配置会自动清楚</span></span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable(); <span class="comment">//关闭csrf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><p>注意登录表单的action必须是”/login.html”以及账号和密码输入框的name一个为username一个为password，不然就不到参会报错</p>
</li>
<li><p>登录成功的回调配置有两个：</p>
</li>
</ol>
<ul>
<li>defaultSuccessUrl ：登录成功后返回刚才页面，可以设置第二个参数true/false，若为true就跟successForwardUrl一样的效果</li>
<li>successForwardUrl：不管从哪里进入的登录界面，只要登录成功都统一进入指定的接口</li>
</ul>
<ol start="3">
<li>登录失败的回调配置：</li>
</ol>
<ul>
<li>failureForwardUrl：failureForwardUrl 是forward 跳转 ，failureForwardUrl异常信息存储在request中</li>
<li>failureUrl ：failureUrl 是redirect 跳转，failureUrl认证失败异常信息存储在session中</li>
</ul>
<ol start="4">
<li>修改注销url的配置：</li>
</ol>
<ul>
<li>logoutUrl：修改默认的注销 URL，默认为GET请求</li>
<li>logoutRequestMatcher ：logoutRequestMatcher 方法不仅可以修改注销 URL，还可以修改请求方式，实际项目中，这个方法和 logoutUrl 任意设置一个即可</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="前后端分离登录"><a href="#前后端分离登录" class="headerlink" title="前后端分离登录"></a>前后端分离登录</h3><h4 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h4><h5 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h5><p>因为Spring Security 默认是通过 key/value 的形式来传递登录参数，因为它处理的方式就是 request.getParameter，但是很多时候我们是通过json来传递数据的，就需要自定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFilter</span> <span class="keyword">extends</span> <span class="title">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否是post请求</span></span><br><span class="line">        <span class="keyword">if</span> (!request.getMethod().equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(</span><br><span class="line">                    <span class="string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取session中存的正确验证码（也可以存redis中）</span></span><br><span class="line">        String verify_code = (String) request.getSession().getAttribute(<span class="string">&quot;verify_code&quot;</span>);</span><br><span class="line">        <span class="comment">//如果是json类型</span></span><br><span class="line">        <span class="keyword">if</span> (request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE) || request.getContentType().equals(MediaType.APPLICATION_JSON_UTF8_VALUE)) &#123;</span><br><span class="line">            Map&lt;String, String&gt; loginData = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                loginData = <span class="keyword">new</span> ObjectMapper().readValue(request.getInputStream(), Map.class);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                String code = loginData.get(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">                checkCode(response, code, verify_code);</span><br><span class="line">            &#125;</span><br><span class="line">            String username = loginData.get(getUsernameParameter());</span><br><span class="line">            String password = loginData.get(getPasswordParameter());</span><br><span class="line">            <span class="keyword">if</span> (username == <span class="keyword">null</span>) &#123;</span><br><span class="line">                username = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (password == <span class="keyword">null</span>) &#123;</span><br><span class="line">                password = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            username = username.trim();</span><br><span class="line">            <span class="comment">//生成UsernamePasswordAuthenticationToken用于验证</span></span><br><span class="line">            UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">                    username, password);</span><br><span class="line">            setDetails(request, authRequest);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果不是json，就用key/value形式</span></span><br><span class="line">            checkCode(response, request.getParameter(<span class="string">&quot;code&quot;</span>), verify_code);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.attemptAuthentication(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkCode</span><span class="params">(HttpServletResponse resp, String code, String verify_code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="keyword">null</span> || verify_code == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(code) || !verify_code.toLowerCase().equals(code.toLowerCase())) &#123;</span><br><span class="line">            <span class="comment">//验证码不正确</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(<span class="string">&quot;验证码不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="配置过滤器"><a href="#配置过滤器" class="headerlink" title="配置过滤器"></a>配置过滤器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function">LoginFilter <span class="title">loginFilter</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LoginFilter loginFilter = <span class="keyword">new</span> LoginFilter();</span><br><span class="line">        loginFilter.setAuthenticationSuccessHandler(<span class="keyword">new</span> AuthenticationSuccessHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                PrintWriter out = response.getWriter();</span><br><span class="line">                String s = <span class="keyword">new</span> ObjectMapper().writeValueAsString(ResponseEntityDemo.successWithData(authentication.getPrincipal()));</span><br><span class="line">                out.write(s);</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        loginFilter.setAuthenticationFailureHandler(<span class="keyword">new</span> AuthenticationFailureHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                PrintWriter out = response.getWriter();</span><br><span class="line">                ResponseEntityDemo responseEntityDemo = ResponseEntityDemo.failed(exception.getMessage());</span><br><span class="line">                <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> LockedException) &#123;</span><br><span class="line">                    responseEntityDemo.setMessage(<span class="string">&quot;账户被锁定，请联系管理员!&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> CredentialsExpiredException) &#123;</span><br><span class="line">                    responseEntityDemo.setMessage(<span class="string">&quot;密码过期，请联系管理员!&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> AccountExpiredException) &#123;</span><br><span class="line">                    responseEntityDemo.setMessage(<span class="string">&quot;账户过期，请联系管理员!&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> DisabledException) &#123;</span><br><span class="line">                    responseEntityDemo.setMessage(<span class="string">&quot;账户被禁用，请联系管理员!&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">                    responseEntityDemo.setMessage(<span class="string">&quot;用户名或者密码输入错误，请重新输入!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(responseEntityDemo));</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        loginFilter.setAuthenticationManager(authenticationManagerBean());</span><br><span class="line">        loginFilter.setFilterProcessesUrl(<span class="string">&quot;/doLogin&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> loginFilter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><h5 id="从数据库中获取用户信息"><a href="#从数据库中获取用户信息" class="headerlink" title="从数据库中获取用户信息"></a>从数据库中获取用户信息</h5><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220803212446730.png" alt="image-20220803212446730"></p>
<p>因为需要从数据库中获取用户信息，则不需要InMemoryUserDetailsManager（将用户存入内存数据源中），需要自定义UserDetailsService的实现类</p>
<ul>
<li><p>定义UserDetails对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wht.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginUser</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUserName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>再定义自定义UserDetailsService的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wht.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.wht.entity.LoginUser;</span><br><span class="line"><span class="keyword">import</span> com.wht.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.wht.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//根据用户名查询用户信息</span></span><br><span class="line">        User user = userMapper.selectOne(<span class="keyword">new</span> LambdaQueryWrapper&lt;User&gt;().eq(User::getUserName,username));</span><br><span class="line">        <span class="comment">//如果查询不到数据就通过抛出异常来给出提示</span></span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(user))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//TODO 根据用户查询权限信息 添加到LoginUser中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装成UserDetails对象返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoginUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将AuthenticationManager注入进容器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义service来处理具体登录逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisUtil redisUtil;	</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntityDemo <span class="title">login</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//AuthenticationManager authenticate进行用户认证</span></span><br><span class="line">    UsernamePasswordAuthenticationToken authenticationToken = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());</span><br><span class="line">    Authentication authenticate = authenticationManager.authenticate(authenticationToken);</span><br><span class="line">    <span class="comment">//如果认证没通过，给出对应的提示</span></span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(authenticate))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果认证通过了，使用userid生成一个jwt jwt存入ResponseResult返回</span></span><br><span class="line">    LoginUser loginUser = (LoginUser) authenticate.getPrincipal();</span><br><span class="line">    String userid = loginUser.getUser().getId().toString();</span><br><span class="line">    String jwt = JwtUtil.createJWT(userid);</span><br><span class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;token&quot;</span>,jwt);</span><br><span class="line">    <span class="comment">//把完整的用户信息存入redis  userid作为key</span></span><br><span class="line">    redisUtil.set(<span class="string">&quot;login:&quot;</span>+userid,loginUser);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntityDemo.successWithData(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置SpringSecurity</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">//关闭csrf</span></span><br><span class="line">        .csrf().disable()</span><br><span class="line">        <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">        .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">        .and()</span><br><span class="line">        .authorizeRequests()</span><br><span class="line">        <span class="comment">// 对于登录接口 允许匿名访问</span></span><br><span class="line">        .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">        <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">        .anyRequest().authenticated();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>继续配置过滤器将用户封装成Authentication放入SecurityContextHolder中方便后面的认证流程使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wht.Filter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wht.entity.LoginUser;</span><br><span class="line"><span class="keyword">import</span> com.wht.utils.JwtUtil;</span><br><span class="line"><span class="keyword">import</span> com.wht.utils.RedisUtil;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.OncePerRequestFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取token</span></span><br><span class="line">        String token = request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(token)) &#123;</span><br><span class="line">            <span class="comment">//放行</span></span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析token</span></span><br><span class="line">        String userid;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Claims claims = JwtUtil.parseJWT(token);</span><br><span class="line">            userid = claims.getSubject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;token非法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从redis中获取用户信息</span></span><br><span class="line">        String redisKey = <span class="string">&quot;login:&quot;</span> + userid;</span><br><span class="line">        LoginUser loginUser = (LoginUser) redisUtil.get(redisKey);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(loginUser))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存入SecurityContextHolder</span></span><br><span class="line">        <span class="comment">//TODO 获取权限信息封装到Authentication中</span></span><br><span class="line">        UsernamePasswordAuthenticationToken authenticationToken =</span><br><span class="line">                <span class="keyword">new</span> UsernamePasswordAuthenticationToken(loginUser,<span class="keyword">null</span>,loginUser.getAuthorities());</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置过滤器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在UsernamePasswordAuthenticationFilter过滤器认证之前拦截</span></span><br><span class="line">    http.addFilterBefore(jwtAuthenticationTokenFilter,UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure>
<h4 id="用户注销"><a href="#用户注销" class="headerlink" title="用户注销"></a>用户注销</h4></li>
</ul>
<p>只需要提供一个接口，删除掉存入redis中的用户信息即可</p>
<ul>
<li><p>controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/logout&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntityDemo <span class="title">logout</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loginServcie.logout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>service</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntityDemo <span class="title">logout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取SecurityContextHolder中的用户id</span></span><br><span class="line">    UsernamePasswordAuthenticationToken authentication = (UsernamePasswordAuthenticationToken) SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">    LoginUser loginUser = (LoginUser) authentication.getPrincipal();</span><br><span class="line">    Long userid = loginUser.getUser().getId();</span><br><span class="line">    <span class="comment">//删除redis中的值</span></span><br><span class="line">    redisUtil.del(<span class="string">&quot;login:&quot;</span>+userid);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntityDemo.successWithoutData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<h2 id="用户授权"><a href="#用户授权" class="headerlink" title="用户授权"></a>用户授权</h2><h3 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h3><p>在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。</p>
<p>所以我们只需要做好两步：</p>
<ul>
<li>把当前登录用户的权限信息也存入Authentication。</li>
<li>设置我们的资源所需要的权限即可。</li>
</ul>
<h3 id="授权配置"><a href="#授权配置" class="headerlink" title="授权配置"></a>授权配置</h3><h4 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h4><ul>
<li><p>给资源分配权限：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;admin&quot;</span>) <span class="comment">//只允许admin进入</span></span><br><span class="line">        .antMatchers(<span class="string">&quot;/user/**&quot;</span>).hasRole(<span class="string">&quot;user&quot;</span>)  <span class="comment">//允许有user角色的进入</span></span><br><span class="line">        .anyRequest().authenticated() <span class="comment">//一定要放最后</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要让admin有user权限，可以使用角色继承，使上级可能具备下级的所有权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">RoleHierarchy <span class="title">roleHierarchy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> RoleHierarchyImpl hierarchy = <span class="keyword">new</span> RoleHierarchyImpl();</span><br><span class="line"> hierarchy.setHierarchy(<span class="string">&quot;ROLE_admin &gt; ROLE_user&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> hierarchy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，在配置时，需要给角色手动加上 ROLE_ 前缀。上面的配置表示 ROLE_admin 自动具备 ROLE_user 的权限。</p>
</blockquote>
</li>
</ul>
<h4 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h4><ol>
<li><p>添加权限</p>
<ul>
<li><p>先开启相关配置：<code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code></p>
</li>
<li><p>给接口添加权限限制：<code>@PreAuthorize(hasAuthority(&#39;权限名&#39;))</code></p>
<ul>
<li>hasAuthority：只有有这个权限才能访问</li>
<li>hasAnyAuthority：只要有其中任一一个权限即可访问</li>
<li>hasRole：只有有这个角色才能访问（但是会有一个ROLE_前缀）</li>
<li>hasAnyRole：只要有其中任一一个角色即可访问（同样会有ROLE_前缀）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;test&#x27;)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>权限判断可以使用自定义方法：</p>
<ul>
<li><p>先定义方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;ex&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressionRoot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAuthority</span><span class="params">(String authority)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取当前用户的权限</span></span><br><span class="line">        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        LoginUser loginUser = (LoginUser) authentication.getPrincipal();</span><br><span class="line">        List&lt;String&gt; permissions = loginUser.getPermissions();</span><br><span class="line">        <span class="comment">//判断用户权限集合中是否存在authority</span></span><br><span class="line">        <span class="keyword">return</span> permissions.contains(authority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在授权时使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;@ex.hasAuthority(&#x27;system:dept:list&#x27;)&quot;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>获取权限</p>
<ul>
<li><p>给UserDetails添加权限属性(保证登录时将权限存入)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储权限信息</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; permissions;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LoginUser</span><span class="params">(User user,List&lt;String&gt; permissions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.user = user;</span><br><span class="line">    <span class="keyword">this</span>.permissions = permissions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储SpringSecurity所需要的权限信息的集合</span></span><br><span class="line"><span class="meta">@JSONField(serialize = false)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;GrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span>  Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">    <span class="keyword">if</span>(authorities!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中</span></span><br><span class="line">    authorities = permissions.stream().</span><br><span class="line">        map(SimpleGrantedAuthority::<span class="keyword">new</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> authorities;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在登录时从数据库查询权限列表封装成loginUser</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//根据用户名查询用户信息</span></span><br><span class="line">    User user = userMapper.selectOne(<span class="keyword">new</span> LambdaQueryWrapper&lt;User&gt;().eq(User::getUserName,username));</span><br><span class="line">    <span class="comment">//如果查询不到数据就通过抛出异常来给出提示</span></span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(user))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装成UserDetails对象返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoginUser(user,menuMapper.selectPermsByUserId(user.getId()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在认证过滤时封装进Authentication</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UsernamePasswordAuthenticationToken authenticationToken =</span><br><span class="line">   <span class="keyword">new</span> UsernamePasswordAuthenticationToken(loginUser,<span class="keyword">null</span>,loginUser.getAuthorities());</span><br></pre></td></tr></table></figure>
<h2 id="统一处理认证与授权异常"><a href="#统一处理认证与授权异常" class="headerlink" title="统一处理认证与授权异常"></a>统一处理认证与授权异常</h2></li>
</ul>
</li>
</ol>
<p>在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。</p>
<p>​    如果是认证过程中出现的异常会被封装成AuthenticationException然后调用<strong>AuthenticationEntryPoint</strong>对象的方法去进行异常处理。</p>
<p>​    如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用<strong>AccessDeniedHandler</strong>对象的方法去进行异常处理。</p>
<p>直接可以在配置类中进行配置（也可以实现接口）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置异常处理器</span></span><br><span class="line">        http.exceptionHandling()</span><br><span class="line">            .authenticationEntryPoint((req, resp, authException) -&gt; &#123;</span><br><span class="line">                WebUtils.renderString(resp,JSON.toJSONString(ResponseEntityDemo.failed(ResultCode.UNAUTHORIZED)));</span><br><span class="line">            &#125;)</span><br><span class="line">            .accessDeniedHandler((req, resp, authException) -&gt; &#123;</span><br><span class="line">                WebUtils.renderString(resp,JSON.toJSONString(ResponseEntityDemo.failed(ResultCode.FORBIDDEN)));</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring全家桶</category>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch</title>
    <url>/2023/03/11/%E4%B8%AD%E9%97%B4%E4%BB%B6/Elasticsearch/ElasticSearch/</url>
    <content><![CDATA[<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Elasticsearch 是一个分布式、可扩展、实时的搜索与数据分析引擎，建立在一个全文搜索引擎库 Apache Lucene™基础之上，是整个 ElasticStack 技术栈的核心。ES是采用java语言编写，提供了简单易用的RestFul API，开发者可以使用其简单的RestFul API，开发相关的搜索功能，从而避免lucene的复杂性。</p>
<p><strong>优点：</strong></p>
<ul>
<li>一个分布式的实时文档存储，<em>每个字段</em>可以被索引与搜索</li>
<li>一个分布式实时分析搜索引擎</li>
<li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</li>
</ul>
<blockquote>
<p>ElasticStack ：包括 Elasticsearch、 Kibana、 Beats 和 Logstash（也称为 ELK Stack）</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Docker方式安装"><a href="#Docker方式安装" class="headerlink" title="Docker方式安装"></a>Docker方式安装</h3><ol>
<li><p>获取镜像：<code>docker pull elasticsearch:7.14.0</code></p>
</li>
<li><p>创建数据目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /opt/docker_app/elasticsearch/config</span><br><span class="line">mkdir -p /opt/docker_app/elasticsearch/logs</span><br><span class="line">mkdir -p /opt/docker_app/elasticsearch/data</span><br><span class="line">mkdir -p /opt/docker_app/elasticsearch/plugins</span><br></pre></td></tr></table></figure></li>
<li><p>创建配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;http.host: 0.0.0.0&quot;&gt;&gt;/opt/docker_app/elasticsearch/config/elasticsearch.yml</span><br></pre></td></tr></table></figure></li>
<li><p>系统配置修改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br><span class="line">vm.max_map_count=655360</span><br><span class="line">sysctl -p /etc/sysctl.conf/</span><br></pre></td></tr></table></figure></li>
<li><p>创建容器：(注意不能用root用户启动)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms1g -Xmx2g&quot; --restart=always -v /opt/docker_app/elasticsearch/config/elasticsearch.yml:/config/elasticsearch.yml -v /opt/docker_app/elasticsearch/data:/elasticsearch/data -v /opt/docker_app/elasticsearch/plugins:/elasticsearch/plugins -v /opt/docker_app/elasticsearch/logs:/elasticsearch/logs -d elasticsearch:7.14.0</span><br></pre></td></tr></table></figure></li>
<li><p>检查是否连接成功：浏览器输入<a href="http://ip:9200/">http://ip:9200</a></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220914183156571.png" alt="image-20220914183156571"></p>
</li>
<li><p>安装成功</p>
</li>
</ol>
<h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h2><p>Kibana是一个针对Elasticsearch的开源分析及可视化平台，使用Kibana可以查询、查看并与存储在ES索引的数据进行交互操作，使用Kibana能执行高级的数据分析，并能以图表、表格和地图的形式查看数据。（当然如果对esAPI很熟悉的话可以使用postman）</p>
<h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><ol>
<li><p>拉取镜像：<code>docker pull kibana:7.14.0</code></p>
</li>
<li><p>创建数据目录以及配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /opt/docker_app/kibana/config </span><br><span class="line">vim kibana.yml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">配置内容：</span></span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line">server.shutdownTimeout: &quot;5s&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">集群</span></span><br><span class="line">elasticsearch.hosts: [ &quot;http://localhost:9200&quot; ]</span><br><span class="line"><span class="meta">#</span><span class="bash">elasticsearch中用户名和密码</span></span><br><span class="line"><span class="meta">#</span><span class="bash">elasticsearch.username: <span class="string">&quot;kibana_system&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">elasticsearch.password: <span class="string">&quot;JNeepMbbA0inbAI8voK3&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">设置kibana中文显示</span></span><br><span class="line">i18n.locale: zh-CN</span><br></pre></td></tr></table></figure></li>
<li><p>启动容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name=kibana -p 5601:5601 --restart=always -v /opt/docker_app/kibana/config/kibana.yml:/usr/share/kibana/config/kibana.yml kibana:7.14.0</span><br></pre></td></tr></table></figure></li>
<li><p>进入kibana：<a href="http://ip:5601/">http://ip:5601</a></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220914201331121.png" alt="image-20220914201331121"></p>
</li>
</ol>
<h4 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h4><h5 id="设置es密码"><a href="#设置es密码" class="headerlink" title="设置es密码"></a>设置es密码</h5><ul>
<li><p>在配置文件中进行配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line">http.cors.allow-headers: Authorization</span><br><span class="line">xpack.security.enabled: true</span><br><span class="line">xpack.security.transport.ssl.enabled: true</span><br></pre></td></tr></table></figure></li>
<li><p>进入容器执行<code>./bin/elasticsearch-setup-passwords interactive</code></p>
</li>
<li><p>期间设置各种账号密码</p>
<blockquote>
<p>账号：</p>
<ul>
<li>elastic：超级管理员账号</li>
<li>kibana：Kibana访问专用账号</li>
<li>logstash_system：Logstash访问专用账号</li>
<li>beats_system：FileBeat访问专用账号</li>
<li>apm_system：APM系统专用账号</li>
<li>remote_monitoring_user：远程监控账号</li>
</ul>
</blockquote>
</li>
<li><p>此时进入es就需要输入账号密码了（可以选择上面注册的各种账号密码）</p>
</li>
</ul>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引<Index></h3><p>一个索引就是一个拥有几分相似特征的文档的集合，一个 索引 类似于传统关系数据库中的一个 数据库 ，是一个存储关系型文档的地方。比如说，你可以有一个商品数据的索引，一个订单数据的索引，还有一个用户数据的索引。一个索引由一个名字来标识（必须全部是小写字母的)，并且当我们要对这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。</p>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射<Mapping></h3><p>映射是定义一个文档和它所包含的字段如何被存储和索引的过程。在默认配置下，ES可以根据插入的数据自动地创建mapping，也可以手动创建mapping。mapping中主要包括字段名、字段类型等</p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档<Document></h3><p>文档是索引中存储的一条条数据。一条文档是一个可被索引的最小单元。ES中的文档采用了轻量级的JSON格式数据来表示。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><ul>
<li><p>创建索引：<code>PUT /索引名</code>（默认ES在创建索引时会为索引创建1个备份索引和一个primary索引）</p>
<ul>
<li><p>例子：<code>PUT /products</code></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220914205524808.png" alt="image-20220914205524808"></p>
<p>由于主索引和备份索引在同一台机器上（这样并不安全），所以当前索引状态为yellow</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">可以不创建备份索引：</span></span><br><span class="line">PUT /goods</span><br><span class="line">&#123;</span><br><span class="line">	&quot;settings&quot;:&#123;</span><br><span class="line">		&quot;number_of_shards&quot;: 1,</span><br><span class="line">		&quot;number_of_replicas&quot;: 0</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220914210033118.png" alt="image-20220914210033118"></p>
<blockquote>
<p>ES中索引健康转态red(索引不可用)、yellwo(索引可用,存在风险)、green(健康)</p>
</blockquote>
</li>
</ul>
</li>
<li><p>查看es中所有索引：<code>GET /_cat/indices</code>或者<code>GET /_cat/indices?v</code>(带上标题)</p>
</li>
<li><p>删除索引：<code>DELETE /索引名</code></p>
</li>
</ul>
<h3 id="映射操作"><a href="#映射操作" class="headerlink" title="映射操作"></a>映射操作</h3><ul>
<li><p>创建映射（创建索引时一起创建）</p>
<ul>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建索引以及映射</span></span><br><span class="line">PUT /products</span><br><span class="line">&#123;</span><br><span class="line">	&quot;settings&quot;:&#123;</span><br><span class="line">		&quot;number_of_shards&quot;: 1,</span><br><span class="line">		&quot;number_of_replicas&quot;: 0</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;mappings&quot;: &#123;</span><br><span class="line">	  &quot;properties&quot;: &#123;</span><br><span class="line">	    &quot;id&quot;:&#123;</span><br><span class="line">	      &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">	    &#125;,</span><br><span class="line">	    &quot;title&quot;:&#123;</span><br><span class="line">	      &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">	    &#125;,</span><br><span class="line">	    &quot;price&quot;:&#123;</span><br><span class="line">	      &quot;type&quot;: &quot;double&quot;</span><br><span class="line">	    &#125;,</span><br><span class="line">	    &quot;created_at&quot;:&#123;</span><br><span class="line">	      &quot;type&quot;: &quot;date&quot;</span><br><span class="line">	    &#125;,</span><br><span class="line">	    &quot;description&quot;:&#123;</span><br><span class="line">	      &quot;type&quot;: &quot;text&quot;</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>映射类型：</strong></p>
<ul>
<li>字符串类型：keyword关键词、text文本</li>
<li>数字类型：intrger、long</li>
<li>小数类型：float、double</li>
<li>布尔类型：boolean</li>
<li>日期类型：date</li>
<li>IPv4及IPv6地址类型：ip</li>
<li>自动判断字段类型：Auto</li>
<li>Nested：嵌套对象类型</li>
<li>….更多查看<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.15/mapping-types.html">官网</a></li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>查看索引的映射信息：<code>GET /索引名/_mapping</code></p>
</li>
</ul>
<h3 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h3><ul>
<li><p>添加文档：<code>POST /索引名/_doc/[id]</code></p>
<ul>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">自动生成文档_id方式</span></span><br><span class="line">POST /products/_doc/</span><br><span class="line">&#123;</span><br><span class="line">	&quot;title&quot; : &quot;可口可乐&quot; ,</span><br><span class="line">	&quot;price&quot;: 3.5,</span><br><span class="line">	&quot;created_at&quot; : &quot;2022-09-15&quot;，</span><br><span class="line">	&quot;description&quot; : &quot;肥宅快乐水&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">指定义文档_id</span></span><br><span class="line">POST /products/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">	&quot;id&quot;: 1</span><br><span class="line">	&quot;title&quot; : &quot;卫龙小辣棒&quot; ,</span><br><span class="line">	&quot;price&quot;: 6.2,</span><br><span class="line">	&quot;created_at&quot; : &quot;2022-09-15&quot;,</span><br><span class="line">	&quot;description&quot; : &quot;辣条&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>查询文档：<code>GET /索引名/_doc/_id值</code></p>
</li>
<li><p>删除文档：<code>DELETE /索引名/_doc/_id值</code></p>
</li>
<li><p>更新文档：</p>
<ul>
<li><p>方式一：<code>PUT /索引名/_doc/_id值&#123;文档内容&#125;</code>(这种方式会删除原来的文档，重新添加)</p>
</li>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新文档</span></span><br><span class="line">PUT /products/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">	&quot;price&quot;:6.5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方式二：</p>
</li>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新文档2</span></span><br><span class="line">POST /products/_doc/1/_update</span><br><span class="line">&#123;   </span><br><span class="line">  &quot;doc&quot;:&#123;</span><br><span class="line">    &quot;price&quot;:4.8</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>批量操作：<code>POST /索引名/_doc/_bulk&#123;操作数据&#125;</code></p>
<ul>
<li><p>例子1批量插入(注意数据不能换行)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;products&#x2F;_doc&#x2F;_bulk</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:2&#125;&#125;</span><br><span class="line">  &#123;&quot;id&quot;: 2,&quot;title&quot; : &quot;百事可乐&quot; ,&quot;price&quot;: 3.0,&quot;created_at&quot; : &quot;2022-09-15&quot;,&quot;description&quot; : &quot;肥宅快乐水02&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:3&#125;&#125;</span><br><span class="line">  &#123;&quot;id&quot;: 3,&quot;title&quot; : &quot;乐事薯片&quot; ,&quot;price&quot;: 6.9,&quot;created_at&quot; : &quot;2022-09-15&quot;,&quot;description&quot; : &quot;看电视时吃&quot;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>例子2批量各种操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">批量添加更新删除</span></span><br><span class="line">POST /products/_doc/_bulk</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:4&#125;&#125;</span><br><span class="line">  &#123;&quot;id&quot;: 4,&quot;title&quot; : &quot;口香糖&quot; ,&quot;price&quot;: 9.9,&quot;created_at&quot; : &quot;2022-09-15&quot;,&quot;description&quot; : &quot;清新口气&quot;&#125;</span><br><span class="line">&#123;&quot;update&quot;:&#123;&quot;_id&quot;:3&#125;&#125;</span><br><span class="line">  &#123;&quot;doc&quot;:&#123;&quot;price&quot;:7.9&#125;&#125;</span><br><span class="line">&#123;&quot;delete&quot;:&#123;&quot;_id&quot;:2&#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明:批量时不会因为一个失败而全部失败,而是继续执行后续操作,在返回时按照执行的状态返回!</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h2><h3 id="DSL查询"><a href="#DSL查询" class="headerlink" title="DSL查询"></a>DSL查询</h3><p>ES中提供了一种强大的检索数据方式,这种检索方式称之为<code>Query DSL</code><DomainSpecified Language>，查询表达式(Query DSL)是一种非常灵活又富有表现力的查询语言，Query DSL是利用Rest API传递JSON格式的请求体(RequestBody)数据与ES进行交互，这种方式的丰富查询语法让ES检索变得更强大，更简洁。</p>
<p><strong>基础语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /索引名/_search &#123;json格式请求体数据&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>查询所有：使用<code>match_all</code>来表示</p>
<ul>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查询所有</span></span><br><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;match_all&quot;:&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>关键词查询：使用<code>term</code>进行查询</p>
<ul>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 条件查询02</span></span><br><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &#123;</span><br><span class="line">      	&quot;value&quot;:&quot;可口可乐&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>keyword、integer、double等除text类型需要精确匹配，text类型由于采用标准分词器，按照单字单词分词所以只能按照单字单词查询。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>条件查询：使用<code>match</code>表示匹配条件</p>
<ul>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 条件查询</span></span><br><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;price&quot;: 3.5</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于数值类型<code>match</code>操作使用的是精确匹配，对于text文本类型使用的是模糊匹配。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>范围查询：使用<code>range</code>来指定范围</p>
<ul>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 范围查询 gt大于/gte大于等于/lt小于/lte小于等于</span></span><br><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: 1,</span><br><span class="line">        &quot;lte&quot;: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>前缀查询：使用<code>prefix</code>表示前缀(依然根据关键词查询)</p>
<ul>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">前缀查询</span></span><br><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;prefix&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;乐事&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>通配符查询：使用<code>wildcard</code>表示使用通配符查询（<code>*</code>代表多个任意字符<code>?</code>代表一个字符）</p>
<ul>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">通配符查询</span></span><br><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;wildcard&quot;: &#123;</span><br><span class="line">      &quot;description&quot;:&#123;</span><br><span class="line">        &quot;value&quot;: &quot;看*&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>根据_id查询：使用<code>ids</code>根据多个id查询</p>
<ul>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 根据_id查询</span></span><br><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;ids&quot;: &#123;</span><br><span class="line">      &quot;values&quot;: [1,2,3]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>模糊查询：使用<code>fuzzy</code>表示模糊查询</p>
<ul>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">模糊查询</span></span><br><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;fuzzy&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;乐事&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: <code>fuzzy</code>模糊查询最大模糊错误必须在0-2之间</p>
<ul>
<li>搜索关键词长度为2不允许存在模糊</li>
<li>搜索关键词长度为3-5允许一次模糊</li>
<li>搜索关键词长度大于5允许最大2模糊</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>布尔查询：使用<code>bool</code>来组合多个条件实现复杂查询</p>
<ul>
<li><p>关键字：</p>
<ul>
<li><code>must</code>：相当于与，表示同时满足</li>
<li><code>should</code>：相当于或，表示满足其中任意一个</li>
<li><code>must_not</code>：相当于非，表示同时不满足</li>
</ul>
</li>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">布尔查询</span></span><br><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;ids&quot;: &#123;&quot;values&quot;: [1,3,5]&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;prefix&quot;: &#123;</span><br><span class="line">            &quot;title&quot;: &#123;</span><br><span class="line">              &quot;value&quot;: &quot;乐事&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>多字段查询：使用<code>multi_match</code>表示根据多字段查询（multi_match同match一样text进行模糊查询，其他进行精确查询）</p>
<ul>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">多字段查询</span></span><br><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &quot;乐事&quot;,</span><br><span class="line">      &quot;price&quot;: 3.5</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>默认字段分词查询：使用<code>query_string</code>开启默认字段分词查询（如果之前分词就按照分词查找，不分词就按照不分词来查找）</p>
<ul>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">默认字段分词查询</span></span><br><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;query_string&quot;: &#123;</span><br><span class="line">      &quot;default_field&quot;: &quot;title&quot;,</span><br><span class="line">      &quot;query&quot;: &quot;乐事薯片&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>高亮查询：使用<code>highlight</code>可以让符合条件的文档中的关键词高亮</p>
<ul>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">高亮查询</span></span><br><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;query_string&quot;: &#123;</span><br><span class="line">      &quot;default_field&quot;: &quot;description&quot;,</span><br><span class="line">      &quot;query&quot;: &quot;电视快乐睡&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;highlight&quot;: &#123;</span><br><span class="line"><span class="meta">  	#</span><span class="bash"> 设置前置标签默认为&lt;em&gt;</span></span><br><span class="line">    &quot;pre_tags&quot;: [&quot;&lt;span style=&#x27;color:red;&#x27;&gt;&quot;], </span><br><span class="line">    # 设置后置标签默认为&lt;/em&gt;</span><br><span class="line">    &quot;post_tags&quot;: [&quot;&lt;/span&gt;&quot;],</span><br><span class="line">    # 设置字段匹配的校验默认只能是text字段，但是必须能够分词才行</span><br><span class="line">    &quot;require_field_match&quot;: &quot;false&quot;, </span><br><span class="line">    # 规定哪些字段高亮</span><br><span class="line">    &quot;fields&quot;: &#123;</span><br><span class="line">      &quot;*&quot;:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220915215124736.png" alt="image-20220915215124736"></p>
</li>
</ul>
</li>
<li><p>分页查询：使用<code>size</code>和<code>from</code>来控制分页大小</p>
<ul>
<li><p>关键字：</p>
<ul>
<li><code>size</code>：指定查询结果中的返回条数</li>
<li><code>from</code>：用来指定起始返回位置</li>
</ul>
</li>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">分页</span></span><br><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;query_string&quot;: &#123;</span><br><span class="line">      &quot;default_field&quot;: &quot;description&quot;,</span><br><span class="line">      &quot;query&quot;: &quot;电视快乐睡&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;highlight&quot;: &#123;</span><br><span class="line">    &quot;pre_tags&quot;: [&quot;&lt;span style=&#x27;color:red;&#x27;&gt;&quot;], </span><br><span class="line">    &quot;post_tags&quot;: [&quot;&lt;/span&gt;&quot;],</span><br><span class="line">    &quot;require_field_match&quot;: &quot;false&quot;, </span><br><span class="line">    &quot;fields&quot;: &#123;</span><br><span class="line">      &quot;*&quot;:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ,</span><br><span class="line">  &quot;size&quot;: 1,</span><br><span class="line">  &quot;from&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>指定排序：使用<code>sort</code>表示进行排序，并用<code>order</code>指定降序还是升序</p>
<ul>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">指定排序</span></span><br><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;match_all&quot;:&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>指定返回字段：使用<code>_source</code>指明要返回的字段</p>
<ul>
<li><p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定返回字段</span></span><br><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;match_all&quot;:&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_source&quot;: [</span><br><span class="line">    &quot;description&quot;, &quot;title&quot; </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="过滤查询"><a href="#过滤查询" class="headerlink" title="过滤查询"></a>过滤查询</h3></li>
</ul>
</li>
</ul>
<p>过滤查询<filter query>，其实准确来说，ES中的查询操作分为2种:查询(query)和过滤(filter)。查询即是之前提到的Query DSL 查询，它(查询)默认会计算每个返回文档的得分，然后根据得分排序。而过滤(filter)只会筛选出符合的文档，并不计算得分，而且它可以缓存文档。</p>
<p>所以，单从性能考虑，过滤比查询更快。换句话说过滤适合在大范围筛选数据，而查询则适合精确匹配数据。一般应用时，应先使用过滤操作过滤数据，然后使用查询匹配数据。</p>
<p><strong>基础语法：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /索引/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;&quot;match_all&quot;: &#123;&#125;&#125; //查询条件</span><br><span class="line">      ],</span><br><span class="line">      #过滤条件（会在query之前执行，并且ES会缓存经常使用的过滤器）</span><br><span class="line">      &quot;filter&quot;: &#123;...&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>term、terms过滤器：根据关键词过滤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用term过滤</span></span><br><span class="line">GET /products/_search   </span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;&quot;term&quot;: &#123;</span><br><span class="line">          &quot;name&quot;: &#123;</span><br><span class="line">            &quot;value&quot;: &quot;可口可乐&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;term&quot;: &#123;</span><br><span class="line">          &quot;description&quot;:&quot;好吃&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用terms过滤</span></span><br><span class="line">GET /products/_search  </span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;&quot;term&quot;: &#123;</span><br><span class="line">          &quot;name&quot;: &#123;</span><br><span class="line">            &quot;value&quot;: &quot;可口可乐&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;terms&quot;: &#123;</span><br><span class="line">          &quot;description&quot;:[&quot;饮料&quot;,&quot;好吃&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ranage过滤器：根据范围过滤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ranage过滤器</span></span><br><span class="line">GET /products/_search  </span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;&quot;term&quot;: &#123;</span><br><span class="line">          &quot;name&quot;: &#123;</span><br><span class="line">            &quot;value&quot;: &quot;可口可乐&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;ranage&quot;: &#123;</span><br><span class="line">          &quot;price&quot;: &#123;</span><br><span class="line">            &quot;gte&quot;: 0,</span><br><span class="line">            &quot;lte&quot;: 5.2</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>exists过滤器：过滤存在指定字段,获取字段不为空的索引记录使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> exists过滤器</span></span><br><span class="line">GET /products/_search  </span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;&quot;term&quot;: &#123;</span><br><span class="line">          &quot;name&quot;: &#123;</span><br><span class="line">            &quot;value&quot;: &quot;可口可乐&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;exists&quot;: &#123;</span><br><span class="line">          &quot;field&quot;:&quot;price&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ids过滤器：过滤含有指定_id的索引记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ids过滤器</span></span><br><span class="line">GET /products/_search  </span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;&quot;term&quot;: &#123;</span><br><span class="line">          &quot;name&quot;: &#123;</span><br><span class="line">            &quot;value&quot;: &quot;可口可乐&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;ids&quot;: &#123;</span><br><span class="line">          &quot;values&quot;: [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><p>聚合︰<strong>英文为Aggregation Aggs，是es除搜索功能外提供的针对es数据做统计分析的功能</strong>。聚合有助于根据搜索查询提供聚合数据。聚合查询是数据库中重要的功能特性，ES作为搜索引擎兼数据库，同样提供了强大的聚合分析能力。它基于查询条件来对数据进行分桶、计算的方法。有点类似于SQL中的group by再加一些函数方法的操作。</p>
<blockquote>
<p>注意：text类型不支持聚合查询</p>
</blockquote>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li><p>根据某个字段进行分组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  , &quot;aggs&quot;: &#123;</span><br><span class="line"><span class="meta">  	#</span><span class="bash"> 分组名称（自定义）</span></span><br><span class="line">    &quot;price_group&quot;: &#123;</span><br><span class="line">      # 分组字段</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220921215721643.png" alt="image-20220921215721643" style="zoom:67%;" />
</li>
<li><p>求最大/小值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  , &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;max_price&quot;: &#123;</span><br><span class="line">      &quot;max/min&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220921215943972.png" alt="image-20220921215943972" style="zoom:67%;" />
</li>
<li><p>求平均值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  , &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;avg_price&quot;: &#123;</span><br><span class="line">      &quot;avg&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220921220130957.png" alt="image-20220921220130957" style="zoom:67%;" />

</li>
</ul>
<h2 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h2><h3 id="Analysis和Analyzer"><a href="#Analysis和Analyzer" class="headerlink" title="Analysis和Analyzer"></a>Analysis和Analyzer</h3><p>Analysis∶文本分析是把全文本转换一系列单词(term/token)的过程，也叫分词。</p>
<p>Analysis是通过Analyzer来实现的。分词就是将文档通过Analyzer分成一个一个的Term,每一个Term都指向包含这个Term的文档。</p>
<h4 id="Analyzer组成"><a href="#Analyzer组成" class="headerlink" title="Analyzer组成"></a>Analyzer组成</h4><p>在ES中默认使用标准分词器: StandardAnalyzer，其会将中文分为一个字一个字，将英文分为一个单词一个单词。</p>
<p>Analyzer主要由三个部分组成：<code>character filters </code>、<code>tokenizers</code>、<code>token filters</code></p>
<ul>
<li><p><strong>character filters：</strong></p>
<p>字符过滤器，在一段文本进行分词之前，先进行预处理。</p>
</li>
<li><p><strong>tokenizers：</strong></p>
<p>分词器，英文分词可以根据空格将单词分开,中文分词比较复杂,可以采用机器学习算法来分词。</p>
</li>
<li><p><strong>token filters：</strong></p>
<p>Token过滤器，将切分的单词进行加工。大小写转换（例将“Quick”转为小写)，去掉停用词（例如停用词像“a”、“and”、“the”等等)，加入同义词（例如同义词像”jump”和“leap”)。</p>
</li>
</ul>
<h3 id="内置分词器"><a href="#内置分词器" class="headerlink" title="内置分词器"></a>内置分词器</h3><ul>
<li>Standard Analyzer：默认分词器，按照单词分词英文统一转为小写过滤标点符号中文单字分词，并小写处理</li>
<li>Simple Analyzer：英文按照单词分词英文统一转为小写，去掉符号，中文按照空格分词，小写处理</li>
<li>Stop Analyzer ：小写处理，停用词过滤(the,a,is)</li>
<li>Whitespace Analyzer：中文英文按照空格分词，英文不会转为小写不去掉标点符号，不转小写</li>
<li>Keyword Analyzer：不分词，直接将输入当作输出</li>
</ul>
<blockquote>
<p>如果需要对分词器进行测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line">&#123;</span><br><span class="line">	&quot;analyzer&quot;:&quot;分词器简名如：standard&quot;,</span><br><span class="line">	&quot;text&quot;: &quot;分词文本&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建索引时设置分词器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT /products</span><br><span class="line">&#123;</span><br><span class="line">	&quot;settings&quot;:&#123;</span><br><span class="line">		&quot;number_of_shards&quot;: 1,</span><br><span class="line">		&quot;number_of_replicas&quot;: 0</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;mappings&quot;: &#123;</span><br><span class="line">	  &quot;properties&quot;: &#123;</span><br><span class="line">	    &quot;title&quot;:&#123;</span><br><span class="line">	      &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">	      # 指定分词器</span><br><span class="line">	      &quot;analyzer&quot;:&quot;standard&quot;</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h3><p>IK分词器是ES的一个插件，主要用于把一段中文或者英文的划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一个匹配操作，默认的中文分词器是将每个字看成一个词。</p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><ul>
<li>下载IK分词器(<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases)%EF%BC%8C%E6%B3%A8%E6%84%8F%E7%89%88%E6%9C%AC%E8%A6%81%E4%B8%8EES%E7%89%88%E6%9C%AC%E4%B8%80%E8%87%B4">https://github.com/medcl/elasticsearch-analysis-ik/releases)，注意版本要与ES版本一致</a></li>
<li>下载后解压上传到docker容器的插件数据卷中：<code>/opt/docker_app/elasticsearch/plugins</code></li>
<li>重启容器</li>
</ul>
<h4 id="测试使用"><a href="#测试使用" class="headerlink" title="测试使用"></a>测试使用</h4><p>IK有两种颗粒度的拆分：</p>
<ul>
<li><code>ik_smart</code>：会做最粗粒度的拆分</li>
<li><code>ik_max_word</code>：会将文本做最细粒度的拆分</li>
</ul>
<p>ik_smart测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line">&#123;</span><br><span class="line">	&quot;analyzer&quot;:&quot;ik_smart&quot;,</span><br><span class="line">	&quot;text&quot;: &quot;分词文本真的不错&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220916213726050.png" alt="image-20220916213726050" style="zoom:67%;" />

<p>ik_max_word测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;_analyze</span><br><span class="line">&#123;</span><br><span class="line">	&quot;analyzer&quot;:&quot;ik_max_word&quot;,</span><br><span class="line">	&quot;text&quot;: &quot;分词文本真的不错&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220916213835329.png" alt="image-20220916213835329" style="zoom:67%;" />

<h4 id="扩展词、停用词配置"><a href="#扩展词、停用词配置" class="headerlink" title="扩展词、停用词配置"></a>扩展词、停用词配置</h4><p>IK分词器支持自定义<code>扩展词典</code>和<code>停用词典</code></p>
<p><strong>扩展词典：</strong>就是有些词并不是关键词,但是也希望被ES用来作为检索的关键词,可以将这些词加入扩展词典。</p>
<p><strong>停用词典：</strong>就是有些词是关键词,但是出于业务场景不想使用这些关键词被检索到，可以将这些词放入停用词典。</p>
<p>定义扩展词典和停用词典可以修改IK分词器中config目录中IKAnalyzer.cfg.xml这个文件。</p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><ol>
<li><p>先创建扩展词和停用词的.dic文件（注意文件中一行只能放一个词）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建并输入扩展词</span></span><br><span class="line">vim ext_dict.dic</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建并输入停用词</span></span><br><span class="line">vim ext_stopword.dic</span><br></pre></td></tr></table></figure></li>
<li><p>在IKAnalyzer.cfg.xml中配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim IKAnalyzer.cfg.xml</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">        &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;</span><br><span class="line">        &lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span><br><span class="line">        &lt;entry key=&quot;ext_dict&quot;&gt;ext_dict.dic&lt;/entry&gt;</span><br><span class="line">         &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span><br><span class="line">        &lt;entry key=&quot;ext_stopwords&quot;&gt;ext_stopword.dic&lt;/entry&gt;</span><br><span class="line">        &lt;!--用户可以在这里配置远程扩展字典 --&gt;</span><br><span class="line">        &lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt;</span><br><span class="line">        &lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span><br><span class="line">        &lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>
<p>3 . 重启es</p>
</li>
</ol>
<blockquote>
<p>当然一般可以使用他所提供的字典：</p>
<ul>
<li>扩展词典：extra_main.dic</li>
<li>停用词典：extra_stopword.dic</li>
</ul>
</blockquote>
<h2 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h2><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisClientConfig</span> <span class="keyword">extends</span> <span class="title">AbstractElasticsearchConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.elasticsearch.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">elasticsearchClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ClientConfiguration clientConfiguration = ClientConfiguration.builder()</span><br><span class="line">                .connectedTo(host)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> RestClients.create(clientConfiguration).rest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置之后，会在spring工厂中创建RestHighLevelClient对象（之前的restful交互方式）和ElasticSearchOperations对象（面向对象的方式）</p>
</blockquote>
<h3 id="客户端对象"><a href="#客户端对象" class="headerlink" title="客户端对象"></a>客户端对象</h3><h4 id="ElasticSearchOperations"><a href="#ElasticSearchOperations" class="headerlink" title="ElasticSearchOperations"></a>ElasticSearchOperations</h4><ul>
<li>特点：以面向对象的方式操作ElasticSearch</li>
</ul>
<p><strong>相关注解：</strong></p>
<ul>
<li>@Document(indexName=”索引名”,createIndex = true)：用在类上，代表一个对象为一个文档<ul>
<li>indexName：指定索引名</li>
<li>createIndex：是否创建索引（不存在则创建）</li>
</ul>
</li>
<li>@Id：用在属性上，指定字段与es文档中_id对应</li>
<li>@Field(type =  FieldType.keyword,analyzer=”ik_max_word”)：用在属性上，描述属性在es中存储类型以及分词情况<ul>
<li>type：用于指定字段类型</li>
<li>analyzer：指定分词器</li>
</ul>
</li>
</ul>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><ul>
<li><p>文档实体：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Document(indexName = &quot;products&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="meta">@Field(type = FieldType.Float)</span></span><br><span class="line">    <span class="keyword">private</span> Double price;</span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text,analyzer = &quot;ik_max_word&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EsDemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ElasticsearchOperations operations;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * save方法如果id不存在则插入，如果id存在则更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product(<span class="number">1</span>,<span class="string">&quot;可口可乐&quot;</span>,<span class="number">3.5</span>,<span class="string">&quot;可乐很好喝，肥宅快乐水&quot;</span>);</span><br><span class="line">        operations.save(product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSearch</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//根据id查询</span></span><br><span class="line">        Product product = operations.get(<span class="string">&quot;1&quot;</span>, Product.class);</span><br><span class="line">        System.out.println(product);</span><br><span class="line">        <span class="comment">//查询所有</span></span><br><span class="line">        SearchHits&lt;Product&gt; searchHits = operations.search(Query.findAll(), Product.class);</span><br><span class="line">        System.out.println(searchHits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testDel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//根据id删除</span></span><br><span class="line">        operations.delete(<span class="string">&quot;1&quot;</span>, Product.class);</span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        product.setId(<span class="number">1</span>);</span><br><span class="line">        operations.delete(product);</span><br><span class="line">        <span class="comment">//删除所有</span></span><br><span class="line">        operations.delete(Query.findAll(),Product.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RestHighLevelClient"><a href="#RestHighLevelClient" class="headerlink" title="RestHighLevelClient"></a>RestHighLevelClient</h4></li>
<li><p>测试索引操作：</p>
<ul>
<li><p>创建索引：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateIndexAndMapping</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//参数1：创建索引请求对象，参数2：请求配置对象</span></span><br><span class="line">    CreateIndexRequest createIndexRequest = <span class="keyword">new</span> CreateIndexRequest(<span class="string">&quot;goods&quot;</span>);</span><br><span class="line">    <span class="comment">//指定映射,以json形式</span></span><br><span class="line">    createIndexRequest.mapping(<span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">                               <span class="string">&quot;\t  \&quot;properties\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">                               <span class="string">&quot;\t    \&quot;id\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">                               <span class="string">&quot;\t      \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">                               <span class="string">&quot;\t    &#125;,\n&quot;</span> +</span><br><span class="line">                               <span class="string">&quot;\t    \&quot;title\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">                               <span class="string">&quot;\t      \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">                               <span class="string">&quot;\t    &#125;,\n&quot;</span> +</span><br><span class="line">                               <span class="string">&quot;\t    \&quot;price\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">                               <span class="string">&quot;\t      \&quot;type\&quot;: \&quot;double\&quot;\n&quot;</span> +</span><br><span class="line">                               <span class="string">&quot;\t    &#125;,\n&quot;</span> +</span><br><span class="line">                               <span class="string">&quot;\t    \&quot;created_at\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">                               <span class="string">&quot;\t      \&quot;type\&quot;: \&quot;date\&quot;\n&quot;</span> +</span><br><span class="line">                               <span class="string">&quot;\t    &#125;,\n&quot;</span> +</span><br><span class="line">                               <span class="string">&quot;\t    \&quot;description\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">                               <span class="string">&quot;\t      \&quot;type\&quot;: \&quot;text\&quot;\n&quot;</span> +</span><br><span class="line">                               <span class="string">&quot;\t    &#125;\n&quot;</span> +</span><br><span class="line">                               <span class="string">&quot;\t  &#125;\n&quot;</span> +</span><br><span class="line">                               <span class="string">&quot;\t&#125;&quot;</span>, XContentType.JSON);</span><br><span class="line">    CreateIndexResponse createIndexResponse = restHighLevelClient.indices().create(createIndexRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//查看是否创建成功</span></span><br><span class="line">    System.out.println(createIndexResponse.isAcknowledged());</span><br><span class="line">    restHighLevelClient.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除索引：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//参数1：删除索引请求对象，参数2：请求配置对象</span></span><br><span class="line">    AcknowledgedResponse acknowledgedResponse = restHighLevelClient.indices().delete(<span class="keyword">new</span> DeleteIndexRequest(<span class="string">&quot;goods&quot;</span>), RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(acknowledgedResponse.isAcknowledged());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>测试文档操作：</p>
<ul>
<li><p>插入文档：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//指定索引</span></span><br><span class="line">    IndexRequest indexRequest = <span class="keyword">new</span> IndexRequest(<span class="string">&quot;goods&quot;</span>);</span><br><span class="line">    <span class="comment">//指定文档id</span></span><br><span class="line">    indexRequest.id(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">//指定文档内容</span></span><br><span class="line">    indexRequest.source(<span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;\t\&quot;title\&quot; : \&quot;卫龙小辣棒\&quot;,\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;\t\&quot;price\&quot;:6.2,\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;\t\&quot;created_at\&quot; : \&quot;2022-09-15\&quot;,\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;\t\&quot;description\&quot; : \&quot;辣条\&quot;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;&#125;&quot;</span>, XContentType.JSON);</span><br><span class="line">    IndexResponse response = restHighLevelClient.index(indexRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//获取插入状态</span></span><br><span class="line">    System.out.println(response.status());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>更新文档：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//指定索引以及id</span></span><br><span class="line">    UpdateRequest updateRequest = <span class="keyword">new</span> UpdateRequest(<span class="string">&quot;goods&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">//指定修改内容</span></span><br><span class="line">    updateRequest.doc(<span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">                      <span class="string">&quot;    \&quot;price\&quot;:4.8\n&quot;</span> +</span><br><span class="line">                      <span class="string">&quot;  &#125;&quot;</span>,XContentType.JSON);</span><br><span class="line">    restHighLevelClient.update(updateRequest,RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除文档：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//指定索引以及id</span></span><br><span class="line">    DeleteRequest deleteRequest = <span class="keyword">new</span> DeleteRequest(<span class="string">&quot;goods&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    restHighLevelClient.delete(deleteRequest,RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>基于id查询文档：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryById</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    GetResponse documentFields = restHighLevelClient.get(<span class="keyword">new</span> GetRequest(<span class="string">&quot;goods&quot;</span>,<span class="string">&quot;1&quot;</span>), RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//获取id</span></span><br><span class="line">    System.out.println(documentFields.getId());</span><br><span class="line">    System.out.println(documentFields.getSourceAsString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>各种查询：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//term关键词查询</span></span><br><span class="line">    query(QueryBuilders.termQuery(<span class="string">&quot;description&quot;</span>, <span class="string">&quot;辣&quot;</span>));</span><br><span class="line">    <span class="comment">// range查询</span></span><br><span class="line">    query(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).from(<span class="number">0</span>).to(<span class="number">6.5</span>));</span><br><span class="line">    <span class="comment">// match查询</span></span><br><span class="line">    query(QueryBuilders.matchQuery(<span class="string">&quot;description&quot;</span>,<span class="string">&quot;辣条&quot;</span>));</span><br><span class="line">    <span class="comment">// 前缀查询</span></span><br><span class="line">    query(QueryBuilders.prefixQuery(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;卫龙&quot;</span>));</span><br><span class="line">    <span class="comment">// 通配符查询</span></span><br><span class="line">    query(QueryBuilders.wildcardQuery(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;卫龙*&quot;</span>));</span><br><span class="line">    <span class="comment">// ids查询</span></span><br><span class="line">    query(QueryBuilders.idsQuery().addIds(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>));</span><br><span class="line">    <span class="comment">// 多字段查询</span></span><br><span class="line">    query(QueryBuilders.multiMatchQuery(<span class="string">&quot;辣&quot;</span>,<span class="string">&quot;title&quot;</span>,<span class="string">&quot;description&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(QueryBuilder queryBuilder)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//指定查询索引</span></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;goods&quot;</span>);</span><br><span class="line">    <span class="comment">//指定查询条件</span></span><br><span class="line">    SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    sourceBuilder.query(queryBuilder);</span><br><span class="line">    searchRequest.source(sourceBuilder);</span><br><span class="line">    SearchResponse response = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//获取总条数和最大得分</span></span><br><span class="line">    System.out.println(<span class="string">&quot;总条数：&quot;</span> + response.getHits().getTotalHits().value);</span><br><span class="line">    System.out.println(<span class="string">&quot;最大得分：&quot;</span> + response.getHits().getMaxScore());</span><br><span class="line">    <span class="comment">//获取并输出查询数据</span></span><br><span class="line">    SearchHit[] hits = response.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getId());</span><br><span class="line">        System.out.println(hit.getSourceAsString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>分页查询以及排序、指定返回字段、高亮：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(QueryBuilder queryBuilder)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//指定查询索引</span></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;goods&quot;</span>);</span><br><span class="line">    <span class="comment">//指定查询条件</span></span><br><span class="line">    SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//指定高亮字段</span></span><br><span class="line">    HighlightBuilder highlightBuilder = <span class="keyword">new</span> HighlightBuilder();</span><br><span class="line">    highlightBuilder.requireFieldMatch(<span class="keyword">false</span>).field(<span class="string">&quot;description&quot;</span>).field(<span class="string">&quot;title&quot;</span>).preTags(<span class="string">&quot;&lt;span&gt;&quot;</span>).postTags(<span class="string">&quot;&lt;/span&gt;&quot;</span>);</span><br><span class="line">    sourceBuilder.query(queryBuilder)</span><br><span class="line">        .from(<span class="number">0</span>)</span><br><span class="line">        .size(<span class="number">1</span>)</span><br><span class="line">        .sort(<span class="string">&quot;price&quot;</span>, SortOrder.DESC)</span><br><span class="line">        .fetchSource(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;title&quot;</span>&#125;,<span class="keyword">new</span> String[]&#123;&#125;)</span><br><span class="line">        .highlighter(highlightBuilder);</span><br><span class="line">    searchRequest.source(sourceBuilder);</span><br><span class="line">    SearchResponse response = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//获取总条数和最大得分</span></span><br><span class="line">    System.out.println(<span class="string">&quot;总条数：&quot;</span> + response.getHits().getTotalHits().value);</span><br><span class="line">    System.out.println(<span class="string">&quot;最大得分：&quot;</span> + response.getHits().getMaxScore());</span><br><span class="line">    <span class="comment">//获取并输出查询数据</span></span><br><span class="line">    SearchHit[] hits = response.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getId());</span><br><span class="line">        System.out.println(hit.getSourceAsString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>过滤查询：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFilterQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;goods&quot;</span>);</span><br><span class="line">    SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    sourceBuilder.query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">//设置过滤条件</span></span><br><span class="line">    sourceBuilder.postFilter(QueryBuilders.termQuery(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;卫龙小辣棒&quot;</span>));</span><br><span class="line">    searchRequest.source(sourceBuilder);</span><br><span class="line">    SearchResponse response = restHighLevelClient.search(searchRequest,RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//获取总条数和最大得分</span></span><br><span class="line">    System.out.println(<span class="string">&quot;总条数：&quot;</span> + response.getHits().getTotalHits().value);</span><br><span class="line">    System.out.println(<span class="string">&quot;最大得分：&quot;</span> + response.getHits().getMaxScore());</span><br><span class="line">    <span class="comment">//获取并输出查询数据</span></span><br><span class="line">    SearchHit[] hits = response.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getId());</span><br><span class="line">        System.out.println(hit.getSourceAsString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>聚合查询：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAggs</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;products&quot;</span>);</span><br><span class="line">    SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    sourceBuilder.query(QueryBuilders.matchAllQuery())</span><br><span class="line">        .aggregation(AggregationBuilders.terms(<span class="string">&quot;price_group&quot;</span>).field(<span class="string">&quot;price&quot;</span>))</span><br><span class="line">        .size(<span class="number">0</span>);</span><br><span class="line">    searchRequest.source(sourceBuilder);</span><br><span class="line">    SearchResponse response = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    Aggregations aggregations = response.getAggregations();</span><br><span class="line">    ParsedDoubleTerms aggregation = aggregations.get(<span class="string">&quot;price_group&quot;</span>);</span><br><span class="line">    List&lt;? extends Terms.Bucket&gt; buckets = aggregation.getBuckets();</span><br><span class="line">    <span class="keyword">for</span> (Terms.Bucket bucket : buckets) &#123;</span><br><span class="line">        System.out.println(bucket.getKey()+<span class="string">&quot; &quot;</span>+bucket.getDocCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>聚合函数为max、min、sum桶中只有一个返回值，则max转化为ParsedMax、min转化为ParsedMin、sum转化为ParsedSum、 avg转化为ParsedAvg</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>一个集群就是由一个或多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能。一个集群由一个唯一的名字标识，这个名字默认就是elasticsearch。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群。</p>
<p><strong>节点：</strong></p>
<p>一个节点是你集群中的一个服务器，作为集群的一部分，它存储你的数据，参与集群的索引和搜索功能。</p>
<p><strong>分片：</strong></p>
<p>Elasticsearch提供了将索引划分成多份的能力，这些份就叫做分片。当创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”,这个“索引”可以被放置到集群中的任何节点上。</p>
<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p><strong>集群规划：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 三个节点</span><br><span class="line">- node1：web端口9201，tcp端口9301</span><br><span class="line">- node2：web端口9202，tcp端口9302</span><br><span class="line">- node3：web端口9203，tcp端口9303</span><br></pre></td></tr></table></figure>
<ol>
<li><p>依次创建备份数据卷：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 节点1</span></span><br><span class="line">mkdir -p /opt/docker_app/elasticsearch/config_node1</span><br><span class="line">mkdir -p /opt/docker_app/elasticsearch/data_node1</span><br><span class="line">mkdir -p /opt/docker_app/elasticsearch/plugins_node1</span><br><span class="line">echo &quot;http.host: 0.0.0.0&quot;&gt;&gt;/opt/docker_app/elasticsearch/config_node1/elasticsearch.yml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 节点2</span></span><br><span class="line">mkdir -p /opt/docker_app/elasticsearch/config_node2</span><br><span class="line">mkdir -p /opt/docker_app/elasticsearch/data_node2</span><br><span class="line">mkdir -p /opt/docker_app/elasticsearch/plugins_node2</span><br><span class="line">echo &quot;http.host: 0.0.0.0&quot;&gt;&gt;/opt/docker_app/elasticsearch/config_node2/elasticsearch.yml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 节点3</span></span><br><span class="line">mkdir -p /opt/docker_app/elasticsearch/config_node3</span><br><span class="line">mkdir -p /opt/docker_app/elasticsearch/data_node3</span><br><span class="line">mkdir -p /opt/docker_app/elasticsearch/plugins_node3</span><br><span class="line">echo &quot;http.host: 0.0.0.0&quot;&gt;&gt;/opt/docker_app/elasticsearch/config_node3/elasticsearch.yml</span><br></pre></td></tr></table></figure></li>
<li><p>对配置文件进行配置：</p>
<p>node-1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定集群名称 一个集群必须一致</span></span><br><span class="line">cluster.name: es-cluster</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定节点名称 每个节点唯一</span></span><br><span class="line">node.name: node-1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开放远程连接</span> </span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定使用发布地址进行集群间通信</span></span><br><span class="line">network.publish_host: 192.168.227.130</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定web端口</span></span><br><span class="line">http.port: 9201</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定tcp端口</span></span><br><span class="line">transport.tcp.port: 9301</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定所有节点的tcp通信</span></span><br><span class="line">discovery.seed_hosts: [&quot;192.168.227.130:9301&quot;,&quot;192.168.227.130:9302&quot;,&quot;192.168.227.130:9303&quot;]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定可以初始化集群节点名称</span></span><br><span class="line">cluster.initial_master_nodes: [&quot;node-1&quot;,&quot;node-2&quot;,&quot;node-3&quot;]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群最少几个点可用</span></span><br><span class="line">gateway.recover_after_nodes: 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决跨域问题</span></span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure>
<p>node-2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定集群名称 一个集群必须一致</span></span><br><span class="line">cluster.name: es-cluster</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定节点名称 每个节点唯一</span></span><br><span class="line">node.name: node-2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开放远程连接</span> </span><br><span class="line">http.host: 0.0.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定使用发布地址进行集群间通信</span></span><br><span class="line">network.publish_host: 192.168.227.130</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定web端口</span></span><br><span class="line">http.port: 9202</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定tcp端口</span></span><br><span class="line">transport.tcp.port: 9302</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定所有节点的tcp通信</span></span><br><span class="line">discovery.seed_hosts: [&quot;192.168.227.130:9301&quot;,&quot;192.168.227.130:9302&quot;,&quot;192.168.227.130:9303&quot;]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定可以初始化集群节点名称</span></span><br><span class="line">cluster.initial_master_nodes: [&quot;node-1&quot;,&quot;node-2&quot;,&quot;node-3&quot;]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群最少几个点可用</span></span><br><span class="line">gateway.recover_after_nodes: 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决跨域问题</span></span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure>
<p>node-3</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定集群名称 一个集群必须一致</span></span><br><span class="line">cluster.name: es-cluster</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定节点名称 每个节点唯一</span></span><br><span class="line">node.name: node-3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开放远程连接</span> </span><br><span class="line">http.host: 0.0.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定使用发布地址进行集群间通信</span></span><br><span class="line">network.publish_host: 192.168.227.130</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定web端口</span></span><br><span class="line">http.port: 9203</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定tcp端口</span></span><br><span class="line">transport.tcp.port: 9303</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定所有节点的tcp通信</span></span><br><span class="line">discovery.seed_hosts: [&quot;192.168.227.130:9301&quot;,&quot;192.168.227.130:9302&quot;,&quot;192.168.227.130:9303&quot;]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定可以初始化集群节点名称</span></span><br><span class="line">cluster.initial_master_nodes: [&quot;node-1&quot;,&quot;node-2&quot;,&quot;node-3&quot;]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群最少几个点可用</span></span><br><span class="line">gateway.recover_after_nodes: 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决跨域问题</span></span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>启动各个节点容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> node-1</span></span><br><span class="line">docker run --name elasticsearch01 -p 9201:9201 -p 9301:9301 -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot;  -v /opt/docker_app/elasticsearch/config_node1/elasticsearch.yml:/usr/share/config/elasticsearch.yml -v /opt/docker_app/elasticsearch/data_node1:/usr/share/elasticsearch/data -v /opt/docker_app/elasticsearch/plugins_node1:/usr/share/elasticsearch/plugins  -d elasticsearch:7.14.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> node-2</span></span><br><span class="line">docker run --name elasticsearch02 -p 9202:9202 -p 9302:9302 -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot;  -v /opt/docker_app/elasticsearch/config_node2/elasticsearch.yml:/usr/share/config/elasticsearch.yml -v /opt/docker_app/elasticsearch/data_node2:/usr/share/elasticsearch/data -v /opt/docker_app/elasticsearch/plugins_node2:/usr/share/elasticsearch/plugins  -d elasticsearch:7.14.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> node-3</span></span><br><span class="line">docker run --name elasticsearch03 -p 9203:9203 -p 9303:9303 -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot;  -v /opt/docker_app/elasticsearch/config_node3/elasticsearch.yml:/usr/share/config/elasticsearch.yml -v /opt/docker_app/elasticsearch/data_node3:/usr/share/elasticsearch/data -v /opt/docker_app/elasticsearch/plugins_node3:/usr/share/elasticsearch/plugins  -d elasticsearch:7.14.0</span><br></pre></td></tr></table></figure></li>
<li><p>查看集群状态：<code>http://192.168.xx.xx:9201/_cat/health?v</code></p>
</li>
</ol>
<h4 id="安装head插件"><a href="#安装head插件" class="headerlink" title="安装head插件"></a>安装head插件</h4><ol>
<li>拉取镜像：<code>docker pull mobz/elasticsearch-head:5</code></li>
<li>创建容器：<code>docker run --name es-head -p 9100:9100 mobz/elasticsearch-head:5</code></li>
<li>访问：<code>http://192.168.xx.xx:9100</code></li>
</ol>
]]></content>
      <categories>
        <category>中间件</category>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK日志平台搭建</title>
    <url>/2023/03/12/%E4%B8%AD%E9%97%B4%E4%BB%B6/Elasticsearch/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="ELK日志平台搭建"><a href="#ELK日志平台搭建" class="headerlink" title="ELK日志平台搭建"></a>ELK日志平台搭建</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ELK即Elasticsearch、Logstash、Kibana,组合起来可以搭建线上日志系统</p>
<ul>
<li>Elasticsearch:用于存储收集到的日志信息。</li>
<li>Logstash:用于收集日志，SpringBoot应用整合了Logstash以后会把日志发送给Logstash,Logstash再把日志转发给Elasticsearch。</li>
<li>Kibana:通过Web端的可视化界面来查看日志。</li>
</ul>
<h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h3 id="基本镜像环境"><a href="#基本镜像环境" class="headerlink" title="基本镜像环境"></a>基本镜像环境</h3><ul>
<li><p>首先拉取ELK的镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull elasticsearch:7.14.0</span><br><span class="line">docker pull logstash:7.14.0</span><br><span class="line">docker pull kibana:7.14.0</span><br></pre></td></tr></table></figure></li>
<li><p>处理elasticsearch启动问题的配置：</p>
<p>需要设置系统内核参数，否则会因为内存不足无法启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl -w vm.max_map_count&#x3D;262144</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<p>给data文件权限：<code>chmod 777 /opt/docker_app/elasticsearch/data</code></p>
</li>
<li><p>编写docker-compose.yml脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">  elasticsearch:</span><br><span class="line">    image: elasticsearch:7.14.0</span><br><span class="line">    container_name: elasticsearch_7.14.0</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      - &quot;cluster.name&#x3D;elasticsearch&quot; #设置集群名称为elasticsearch</span><br><span class="line">      - &quot;discovery.type&#x3D;single-node&quot; #以单一节点模式启动</span><br><span class="line">      - &quot;ES_JAVA_OPTS&#x3D;-Xms512m -Xmx512m&quot; #设置使用jvm内存大小</span><br><span class="line">      - TZ&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;opt&#x2F;docker_app&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml #配置文件挂载</span><br><span class="line">      - &#x2F;opt&#x2F;docker_app&#x2F;elasticsearch&#x2F;plugins:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins #插件文件挂载</span><br><span class="line">      - &#x2F;opt&#x2F;docker_app&#x2F;elasticsearch&#x2F;data:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data #数据文件挂载</span><br><span class="line">    ports:</span><br><span class="line">      - 9200:9200</span><br><span class="line">      - 9300:9300</span><br><span class="line">  kibana:</span><br><span class="line">    image: kibana:7.14.0</span><br><span class="line">    container_name: kibana_7.14.0</span><br><span class="line">    restart: always</span><br><span class="line">    links:</span><br><span class="line">      - elasticsearch:es #可以用es这个域名访问elasticsearch服务</span><br><span class="line">    depends_on:</span><br><span class="line">      - elasticsearch #kibana在elasticsearch启动之后再启动</span><br><span class="line">    environment:</span><br><span class="line">      - &quot;elasticsearch.hosts&#x3D;http:&#x2F;&#x2F;es:9200&quot; #设置访问elasticsearch的地址</span><br><span class="line">      - TZ&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;opt&#x2F;docker_app&#x2F;kibana&#x2F;config&#x2F;kibana.yml:&#x2F;usr&#x2F;share&#x2F;kibana&#x2F;config&#x2F;kibana.yml</span><br><span class="line">    ports:</span><br><span class="line">      - 5601:5601</span><br><span class="line">  logstash:</span><br><span class="line">    image: logstash:7.14.0</span><br><span class="line">    container_name: logstash_7.14.0</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      - TZ&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;opt&#x2F;docker_app&#x2F;logstash&#x2F;logstash.conf:&#x2F;usr&#x2F;share&#x2F;logstash&#x2F;pipeline&#x2F;logstash.conf #挂载logstash的配置文件</span><br><span class="line">    depends_on:</span><br><span class="line">      - elasticsearch #kibana在elasticsearch启动之后再启动</span><br><span class="line">    links:</span><br><span class="line">      - elasticsearch:es #可以用es这个域名访问elasticsearch服务</span><br><span class="line">    ports:</span><br><span class="line">      - 4560:4560</span><br><span class="line">      - 4561:4561</span><br><span class="line">      - 4562:4562</span><br><span class="line">      - 4563:4563</span><br></pre></td></tr></table></figure></li>
<li><p>编写logstash.conf：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    mode &#x3D;&gt; &quot;server&quot;</span><br><span class="line">    host &#x3D;&gt; &quot;0.0.0.0&quot;</span><br><span class="line">    port &#x3D;&gt; 4560</span><br><span class="line">    codec &#x3D;&gt; json_lines</span><br><span class="line">    type &#x3D;&gt; &quot;debug&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    mode &#x3D;&gt; &quot;server&quot;</span><br><span class="line">    host &#x3D;&gt; &quot;0.0.0.0&quot;</span><br><span class="line">    port &#x3D;&gt; 4561</span><br><span class="line">    codec &#x3D;&gt; json_lines</span><br><span class="line">    type &#x3D;&gt; &quot;error&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    mode &#x3D;&gt; &quot;server&quot;</span><br><span class="line">    host &#x3D;&gt; &quot;0.0.0.0&quot;</span><br><span class="line">    port &#x3D;&gt; 4562</span><br><span class="line">    codec &#x3D;&gt; json_lines</span><br><span class="line">    type &#x3D;&gt; &quot;business&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    mode &#x3D;&gt; &quot;server&quot;</span><br><span class="line">    host &#x3D;&gt; &quot;0.0.0.0&quot;</span><br><span class="line">    port &#x3D;&gt; 4563</span><br><span class="line">    codec &#x3D;&gt; json_lines</span><br><span class="line">    type &#x3D;&gt; &quot;record&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter&#123;</span><br><span class="line">  if [type] &#x3D;&#x3D; &quot;record&quot; &#123;</span><br><span class="line">    mutate &#123;</span><br><span class="line">      remove_field &#x3D;&gt; &quot;port&quot;</span><br><span class="line">      remove_field &#x3D;&gt; &quot;host&quot;</span><br><span class="line">      remove_field &#x3D;&gt; &quot;@version&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    json &#123;</span><br><span class="line">      source &#x3D;&gt; &quot;message&quot;</span><br><span class="line">      remove_field &#x3D;&gt; [&quot;message&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts &#x3D;&gt; [&quot;es:9200&quot;]</span><br><span class="line">    action &#x3D;&gt; &quot;index&quot;</span><br><span class="line">    codec &#x3D;&gt; json</span><br><span class="line">    user &#x3D;&gt; elastic</span><br><span class="line">    password &#x3D;&gt; &quot;123456&quot;</span><br><span class="line">    index &#x3D;&gt; &quot;AdminTamplate-%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">    template_name &#x3D;&gt; &quot;AdminTamplate&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>运行docker-compose脚本：<code>docker-compose up -d</code></p>
</li>
<li><p>Logstash需要安装<code>json_lines</code>插件：<code>logstash-plugin install logstash-codec-json_lines</code></p>
</li>
</ul>
<h3 id="SpringBoot应用集成Logstash"><a href="#SpringBoot应用集成Logstash" class="headerlink" title="SpringBoot应用集成Logstash"></a>SpringBoot应用集成Logstash</h3><ul>
<li><p>添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--集成logstash--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在logback-spring.xml中配置日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!--引用默认日志配置--&gt;</span><br><span class="line">    &lt;include resource&#x3D;&quot;org&#x2F;springframework&#x2F;boot&#x2F;logging&#x2F;logback&#x2F;defaults.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!--使用默认的控制台日志输出实现--&gt;</span><br><span class="line">    &lt;include resource&#x3D;&quot;org&#x2F;springframework&#x2F;boot&#x2F;logging&#x2F;logback&#x2F;console-appender.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!--应用名称--&gt;</span><br><span class="line">    &lt;springProperty scope&#x3D;&quot;context&quot; name&#x3D;&quot;APP_NAME&quot; source&#x3D;&quot;spring.application.name&quot; defaultValue&#x3D;&quot;springBoot&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!--日志文件保存路径--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;LOG_FILE_PATH&quot; value&#x3D;&quot;$&#123;LOG_FILE:-$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-&#x2F;tmp&#125;&#125;&#125;&#x2F;logs&#125;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!--LogStash访问host--&gt;</span><br><span class="line">    &lt;springProperty name&#x3D;&quot;LOG_STASH_HOST&quot; scope&#x3D;&quot;context&quot; source&#x3D;&quot;logstash.host&quot; defaultValue&#x3D;&quot;192.168.227.130&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--DEBUG日志输出到文件--&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;FILE_DEBUG&quot;</span><br><span class="line">              class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;!--输出DEBUG以上级别日志--&gt;</span><br><span class="line">        &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;</span><br><span class="line">            &lt;level&gt;DEBUG&lt;&#x2F;level&gt;</span><br><span class="line">        &lt;&#x2F;filter&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;!--设置为默认的文件日志格式--&gt;</span><br><span class="line">            &lt;pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;&#x2F;pattern&gt;</span><br><span class="line">            &lt;charset&gt;UTF-8&lt;&#x2F;charset&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">        &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;!--设置文件命名格式--&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;LOG_FILE_PATH&#125;&#x2F;debug&#x2F;$&#123;APP_NAME&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log&lt;&#x2F;fileNamePattern&gt;</span><br><span class="line">            &lt;!--设置日志文件大小，超过就重新生成文件，默认10M--&gt;</span><br><span class="line">            &lt;maxFileSize&gt;$&#123;LOG_FILE_MAX_SIZE:-10MB&#125;&lt;&#x2F;maxFileSize&gt;</span><br><span class="line">            &lt;!--日志文件保留天数，默认30天--&gt;</span><br><span class="line">            &lt;maxHistory&gt;$&#123;LOG_FILE_MAX_HISTORY:-30&#125;&lt;&#x2F;maxHistory&gt;</span><br><span class="line">        &lt;&#x2F;rollingPolicy&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--ERROR日志输出到文件--&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;FILE_ERROR&quot;</span><br><span class="line">              class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;!--只输出ERROR级别的日志--&gt;</span><br><span class="line">        &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;</span><br><span class="line">            &lt;level&gt;ERROR&lt;&#x2F;level&gt;</span><br><span class="line">            &lt;onMatch&gt;ACCEPT&lt;&#x2F;onMatch&gt;</span><br><span class="line">            &lt;onMismatch&gt;DENY&lt;&#x2F;onMismatch&gt;</span><br><span class="line">        &lt;&#x2F;filter&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;!--设置为默认的文件日志格式--&gt;</span><br><span class="line">            &lt;pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;&#x2F;pattern&gt;</span><br><span class="line">            &lt;charset&gt;UTF-8&lt;&#x2F;charset&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">        &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;!--设置文件命名格式--&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;LOG_FILE_PATH&#125;&#x2F;error&#x2F;$&#123;APP_NAME&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log&lt;&#x2F;fileNamePattern&gt;</span><br><span class="line">            &lt;!--设置日志文件大小，超过就重新生成文件，默认10M--&gt;</span><br><span class="line">            &lt;maxFileSize&gt;$&#123;LOG_FILE_MAX_SIZE:-50MB&#125;&lt;&#x2F;maxFileSize&gt;</span><br><span class="line">            &lt;!--日志文件保留天数，默认30天--&gt;</span><br><span class="line">            &lt;maxHistory&gt;$&#123;LOG_FILE_MAX_HISTORY:-30&#125;&lt;&#x2F;maxHistory&gt;</span><br><span class="line">        &lt;&#x2F;rollingPolicy&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--DEBUG日志输出到LogStash--&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;LOG_STASH_DEBUG&quot; class&#x3D;&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&gt;</span><br><span class="line">        &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;</span><br><span class="line">            &lt;level&gt;DEBUG&lt;&#x2F;level&gt;</span><br><span class="line">        &lt;&#x2F;filter&gt;</span><br><span class="line">        &lt;destination&gt;$&#123;LOG_STASH_HOST&#125;:4560&lt;&#x2F;destination&gt;</span><br><span class="line">        &lt;encoder charset&#x3D;&quot;UTF-8&quot; class&#x3D;&quot;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder&quot;&gt;</span><br><span class="line">            &lt;providers&gt;</span><br><span class="line">                &lt;timestamp&gt;</span><br><span class="line">                    &lt;timeZone&gt;Asia&#x2F;Shanghai&lt;&#x2F;timeZone&gt;</span><br><span class="line">                &lt;&#x2F;timestamp&gt;</span><br><span class="line">                &lt;!--自定义日志输出格式--&gt;</span><br><span class="line">                &lt;pattern&gt;</span><br><span class="line">                    &lt;pattern&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                        &quot;project&quot;: &quot;AdminTemplate&quot;,</span><br><span class="line">                        &quot;level&quot;: &quot;%level&quot;,</span><br><span class="line">                        &quot;service&quot;: &quot;$&#123;APP_NAME:-&#125;&quot;,</span><br><span class="line">                        &quot;pid&quot;: &quot;$&#123;PID:-&#125;&quot;,</span><br><span class="line">                        &quot;thread&quot;: &quot;%thread&quot;,</span><br><span class="line">                        &quot;class&quot;: &quot;%logger&quot;,</span><br><span class="line">                        &quot;message&quot;: &quot;%message&quot;,</span><br><span class="line">                        &quot;stack_trace&quot;: &quot;%exception&#123;20&#125;&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &lt;&#x2F;pattern&gt;</span><br><span class="line">                &lt;&#x2F;pattern&gt;</span><br><span class="line">            &lt;&#x2F;providers&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">        &lt;!--当有多个LogStash服务时，设置访问策略为轮询--&gt;</span><br><span class="line">        &lt;connectionStrategy&gt;</span><br><span class="line">            &lt;roundRobin&gt;</span><br><span class="line">                &lt;connectionTTL&gt;5 minutes&lt;&#x2F;connectionTTL&gt;</span><br><span class="line">            &lt;&#x2F;roundRobin&gt;</span><br><span class="line">        &lt;&#x2F;connectionStrategy&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--ERROR日志输出到LogStash--&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;LOG_STASH_ERROR&quot; class&#x3D;&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&gt;</span><br><span class="line">        &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;</span><br><span class="line">            &lt;level&gt;ERROR&lt;&#x2F;level&gt;</span><br><span class="line">            &lt;onMatch&gt;ACCEPT&lt;&#x2F;onMatch&gt;</span><br><span class="line">            &lt;onMismatch&gt;DENY&lt;&#x2F;onMismatch&gt;</span><br><span class="line">        &lt;&#x2F;filter&gt;</span><br><span class="line">        &lt;destination&gt;$&#123;LOG_STASH_HOST&#125;:4561&lt;&#x2F;destination&gt;</span><br><span class="line">        &lt;encoder charset&#x3D;&quot;UTF-8&quot; class&#x3D;&quot;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder&quot;&gt;</span><br><span class="line">            &lt;providers&gt;</span><br><span class="line">                &lt;timestamp&gt;</span><br><span class="line">                    &lt;timeZone&gt;Asia&#x2F;Shanghai&lt;&#x2F;timeZone&gt;</span><br><span class="line">                &lt;&#x2F;timestamp&gt;</span><br><span class="line">                &lt;!--自定义日志输出格式--&gt;</span><br><span class="line">                &lt;pattern&gt;</span><br><span class="line">                    &lt;pattern&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                        &quot;project&quot;: &quot;AdminTemplate&quot;,</span><br><span class="line">                        &quot;level&quot;: &quot;%level&quot;,</span><br><span class="line">                        &quot;service&quot;: &quot;$&#123;APP_NAME:-&#125;&quot;,</span><br><span class="line">                        &quot;pid&quot;: &quot;$&#123;PID:-&#125;&quot;,</span><br><span class="line">                        &quot;thread&quot;: &quot;%thread&quot;,</span><br><span class="line">                        &quot;class&quot;: &quot;%logger&quot;,</span><br><span class="line">                        &quot;message&quot;: &quot;%message&quot;,</span><br><span class="line">                        &quot;stack_trace&quot;: &quot;%exception&#123;20&#125;&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &lt;&#x2F;pattern&gt;</span><br><span class="line">                &lt;&#x2F;pattern&gt;</span><br><span class="line">            &lt;&#x2F;providers&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">        &lt;!--当有多个LogStash服务时，设置访问策略为轮询--&gt;</span><br><span class="line">        &lt;connectionStrategy&gt;</span><br><span class="line">            &lt;roundRobin&gt;</span><br><span class="line">                &lt;connectionTTL&gt;5 minutes&lt;&#x2F;connectionTTL&gt;</span><br><span class="line">            &lt;&#x2F;roundRobin&gt;</span><br><span class="line">        &lt;&#x2F;connectionStrategy&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--业务日志输出到LogStash--&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;LOG_STASH_BUSINESS&quot; class&#x3D;&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&gt;</span><br><span class="line">        &lt;destination&gt;$&#123;LOG_STASH_HOST&#125;:4562&lt;&#x2F;destination&gt;</span><br><span class="line">        &lt;encoder charset&#x3D;&quot;UTF-8&quot; class&#x3D;&quot;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder&quot;&gt;</span><br><span class="line">            &lt;providers&gt;</span><br><span class="line">                &lt;timestamp&gt;</span><br><span class="line">                    &lt;timeZone&gt;Asia&#x2F;Shanghai&lt;&#x2F;timeZone&gt;</span><br><span class="line">                &lt;&#x2F;timestamp&gt;</span><br><span class="line">                &lt;!--自定义日志输出格式--&gt;</span><br><span class="line">                &lt;pattern&gt;</span><br><span class="line">                    &lt;pattern&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                        &quot;project&quot;: &quot;AdminTemplate&quot;,</span><br><span class="line">                        &quot;level&quot;: &quot;%level&quot;,</span><br><span class="line">                        &quot;service&quot;: &quot;$&#123;APP_NAME:-&#125;&quot;,</span><br><span class="line">                        &quot;pid&quot;: &quot;$&#123;PID:-&#125;&quot;,</span><br><span class="line">                        &quot;thread&quot;: &quot;%thread&quot;,</span><br><span class="line">                        &quot;class&quot;: &quot;%logger&quot;,</span><br><span class="line">                        &quot;message&quot;: &quot;%message&quot;,</span><br><span class="line">                        &quot;stack_trace&quot;: &quot;%exception&#123;20&#125;&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &lt;&#x2F;pattern&gt;</span><br><span class="line">                &lt;&#x2F;pattern&gt;</span><br><span class="line">            &lt;&#x2F;providers&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">        &lt;!--当有多个LogStash服务时，设置访问策略为轮询--&gt;</span><br><span class="line">        &lt;connectionStrategy&gt;</span><br><span class="line">            &lt;roundRobin&gt;</span><br><span class="line">                &lt;connectionTTL&gt;5 minutes&lt;&#x2F;connectionTTL&gt;</span><br><span class="line">            &lt;&#x2F;roundRobin&gt;</span><br><span class="line">        &lt;&#x2F;connectionStrategy&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--接口访问记录日志输出到LogStash--&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;LOG_STASH_RECORD&quot; class&#x3D;&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&gt;</span><br><span class="line">        &lt;destination&gt;$&#123;LOG_STASH_HOST&#125;:4563&lt;&#x2F;destination&gt;</span><br><span class="line">        &lt;encoder charset&#x3D;&quot;UTF-8&quot; class&#x3D;&quot;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder&quot;&gt;</span><br><span class="line">            &lt;providers&gt;</span><br><span class="line">                &lt;timestamp&gt;</span><br><span class="line">                    &lt;timeZone&gt;Asia&#x2F;Shanghai&lt;&#x2F;timeZone&gt;</span><br><span class="line">                &lt;&#x2F;timestamp&gt;</span><br><span class="line">                &lt;!--自定义日志输出格式--&gt;</span><br><span class="line">                &lt;pattern&gt;</span><br><span class="line">                    &lt;pattern&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                        &quot;project&quot;: &quot;AdminTemplate&quot;,</span><br><span class="line">                        &quot;level&quot;: &quot;%level&quot;,</span><br><span class="line">                        &quot;service&quot;: &quot;$&#123;APP_NAME:-&#125;&quot;,</span><br><span class="line">                        &quot;class&quot;: &quot;%logger&quot;,</span><br><span class="line">                        &quot;message&quot;: &quot;%message&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &lt;&#x2F;pattern&gt;</span><br><span class="line">                &lt;&#x2F;pattern&gt;</span><br><span class="line">            &lt;&#x2F;providers&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">        &lt;!--当有多个LogStash服务时，设置访问策略为轮询--&gt;</span><br><span class="line">        &lt;connectionStrategy&gt;</span><br><span class="line">            &lt;roundRobin&gt;</span><br><span class="line">                &lt;connectionTTL&gt;5 minutes&lt;&#x2F;connectionTTL&gt;</span><br><span class="line">            &lt;&#x2F;roundRobin&gt;</span><br><span class="line">        &lt;&#x2F;connectionStrategy&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--控制框架输出日志--&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;org.slf4j&quot; level&#x3D;&quot;INFO&quot;&#x2F;&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;springfox&quot; level&#x3D;&quot;INFO&quot;&#x2F;&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;io.swagger&quot; level&#x3D;&quot;INFO&quot;&#x2F;&gt;</span><br><span class="line">    &lt;logger name&#x3D;&quot;org.springframework&quot; level&#x3D;&quot;INFO&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;root level&#x3D;&quot;DEBUG&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;CONSOLE&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!--&lt;appender-ref ref&#x3D;&quot;FILE_DEBUG&quot;&#x2F;&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;appender-ref ref&#x3D;&quot;FILE_ERROR&quot;&#x2F;&gt;--&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;LOG_STASH_DEBUG&quot;&#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;LOG_STASH_ERROR&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;root&gt;</span><br><span class="line"></span><br><span class="line">    &lt;logger name&#x3D;&quot;com.wht.config.LogAspect&quot; level&#x3D;&quot;DEBUG&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;LOG_STASH_RECORD&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;logger&gt;</span><br><span class="line"></span><br><span class="line">    &lt;logger name&#x3D;&quot;com.wht&quot; level&#x3D;&quot;DEBUG&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;LOG_STASH_BUSINESS&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;logger&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>启动项目等待日志打印</p>
</li>
</ul>
<h3 id="在Kinbana中查看日志"><a href="#在Kinbana中查看日志" class="headerlink" title="在Kinbana中查看日志"></a>在Kinbana中查看日志</h3><ol>
<li><p>创建索引</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230312102011681.png" alt="image-20230312102011681"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230312102032056.png" alt="image-20230312102032056"></p>
</li>
<li><p>在监控面板查看</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230312102113083.png" alt="image-20230312102113083"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230312102133305.png" alt="image-20230312102133305"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>中间件</category>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
        <tag>日志</tag>
        <tag>Logstash</tag>
        <tag>Kibana</tag>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud</title>
    <url>/2023/03/15/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/SpringCloud/SpringCloud/</url>
    <content><![CDATA[<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>架构的变化：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://ask.qcloudimg.com/http-save/yehe-8223537/7322fd61404a12b7e790bd4173340060.jpeg?imageView2/2/w/1620" alt="img"></p>
<p>微服务：一种软件开发技术- 面向服务的体系结构（SOA）架构样式的一种变体，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221107215741696.png" alt="image-20221107215741696"></p>
<p>Spring Cloud全家桶是Pivotal团队提供的一整套微服务开源解决方案，包括服务注册与发现、配置中心、全链路监控、服务网关、负载均衡、熔断器等组件。</p>
<p>基本架构：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://ask.qcloudimg.com/http-save/yehe-8223537/f211e6356975735a470f38c28d6e083e.png?imageView2/2/w/1620" alt="img"></p>
<p>技术落地（目前很多已经停更，后面会有替代技术）：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221107221302179.png" alt="image-20221107221302179"></p>
<blockquote>
<p>注册中心Eureka、服务配置Config、服务总线Bus被Nacos替代</p>
<p>Ribbon、Feign被OpenFeign替代</p>
<p>Hystrix被Alibaba的Sentinel替代</p>
<p>Zuul被gateway替代</p>
</blockquote>
<h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><p>在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221108201953643.png" alt="image-20221108201953643"></p>
<h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>需要对各个服务进行发现与注册，方便之后各个服务之间相互调用。</p>
<p>主要实现有Eureka（停更）、Zookeeper、Consul、Nacos（重点，后续会讲到）</p>
<h2 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h2><p>简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer(简称LB)后面所有的机器，Ribbon会自动的帮助你基于某种规则(如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。</p>
<p>与ngnix负载均衡的区别在于Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到VM本地，从而在本地实现RPC远程服务调用技术。</p>
<h3 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h3><p>Feign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单，对Ribbon进行了再封装。<br>它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。</p>
<blockquote>
<p>在OpenFeign之前是使用Ribbon+RestTemplate进行服务的调用：</p>
<p>配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Applicationcontextconfig</span></span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line"> <span class="meta">@LoadBalanced</span>  <span class="comment">//赋予负载均衡的能力</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口通信：</p>
<p><code>restTemplate.postForObject/getForObject/..(接口url,参数,响应体)</code></p>
</blockquote>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="服务调用实现"><a href="#服务调用实现" class="headerlink" title="服务调用实现"></a>服务调用实现</h5><ul>
<li><p>导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加 OpenFeign 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>激活Feign：在接口消费者的主启动类上添加注解<code>@EnableFeignClients</code></p>
</li>
<li><p>编写服务接口（这里可以完全支持springMVC的编码风格）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;接口所属的服务名&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FeignService</span></span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">Result&lt;Res&gt; <span class="title">getResById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>直接在本模块接口调用上面模板接口的服务（Feign自带负载均衡功能 ）</p>
</li>
</ul>
<h5 id="超时控制实现"><a href="#超时控制实现" class="headerlink" title="超时控制实现"></a>超时控制实现</h5><p>OpenFeign客户端默认只等待一秒钟，如果服务端处理超过1秒钟，导致OpenFeign客户端不想等待了，直接返回报错。</p>
<ul>
<li><p>在客户端yml中进行配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置feign客户端超时时间</span><br><span class="line">feign:</span><br><span class="line">  client:</span><br><span class="line">    config:</span><br><span class="line">      default:</span><br><span class="line">        # 从连接建立时开始应用，在返回响应时间过长时触发。</span><br><span class="line">        readTimeout: 5000</span><br><span class="line">        # 指的是建立连接后从服务器读取到可用资源所用的时间</span><br><span class="line">        connectTimeout: 5000</span><br></pre></td></tr></table></figure>
<h5 id="日志增强"><a href="#日志增强" class="headerlink" title="日志增强"></a>日志增强</h5></li>
</ul>
<p>Feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解Feign 中 Http请求的细节。说白了就是对Feign接口的调用情况进行监控和输出。</p>
<p>日志级别：</p>
<ul>
<li>NONE:默认的，不显示任何日志。</li>
<li>BASIC:仅记录请求方法、URL、响应状态码及执行时间。</li>
<li>HEADERS:除了BASIC中定义的信息之外，还有请求和响应的头信息。</li>
<li>FULL:除了HEADERS 中定义的信息之外，还有请求和响应的正文及元数据。</li>
</ul>
<p>实现：</p>
<ul>
<li><p>创建配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置yml：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">	<span class="attr">level:</span></span><br><span class="line">		<span class="comment"># feign日志以什么级别监控哪个接口</span></span><br><span class="line">		<span class="attr">com.wht.springcloud.service.TestFeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>
<h2 id="服务熔断和降级"><a href="#服务熔断和降级" class="headerlink" title="服务熔断和降级"></a>服务熔断和降级</h2></li>
</ul>
<p>分布式系统面临的问题：复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。</p>
<p>例如：</p>
<p>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。</p>
<p>针对这个问题就需要一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，就需要一个开源库让系统能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。</p>
<h3 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><p>当某个服务单元发生故障之后，通过断路器的故障监控(类似熔断保险丝)，向调用方返回—个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p>
<h4 id="服务熔断："><a href="#服务熔断：" class="headerlink" title="服务熔断："></a>服务熔断：</h4><p>类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示。</p>
<p>熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。</p>
<p><strong>熔断类型：</strong></p>
<ul>
<li>熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR(平均故障处理时间)，当打开时长达到所设时钟则进入半熔断状态</li>
<li>熔断关闭：熔断关闭不会对服务进行熔断</li>
<li>熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断</li>
</ul>
<p><strong>涉及到断路器的三个重要参数:</strong></p>
<ol>
<li>快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</li>
<li>请求总数阀值：在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20，意味着在10秒内，如果该hystri命令的调用次数不足20次,即使所有的请求都超时或其他原因失败，断路器都不会打开。</li>
<li>错误百分比阀值：当请求总数在快照时间窗内超过了阀值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。</li>
</ol>
<h4 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h4><p>秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221110212345716.png" alt="image-20221110212345716"></p>
<h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><h4 id="服务降级-1"><a href="#服务降级-1" class="headerlink" title="服务降级"></a>服务降级</h4><p>对服务提供方进行峰值限制降级（只要是服务不可用了，都会做服务降级）</p>
<ul>
<li>启动类加<code>@EnableHystrix</code></li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221110212742951.png" alt="image-20221110212742951"></p>
<p>但是一般都是对服务消费方进行服务降级</p>
<ul>
<li>启动类加<code>@EnableHystrix</code></li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221110213441671.png" alt="image-20221110213441671"></p>
<p>为了避免每个接口都进行自定义兜底方法，可以使用全局服务降级（只有不指定自定义才会使用）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221110213906775.png" alt="image-20221110213906775"></p>
<p>或者直接在feign接口处理，定义该接口的实现类，并在接口中配置fallback</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221110214319868.png" alt="image-20221110214319868"></p>
<h4 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h4><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221110215600139.png" alt="image-20221110215600139"></p>
<h3 id="Sentinal"><a href="#Sentinal" class="headerlink" title="Sentinal"></a>Sentinal</h3><p>后续会讲到</p>
<h2 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h2><p>Cloud全家桶中有个很重要的组件就是网关，在1.x版本中都是采用的Zuul网关;但在2.x版本中，zuul的升级一直跳票，SpringCloud最后自己研发了一个网关替代Zuul,那就是SpringCloud Gateway一句话: gateway是原zuul1.x版的替代。</p>
<p>服务网关的作用：用于接收分配前端请求</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221111184643207.png" alt="image-20221111184643207"></p>
<h3 id="SpringCloud-Gateway"><a href="#SpringCloud-Gateway" class="headerlink" title="SpringCloud Gateway"></a>SpringCloud Gateway</h3><p>SpringCloud Gateway作为 Spring Cloud 生态系统中的网关，目标是替代Zuul，为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。</p>
<p>Spring Cloud Gateway的目标提供统一的路由方式且基于Filter链的方式提供了网关基本的功能，例如:安全，监控/指标，和限流。</p>
<h4 id="相关概念-2"><a href="#相关概念-2" class="headerlink" title="相关概念"></a>相关概念</h4><h5 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h5><p>路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由</p>
<h5 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h5><p>开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数)，如果请求与断言相匹配则进行路由</p>
<h5 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h5><p>指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。</p>
<p>工作流程：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221111190137947.png" alt="image-20221111190137947"></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h5><ul>
<li><p>依赖（注意不要引入web的依赖）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>注册到注册中心：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221111190645447.png" alt="image-20221111190645447"></p>
</li>
<li><p>配置路由：</p>
<p>方式一：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">  	<span class="attr">gateway:</span></span><br><span class="line">  		<span class="attr">routes:</span></span><br><span class="line">  			<span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_route</span> <span class="comment"># 路由ID，没有固定规则但是要求唯一，建议配合服务名</span></span><br><span class="line">  			  <span class="attr">uri:</span> <span class="string">http://localhost:8001</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">  			  <span class="attr">predicates:</span></span><br><span class="line">  			  	<span class="bullet">-</span> <span class="string">Path=/payment/get/**</span> <span class="comment">#断言，路径相匹配的进行路由</span></span><br><span class="line">  			  	</span><br><span class="line">            <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_route2</span> <span class="comment"># 路由ID，没有固定规则但是要求唯一，建议配合服务名</span></span><br><span class="line">              <span class="attr">uri:</span> <span class="string">http://localhost:8001</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">              <span class="attr">predicates:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span> <span class="comment">#断言，路径相匹配的进行路由</span></span><br></pre></td></tr></table></figure>
<p>方式二：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221111192558743.png" alt="image-20221111192558743"></p>
</li>
</ul>
<h5 id="基于微服务名实现动态路由"><a href="#基于微服务名实现动态路由" class="headerlink" title="基于微服务名实现动态路由"></a>基于微服务名实现动态路由</h5><ul>
<li><p>开启从注册中心获取服务名：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">gateway:</span></span><br><span class="line">			<span class="attr">discovery:</span></span><br><span class="line">				<span class="attr">locator:</span></span><br><span class="line">					<span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改uri：</p>
<p><code>uri: lb://服务名</code></p>
</li>
</ul>
<h5 id="Prediates常用模式"><a href="#Prediates常用模式" class="headerlink" title="Prediates常用模式"></a>Prediates常用模式</h5><ul>
<li>After/Before/Between：在某时间以后/以前/之间才生效，通过<code>ZonedDateTime.now()</code>获取时间</li>
<li>Path：根据请求路径进行匹配</li>
<li>Cookie/Header：获取携带相应Cookie/请求头才行（语法：Cookie/Header=key,value，value可以为正则表达式）</li>
<li>Host：对域名进行匹配</li>
<li>Method：对请求方式进行匹配（Method=GET）</li>
<li>Query：对请求参数进行断言匹配（Query=参数名,值正则）</li>
</ul>
<h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><p>生命周期分为pre和post，种类分为全局过滤器和单一过滤器</p>
<ol>
<li><p>配置官网过滤器：（更多配置项参考<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">官网</a>）</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filters:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">AddRequestParameter=XXX,1024</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置自定义过滤器：</p>
<ul>
<li><p>创建自定义过滤器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreGlobalCustomFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 过滤器，过滤逻辑</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;Global Pre Filter Execute...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 优先级，越小优先级越高</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务配置"><a href="#服务配置" class="headerlink" title="服务配置"></a>服务配置</h2></li>
</ul>
</li>
</ol>
<p>微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。</p>
<p>SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。</p>
<h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p>后续会讲到</p>
<h2 id="消息总线（停更）"><a href="#消息总线（停更）" class="headerlink" title="消息总线（停更）"></a>消息总线（停更）</h2><p>Spring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当作微服务间的通信通道。</p>
<h2 id="消息驱动"><a href="#消息驱动" class="headerlink" title="消息驱动"></a>消息驱动</h2><p>屏蔽底层消息中间件的差异,降低切换成本，统一消息的编程模型。通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。</p>
<h3 id="SpringCloud-Stream"><a href="#SpringCloud-Stream" class="headerlink" title="SpringCloud Stream"></a>SpringCloud Stream</h3><p>解决了不同消息队列之间的差异问题。</p>
<h2 id="分布式请求链路追踪"><a href="#分布式请求链路追踪" class="headerlink" title="分布式请求链路追踪"></a>分布式请求链路追踪</h2><p>在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。</p>
<h3 id="SpringCloud-Sleuth"><a href="#SpringCloud-Sleuth" class="headerlink" title="SpringCloud Sleuth"></a>SpringCloud Sleuth</h3><p>Spring Cloud Sleuth提供了一套完整的服务跟踪的解决方案。在分布式系统中提供追踪解决方案并且兼容支持了zipkin（展示面板）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221113195201025.png" alt="image-20221113195201025"></p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p><strong>运行zipkin</strong></p>
<ul>
<li>下载zipkin-server的jar包</li>
<li>java -jar 来运行</li>
<li>访问9411端口</li>
</ul>
<p><strong>配置Sleuth</strong></p>
<ul>
<li><p>给服务提供方/消费方导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-start-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>服务提供方/消费方配置yml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">zipkin:</span></span><br><span class="line">			<span class="attr">base-url:</span> <span class="string">http://localhost:9411</span></span><br><span class="line">        <span class="attr">sleuth:</span></span><br><span class="line">        	<span class="attr">sampler:</span></span><br><span class="line">        	<span class="comment">#采样率值介于0到1之间，1表示全部采集</span></span><br><span class="line">        		<span class="attr">probability:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p>在浏览器查看</p>
</li>
</ul>
<h2 id="SpringCloud-Alibaba"><a href="#SpringCloud-Alibaba" class="headerlink" title="SpringCloud Alibaba"></a>SpringCloud Alibaba</h2><p><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">Spring Cloud for Alibaba</a>，它是由一些阿里巴巴的开源组件和云产品组成的。这个项目的目的是为了让大家所熟知的Spring 框架，其优秀的设计模式和抽象理念，以给使用阿里巴巴产品的Java开发者带来使用Spring Boot和Spring Cloud的更多便利。</p>
<p>依托Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将Spring Cloud应用接入阿里微服务解决方案，通过阿里中间件来讯速搭建分布式应用系统。</p>
<p>包含的功能：</p>
<ul>
<li>服务限流降级：默认支持Servlet、Feign、RestTemplate、Dubbo和RocketMQ限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级Metrics 监控。</li>
<li>服务注册与发现：适配 Spring Cloud服务注册与发现标准，默认集成了Ribbon的支持。分布式配置管理:支持分布式系统中的外部化配置，配置更改时自动刷新。</li>
<li>消息驱动能力：基于Spring Cloud Stream为微服务应用构建消息驱动能力。</li>
<li>阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>
<li>分布式任务调度：提供秒级、精准、高可靠、高可用的定时 (基于Cron表达式)任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有Worker (schedulerx-client)上执行。</li>
</ul>
<p>相关组件：</p>
<ol>
<li>Sentinel：阿里巴巴开源产品，把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li>
<li>Nacos：阿里巴巴开源产品，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li>
<li>RocketMQ：Apache RocketMQ基于Java的高性能、高吞吐量的分布式消息和流计算平台。</li>
<li>Dubbo：Apache DubboM是―款高性能Java RPC框架。</li>
<li>Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li>
<li>OSS：阿里云对象存储服务（Object Storage Service，简称OSS)，是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>
<li>SchedulerX：阿里中间件团队开发的一款分布式任务调度产品，支持周期性的任务与固定时间点触发任务。</li>
</ol>
<p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Nacos-1"><a href="#Nacos-1" class="headerlink" title="Nacos"></a>Nacos</h3><p>一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。说白了Nacos就是注册中心＋配置中心的组合，替代了之前的注册中心Eureka、服务配置Config。并且Nacos支持AP和CP模式的切换（一般都是AP模式，只有当K8S服务和DNS服务等适用于CP模式）</p>
<p>官网：<a href="https://nacos.io/">https://nacos.io/</a></p>
<p>官方文档：<a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html">https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html</a></p>
<h4 id="安装并运行"><a href="#安装并运行" class="headerlink" title="安装并运行"></a>安装并运行</h4><ol>
<li><p>下载（地址：<a href="https://github.com/alibaba/nacos/releases%EF%BC%89">https://github.com/alibaba/nacos/releases）</a></p>
</li>
<li><p>解压点击bin目录下的startup.cmd：<code>startup.cmd -m standalone</code>先以单个nacos启动</p>
</li>
<li><p>访问<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> (账号密码默认是nacos)</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221113205723789.png" alt="image-20221113205723789"></p>
</li>
</ol>
<h4 id="注册中心-1"><a href="#注册中心-1" class="headerlink" title="注册中心"></a>注册中心</h4><p><strong>建立父工程：</strong></p>
<ul>
<li><p>编写pom文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.wht<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringCloudAlibabaTest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>SpringCloudAlibabaTest<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>SpringCloudAlibabaTest<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>ServiceProvider<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--设置父工程的包为pom--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.cloud.version</span>&gt;</span>2020.0.5<span class="tag">&lt;/<span class="name">spring.cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot依赖--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--springCloud Alibaba依赖--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.wht.SpringCloudAlibabaTestApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>环境配置时必须保持SpringBoot与SpringCloud版本对应(<a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a>)</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221107222026825.png" alt="image-20221107222026825"></p>
<p>避免以后模块太多，可以提前打开Run Dashboard</p>
<p>在workspace.xml中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;configurationTypes&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;SpringBootApplicationConfigurationType&quot;</span>/&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">set</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p><strong>服务提供子工程</strong></p>
<ul>
<li><p>导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注册中心--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- actuator--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写主启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProviderApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ServiceProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RestController</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoController</span> </span>&#123;</span><br><span class="line">        <span class="meta">@GetMapping(value = &quot;/echo/&#123;string&#125;&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(<span class="meta">@PathVariable</span> String string)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello Nacos Discovery &quot;</span> + string;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写yml文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ServiceProvider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos服务地址</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动主启动类</p>
</li>
<li><p>查看是否已经注册进nacos：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221113221022796.png" alt="image-20221113221022796"></p>
</li>
<li><p>模拟服务的集群（这里使用的复制启动类改端口方式，也可以再重新创建一个模块）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221115200300030.png" alt="image-20221115200300030"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221115200329852.png" alt="image-20221115200329852"></p>
<blockquote>
<p>因为nacos天生集成了Ribbon所以自带有负载均衡</p>
</blockquote>
</li>
</ul>
<p><strong>服务消费子工程</strong></p>
<ul>
<li><p>编写pom导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.wht<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ServiceConsumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>ServiceConsumer<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>ServiceConsumer<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.wht<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringCloudAlibabaTest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注册中心--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加 OpenFeign 依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 负载均衡--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- actuator--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.wht.ServiceConsumerApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置yml：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ServiceConsumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos服务地址</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8003</span></span><br><span class="line"></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="comment"># 日志级别</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">full</span></span><br><span class="line">        <span class="comment"># 从连接建立时开始应用，在返回响应时间过长时触发。</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="comment"># 指的是建立连接后从服务器读取到可用资源所用的时间</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment"># feign日志以什么级别监控哪个接口</span></span><br><span class="line">    <span class="attr">com.wht.service.FeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写服务调用接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;ServiceProvider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FeignService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/echo/&#123;str&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(<span class="meta">@PathVariable(value = &quot;str&quot;)</span> String string)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>主启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    FeignService feignService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ServiceConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RestController</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoController</span> </span>&#123;</span><br><span class="line">        <span class="meta">@GetMapping(value = &quot;/test/&#123;string&#125;&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(<span class="meta">@PathVariable</span> String string)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> feignService.echo(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用业务（会自动轮训负载均衡）：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221115212052328.png" alt="image-20221115212052328"></p>
</li>
</ul>
<h4 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h4><ul>
<li><p>建模块编写pom：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.wht<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>config<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>config<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.wht<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringCloudAlibabaTest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置中心--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注册中心--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- actuator--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.wht.ConfigApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>一个application.yml和bootstrap.yml</p>
<blockquote>
<p>Nacos和SpringCloudConfig一样，在项目初始化时，要保证先从配置中心进行拉取配置，配置拉取成功之后，才能保证项目的正常启动。</p>
<p>所以bootstrap.yml优先级高于application.yml</p>
<p>Nacos的配置规则：</p>
<ul>
<li>DataID：严格遵守${prefix}-${spring.profile.active}.${file-extension}官方提供的格式</li>
<li>prefix：prefix默认为spring.application.name 的值，也可以通过配置项spring.cloud.nacos.config.prefix来配置。</li>
<li>spring.profile.active：即为当前环境对应的profile，如果为空则-也会被去掉</li>
<li>file-extension：文件后缀只支持yaml和properties</li>
</ul>
</blockquote>
<ul>
<li><p>bootstrap.yml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8004</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-test</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos服务注册中心地址</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos 服务配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 指定配置文件的类型是yaml</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br></pre></td></tr></table></figure></li>
<li><p>application.yml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 代表开发环境</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>主启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">// 开启服务发现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>控制层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span>   <span class="comment">// @RefreshScope 支持Nacos的动态刷新功能 这个注解非常关键！！！！</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/config/info&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在nacos中进行全局配置</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221116205159308.png" alt="image-20221116205159308"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221116210907673.png" alt="image-20221116210907673"></p>
</li>
<li><p>访问验证：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221116211018018.png" alt="image-20221116211018018"></p>
</li>
<li><p>在nacos修改后：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221116211131920.png" alt="image-20221116211131920"></p>
</li>
</ul>
<p><strong>Nacos分类配置：</strong></p>
<p>实际开发环境中，通常一个系统会准备dev开发环境、test测试环境、prod生产环境等需要不同的配置文件。Nacos提供了Namespcae + Group + DataID的三层结构。</p>
<ul>
<li>Namespcae：Nacos默认的命名空间是public，Namespace主要用来实现隔离。比如说我们现在有三个环境：开发、测试、生产环境，我们就可以创建3个Namespace，不同的Namespace之间是隔离的。只需要在bootstrap的config下配置<code>namespace:命名空间唯一id</code>即可。</li>
<li>Group ：Group默认是DEFAULT_GROUP，Group可以把不同的微服务划分到同一个分组中去。只需要在bootstrap的config下配置<code>group:XX</code>即可。</li>
<li>DataID：就是指明到底是那个服务</li>
</ul>
<h4 id="集群和持久化配置"><a href="#集群和持久化配置" class="headerlink" title="集群和持久化配置"></a>集群和持久化配置</h4><p>Nacos支持三种部署模式：</p>
<ul>
<li>单机模式：用于测试和单机使用。</li>
<li>集群模式：用于生产环境，确保高可用性。</li>
<li>多集群模式：用于多数据中心场景。</li>
</ul>
<p>并且默认Nacos使用嵌入式数据库实现数据的存储。所以，如果启动多个默认配置下的Nacos节点，数据存储是存在一致性问题的。为了解决这个问题，Nacos采用了集中式存储的方式来支持集群化部署，目前只支持MySQL的存储。</p>
<h5 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h5><ul>
<li><p>执行sql脚本（在nacos\conf目录下自带有）</p>
</li>
<li><p>修改nacos配置文件（在nacos\conf目录下）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="meta">db.num</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">db.url.0</span>=<span class="string">jdbc:mysql://localhost:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">db.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure></li>
<li><p>重启nacos</p>
</li>
</ul>
<h5 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h5><p>集群结构图：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221116215937074.png" alt="image-20221116215937074"></p>
<p>因此开源的时候推荐用户把所有服务列表放到一个vip下面，然后挂到一个域名下面，预计需要，1个Nginx+3个nacos注册中心+1个mysql，所以建议使用docker搭建</p>
<p><strong>docker搭建</strong></p>
<p>这里nginx和mysql的安装以及数据库表创建就省略…直接安装nacos</p>
<p><strong>搭建nacos集群</strong></p>
<ul>
<li><p>拉取镜像：<code>docker pull nacos/nacos-server:1.4.0  </code></p>
</li>
<li><p>编写docker-compose.yml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span> </span><br><span class="line"><span class="attr">services:</span>  </span><br><span class="line">  <span class="attr">docker-nacos-server-1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server:1.4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nacos-server-1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8848:8848&quot;</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span>  <span class="comment"># 将Linux宿主机的IP赋给容器</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">SPRING_DATASOURCE_PLATFORM:</span> <span class="string">mysql</span> </span><br><span class="line">      <span class="attr">NACOS_SERVERS:</span> <span class="number">192.168</span><span class="number">.227</span><span class="number">.130</span><span class="string">:8848</span> <span class="number">192.168</span><span class="number">.227</span><span class="number">.130</span><span class="string">:8849</span> <span class="number">192.168</span><span class="number">.227</span><span class="number">.130</span><span class="string">:8850</span>  <span class="comment"># 集群中容器节点的IP地址</span></span><br><span class="line">      <span class="attr">MYSQL_SERVICE_HOST:</span> <span class="number">192.168</span><span class="number">.227</span><span class="number">.130</span></span><br><span class="line">      <span class="attr">NACOS_APPLICATION_PORT:</span> <span class="number">8848</span>  <span class="comment"># 该容器的端口号，如果不指定的话，默认就是8848</span></span><br><span class="line">      <span class="attr">MYSQL_SERVICE_DB_NAME:</span> <span class="string">nacos_config</span></span><br><span class="line">      <span class="attr">MYSQL_SERVICE_USER:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MYSQL_SERVICE_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">      <span class="comment"># JVM虚拟机参数，调小点，太大了启动不起来。</span></span><br><span class="line">      <span class="attr">JVM_XMS:</span> <span class="string">256m</span></span><br><span class="line">      <span class="attr">JVM_XMX:</span> <span class="string">256m</span></span><br><span class="line">      <span class="attr">JVM_XMN:</span> <span class="string">256m</span></span><br><span class="line">  <span class="attr">docker-nacos-server-2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server:1.4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nacos-server-2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8849:8848&quot;</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">SPRING_DATASOURCE_PLATFORM:</span> <span class="string">mysql</span> </span><br><span class="line">      <span class="attr">NACOS_SERVERS:</span> <span class="number">192.168</span><span class="number">.227</span><span class="number">.130</span><span class="string">:8848</span> <span class="number">192.168</span><span class="number">.227</span><span class="number">.130</span><span class="string">:8849</span> <span class="number">192.168</span><span class="number">.227</span><span class="number">.130</span><span class="string">:8850</span></span><br><span class="line">      <span class="attr">NACOS_APPLICATION_PORT:</span> <span class="number">8849</span></span><br><span class="line">      <span class="attr">MYSQL_SERVICE_HOST:</span> <span class="number">192.168</span><span class="number">.227</span><span class="number">.130</span></span><br><span class="line">      <span class="attr">MYSQL_SERVICE_DB_NAME:</span> <span class="string">nacos_config</span></span><br><span class="line">      <span class="attr">MYSQL_SERVICE_USER:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MYSQL_SERVICE_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">JVM_XMS:</span> <span class="string">256m</span></span><br><span class="line">      <span class="attr">JVM_XMX:</span> <span class="string">256m</span></span><br><span class="line">      <span class="attr">JVM_XMN:</span> <span class="string">256m</span></span><br><span class="line">  <span class="attr">docker-nacos-server-3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server:1.4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nacos-server-3</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8850:8848&quot;</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">SPRING_DATASOURCE_PLATFORM:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">NACOS_SERVERS:</span> <span class="number">192.168</span><span class="number">.227</span><span class="number">.130</span><span class="string">:8848</span> <span class="number">192.168</span><span class="number">.227</span><span class="number">.130</span><span class="string">:8849</span> <span class="number">192.168</span><span class="number">.227</span><span class="number">.130</span><span class="string">:8850</span></span><br><span class="line">      <span class="attr">NACOS_APPLICATION_PORT:</span> <span class="number">8850</span></span><br><span class="line">      <span class="attr">MYSQL_SERVICE_HOST:</span> <span class="number">192.168</span><span class="number">.227</span><span class="number">.130</span></span><br><span class="line">      <span class="attr">MYSQL_SERVICE_DB_NAME:</span> <span class="string">nacos_config</span></span><br><span class="line">      <span class="attr">MYSQL_SERVICE_USER:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MYSQL_SERVICE_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">JVM_XMS:</span> <span class="string">256m</span></span><br><span class="line">      <span class="attr">JVM_XMX:</span> <span class="string">256m</span></span><br><span class="line">      <span class="attr">JVM_XMN:</span> <span class="string">256m</span></span><br></pre></td></tr></table></figure></li>
<li><p>运行：<code>docker-compose up -d </code></p>
</li>
<li><p>访问<a href="http://192.168.227.130:8848/nacos%E8%BF%9B%E8%A1%8C%E9%AA%8C%E8%AF%81">http://192.168.227.130:8848/nacos进行验证</a></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221117190423735.png" alt="image-20221117190423735"></p>
</li>
</ul>
<p><strong>利用ngnix进行反向代理</strong></p>
<ul>
<li><p>编写配置文件添加返校代理(这里需要注意释放端口)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream nacosList &#123;</span><br><span class="line">    server 192.168.227.130:8848;</span><br><span class="line">    server 192.168.227.130:8849;</span><br><span class="line">    server 192.168.227.130:8850;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">	listen 1111;</span><br><span class="line">	server_name nacosServer;</span><br><span class="line">	location &#x2F;nacos &#123;</span><br><span class="line">        proxy_pass  https:&#x2F;&#x2F;nacosList&#x2F;nacos;</span><br><span class="line">        proxy_ssl_session_reuse off;</span><br><span class="line">        proxy_ssl_server_name on;</span><br><span class="line">        proxy_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>直接访问 <code>http://ip:1111/nacos</code>即可</p>
</li>
</ul>
<h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 是面向分布式、多语言异构化服务架构的流量治理组件，主要以流量为切入点，从流量路由、流量控制、流量整形、熔断降级、系统自适应过载保护、热点流量防护等多个维度来帮助开发者保障微服务的稳定性。</p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p><strong>流量控制</strong></p>
<p>在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状，如下图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221119152247911.png" alt="image-20221119152247911"></p>
<p>流量控制有以下几个角度:</p>
<ul>
<li>资源的调用关系，例如资源的调用链路，资源和资源之间的关系；</li>
<li>运行指标，例如 QPS、线程池、系统负载等；</li>
<li>控制的效果，例如直接限流、冷启动、排队等。</li>
</ul>
<p><strong>熔断降级</strong></p>
<p>除了流量控制以外，降低调用链路中的不稳定资源也是 Sentinel 的使命之一。由于调用关系的复杂性，如果调用链路中的某个资源出现了不稳定，最终会导致请求发生堆积。这个问题和 <a href="https://github.com/Netflix/Hystrix/wiki#what-problem-does-hystrix-solve">Hystrix</a> 里面描述的问题是一样的。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221119152331405.png" alt="image-20221119152331405"></p>
<p>Sentinel 和 Hystrix 的原则是一致的: 当调用链路中某个资源出现不稳定，例如，表现为 timeout，异常比例升高的时候，则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生雪崩的效果。</p>
<blockquote>
<p><strong>熔断降级设计理念</strong></p>
<p>Sentinel 对这个问题采取了两种手段：</p>
<ul>
<li><p>通过并发线程数进行限制</p>
<p>和资源池隔离的方法不同，Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。这样不但没有线程切换的损耗，也不需要您预先分配线程池的大小。当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。</p>
</li>
<li><p>通过响应时间对资源进行降级</p>
<p>除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复。</p>
</li>
</ul>
</blockquote>
<p><strong>系统负载保护</strong></p>
<p>Sentinel 同时提供<strong>系统维度的自适应保护能力</strong>防止雪崩，是系统防护中重要的一环。当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。</p>
<p>针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。</p>
<h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><ul>
<li><p>下载地址：<code>https://github.com/alibaba/Sentinel/releases</code>下载jar包</p>
</li>
<li><p>java -jar 运行sentinel</p>
</li>
<li><p>浏览器访问8080端口：(账号密码都是sentinel)</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221119153531758.png" alt="image-20221119153531758"></p>
</li>
</ul>
<h4 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h4><p><strong>搭建子模块：</strong></p>
<ul>
<li><p>编写pom：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.wht<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinelTest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>sentinelTest<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>sentinelTest<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.wht<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringCloudAlibabaTest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--后续持久化会用到--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置中心--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注册中心--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加 OpenFeign 依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 负载均衡--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- actuator--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.wht.SentinelTestApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写yml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8005</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sentinelTest</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># nacos服务注册地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="comment"># 配置dashboard地址</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br><span class="line">        <span class="comment"># 默认8719端口</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelTestApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SentinelTestApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RestController</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowLimitController</span></span>&#123;</span><br><span class="line">        <span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">testA</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;-----testA&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@GetMapping(&quot;/testB&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">testB</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;----testB&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动项目访问业务（因为sentinel使用的懒加载）</p>
</li>
<li><p>查看sentinel：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221119163940512.png" alt="image-20221119163940512"></p>
</li>
</ul>
<h4 id="功能使用"><a href="#功能使用" class="headerlink" title="功能使用"></a>功能使用</h4><h5 id="流控规则"><a href="#流控规则" class="headerlink" title="流控规则"></a>流控规则</h5><p><strong>相关概念</strong></p>
<ul>
<li>资源名：唯一名称，默认请求路径。</li>
<li>针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default（不区分来源）。</li>
<li>阈值类型/单机阈值：<ul>
<li><strong>QPS（每秒钟的请求数量）：当调用该api的QPS达到阈值的时候，进行限流。</strong></li>
<li><strong>线程数：当调用该api的线程数达到阈值的时候，进行限流。</strong></li>
</ul>
</li>
<li>是否集群：不需要集群。</li>
<li>流控模式：<ul>
<li>直接：api达到限流条件时，直接限流。</li>
<li>关联：当关联的资源达到阈值时，就限流自己。</li>
<li>链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流）【api级别的针对来源】。</li>
</ul>
</li>
<li>流控效果：<ul>
<li>快速失败：直接失败，抛异常。</li>
<li>Warm Up：根据coldFactor（冷加载因子，默认3）的值，从阈值/coldFactor，经过预热时长，才达到设置的QPS阈值。</li>
<li>排队等待：匀速排队，让请求以均匀的速度通过，阈值类型必须为QPS，否则无效。</li>
</ul>
</li>
</ul>
<p><strong>流控模式</strong></p>
<ol>
<li><p>直接失败</p>
<ul>
<li><p>配置流控：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221119164752752.png" alt="image-20221119164752752"></p>
</li>
<li><p>每秒超过一次请求则直接失败：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221119164836493.png" alt="image-20221119164836493"></p>
</li>
</ul>
</li>
<li><p>关联：当关联的资源达到阈值时，就限流自己</p>
<ul>
<li><p>配置：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221119165608216.png" alt="image-20221119165608216"></p>
</li>
<li><p>当testB每秒请求超过一次之后testA对自己进行限流：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221119165752310.png" alt="image-20221119165752310"></p>
</li>
</ul>
</li>
<li><p>链路：根据调用链路入口限流</p>
<ul>
<li><p>修改业务让testB调用testA()</p>
</li>
<li><p>配置：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221119170415257.png" alt="image-20221119170415257"></p>
</li>
<li><p>当testB调用的testA每秒超过一次请求之后，就会对testA进行限流</p>
</li>
</ul>
</li>
</ol>
<p><strong>流控效果</strong></p>
<ol>
<li><p>快速失败：直接报Blocked by Sentinel (flow limiting)错误</p>
</li>
<li><p>预热：</p>
<ul>
<li><p>公式：阈值除以coldFactor(默认值为3),经过预热时长后才会达到阈值</p>
</li>
<li><p>案例：阀值为10+预热时长设置5秒，系统初始化的阀值为10/ 3约等于3,即阀值刚开始为刭；然后过了5秒后阀值才慢慢升高恢复到10</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221119171055704.png" alt="image-20221119171055704"></p>
</li>
</ul>
</li>
<li><p>排队等待：让请求以均匀的速度通过，阀值类型必须设成QPS，否则无效。</p>
<ul>
<li><p>案例：/testA每秒1次请求，超过的话就排队等待，等待的超时时间为500毫秒。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221119171411050.png" alt="image-20221119171411050"></p>
</li>
</ul>
</li>
</ol>
<h5 id="降级规则"><a href="#降级规则" class="headerlink" title="降级规则"></a>降级规则</h5><p>除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。由于调用关系的复杂性，如果调用链路中的某个资源不稳定，最终会导致请求发生堆积。Sentinel熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高)，对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出DegradeException ) 。</p>
<p><strong>相关概念</strong></p>
<ul>
<li>平均响应时间 (<code>DEGRADE_GRADE_RT</code>)：当 1s 内持续进入N个请求（可配置默认5），对应时刻的平均响应时间（秒级）均超过阈值（<code>count</code>，以 ms 为单位），那么在接下的时间窗口（<code>DegradeRule</code> 中的 <code>timeWindow</code>，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 <code>DegradeException</code>）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，<strong>超出此阈值的都会算作 4900 ms</strong>，若需要变更此上限可以通过启动配置项 <code>-Dcsp.sentinel.statistic.max.rt=xxx</code> 来配置。</li>
<li>异常比例 (<code>DEGRADE_GRADE_EXCEPTION_RATIO</code>)：当资源的每秒请求量 &gt;= N（可配置默认5），并且每秒异常总数占通过量的比值超过阈值（<code>DegradeRule</code> 中的 <code>count</code>）之后，资源进入降级状态，即在接下的时间窗口（<code>DegradeRule</code> 中的 <code>timeWindow</code>，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 0% - 100%。</li>
<li>异常数 (<code>DEGRADE_GRADE_EXCEPTION_COUNT</code>)：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 <code>timeWindow</code> 小于 60s，则结束熔断状态后仍可能再进入熔断状态。</li>
</ul>
<p><strong>配置实战</strong></p>
<ol>
<li><p>RT：</p>
<ul>
<li><p>让程序睡一秒钟</p>
</li>
<li><p>配置：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221119172420933.png" alt="image-20221119172420933"></p>
</li>
<li><p>持续访问：</p>
<p>永远一秒钟打进来10个线程（大于5个了)调用testD，我们希望200毫秒处理完本次任务，但是超时服务就会被熔断不可用，直到满足条件则会恢复</p>
</li>
</ul>
</li>
<li><p>异常比例：</p>
<ul>
<li><p>制造异常</p>
</li>
<li><p>配置：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221119173315901.png" alt="image-20221119173315901"></p>
</li>
<li><p>持续访问：</p>
<p>同样只要请求数以及异常比例达到阈值就会触发熔断，服务不可用</p>
</li>
</ul>
</li>
<li><p>异常数：</p>
<ul>
<li><p>配置：<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221119173552971.png" alt="image-20221119173552971"></p>
</li>
<li><p>持续访问：</p>
<p>同样只要请求数以及单请求异常数目达到阈值就会触发熔断，服务不可用</p>
</li>
</ul>
</li>
</ol>
<h5 id="热点规则"><a href="#热点规则" class="headerlink" title="热点规则"></a>热点规则</h5><p>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。</p>
<p><strong>具体实现</strong></p>
<ul>
<li><p>重新编写业务类（可以通过@SentinelResource来指定资源名以及兜底方法）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testHotKey&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testHotKey&quot;,blockHandler = &quot;handlerException&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testHotKey</span><span class="params">(<span class="meta">@RequestParam(value = &quot;v1&quot;,required = false,defaultValue = &quot;1&quot;)</span> String v1,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="meta">@RequestParam(value = &quot;v2&quot;,required = false,defaultValue = &quot;2&quot;)</span> String v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;testHotKey&quot;</span> + v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**系统的自定义熔断限流异常处理方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handlerException</span><span class="params">(String v1, String v2, BlockException exception)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;系统暂时不可用...&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221119175150302.png" alt="image-20221119175150302"></p>
</li>
<li><p>效果：当访问该资源带了热点参数并且请求数超过阈值则会调用兜底方法</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221119175326307.png" alt="image-20221119175326307"></p>
</li>
</ul>
<p><strong>参数例外项</strong></p>
<p>可以对参数进行更加细致化的区分（例如类型、值等）</p>
<p>案例：当参数为String类型并且等于5时阈值变为500</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221119180112191.png" alt="image-20221119180112191"></p>
<h5 id="系统规则"><a href="#系统规则" class="headerlink" title="系统规则"></a>系统规则</h5><p>Sentinel系统自适应限流从<strong>整体维度对应用入口流量进行控制</strong>，结合应用的Load、CPU使用率、总体平均RT、入口QPS和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221120174313608.png" alt="image-20221120174313608"></p>
<p>系统规则支持以下的模式：</p>
<ul>
<li><strong>Load 自适应</strong>（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 <code>maxQps * minRt</code> 估算得出。设定参考值一般是 <code>CPU cores * 2.5</code>。</li>
<li><strong>CPU usage</strong>（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</li>
<li><strong>平均 RT</strong>：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li>
<li><strong>并发线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li>
<li><strong>入口 QPS</strong>：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li>
</ul>
<h4 id="SentinelResource配置"><a href="#SentinelResource配置" class="headerlink" title="SentinelResource配置"></a>SentinelResource配置</h4><ol>
<li><p>可以配置资源名称，以及兜底方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(value = &quot;testHotKey&quot;,blockHandler = &quot;handlerException&quot;)</span></span><br></pre></td></tr></table></figure></li>
<li><p>指定兜底方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(value = &quot;testHotKey&quot;,blockHandlerClass = CustomerBlockHandler.class,blockHandler = &quot;handlerException&quot;)</span></span><br></pre></td></tr></table></figure>
<h4 id="服务熔断-1"><a href="#服务熔断-1" class="headerlink" title="服务熔断"></a>服务熔断</h4></li>
</ol>
<p><strong>具体实现</strong></p>
<ul>
<li><p>创建服务提供者（跟nacos案例一致略）</p>
</li>
<li><p>创建服务调用接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;ServiceProvider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FeignService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/echo/&#123;str&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(<span class="meta">@PathVariable(value = &quot;str&quot;)</span> String string)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>业务类（feign用的同一个兜底方法）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testA&quot;,fallback = &quot;handlerFallback&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> feignService.echo(<span class="string">&quot;测试&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handlerFallback</span><span class="params">(Throwable e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;系统出现故障/限流&quot;</span> + e.getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以添加这个注解<code>@FeignClient(value = &quot;ServiceProvider&quot;,fallback = FeignServiceFallback.class)</code></p>
<p>实现兜底类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignServiceFallback</span> <span class="keyword">implements</span> <span class="title">FeignService</span></span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;系统出现故障&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="规则持久化"><a href="#规则持久化" class="headerlink" title="规则持久化"></a>规则持久化</h4></li>
</ul>
<p>由于sentinel默认的规则是临时性的，只要服务一重启规则就丢失了。</p>
<p>所以我们将限流配置规则持久化进Nacos保存，只要刷新服务的某个rest地址,sentinel控制台的流控规则就能看到，只要Naos里面的配置不删除，sentinel上的流控规则持续有效</p>
<p><strong>具体实现</strong></p>
<ul>
<li><p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>yml配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sentinelTest</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># nacos服务注册地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="comment"># 配置dashboard地址</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br><span class="line">        <span class="comment"># 默认8719端口</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">ds1:</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">            <span class="attr">data-type:</span> <span class="string">json</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span></span><br></pre></td></tr></table></figure></li>
<li><p>在nacos中添加配置：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221120202412362.png" alt="image-20221120202412362"></p>
<ul>
<li><strong>resource</strong>：资源名称。</li>
<li><strong>limitApp</strong>：来源应用。</li>
<li><strong>grade</strong>：阈值类型，0表示线程数，1表示QPS。</li>
<li><strong>count</strong>：单机阈值。</li>
<li><strong>strategy</strong>：流控模式，0表示直接，1表示关联，2表示链路。</li>
<li><strong>controlBehavior</strong>：流控效果，0表示快速失败，1表示Warm Up，2表示排队等待。</li>
<li><strong>clusterMode</strong>：是否集群。</li>
</ul>
</li>
<li><p>启动服务：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221120202756159.png" alt="image-20221120202756159"></p>
</li>
</ul>
<h3 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用，分别使用三个独立的数据源，业务操作需要调用三个服务来完成。此时每个服务内部的数据一致性由本地事务来保证，但是全局的数据一致性问题没办法保证。这个时候就需要处理分布式事务问题。</p>
<p>Seata是具有高性能和易用性的分布式事务解决方案。</p>
<p><strong>相关术语：</strong></p>
<ul>
<li><code>Transaction ID</code>(XID)：全局唯一事务ID。</li>
<li><code>TransactionCoordinator(TC)</code>：事务协调器，维护全局和分支事务的状态，驱动全局事务提交或回滚。</li>
<li><code>TransactionManager(TM)</code>：事务管理器，定义全局事务的范围：开始全局事务、提交或回滚全局事务。</li>
<li><code>ResourceManager(RM)</code>：资源管理器，管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>
</ul>
<p><strong>处理过程：</strong></p>
<ul>
<li>TM向TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID。</li>
<li>XID在微服务调用链路的上下文中传播。</li>
<li>RM向TC注册分支服务，将其纳入XID对应全局事务的管辖。</li>
<li>TM向TC发起针对XID的全局提交或回滚决议。</li>
<li>TC调度XID下管辖的全部分支事务完成提交或回滚请求。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221121142441253.png" alt="image-20221121142441253"></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li><p><strong>官网地址：<a href="http://seata.io./">http://seata.io。</a></strong></p>
</li>
<li><p><strong>下载地址：<a href="https://github.com/seata/seata/releases%E3%80%82">https://github.com/seata/seata/releases。</a></strong></p>
</li>
<li><p>下载：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221121153358750.png" alt="image-20221121153358750"></p>
</li>
<li><p>修改conf下的配置文件：</p>
<ul>
<li><p>registry.conf(我使用的nacos作为配置中心和注册中心)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br><span class="line">  type &#x3D; &quot;nacos&quot;</span><br><span class="line">  loadBalance &#x3D; &quot;RandomLoadBalance&quot;</span><br><span class="line">  loadBalanceVirtualNodes &#x3D; 10</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    application &#x3D; &quot;seata-server&quot;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:8848&quot;</span><br><span class="line">    group &#x3D; &quot;SEATA_GROUP&quot;</span><br><span class="line">    namespace &#x3D; &quot;&quot;</span><br><span class="line">    cluster &#x3D; &quot;default&quot;</span><br><span class="line">    username &#x3D; &quot;nacos&quot;</span><br><span class="line">    password &#x3D; &quot;nacos&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config &#123;</span><br><span class="line">  # file、nacos 、apollo、zk、consul、etcd3</span><br><span class="line">  type &#x3D; &quot;nacos&quot;</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:8848&quot;</span><br><span class="line">    namespace &#x3D; &quot;&quot;</span><br><span class="line">    group &#x3D; &quot;SEATA_GROUP&quot;</span><br><span class="line">    username &#x3D; &quot;nacos&quot;</span><br><span class="line">    password &#x3D; &quot;nacos&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>file.conf：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">store &#123;</span><br><span class="line">  ## store mode: file、db、redis</span><br><span class="line">  mode &#x3D; &quot;db&quot;</span><br><span class="line">  ## database store property</span><br><span class="line">  db &#123;</span><br><span class="line">    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)&#x2F;BasicDataSource(dbcp)&#x2F;HikariDataSource(hikari) etc.</span><br><span class="line">    datasource &#x3D; &quot;druid&quot;</span><br><span class="line">    ## mysql&#x2F;oracle&#x2F;postgresql&#x2F;h2&#x2F;oceanbase etc.</span><br><span class="line">    dbType &#x3D; &quot;mysql&quot;</span><br><span class="line">    driverClassName &#x3D; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">    url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;42.193.***.***:3981&#x2F;seate_server&quot;</span><br><span class="line">    user &#x3D; &quot;root&quot;</span><br><span class="line">    password &#x3D; &quot;*****&quot;</span><br><span class="line">    minConn &#x3D; 5</span><br><span class="line">    maxConn &#x3D; 100</span><br><span class="line">    globalTable &#x3D; &quot;global_table&quot;</span><br><span class="line">    branchTable &#x3D; &quot;branch_table&quot;</span><br><span class="line">    lockTable &#x3D; &quot;lock_table&quot;</span><br><span class="line">    queryLimit &#x3D; 100</span><br><span class="line">    maxWait &#x3D; 5000</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>创建数据库表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- -------------------------------- The script used when storeMode is &#x27;db&#x27; --------------------------------</span></span><br><span class="line"><span class="comment">-- the table to store GlobalSession data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `global_table`</span><br><span class="line">(</span><br><span class="line">    `xid`                       <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `transaction_id`            <span class="type">BIGINT</span>,</span><br><span class="line">    `status`                    TINYINT      <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `application_id`            <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `transaction_service_group` <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `transaction_name`          <span class="type">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">    `timeout`                   <span class="type">INT</span>,</span><br><span class="line">    `begin_time`                <span class="type">BIGINT</span>,</span><br><span class="line">    `application_data`          <span class="type">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    `gmt_create`                DATETIME,</span><br><span class="line">    `gmt_modified`              DATETIME,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`xid`),</span><br><span class="line">    KEY `idx_status_gmt_modified` (`status` , `gmt_modified`),</span><br><span class="line">    KEY `idx_transaction_id` (`transaction_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store BranchSession data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `branch_table`</span><br><span class="line">(</span><br><span class="line">    `branch_id`         <span class="type">BIGINT</span>       <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `xid`               <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `transaction_id`    <span class="type">BIGINT</span>,</span><br><span class="line">    `resource_group_id` <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `resource_id`       <span class="type">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    `branch_type`       <span class="type">VARCHAR</span>(<span class="number">8</span>),</span><br><span class="line">    `status`            TINYINT,</span><br><span class="line">    `client_id`         <span class="type">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">    `application_data`  <span class="type">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    `gmt_create`        DATETIME(<span class="number">6</span>),</span><br><span class="line">    `gmt_modified`      DATETIME(<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`branch_id`),</span><br><span class="line">    KEY `idx_xid` (`xid`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store lock data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `lock_table`</span><br><span class="line">(</span><br><span class="line">    `row_key`        <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `xid`            <span class="type">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">    `transaction_id` <span class="type">BIGINT</span>,</span><br><span class="line">    `branch_id`      <span class="type">BIGINT</span>       <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `resource_id`    <span class="type">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    `table_name`     <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `pk`             <span class="type">VARCHAR</span>(<span class="number">36</span>),</span><br><span class="line">    `status`         TINYINT      <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;0:locked ,1:rollbacking&#x27;</span>,</span><br><span class="line">    `gmt_create`     DATETIME,</span><br><span class="line">    `gmt_modified`   DATETIME,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`row_key`),</span><br><span class="line">    KEY `idx_status` (`status`),</span><br><span class="line">    KEY `idx_branch_id` (`branch_id`),</span><br><span class="line">    KEY `idx_xid` (`xid`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `distributed_lock`</span><br><span class="line">(</span><br><span class="line">    `lock_key`       <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `lock_value`     <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `expire`         <span class="type">BIGINT</span>,</span><br><span class="line">    <span class="keyword">primary</span> key (`lock_key`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;AsyncCommitting&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;RetryCommitting&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;RetryRollbacking&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;TxTimeoutCheck&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>接下来就是seata的配置文件了写入nacos里：</p>
<ul>
<li><p>nacos-config.sh：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># Copyright 1999-2019 Seata.io Group.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"># you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"># You may obtain a copy of the License at、</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">&quot;:h:p:g:t:u:w:&quot;</span> opt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$opt</span> <span class="keyword">in</span></span><br><span class="line">  h)</span><br><span class="line">    host=<span class="variable">$OPTARG</span></span><br><span class="line">    ;;</span><br><span class="line">  p)</span><br><span class="line">    port=<span class="variable">$OPTARG</span></span><br><span class="line">    ;;</span><br><span class="line">  g)</span><br><span class="line">    group=<span class="variable">$OPTARG</span></span><br><span class="line">    ;;</span><br><span class="line">  t)</span><br><span class="line">    tenant=<span class="variable">$OPTARG</span></span><br><span class="line">    ;;</span><br><span class="line">  u)</span><br><span class="line">    username=<span class="variable">$OPTARG</span></span><br><span class="line">    ;;</span><br><span class="line">  w)</span><br><span class="line">    password=<span class="variable">$OPTARG</span></span><br><span class="line">    ;;</span><br><span class="line">  ?)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot; USAGE OPTION: <span class="variable">$0</span> [-h host] [-p port] [-g group] [-t tenant] [-u username] [-w password] &quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">    ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$&#123;host&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">    host=localhost</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$&#123;port&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">    port=8848</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$&#123;group&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">    group=<span class="string">&quot;SEATA_GROUP&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$&#123;tenant&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">    tenant=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$&#123;username&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">    username=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$&#123;password&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">    password=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line">nacosAddr=<span class="variable">$host</span>:<span class="variable">$port</span></span><br><span class="line">contentType=<span class="string">&quot;content-type:application/json;charset=UTF-8&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;set nacosAddr=<span class="variable">$nacosAddr</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;set group=<span class="variable">$group</span>&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="title">urlencode</span></span>() &#123;</span><br><span class="line">  length=<span class="string">&quot;<span class="variable">$&#123;#1&#125;</span>&quot;</span></span><br><span class="line">  i=0</span><br><span class="line">  <span class="keyword">while</span> [ <span class="variable">$length</span> -gt <span class="variable">$i</span> ]; <span class="keyword">do</span></span><br><span class="line">    char=<span class="string">&quot;<span class="variable">$&#123;1:$i:1&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$char</span> <span class="keyword">in</span></span><br><span class="line">    [a-zA-Z0-9.~_-]) <span class="built_in">printf</span> <span class="variable">$char</span> ;;</span><br><span class="line">    *) <span class="built_in">printf</span> <span class="string">&#x27;%%%02X&#x27;</span> <span class="string">&quot;&#x27;<span class="variable">$char</span>&quot;</span> ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    i=`expr <span class="variable">$i</span> + 1`</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">failCount=0</span><br><span class="line">tempLog=$(mktemp -u)</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">addConfig</span></span>() &#123;</span><br><span class="line">  dataId=`urlencode <span class="variable">$1</span>`</span><br><span class="line">  content=`urlencode <span class="variable">$2</span>`</span><br><span class="line">  curl -X POST -H <span class="string">&quot;<span class="variable">$&#123;contentType&#125;</span>&quot;</span> <span class="string">&quot;http://<span class="variable">$nacosAddr</span>/nacos/v1/cs/configs?dataId=<span class="variable">$dataId</span>&amp;group=<span class="variable">$group</span>&amp;content=<span class="variable">$content</span>&amp;tenant=<span class="variable">$tenant</span>&amp;username=<span class="variable">$username</span>&amp;password=<span class="variable">$password</span>&quot;</span> &gt;<span class="string">&quot;<span class="variable">$&#123;tempLog&#125;</span>&quot;</span> 2&gt;/dev/null</span><br><span class="line">  <span class="keyword">if</span> [ -z $(cat <span class="string">&quot;<span class="variable">$&#123;tempLog&#125;</span>&quot;</span>) ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot; Please check the cluster status. &quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="subst">$(cat <span class="string">&quot;<span class="variable">$&#123;tempLog&#125;</span>&quot;</span>)</span>&quot;</span> == <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Set <span class="variable">$1</span>=<span class="variable">$2</span> successfully &quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Set <span class="variable">$1</span>=<span class="variable">$2</span> failure &quot;</span></span><br><span class="line">    failCount=`expr <span class="variable">$failCount</span> + 1`</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">count=0</span><br><span class="line">COMMENT_START=<span class="string">&quot;#&quot;</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> $(cat $(dirname <span class="string">&quot;<span class="variable">$PWD</span>&quot;</span>)/config.txt | sed s/[[:space:]]//g); <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$line</span>&quot;</span> =~ ^<span class="string">&quot;<span class="variable">$&#123;COMMENT_START&#125;</span>&quot;</span>.*  ]]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    count=`expr <span class="variable">$count</span> + 1`</span><br><span class="line">	  key=<span class="variable">$&#123;line%%=*&#125;</span></span><br><span class="line">    value=<span class="variable">$&#123;line#*=&#125;</span></span><br><span class="line">	  addConfig <span class="string">&quot;<span class="variable">$&#123;key&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;value&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=========================================================================&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; Complete initialization parameters,  total-count:<span class="variable">$count</span> ,  failure-count:<span class="variable">$failCount</span> &quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=========================================================================&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;failCount&#125;</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot; Init nacos config finished, please start seata-server. &quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot; init nacos config fail. &quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置文件config.txt（放bin目录同级）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#For details about configuration items, see https://seata.io/zh-cn/docs/user/configurations.html</span><br><span class="line">#Transport configuration, for client and server</span><br><span class="line">transport.type=TCP</span><br><span class="line">transport.server=NIO</span><br><span class="line">transport.heartbeat=true</span><br><span class="line">transport.enableTmClientBatchSendRequest=false</span><br><span class="line">transport.enableRmClientBatchSendRequest=true</span><br><span class="line">transport.enableTcServerBatchSendResponse=false</span><br><span class="line">transport.rpcRmRequestTimeout=30000</span><br><span class="line">transport.rpcTmRequestTimeout=30000</span><br><span class="line">transport.rpcTcRequestTimeout=30000</span><br><span class="line">transport.threadFactory.bossThreadPrefix=NettyBoss</span><br><span class="line">transport.threadFactory.workerThreadPrefix=NettyServerNIOWorker</span><br><span class="line">transport.threadFactory.serverExecutorThreadPrefix=NettyServerBizHandler</span><br><span class="line">transport.threadFactory.shareBossWorker=false</span><br><span class="line">transport.threadFactory.clientSelectorThreadPrefix=NettyClientSelector</span><br><span class="line">transport.threadFactory.clientSelectorThreadSize=1</span><br><span class="line">transport.threadFactory.clientWorkerThreadPrefix=NettyClientWorkerThread</span><br><span class="line">transport.threadFactory.bossThreadSize=1</span><br><span class="line">transport.threadFactory.workerThreadSize=default</span><br><span class="line">transport.shutdown.wait=3</span><br><span class="line">transport.serialization=seata</span><br><span class="line">transport.compressor=none</span><br><span class="line"></span><br><span class="line">#Transaction routing rules configuration, only for the client</span><br><span class="line">service.vgroupMapping.my_test_tx_group=default</span><br><span class="line">#If you use a registry, you can ignore it</span><br><span class="line">service.default.grouplist=127.0.0.1:8091</span><br><span class="line">service.enableDegrade=false</span><br><span class="line">service.disableGlobalTransaction=false</span><br><span class="line"></span><br><span class="line">#Transaction rule configuration, only for the client</span><br><span class="line">client.rm.asyncCommitBufferLimit=10000</span><br><span class="line">client.rm.lock.retryInterval=10</span><br><span class="line">client.rm.lock.retryTimes=30</span><br><span class="line">client.rm.lock.retryPolicyBranchRollbackOnConflict=true</span><br><span class="line">client.rm.reportRetryCount=5</span><br><span class="line">client.rm.tableMetaCheckEnable=true</span><br><span class="line">client.rm.tableMetaCheckerInterval=60000</span><br><span class="line">client.rm.sqlParserType=druid</span><br><span class="line">client.rm.reportSuccessEnable=false</span><br><span class="line">client.rm.sagaBranchRegisterEnable=false</span><br><span class="line">client.rm.sagaJsonParser=fastjson</span><br><span class="line">client.rm.tccActionInterceptorOrder=-2147482648</span><br><span class="line">client.tm.commitRetryCount=5</span><br><span class="line">client.tm.rollbackRetryCount=5</span><br><span class="line">client.tm.defaultGlobalTransactionTimeout=60000</span><br><span class="line">client.tm.degradeCheck=false</span><br><span class="line">client.tm.degradeCheckAllowTimes=10</span><br><span class="line">client.tm.degradeCheckPeriod=2000</span><br><span class="line">client.tm.interceptorOrder=-2147482648</span><br><span class="line">client.undo.dataValidation=true</span><br><span class="line">client.undo.logSerialization=jackson</span><br><span class="line">client.undo.onlyCareUpdateColumns=true</span><br><span class="line">server.undo.logSaveDays=7</span><br><span class="line">server.undo.logDeletePeriod=86400000</span><br><span class="line">client.undo.logTable=undo_log</span><br><span class="line">client.undo.compress.enable=true</span><br><span class="line">client.undo.compress.type=zip</span><br><span class="line">client.undo.compress.threshold=64k</span><br><span class="line">#For TCC transaction mode</span><br><span class="line">tcc.fence.logTableName=tcc_fence_log</span><br><span class="line">tcc.fence.cleanPeriod=1h</span><br><span class="line"></span><br><span class="line">#Log rule configuration, for client and server</span><br><span class="line">log.exceptionRate=100</span><br><span class="line"></span><br><span class="line">#Transaction storage configuration, only for the server. The file, db, and redis configuration values are optional.</span><br><span class="line">store.mode=db</span><br><span class="line">store.lock.mode=file</span><br><span class="line">store.session.mode=file</span><br><span class="line">#Used for password encryption</span><br><span class="line">store.publicKey=</span><br><span class="line"></span><br><span class="line">#If `store.mode,store.lock.mode,store.session.mode` are not equal to `file`, you can remove the configuration block.</span><br><span class="line">store.file.dir=file_store/data</span><br><span class="line">store.file.maxBranchSessionSize=16384</span><br><span class="line">store.file.maxGlobalSessionSize=512</span><br><span class="line">store.file.fileWriteBufferCacheSize=16384</span><br><span class="line">store.file.flushDiskMode=async</span><br><span class="line">store.file.sessionReloadReadSize=100</span><br><span class="line"></span><br><span class="line">#These configurations are required if the `store mode` is `db`. If `store.mode,store.lock.mode,store.session.mode` are not equal to `db`, you can remove the configuration block.</span><br><span class="line">store.db.datasource=druid</span><br><span class="line">store.db.dbType=mysql</span><br><span class="line">store.db.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">store.db.url=jdbc:mysql://127.0.0.1:3306/seata?useUnicode=yes&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">store.db.user=root</span><br><span class="line">store.db.password=123456</span><br><span class="line">store.db.minConn=5</span><br><span class="line">store.db.maxConn=30</span><br><span class="line">store.db.globalTable=global_table</span><br><span class="line">store.db.branchTable=branch_table</span><br><span class="line">store.db.distributedLockTable=distributed_lock</span><br><span class="line">store.db.queryLimit=100</span><br><span class="line">store.db.lockTable=lock_table</span><br><span class="line">store.db.maxWait=5000</span><br><span class="line"></span><br><span class="line">#These configurations are required if the `store mode` is `redis`. If `store.mode,store.lock.mode,store.session.mode` are not equal to `redis`, you can remove the configuration block.</span><br><span class="line">store.redis.mode=single</span><br><span class="line">store.redis.single.host=127.0.0.1</span><br><span class="line">store.redis.single.port=6379</span><br><span class="line">store.redis.sentinel.masterName=</span><br><span class="line">store.redis.sentinel.sentinelHosts=</span><br><span class="line">store.redis.maxConn=10</span><br><span class="line">store.redis.minConn=1</span><br><span class="line">store.redis.maxTotal=100</span><br><span class="line">store.redis.database=0</span><br><span class="line">store.redis.password=</span><br><span class="line">store.redis.queryLimit=100</span><br><span class="line"></span><br><span class="line">#Transaction rule configuration, only for the server</span><br><span class="line">server.recovery.committingRetryPeriod=1000</span><br><span class="line">server.recovery.asynCommittingRetryPeriod=1000</span><br><span class="line">server.recovery.rollbackingRetryPeriod=1000</span><br><span class="line">server.recovery.timeoutRetryPeriod=1000</span><br><span class="line">server.maxCommitRetryTimeout=-1</span><br><span class="line">server.maxRollbackRetryTimeout=-1</span><br><span class="line">server.rollbackRetryTimeoutUnlockEnable=false</span><br><span class="line">server.distributedLockExpireTime=10000</span><br><span class="line">server.xaerNotaRetryTimeout=60000</span><br><span class="line">server.session.branchAsyncQueueSize=5000</span><br><span class="line">server.session.enableBranchAsyncRemove=false</span><br><span class="line">server.enableParallelRequestHandle=false</span><br><span class="line"></span><br><span class="line">#Metrics configuration, only for the server</span><br><span class="line">metrics.enabled=false</span><br><span class="line">metrics.registryType=compact</span><br><span class="line">metrics.exporterList=prometheus</span><br><span class="line">metrics.exporterPrometheusPort=9898</span><br></pre></td></tr></table></figure></li>
<li><p>启动sh：<code>sh nacos-config.sh -h 127.0.0.1 -p 8848 -t 6b4c56c3-7428-45a0-b6cc-49a2a38367eb -u nacos -w nacos</code></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221121181517956.png" alt="image-20221121181517956"></p>
</li>
</ul>
</li>
</ul>
<h4 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h4><p>用户购买商品的业务逻辑。整个业务逻辑由3个微服务提供支持：</p>
<ul>
<li>仓储服务：对给定的商品扣除仓储数量。</li>
<li>订单服务：根据采购需求创建订单。</li>
<li>帐户服务：从用户帐户中扣除余额。</li>
</ul>
<p>当用户下单时，会在订单服务中创建一个订单，然后通过远程调用库存服务来扣减下单商品的库存，再通过远程调用账户服务来扣减用户账户里面的余额，最后在订单服务中修改订单状态为已完成。</p>
<p>案例架构：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221121193827087.png" alt="image-20221121193827087"></p>
<ul>
<li><p>业务数据库表准备：</p>
<ul>
<li><p>数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database seata_order;</span><br><span class="line"><span class="keyword">create</span> database seata_storage;</span><br><span class="line"><span class="keyword">create</span> database seata_account;</span><br></pre></td></tr></table></figure></li>
<li><p>表数据：</p>
<p>seata_order库下建t_order表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_order`(</span><br><span class="line">	`id` <span class="type">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    `user_id` <span class="type">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">    `product_id` <span class="type">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;产品id&#x27;</span>,</span><br><span class="line">    `count` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;数量&#x27;</span>,</span><br><span class="line">    `money` <span class="type">DECIMAL</span>(<span class="number">11</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;金额&#x27;</span>,</span><br><span class="line">    `status` <span class="type">INT</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单状态:0:创建中；1:已完结&#x27;</span></span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">7</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
<p>seata_storage库下建t_storage表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_storage`(</span><br><span class="line">	`id` <span class="type">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    `product_id` <span class="type">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;产品id&#x27;</span>,</span><br><span class="line">    `total` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;总库存&#x27;</span>,</span><br><span class="line">    `used` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;已用库存&#x27;</span>,</span><br><span class="line">    `residue` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;剩余库存&#x27;</span></span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
<p>seata_account库下建t_account表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_account`(</span><br><span class="line">	`id` <span class="type">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    `user_id` <span class="type">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">    `total` <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;总额度&#x27;</span>,</span><br><span class="line">    `used` <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;已用余额&#x27;</span>,</span><br><span class="line">    `residue` <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;剩余可用额度&#x27;</span></span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
<p>以及各个数据库的回滚日志表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> `undo_log`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_created` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ext` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>业务模块建立：</p>
<ul>
<li><p>订单模块：</p>
<ul>
<li><p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 注册中心--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加 OpenFeign 依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-openfeign-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-openfeign-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 负载均衡--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--mybatisPlus依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mysql数据库驱动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- web--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- actuator--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>yml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderTest</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/t_order?characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">my_test_tx_group</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">  <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">6b4c56c3-7428-45a0-b6cc-49a2a38367eb</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span></span><br><span class="line">      <span class="attr">my_test_tx_group:</span> <span class="string">default</span></span><br><span class="line"></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line"><span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">    <span class="comment"># 日志级别</span></span><br><span class="line"><span class="comment">#        loggerLevel: full</span></span><br><span class="line">        <span class="comment"># 从连接建立时开始应用，在返回响应时间过长时触发。</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="comment"># 指的是建立连接后从服务器读取到可用资源所用的时间</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建dao/service等省略..</p>
</li>
<li><p>服务调用接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;accountProvider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FeignService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/account/&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(<span class="meta">@PathVariable(value = &quot;userId&quot;)</span> String userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>关键业务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OrderService orderService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    FeignService feignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GlobalTransactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;setOrder/&#123;userId&#125;/&#123;commodityId&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setOrder</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> String userId,<span class="meta">@PathVariable(&quot;commodityId&quot;)</span> String commodityId)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建订单</span></span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setId(<span class="number">1L</span>);</span><br><span class="line">        order.setCount(<span class="number">1</span>);</span><br><span class="line">        order.setMoney(<span class="number">3.5</span>);</span><br><span class="line">        order.setStatus(<span class="number">0</span>);</span><br><span class="line">        order.setUserId(Long.parseLong(userId));</span><br><span class="line">        order.setProductId(Long.parseLong(commodityId));</span><br><span class="line">        orderService.save(order);</span><br><span class="line">        <span class="comment">// 减少用户余额</span></span><br><span class="line">        feignService.updateAccount(userId);</span><br><span class="line">        <span class="comment">// 更新订单状态</span></span><br><span class="line">        Order order2 = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setId(<span class="number">1L</span>);</span><br><span class="line">        order.setStatus(<span class="number">1</span>);</span><br><span class="line">        orderService.updateById(order2);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;下单成功！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>账户模块：</p>
<ul>
<li><p>依赖：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;dependencies&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&lt;!--mybatisPlus依赖--&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span></span><br><span class="line">            <span class="string">&lt;version&gt;3.4.3&lt;/version&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="string">&lt;!--mysql数据库驱动--&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;mysql&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;io.seata&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;</span></span><br><span class="line">            <span class="string">&lt;version&gt;1.4.0&lt;/version&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="string">&lt;!--</span> <span class="string">注册中心--&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&lt;!--</span> <span class="string">web--&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="string">&lt;!--</span> <span class="string">actuator--&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span></span><br><span class="line">            <span class="string">&lt;scope&gt;test&lt;/scope&gt;</span></span><br><span class="line">            <span class="string">&lt;exclusions&gt;</span></span><br><span class="line">                <span class="string">&lt;exclusion&gt;</span></span><br><span class="line">                    <span class="string">&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span></span><br><span class="line">                    <span class="string">&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span></span><br><span class="line">                <span class="string">&lt;/exclusion&gt;</span></span><br><span class="line">            <span class="string">&lt;/exclusions&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;/dependencies&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>yml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">accountProvider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/t_account?characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">my_test_tx_group</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">6b4c56c3-7428-45a0-b6cc-49a2a38367eb</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span></span><br><span class="line">      <span class="attr">my_test_tx_group:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure></li>
<li><p>关键业务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TAccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/account/&#123;userId&#125;/&#123;money&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(<span class="meta">@PathVariable(value = &quot;userId&quot;)</span> String userId,<span class="meta">@PathVariable(value = &quot;money&quot;)</span> Double money)</span></span>&#123;</span><br><span class="line">        TAccount account = accountMapper.selectById(Long.parseLong(userId));</span><br><span class="line">        account.setUsed(account.getUsed() + money);</span><br><span class="line">        <span class="keyword">if</span>(account.getResidue() - money &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;金额异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        account.setResidue(account.getResidue() - money);</span><br><span class="line">        accountMapper.updateById(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>因为主业务类加了@GlobalTransactional(rollbackFor = Exception.class)所以会遇到异常进行全局回滚</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221122185235168.png" alt="image-20221122185235168"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring全家桶</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis6.0新特性</title>
    <url>/2023/09/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis6-0%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="Redis6-0新特性"><a href="#Redis6-0新特性" class="headerlink" title="Redis6.0新特性"></a>Redis6.0新特性</h1><h2 id="从单线程处理网络请求到多线程处理"><a href="#从单线程处理网络请求到多线程处理" class="headerlink" title="从单线程处理网络请求到多线程处理"></a>从单线程处理网络请求到多线程处理</h2><p>在之前Redis 一直被大家熟知的就是它的单线程架构，虽然有些命令操作可以用后台线程或子进程执行（比如数据删除、快照生成、AOF 重写），但是，从网络 IO 处理到实际的读写命令处理，都是由单个线程完成的。</p>
<p>但是后来硬件的发展，<strong>单个主线程处理网络请求的速度跟不上底层网络硬件的速度</strong>。</p>
<p>Redis6.0为了解决这个问题，采用了<strong>多个 IO 线程来处理网络请求，提高网络请求处理的并行度的方案</strong>。但是，Redis 的多 IO 线程只是用来处理网络请求的，对于读写命令，Redis 仍然使用单线程来处理。</p>
<p>具体多个IO线程的使用是在解析请求以及写会响应的阶段（利用并行提高速度）：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230411183342692.png" alt="image-20230411183342692" style="zoom: 50%;" />

<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230411183401146.png" alt="image-20230411183401146" style="zoom: 50%;" />

<p>相关设置：</p>
<ul>
<li>开启多线程：<code>io-threads-do-reads yes</code></li>
<li>设置多线程数量：<code>io-threads  6</code>（一般来说，<strong>线程个数要小于 Redis 实例所在机器的 CPU 核个数</strong>，例如，对于一个 8 核的机器来说，Redis 官方建议配置 6 个 IO 线程。）</li>
</ul>
<h2 id="实现服务端协助的客户端缓存"><a href="#实现服务端协助的客户端缓存" class="headerlink" title="实现服务端协助的客户端缓存"></a>实现服务端协助的客户端缓存</h2><p>和之前的版本相比，Redis 6.0 新增了一个重要的特性，就是实现了服务端协助的客户端缓存功能，也称为跟踪（Tracking）功能。有了这个功能，业务应用中的 Redis <strong>客户端就可以把读取的数据缓存在业务应用本地了</strong>，应用就可以直接在本地快速读取数据了。</p>
<p>Redis为了解决客户端本地与服务端数据不一致的问题，有两种模式：</p>
<ol>
<li><p><strong>普通模式</strong></p>
<p>在这个模式下，实例会在服务端记录客户端读取过的 key，并监测 key 是否有修改。一旦 key 的值发生变化，服务端会给客户端发送 invalidate 消息，通知客户端缓存失效了。但是服务端只会通知一次，如果再次被修改不会进行通知。只有当客户端再次执行读命令时，服务端才会再次监测被读取的 key，并在 key 修改时发送 invalidate 消息。</p>
<p>打开或关闭普通模式下的 Tracking 功能：<code>CLIENT TRACKING ON|OFF</code></p>
</li>
<li><p><strong>广播模式</strong></p>
<p>在这个模式下，服务端会给客户端广播所有 key 的失效情况，不过，这样做了之后，如果 key 被频繁修改，服务端会发送大量的失效广播消息，这就会消耗大量的网络带宽资源。</p>
<p>所以，在实际应用时，我们<strong>会让客户端注册希望跟踪的 key 的前缀，当带有注册前缀的 key 被修改时，服务端会把失效消息广播给所有注册的客户端。</strong></p>
<p><strong>例子：</strong>如果服务端更新了 <code>user:id:1003</code> 这个 key，那么，客户端就会收到 invalidate 消息：<code>CLIENT TRACKING ON BCAST PREFIX user</code></p>
</li>
</ol>
<h2 id="从简单的基于密码访问到细粒度的权限控制"><a href="#从简单的基于密码访问到细粒度的权限控制" class="headerlink" title="从简单的基于密码访问到细粒度的权限控制"></a>从简单的基于密码访问到细粒度的权限控制</h2><p>Redis 6.0 提供了更加细粒度的访问权限控制。</p>
<ul>
<li><p><strong>支持创建不同用户来使用 Redis</strong>：</p>
<p>在 6.0 版本前，所有客户端可以使用同一个密码进行登录使用，但是没有用户的概念，而在 6.0 中，我们可以使用 ACL SETUSER 命令创建用户。</p>
<p>例如：<code>ACL SETUSER normaluser on &gt; abc</code>来创建并启用一个用户 normaluser，把它的密码设置为“abc”</p>
</li>
<li><p><strong>支持以用户为粒度设置命令操作的访问权限</strong></p>
<p>具体操作列在了下表中</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230411181635237.png" alt="image-20230411181635237"></p>
<p>操作：<code>ACL SETUSER normaluser +@hash -@string</code>(设置用户 normaluser 只能调用 Hash 类型的命令操作，而不能调用 String 类型的命令操作)</p>
<p>还支持以 key 为粒度设置访问权限：</p>
<p>例如，我们执行下面命令，就可以设置用户 normaluser 只能对以“user:”为前缀的 key 进行命令操作：<code>ACL SETUSER normaluser ~user:* +@all</code></p>
</li>
</ul>
<h2 id="启用-RESP-3-协议"><a href="#启用-RESP-3-协议" class="headerlink" title="启用 RESP 3 协议"></a>启用 RESP 3 协议</h2><p>与之前使用的 RESP 2的区别：</p>
<ul>
<li>之前使用的是字节数组形式进行编码的，现在用支持多种数据类型的区分编码（指直接通过不同的开头字符，区分不同的数据类型）</li>
<li>还可以支持客户端以普通模式和广播模式实现客户端缓存</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230411170949287.png" alt="image-20230411170949287"></p>
]]></content>
  </entry>
  <entry>
    <title>Redis主从同步</title>
    <url>/2023/09/06/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h1><h2 id="同步流程"><a href="#同步流程" class="headerlink" title="同步流程"></a>同步流程</h2><p>当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。</p>
<ol>
<li>第一阶段：是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。（从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了<strong>主库的 runID</strong> 和<strong>复制进度 offset</strong> 两个参数。）</li>
<li>在第二阶段：<strong>主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载</strong>。这个过程依赖于内存快照生成的 RDB 文件。（从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件）</li>
<li>第三个阶段：主库会把第二阶段执行过程中新收到的写命令，再发送给从库。</li>
</ol>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230417160818398.png" alt="image-20230417160818398" style="zoom: 80%;" />

<h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p><strong>问题一：</strong></p>
<p>一次全量复制中，对于主库来说，需要完成两个耗时的操作：生成 RDB 文件和传输 RDB 文件。如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量同步，<strong>导致fork操作阻塞主线程</strong>。</p>
<p><strong>解决：</strong>通过“主 - 从 - 从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上。</p>
<p><strong>问题二：</strong></p>
<p>网络断连或阻塞，如果从库和主库重新进行一次全量复制，开销非常大。</p>
<p><strong>解决：</strong>增量复制</p>
<p>当主从库断连后，主库会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些操作命令也写入repl_backlog_buffer 这个缓冲区（repl_backlog_buffer 是一个环形缓冲区（所以如果长时间不恢复或者读取速度太慢了，就会被新数据覆盖<strong>导致主从库间的数据不一致</strong>。），<strong>主库会记录自己写到的位置，从库则会记录自己已经读到的位置</strong>。）。</p>
<p>主从库的连接恢复之后，从库首先会给主库发送 psync 命令，并把自己当前的 slave_repl_offset 发给主库，主库会判断自己的master_repl_offset 和 slave_repl_offset 之间的差距。并将中间语句同步给从库。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis主从复制</title>
    <url>/2022/10/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis主从复制是指：主机数据更新后根据配置和策略， 自动将一台 Redis服务器的数据复制到其它的 Redis 服务器，前者所在的 Redis服务器也被称为 “主节点”（Master / Leader），后者则被称为 “从节点”（Slave / Follower）。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230418141218412.png" alt="image-20230418141218412"></p>
<p><strong>读操作</strong>：主库、从库都可以接收；</p>
<p><strong>写操作</strong>：首先到主库执行，然后，主库将写操作同步给从库。</p>
<p><strong>作用：</strong></p>
<ul>
<li>实现读写分离，性能扩展</li>
<li>能够在Redis服务器崩掉后快速恢复（因为在其他服务器上进行了数据备份）</li>
</ul>
<h2 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h2><p>当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。</p>
<ol>
<li>第一阶段：是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。（从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了<strong>主库的 runID</strong> 和<strong>复制进度 offset</strong> 两个参数。）</li>
<li>在第二阶段：<strong>主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载</strong>。这个过程依赖于内存快照生成的 RDB 文件。（从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件）</li>
<li>第三个阶段：主库会把第二阶段执行过程中新收到的写命令，再发送给从库。</li>
</ol>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230417160818398.png" alt="image-20230417160818398" style="zoom: 80%;" />

<blockquote>
<p><strong>问题一：</strong></p>
<p>一次全量复制中，对于主库来说，需要完成两个耗时的操作：生成 RDB 文件和传输 RDB 文件。如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量同步，<strong>导致fork操作阻塞主线程</strong>。</p>
<p><strong>解决：</strong>通过“主 - 从 - 从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上。</p>
<p><strong>问题二：</strong></p>
<p>网络断连或阻塞，如果从库和主库重新进行一次全量复制，开销非常大。</p>
<p><strong>解决：</strong>增量复制</p>
<p>当主从库断连后，主库会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些操作命令也写入 repl_backlog_buffer 这个缓冲区（repl_backlog_buffer 是一个环形缓冲区（所以如果长时间不恢复或者读取速度太慢了，就会被新数据覆盖<strong>导致主从库间的数据不一致</strong>。），<strong>主库会记录自己写到的位置，从库则会记录自己已经读到的位置</strong>。）。</p>
<p>主从库的连接恢复之后，从库首先会给主库发送 psync 命令，并把自己当前的 slave_repl_offset 发给主库，主库会判断自己的 master_repl_offset 和 slave_repl_offset 之间的差距。并将中间语句同步给从库。</p>
</blockquote>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol>
<li><p>配置多个服务器</p>
<ol>
<li><p>创建多个redis的配置文件</p>
</li>
<li><p>在每个配置文件中配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include redis中的配置文件</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid #配置pid文件位置</span><br><span class="line">port 6379  #配置每个主机端口号</span><br><span class="line">dbfilename dump6379.rdb #配置RDB数据备份位置</span><br><span class="line">slave-priority 10 # 配置从机的优先级，值越小，优先级越高，用于选举主机时使用</span><br><span class="line"># slaveof &lt;主机ip&gt; &lt;主机port&gt; 如果配置了这个就会每次启动自动成为所写ip主机的从机</span><br></pre></td></tr></table></figure></li>
<li><p>启动服务器<code>redis-server 配置文件</code></p>
</li>
<li><p>让某个服务器成为从机：<code>slaveof &lt;主机ip&gt; &lt;主机port&gt;</code></p>
</li>
<li><p>这样主机中写数据，从机都可以看到，但是不允许写</p>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>如果从机太多，可以让从机下面在挂从机，并且可以在主机挂了之后，使用<code>slaveof no one</code>成为主机</p>
</blockquote>
<h2 id="主从问题"><a href="#主从问题" class="headerlink" title="主从问题"></a>主从问题</h2><h3 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h3><p>主要原因：</p>
<ol>
<li>主从库间的网络可能会有传输延迟，所以从库不能及时地收到主库发送的命令，从库上执行同步命令的时间就会被延后。</li>
<li>另一方面，即使从库及时收到了主库的命令，但是，也可能会因为正在处理其它复杂度高的命令（例如集合操作命令）而阻塞。此时，从库需要处理完当前的命令，才能执行主库发送的命令操作，这就会造成主从数据不一致。</li>
</ol>
<p>两种方法：</p>
<ol>
<li><p><strong>在硬件环境配置方面，我们要尽量保证主从库间的网络连接状况良好</strong>。</p>
</li>
<li><p><strong>我们还可以开发一个外部程序来监控主从库间的复制进度</strong>。</p>
<p>因为 Redis 的 INFO replication 命令可以查看主库接收写命令的进度信息（master_repl_offset）和从库复制写命令的进度信息（slave_repl_offset），所以，我们就可以开发一个监控程序，先用 INFO replication 命令查到主、从库的进度，然后，我们用 master_repl_offset 减去 slave_repl_offset，这样就能得到从库和主库间的复制进度差值了。</p>
<p>如果某个从库的进度差值大于我们预设的阈值，我们可以让客户端不再和这个从库连接进行数据读取，这样就可以减少读到不一致数据的情况。</p>
</li>
<li><p>将edis 中的 slave-serve-stale-data（能否处理数据读写命令） 配置项设置为 no，这样当请求来的时候会回复”正在从master同步”，除了 INFO 和 SLAVEOF 命令。</p>
</li>
</ol>
<h3 id="读取过期数据"><a href="#读取过期数据" class="headerlink" title="读取过期数据"></a>读取过期数据</h3><p>主要原因：</p>
<ol>
<li>定期删除策略：留存有没有被删除完的过期数据。</li>
<li>惰性删除策略：使用的是EXPIRE 和 PEXPIRE来设置过期时间，等同步到从库时产生延迟。</li>
</ol>
<p>解决方法：</p>
<p>​    使用 Redis 3.2 及以上版本；使用 EXPIREAT/PEXPIREAT 命令设置过期时间，避免从库上的数据过期时间滞后。</p>
<h3 id="配置项设置得不合理从而导致服务挂掉"><a href="#配置项设置得不合理从而导致服务挂掉" class="headerlink" title="配置项设置得不合理从而导致服务挂掉"></a>配置项设置得不合理从而导致服务挂掉</h3><ol>
<li><p>protected-mode 配置项：</p>
<p>这个配置项的作用是限定哨兵实例能否被其他服务器访问。当这个配置项设置为 yes 时，哨兵实例只能在部署的服务器本地进行访问。当设置为 no 时，其他服务器也可以访问这个哨兵实例。</p>
<p><strong>问题：</strong>如果 protected-mode 被设置为 yes，而其余哨兵实例部署在其它服务器，那么，这些哨兵实例间就无法通信。当主库故障时，哨兵无法判断主库下线，也无法进行主从切换，最终 Redis 服务不可用。</p>
<p><strong>解决：</strong>所以，我们在应用主从集群时，要注意将 protected-mode 配置项设置为 no，并且将 bind 配置项设置为其它哨兵实例的 IP 地址</p>
</li>
<li><p>cluster-node-timeout 配置项</p>
<p>这个配置项设置了 Redis Cluster 中实例响应心跳消息的超时时间。</p>
<p><strong>问题：</strong>如果执行主从切换的实例超过半数，而主从切换时间又过长的话，就可能有半数以上的实例心跳超时，从而可能导致整个集群挂掉。</p>
<p><strong>解决：</strong>将 cluster-node-timeout 调大些（例如 10 到 20 秒）</p>
</li>
</ol>
<h3 id="脑裂问题"><a href="#脑裂问题" class="headerlink" title="脑裂问题"></a>脑裂问题</h3><p>所谓的脑裂，就是指在主从集群中，同时有两个主节点，它们都能接收写请求。而脑裂最直接的影响，就是客户端不知道应该往哪个主节点写入数据，结果就是不同的客户端会往不同的主节点上写入数据。而且，严重的话，脑裂会进一步导致数据丢失。</p>
<p><strong>原因：</strong></p>
<ul>
<li><p>在主从集群中发生数据丢失，最常见的原因就是<strong>主库的数据还没有同步到从库，结果主库发生了故障，等从库升级为主库后，未同步的数据就丢失了。</strong></p>
</li>
<li><p>发现是原主库假故障导致的脑裂：</p>
<p>主库是由于某些原因无法处理请求，也没有响应哨兵的心跳，才被哨兵错误地判断为客观下线的。结果，在被判断下线之后，原主库又重新开始处理请求了，而此时，哨兵还没有完成主从切换，客户端仍然可以和原主库通信，客户端发送的写操作就会在原主库上写入数据了。</p>
</li>
</ul>
<p><strong>解决：</strong></p>
<p>Redis 已经提供了两个配置项来限制主库的请求处理，分别是 min-slaves-to-write 和 min-slaves-max-lag。</p>
<ul>
<li><p>min-slaves-to-write：这个配置项设置了主库能进行数据同步的最少从库数量；</p>
</li>
<li><p>min-slaves-max-lag：这个配置项设置了主从库间进行数据复制时，从库给主库发送 ACK 消息的最大延迟（以秒为单位）。</p>
</li>
</ul>
<p>我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。这两个配置项组合后的要求是，主库连接的从库中至少有 N 个从库，和主库进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的请求了。</p>
<h3 id="通讯开销问题"><a href="#通讯开销问题" class="headerlink" title="通讯开销问题"></a>通讯开销问题</h3><p>为了让集群中的每个实例都知道其它所有实例的状态信息，实例之间会按照一定的规则进行通信。这个规则就是 <strong>Gossip 协议</strong>。</p>
<p>通信开销受到<strong>通信消息大小</strong>和<strong>通信频率</strong>这两方面的影响</p>
<ul>
<li><p><strong>通信消息大小</strong></p>
<p>包含自身状态信息、集群十分之一实例的状态信息、Slot映射表，大概有12KB。并且PING和PONG消息内容一致。一来一回就是24KB。随着集群规模增加，这些心跳消息越来越多占据部分宽带，降低正常服务的吞吐量。</p>
</li>
<li><p><strong>通信频率</strong></p>
<p>每秒会从本地实例随机挑选5个实例，<strong>并选择一个最久没有通信的实例，发送PING命令同步状态</strong>。但是由于是随机挑选的实例，很有可能会有遗漏的实例一直没有进行通信，导致集群状态信息过期。为了解决这种情况，<strong>Redis Cluster 的实例会按照每 100ms 一次的频率扫描本地的实例列表</strong>，如果发现有实例最近一次接收 PONG 消息的时间，已经大于配置项 cluster-node-timeout 的一半了（cluster-node-timeout/2），就会立刻给该实例发送 PING 消息，更新这个实例上的集群状态信息。</p>
</li>
</ul>
<p><strong>解决方案：</strong></p>
<ol>
<li><p>根本的解决方法就是降低集群规模，因为<strong>实例间的通信开销会随着实例规模增加而增大</strong>（理论单个实例每秒能支撑 8 万请求操作（8 万 QPS），那么，400~ 500 个实例可支持 1600 万~2000 万 QPS）</p>
</li>
<li><p>降低通信频率：</p>
<p>提高cluster-node-timeout配置项（默认是15s），但是也不能调太大了，不然会遇到实例真的发生了故障没有得到及时的检测。</p>
<blockquote>
<p><strong>可以在调整 cluster-node-timeout 值的前后，使用 tcpdump 命令抓取实例发送心跳信息网络包的情况</strong>。</p>
<p>例如，执行下面的命令后，我们可以抓取到 192.168.10.3 机器上的实例从 16379 端口发送的心跳网络包，并把网络包的内容保存到 r1.cap 文件中：<code>tcpdump host 192.168.10.3 port 16379 -i 网卡名 -w /tmp/r1.cap</code></p>
<p>通过分析网络包的数量和大小，就可以判断调整 cluster-node-timeout 值前后，心跳消息占用的带宽情况了。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis主从问题</title>
    <url>/2023/09/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E4%B8%BB%E4%BB%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="主从问题"><a href="#主从问题" class="headerlink" title="主从问题"></a>主从问题</h1><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230402154043999.png" alt="image-20230402154043999"></p>
<h2 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h2><p>主要原因：</p>
<ol>
<li>主从库间的网络可能会有传输延迟，所以从库不能及时地收到主库发送的命令，从库上执行同步命令的时间就会被延后。</li>
<li>另一方面，即使从库及时收到了主库的命令，但是，也可能会因为正在处理其它复杂度高的命令（例如集合操作命令）而阻塞。此时，从库需要处理完当前的命令，才能执行主库发送的命令操作，这就会造成主从数据不一致。</li>
</ol>
<p>两种方法：</p>
<ol>
<li><p><strong>在硬件环境配置方面，我们要尽量保证主从库间的网络连接状况良好</strong>。</p>
</li>
<li><p><strong>我们还可以开发一个外部程序来监控主从库间的复制进度</strong>。</p>
<p>因为 Redis 的 INFO replication 命令可以查看主库接收写命令的进度信息（master_repl_offset）和从库复制写命令的进度信息（slave_repl_offset），所以，我们就可以开发一个监控程序，先用 INFO replication 命令查到主、从库的进度，然后，我们用 master_repl_offset 减去 slave_repl_offset，这样就能得到从库和主库间的复制进度差值了。</p>
<p>如果某个从库的进度差值大于我们预设的阈值，我们可以让客户端不再和这个从库连接进行数据读取，这样就可以减少读到不一致数据的情况。</p>
</li>
<li><p>将edis 中的 slave-serve-stale-data（能否处理数据读写命令） 配置项设置为 no，这样当请求来的时候会回复”正在从master同步”，除了 INFO 和 SLAVEOF 命令。</p>
</li>
</ol>
<h2 id="读取过期数据"><a href="#读取过期数据" class="headerlink" title="读取过期数据"></a>读取过期数据</h2><p>主要原因：</p>
<ol>
<li>定期删除策略：留存有没有被删除完的过期数据。</li>
<li>惰性删除策略：使用的是EXPIRE 和 PEXPIRE来设置过期时间，等同步到从库时产生延迟。</li>
</ol>
<p>解决方法：</p>
<p>​    使用 Redis 3.2 及以上版本；使用 EXPIREAT/PEXPIREAT 命令设置过期时间，避免从库上的数据过期时间滞后。</p>
<h2 id="配置项设置得不合理从而导致服务挂掉"><a href="#配置项设置得不合理从而导致服务挂掉" class="headerlink" title="配置项设置得不合理从而导致服务挂掉"></a>配置项设置得不合理从而导致服务挂掉</h2><ol>
<li><p>protected-mode 配置项：</p>
<p>这个配置项的作用是限定哨兵实例能否被其他服务器访问。当这个配置项设置为 yes 时，哨兵实例只能在部署的服务器本地进行访问。当设置为 no 时，其他服务器也可以访问这个哨兵实例。</p>
<p><strong>问题：</strong>如果 protected-mode 被设置为 yes，而其余哨兵实例部署在其它服务器，那么，这些哨兵实例间就无法通信。当主库故障时，哨兵无法判断主库下线，也无法进行主从切换，最终 Redis 服务不可用。</p>
<p><strong>解决：</strong>所以，我们在应用主从集群时，要注意将 protected-mode 配置项设置为 no，并且将 bind 配置项设置为其它哨兵实例的 IP 地址</p>
</li>
<li><p>cluster-node-timeout 配置项</p>
<p>这个配置项设置了 Redis Cluster 中实例响应心跳消息的超时时间。</p>
<p><strong>问题：</strong>如果执行主从切换的实例超过半数，而主从切换时间又过长的话，就可能有半数以上的实例心跳超时，从而可能导致整个集群挂掉。</p>
<p><strong>解决：</strong>将 cluster-node-timeout 调大些（例如 10 到 20 秒）</p>
</li>
</ol>
<h2 id="脑裂问题"><a href="#脑裂问题" class="headerlink" title="脑裂问题"></a>脑裂问题</h2><p>所谓的脑裂，就是指在主从集群中，同时有两个主节点，它们都能接收写请求。而脑裂最直接的影响，就是客户端不知道应该往哪个主节点写入数据，结果就是不同的客户端会往不同的主节点上写入数据。而且，严重的话，脑裂会进一步导致数据丢失。</p>
<p><strong>原因：</strong></p>
<ul>
<li><p>在主从集群中发生数据丢失，最常见的原因就是<strong>主库的数据还没有同步到从库，结果主库发生了故障，等从库升级为主库后，未同步的数据就丢失了。</strong></p>
</li>
<li><p>发现是原主库假故障导致的脑裂：</p>
<p>主库是由于某些原因无法处理请求，也没有响应哨兵的心跳，才被哨兵错误地判断为客观下线的。结果，在被判断下线之后，原主库又重新开始处理请求了，而此时，哨兵还没有完成主从切换，客户端仍然可以和原主库通信，客户端发送的写操作就会在原主库上写入数据了。</p>
</li>
</ul>
<p><strong>解决：</strong></p>
<p>Redis 已经提供了两个配置项来限制主库的请求处理，分别是 min-slaves-to-write 和 min-slaves-max-lag。</p>
<ul>
<li><p>min-slaves-to-write：这个配置项设置了主库能进行数据同步的最少从库数量；</p>
</li>
<li><p>min-slaves-max-lag：这个配置项设置了主从库间进行数据复制时，从库给主库发送 ACK 消息的最大延迟（以秒为单位）。</p>
</li>
</ul>
<p>我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。这两个配置项组合后的要求是，主库连接的从库中至少有 N 个从库，和主库进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的请求了。</p>
<h2 id="通讯开销问题"><a href="#通讯开销问题" class="headerlink" title="通讯开销问题"></a>通讯开销问题</h2><p>为了让集群中的每个实例都知道其它所有实例的状态信息，实例之间会按照一定的规则进行通信。这个规则就是 <strong>Gossip 协议</strong>。</p>
<p>通信开销受到<strong>通信消息大小</strong>和<strong>通信频率</strong>这两方面的影响</p>
<ul>
<li><p><strong>通信消息大小</strong></p>
<p>包含自身状态信息、集群十分之一实例的状态信息、Slot映射表，大概有12KB。并且PING和PONG消息内容一致。一来一回就是24KB。随着集群规模增加，这些心跳消息越来越多占据部分宽带，降低正常服务的吞吐量。</p>
</li>
<li><p><strong>通信频率</strong></p>
<p>每秒会从本地实例随机挑选5个实例，<strong>并选择一个最久没有通信的实例，发送PING命令同步状态</strong>。但是由于是随机挑选的实例，很有可能会有遗漏的实例一直没有进行通信，导致集群状态信息过期。为了解决这种情况，<strong>Redis Cluster 的实例会按照每 100ms 一次的频率扫描本地的实例列表</strong>，如果发现有实例最近一次接收 PONG 消息的时间，已经大于配置项 cluster-node-timeout 的一半了（cluster-node-timeout/2），就会立刻给该实例发送 PING 消息，更新这个实例上的集群状态信息。</p>
</li>
</ul>
<p><strong>解决方案：</strong></p>
<ol>
<li><p>根本的解决方法就是降低集群规模，因为<strong>实例间的通信开销会随着实例规模增加而增大</strong>（理论单个实例每秒能支撑 8 万请求操作（8 万 QPS），那么，400~ 500 个实例可支持 1600 万~2000 万 QPS）</p>
</li>
<li><p>降低通信频率：</p>
<p>提高cluster-node-timeout配置项（默认是15s），但是也不能调太大了，不然会遇到实例真的发生了故障没有得到及时的检测。</p>
<blockquote>
<p><strong>可以在调整 cluster-node-timeout 值的前后，使用 tcpdump 命令抓取实例发送心跳信息网络包的情况</strong>。</p>
<p>例如，执行下面的命令后，我们可以抓取到 192.168.10.3 机器上的实例从 16379 端口发送的心跳网络包，并把网络包的内容保存到 r1.cap 文件中：<code>tcpdump host 192.168.10.3 port 16379 -i 网卡名 -w /tmp/r1.cap</code></p>
<p>通过分析网络包的数量和大小，就可以判断调整 cluster-node-timeout 值前后，心跳消息占用的带宽情况了。</p>
</blockquote>
</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty</title>
    <url>/2023/03/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty/Netty/</url>
    <content><![CDATA[<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>现在的互联网环境下，分布式系统大行其道，而分布式系统的根基在于网络编程，而Netty恰恰是Java领域网络编程的王者。如果要致力于开发高性能的服务器程序、高性能的客户端程序，必须掌握Netty。</p>
<p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端。</p>
<h3 id="地位"><a href="#地位" class="headerlink" title="地位"></a>地位</h3><p>Netty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位</p>
<p>以下的框架都使用了 Netty，因为它们有网络通信需求！</p>
<ul>
<li>Cassandra - nosql 数据库</li>
<li>Spark - 大数据分布式计算框架</li>
<li>Hadoop - 大数据分布式存储框架</li>
<li>RocketMQ - ali 开源的消息队列</li>
<li>ElasticSearch - 搜索引擎</li>
<li>gRPC - rpc 框架</li>
<li>Dubbo - rpc 框架</li>
<li>Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端</li>
<li>Zookeeper - 分布式协调框架</li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>Netty vs NIO：<ul>
<li>NIO工作量大，bug 多</li>
<li>不需要自己构建协议</li>
<li>解决 TCP 传输问题，如粘包、半包</li>
<li>NIO会epoll 空轮询导致 CPU 100%</li>
<li>对 API 进行增强，使之更易用，如 FastThreadLocal =&gt; ThreadLocal，ByteBuf =&gt; ByteBuffer</li>
</ul>
</li>
<li>Netty vs 其它网络应用框架<ul>
<li>Mina 由 apache 维护，将来 3.x 版本可能会有较大重构，破坏 API 向下兼容性，Netty 的开发迭代更迅速，API 更简洁、文档更优秀</li>
<li>久经考验，16年，Netty 版本<ul>
<li>2.x 2004</li>
<li>3.x 2008</li>
<li>4.x 2013</li>
<li>5.x 已废弃（没有明显的性能提升，维护成本高）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="支持的IO模式"><a href="#支持的IO模式" class="headerlink" title="支持的IO模式"></a>支持的IO模式</h3><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230626165256415.png" alt="image-20230626165256415"></p>
<blockquote>
<p>划线的表示不推荐使用</p>
</blockquote>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>开发一个简单的服务器端和客户端</p>
<ul>
<li>客户端向服务器端发送 hello, world</li>
<li>服务器仅接收，不返回</li>
</ul>
<p><strong>加入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.39.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>代码编写</strong></p>
<p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 服务端启动器，功能负责组装netty组件，启动服务器</span></span><br><span class="line">        <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                <span class="comment">// 添加了EventLoop组</span></span><br><span class="line">                .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">                <span class="comment">// 选择服务器的channel的实现</span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">// boss负责处理连接 worker(child) 负责处理读写，编写child干什么事情(handler)</span></span><br><span class="line">                .childHandler(</span><br><span class="line">                    <span class="comment">// channel 代表和客户端进行读写的通道，这里Initializer进行初始化，添加哪些handler</span></span><br><span class="line">                    <span class="keyword">new</span> ChannelInitializer&lt;NioServerSocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioServerSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 添加具体handler</span></span><br><span class="line">                            <span class="comment">// 将ByteBuf转换为字符串</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            <span class="comment">// 自定义handler</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    System.out.println(msg);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 监听的端口</span></span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 启动客户端</span></span><br><span class="line">        <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                <span class="comment">// 添加了EventLoop组</span></span><br><span class="line">                .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">                <span class="comment">// 选择服务器的channel的实现</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">// 添加处理器</span></span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 添加字符串编码器</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 连接服务器</span></span><br><span class="line">                .connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>))</span><br><span class="line">                .sync()</span><br><span class="line">                .channel()</span><br><span class="line">                <span class="comment">// 向服务器发送数据</span></span><br><span class="line">                .writeAndFlush(<span class="string">&quot;hello netty!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行流程</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/0040.png"></p>
<blockquote>
<p>通常一个网络应用的详细步骤如下：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230706112235983.png" alt="image-20230706112235983"></p>
</blockquote>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="Bootstrap、ServerBootstrap"><a href="#Bootstrap、ServerBootstrap" class="headerlink" title="Bootstrap、ServerBootstrap"></a>Bootstrap、ServerBootstrap</h3><ol>
<li><code>Bootstrap</code> 意思是引导，一个 <code>Netty</code> 应用通常由一个 <code>Bootstrap</code> 开始，主要作用是配置整个 <code>Netty</code> 程序，串联各个组件，<code>Netty</code> 中 <code>Bootstrap</code> 类是客户端程序的启动引导类，<code>ServerBootstrap</code> 是服务端启动引导类。</li>
<li>常见的方法有<ul>
<li><code>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code>，该方法用于服务器端，用来设置两个 <code>EventLoop</code></li>
<li><code>public B group(EventLoopGroup group)</code>，该方法用于客户端，用来设置一个 <code>EventLoop</code></li>
<li><code>public B channel(Class&lt;? extends C&gt; channelClass)</code>，该方法用来设置一个服务器端的通道实现</li>
<li><code>public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value)</code>，用来给 <code>ServerChannel</code> 添加配置</li>
<li><code>public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value)</code>，用来给接收到的通道添加配置</li>
<li><code>public ServerBootstrap childHandler(ChannelHandler childHandler)</code>，该方法用来设置业务处理类（自定义的<code>handler</code>）</li>
<li><code>public ChannelFuture bind(int inetPort)</code>，该方法用于服务器端，用来设置占用的端口号</li>
<li><code>public ChannelFuture connect(String inetHost, int inetPort)</code>，该方法用于客户端，用来连接服务器端</li>
</ul>
</li>
</ol>
<h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p><strong>事件循环对象</strong></p>
<p><code>EventLoop </code>本质是一个单线程执行器（同时维护了一个 <code>Selector</code>实例），里面有 run 方法处理 Channel 上源源不断的 io 事件。</p>
<p>它的继承关系比较复杂</p>
<ul>
<li>一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>
<li>另一条线是继承自 netty 自己的 OrderedEventExecutor，<ul>
<li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>
<li>提供了 parent 方法来看看自己属于哪个 EventLoopGroup</li>
</ul>
</li>
</ul>
<p><strong>事件循环组</strong></p>
<p><code>EventLoopGroup</code> 是一组 <code>EventLoop</code>，<code>Channel </code>一般会调用<code> EventLoopGroup</code> 的 register 方法来绑定其中一个 <code>EventLoop</code>，后续这个 <code>Channel </code>上的 io 事件都由此 <code>EventLoop </code>来处理（保证了 io 事件处理时的线程安全）</p>
<ul>
<li>继承自 netty 自己的 <code>EventExecutorGroup</code><ul>
<li>实现了 Iterable 接口提供遍历 <code>EventLoop</code> 的能力</li>
<li>另有 next 方法获取集合中下一个 <code>EventLoop</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>在 <code>Netty</code> 服务器端编程中，我们一般都需要提供两个 <code>EventLoopGroup</code>，例如：<code>BossEventLoopGroup</code> 和 <code>WorkerEventLoopGroup</code>。</p>
<p><code>BossEventLoop</code> 负责接收客户端的连接并将 <code>SocketChannel</code> 交给 <code>WorkerEventLoopGroup</code> 来进行 <code>IO</code> 处理，如下图所示：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230623155002678.png" alt="image-20230623155002678" style="zoom:67%;" />
</blockquote>
<p><strong>简单使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEventLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建事件循环组</span></span><br><span class="line">        <span class="comment">// 能处理io事件、普通任务、定时任务；可以指定线程数</span></span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 能处理普通任务、定时任务</span></span><br><span class="line">        DefaultEventLoopGroup group1 = <span class="keyword">new</span> DefaultEventLoopGroup();</span><br><span class="line">        <span class="comment">// 获取下一个事件</span></span><br><span class="line">        System.out.println(group.next());</span><br><span class="line">        <span class="comment">// 执行普通任务</span></span><br><span class="line">        group.next().submit(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行定时任务</span></span><br><span class="line">        <span class="comment">// 参数1任务，参数2起始延迟时间，参数三间隔时间，参数四时间单位</span></span><br><span class="line">        group.next().scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;定时&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>,<span class="number">1</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>指定NioEventLoop的分工</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventLoopServer</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 创建一个独立的EventLoopGroup,由于不需要处理io事件选择DefaultEventLoopGroup</span></span><br><span class="line">     EventLoopGroup group = <span class="keyword">new</span> DefaultEventLoopGroup();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">             <span class="comment">// 第一个参数为boss只负责accept 第二个参数为worker只负责读写</span></span><br><span class="line">             .group(<span class="keyword">new</span> NioEventLoopGroup(),<span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>))</span><br><span class="line">             .channel(NioServerSocketChannel.class)</span><br><span class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                         <span class="comment">// 数据为ByteBuf</span></span><br><span class="line">                         <span class="meta">@Override</span></span><br><span class="line">                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                             ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                             log.debug(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                             <span class="comment">// 为了让后续handler能读到信息必须调用fireChannelRead将消息进行传递</span></span><br><span class="line">                             ctx.fireChannelRead(msg);</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="comment">// 指定EventLoopGroup</span></span><br><span class="line">                     &#125;).addLast(group,<span class="string">&quot;handler2&quot;</span>,<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                         <span class="meta">@Override</span></span><br><span class="line">                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                             ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                             log.debug(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;).bind(<span class="number">8080</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>channel 的主要作用是能够用于执行网络 <code>I/O</code> 操作、通过<code>Channel</code>可获得当前网络连接的通道的状态、网络连接的配置参数。</p>
<p><strong>各个Channel所关注的事件：</strong></p>
<table>
<thead>
<tr>
<th>Client/Server</th>
<th>SocketChannel/ServerSocketChannel</th>
<th>OP_ACCEPT</th>
<th>OP_CONNECT</th>
<th>OP_WRITE</th>
<th>OP_READ</th>
</tr>
</thead>
<tbody><tr>
<td>Client</td>
<td>SocketChannel</td>
<td></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>Server</td>
<td>ServerSocketChannel</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Server</td>
<td>SocketChannel</td>
<td></td>
<td></td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
<p><strong>相关方法：</strong></p>
<ul>
<li>close() 可以用来关闭 channel</li>
<li>closeFuture() 用来处理 channel 的关闭<ul>
<li>sync 方法作用是同步等待 channel 关闭</li>
<li>而 addListener 方法是异步等待 channel 关闭</li>
</ul>
</li>
<li>pipeline() 方法添加处理器</li>
<li>write() 方法将数据写入</li>
<li>writeAndFlush() 方法将数据写入并刷出</li>
</ul>
<p><strong>常用的 <code>Channel</code> 类型：</strong></p>
<ul>
<li><code>NioSocketChannel</code>，异步的客户端 <code>TCP</code> <code>Socket</code> 连接。</li>
<li><code>NioServerSocketChannel</code>，异步的服务器端 <code>TCP</code> <code>Socket</code> 连接。</li>
<li><code>NioDatagramChannel</code>，异步的 <code>UDP</code> 连接。</li>
<li><code>NioSctpChannel</code>，异步的客户端 <code>Sctp</code> 连接。</li>
<li><code>NioSctpServerChannel</code>，异步的 <code>Sctp</code> 服务器端连接，这些通道涵盖了 <code>UDP</code> 和 <code>TCP</code> 网络 <code>IO</code> 以及文件 <code>IO</code>。</li>
</ul>
<p><strong>相关代码</strong></p>
<ul>
<li><p>同步操作：利用sync方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channelFuture.sync();</span><br><span class="line">System.out.println(channelFuture.channel()); </span><br></pre></td></tr></table></figure></li>
<li><p>异步操作：addListener来实现异步操作，通过注册监听器到 <code>ChannelFuture</code> 上，可以 <code>I/O</code> 操作成功、失败或取消时回调通知调用方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channelFuture.addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">    System.out.println(future.channel()); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>关闭channel后的操作：</p>
<ul>
<li><p>同步关闭：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture closeFuture = channel.closeFuture();</span><br><span class="line">log.debug(<span class="string">&quot;waiting close...&quot;</span>);</span><br><span class="line">closeFuture.sync();</span><br><span class="line">log.debug(<span class="string">&quot;处理关闭之后的操作&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>异步关闭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture closeFuture = channel.closeFuture();</span><br><span class="line">closeFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;处理关闭之后的操作&quot;</span>);</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以通过ChannelOption对channel进行配置：</p>
<ul>
<li><p>配置连接数，对应TCP/IP协议listen函数中的backlog参数：<code>ChannelOption.SO_BACKLOG</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.channel(NioServerSocketChannel.class)</span><br><span class="line">.option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置为一直保持连接活动状态：<code>ChannelOption.SO_KEEPALIVE</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.channel(NioServerSocketChannel.class)</span><br><span class="line">.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置滑动窗口大小：<code>ChannelOption.SO_RCVBUF</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bootstrap.option(ChannelOption.SO_RCVBUF,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置缓冲区大小：<code>ChannelOption.RCVBUF_ALLOCATOR</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR,<span class="keyword">new</span> AdaptiveRecvByteBufAllocator(<span class="number">16</span>,<span class="number">16</span>,<span class="number">16</span>));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="Future-amp-Promise"><a href="#Future-amp-Promise" class="headerlink" title="Future &amp; Promise"></a>Future &amp; Promise</h3></li>
</ul>
</li>
</ul>
<p>在异步处理时，经常用到这两个接口，因为<code>Netty</code> 中所有的 <code>IO</code> 操作都是异步的，不能立刻得知消息是否被正确处理。但是<code>Netty</code> 会提前返回<code>ChannelFuture</code>。</p>
<p>首先要说明 netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口，netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p>
<ul>
<li><code>jdk Future </code>只能同步等待任务结束（或成功、或失败）才能得到结果</li>
<li><code>netty Future</code> 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束</li>
<li><code>netty Promise </code>不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器</li>
</ul>
<table>
<thead>
<tr>
<th>功能/名称</th>
<th>jdk Future</th>
<th>netty Future</th>
<th>Promise</th>
</tr>
</thead>
<tbody><tr>
<td>cancel</td>
<td>取消任务</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isCanceled</td>
<td>任务是否取消</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isDone</td>
<td>任务是否完成，不能区分成功失败</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>get</td>
<td>获取任务结果，阻塞等待</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>getNow</td>
<td>-</td>
<td>获取任务结果，非阻塞，还未产生结果时返回 null</td>
<td>-</td>
</tr>
<tr>
<td>await</td>
<td>-</td>
<td>等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断</td>
<td>-</td>
</tr>
<tr>
<td>sync</td>
<td>-</td>
<td>等待任务结束，如果任务失败，抛出异常</td>
<td>-</td>
</tr>
<tr>
<td>isSuccess</td>
<td>-</td>
<td>判断任务是否成功</td>
<td>-</td>
</tr>
<tr>
<td>cause</td>
<td>-</td>
<td>获取失败信息，非阻塞，如果没有失败，返回null</td>
<td>-</td>
</tr>
<tr>
<td>addLinstener</td>
<td>-</td>
<td>添加回调，异步接收结果</td>
<td>-</td>
</tr>
<tr>
<td>setSuccess</td>
<td>-</td>
<td>-</td>
<td>设置成功结果</td>
</tr>
<tr>
<td>setFailure</td>
<td>-</td>
<td>-</td>
<td>设置失败结果</td>
</tr>
</tbody></table>
<p><strong>JDKfuture的简单使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJdkFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        Future&lt;Integer&gt; future = service.submit(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行计算&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 通过future获取结果</span></span><br><span class="line">        log.debug(<span class="string">&quot;结果是&#123;&#125;&quot;</span>,future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>NettyFuture的使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNettyFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoop loop = group.next();</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        Future&lt;Integer&gt; future = loop.submit(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行计算&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 通过future获取结果 同步方式</span></span><br><span class="line">        <span class="comment">// log.debug(&quot;结果是&#123;&#125;&quot;,future.get());</span></span><br><span class="line">        <span class="comment">// 异步方式,当执行完成后会调用这个回调</span></span><br><span class="line">        future.addListener((f) -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;结果是&#123;&#125;&quot;</span>,f.getNow());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Promise的简单使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNettyPromise</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 准备EventLoop对象</span></span><br><span class="line">        EventLoop loop = <span class="keyword">new</span> NioEventLoopGroup().next();</span><br><span class="line">        <span class="comment">// 主动创建promise,结果容器</span></span><br><span class="line">        DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(loop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行任务，存储结果</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;开始计算...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                promise.setSuccess(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                promise.setFailure(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到结果(同样可以异步/同步)</span></span><br><span class="line">        log.debug(<span class="string">&quot;结果是&#123;&#125;&quot;</span>,promise.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Handler-amp-Pipeline"><a href="#Handler-amp-Pipeline" class="headerlink" title="Handler &amp; Pipeline"></a>Handler &amp; Pipeline</h3><p><code>ChannelHandler </code>用来处理 Channel 上的各种事件，分为入站、出站两种。<strong>所有<code>ChannelHandler</code>被连成一串，就是 <code>Pipeline</code>。</strong></p>
<p><strong>入站事件</strong>和<strong>出站事件</strong>在一个双向链表中，入站事件会从链表head往后传递到最后一个入站的 handler,出站事件会从链表tail往前传递到最前t个出站的handler, <strong>两种类型的handler互不干扰</strong>。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230623151957969.png" alt="image-20230623151957969"></p>
<blockquote>
<p>其中<code>ChannelHandlerContext</code>保存<code>Channel</code>相关的所有上下文信息，同时关联一个<code>ChannelHandler</code>对象</p>
<p><strong>相关方法：</strong></p>
<ul>
<li><code>ChannelFuture close()</code>，关闭通道</li>
<li><code>ChannelOutboundInvoker flush()</code>，刷新</li>
<li><code>ChannelFuture writeAndFlush(Object msg)</code>，将数据写到<code>ChannelPipeline</code>中当前<code>channelHandler</code> 的下一个<code>ChannelHandler</code>开始处理（出站）</li>
</ul>
</blockquote>
<ul>
<li><p>入站处理器通常是 <code>ChannelInboundHandlerAdapter </code>的子类，主要用来读取客户端数据，写回结果</p>
</li>
<li><p>出站处理器通常是<code>ChannelOutboundHandlerAdapter</code>的子类，主要对写回结果进行加工</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230623150919268.png" alt="image-20230623150919268" style="zoom:67%;" />

</li>
</ul>
<p><strong>需要重写的方法：</strong></p>
<ul>
<li><p>通道就绪事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	ctx.fireChannelActive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通道读取数据事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>数据读取完毕事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> throwsException </span>&#123;</span><br><span class="line">	ctx.fireChannelReadComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通道发生异常事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,Throwablecause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	ctx.fireExceptionCaught(cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打个比喻，每个 <code>Channel</code> 是一个产品的加工车间，Pipeline 是车间中的流水线，<code>ChannelHandler</code> 就是流水线上的各道工序，而后面要讲的<code>ByteBuf</code>是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品。</p>
</li>
</ul>
<p><strong>案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPipeline</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 通过channel拿到pipeline</span></span><br><span class="line">                        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                        <span class="comment">// 添加处理器 head -&gt; h1-&gt;h2-&gt;h3 -&gt; tail</span></span><br><span class="line">                        <span class="comment">// 添加入栈handler</span></span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h1&quot;</span>,<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">                                ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                                String s = buf.toString(Charset.defaultCharset());</span><br><span class="line">                                <span class="keyword">super</span>.channelRead(ctx, s);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h2&quot;</span>,<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;2222&quot;</span>);</span><br><span class="line">                                <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h3&quot;</span>,<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;33333&quot;</span>);</span><br><span class="line">                                <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">                                ch.writeAndFlush(ctx.alloc().buffer().writeBytes(<span class="string">&quot;server..&quot;</span>.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">                                <span class="comment">// ctx会从当前的处理器往前找，但是不会从tail开始，导致后面的出栈handler全部失效了</span></span><br><span class="line">                                <span class="comment">//ctx.writeAndFlush(ctx.alloc().buffer().writeBytes(&quot;server..&quot;.getBytes(StandardCharsets.UTF_8)));</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        <span class="comment">// 添加出栈handler(出栈顺序是从后往前传)</span></span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h4&quot;</span>,<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;4444&quot;</span>);</span><br><span class="line">                                <span class="keyword">super</span>.write(ctx, msg, promise);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><p>是对字节数据的封装</p>
<h4 id="1）创建"><a href="#1）创建" class="headerlink" title="1）创建"></a>1）创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>
<p>上面代码创建了一个默认的 ByteBuf（池化基于直接内存的 ByteBuf），初始容量是 10</p>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">read index:0 write index:0 capacity:10</span><br></pre></td></tr></table></figure>
<p>其中 log 方法参考如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(ByteBuf buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = buffer.readableBytes();</span><br><span class="line">    <span class="keyword">int</span> rows = length / <span class="number">16</span> + (length % <span class="number">15</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>) + <span class="number">4</span>;</span><br><span class="line">    StringBuilder buf = <span class="keyword">new</span> StringBuilder(rows * <span class="number">80</span> * <span class="number">2</span>)</span><br><span class="line">        .append(<span class="string">&quot;read index:&quot;</span>).append(buffer.readerIndex())</span><br><span class="line">        .append(<span class="string">&quot; write index:&quot;</span>).append(buffer.writerIndex())</span><br><span class="line">        .append(<span class="string">&quot; capacity:&quot;</span>).append(buffer.capacity())</span><br><span class="line">        .append(NEWLINE);</span><br><span class="line">    appendPrettyHexDump(buf, buffer);</span><br><span class="line">    System.out.println(buf.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2）直接内存-vs-堆内存"><a href="#2）直接内存-vs-堆内存" class="headerlink" title="2）直接内存 vs 堆内存"></a>2）直接内存 vs 堆内存</h4><p>可以使用下面的代码来创建池化基于堆的 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>也可以使用下面的代码来创建池化基于直接内存的 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li>
<li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li>
</ul>
<h4 id="3）池化-vs-非池化"><a href="#3）池化-vs-非池化" class="headerlink" title="3）池化 vs 非池化"></a>3）池化 vs 非池化</h4><p>池化的最大意义在于可以重用 ByteBuf，优点有</p>
<ul>
<li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li>
<li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li>
<li>高并发时，池化功能更节约内存，减少内存溢出的可能</li>
</ul>
<p>池化功能是否开启，可以通过下面的系统环境变量来设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现</li>
<li>4.1 之前，池化功能还不成熟，默认是非池化实现</li>
</ul>
<h4 id="4）组成"><a href="#4）组成" class="headerlink" title="4）组成"></a>4）组成</h4><p>ByteBuf 由四部分组成</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/0010.png"></p>
<p>最开始读写指针都在 0 位置</p>
<h4 id="5）写入"><a href="#5）写入" class="headerlink" title="5）写入"></a>5）写入</h4><p>方法列表，省略一些不重要的方法</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>writeBoolean(boolean value)</td>
<td>写入 boolean 值</td>
<td>用一字节 01|00 代表 true|false</td>
</tr>
<tr>
<td>writeByte(int value)</td>
<td>写入 byte 值</td>
<td></td>
</tr>
<tr>
<td>writeShort(int value)</td>
<td>写入 short 值</td>
<td></td>
</tr>
<tr>
<td>writeInt(int value)</td>
<td>写入 int 值</td>
<td>Big Endian，即 0x250，写入后 00 00 02 50</td>
</tr>
<tr>
<td>writeIntLE(int value)</td>
<td>写入 int 值</td>
<td>Little Endian，即 0x250，写入后 50 02 00 00</td>
</tr>
<tr>
<td>writeLong(long value)</td>
<td>写入 long 值</td>
<td></td>
</tr>
<tr>
<td>writeChar(int value)</td>
<td>写入 char 值</td>
<td></td>
</tr>
<tr>
<td>writeFloat(float value)</td>
<td>写入 float 值</td>
<td></td>
</tr>
<tr>
<td>writeDouble(double value)</td>
<td>写入 double 值</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuf src)</td>
<td>写入 netty 的 ByteBuf</td>
<td></td>
</tr>
<tr>
<td>writeBytes(byte[] src)</td>
<td>写入 byte[]</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuffer src)</td>
<td>写入 nio 的 ByteBuffer</td>
<td></td>
</tr>
<tr>
<td>int writeCharSequence(CharSequence sequence, Charset charset)</td>
<td>写入字符串</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>注意</p>
<ul>
<li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用</li>
<li>网络传输，默认习惯是 Big Endian</li>
</ul>
</blockquote>
<h4 id="6）扩容"><a href="#6）扩容" class="headerlink" title="6）扩容"></a>6）扩容</h4><p>再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.writeInt(<span class="number">6</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>
<p>扩容规则是</p>
<ul>
<li>如何写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16</li>
<li>如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10=1024（2^9=512 已经不够了）</li>
<li>扩容不能超过 max capacity 会报错</li>
</ul>
<h4 id="7）读取"><a href="#7）读取" class="headerlink" title="7）读取"></a>7）读取</h4><p>例如读了 4 次，每次一个字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>
<p>读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分</p>
<h4 id="8）retain-amp-release"><a href="#8）retain-amp-release" class="headerlink" title="8）retain &amp; release"></a>8）retain &amp; release</h4><p>由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。</p>
<ul>
<li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li>
<li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li>
<li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li>
</ul>
<p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p>
<ul>
<li>每个 ByteBuf 对象的初始计数为 1</li>
<li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li>
<li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li>
<li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li>
</ul>
<p>基本规则是，<strong>谁是最后使用者，谁负责 release</strong>，详细分析如下</p>
<ul>
<li>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</li>
<li>入站 ByteBuf 处理原则<ul>
<li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li>
<li>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</li>
<li>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</li>
<li>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</li>
<li>假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li>
</ul>
</li>
<li>出站 ByteBuf 处理原则<ul>
<li>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</li>
</ul>
</li>
<li>异常处理原则<ul>
<li>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true</li>
</ul>
</li>
</ul>
<h4 id="9）slice"><a href="#9）slice" class="headerlink" title="9）slice"></a>9）slice</h4><p>【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针，但是不允许再进行写入。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/0011.png"></p>
<p>例，原始 ByteBuf 进行一些初始操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf origin = ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">origin.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">origin.readByte();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure>
<h4 id="10）duplicate"><a href="#10）duplicate" class="headerlink" title="10）duplicate"></a>10）duplicate</h4><p>【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/0012.png"></p>
<h4 id="11）copy"><a href="#11）copy" class="headerlink" title="11）copy"></a>11）copy</h4><p>会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关</p>
<h4 id="12）CompositeByteBuf"><a href="#12）CompositeByteBuf" class="headerlink" title="12）CompositeByteBuf"></a>12）CompositeByteBuf</h4><p>【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝</p>
<p>有两个 ByteBuf 如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">ByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf1));</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf2));</span><br></pre></td></tr></table></figure>
<p>CompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。</p>
<ul>
<li>优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</li>
<li>缺点，复杂了很多，多次操作会带来性能的损耗</li>
</ul>
<h4 id="13）Unpooled"><a href="#13）Unpooled" class="headerlink" title="13）Unpooled"></a>13）Unpooled</h4><p>Unpooled 是一个工具类，类如其名，提供了非池化的 ByteBuf 创建、组合、复制等操作</p>
<p>这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">ByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf</span></span><br><span class="line">ByteBuf buf3 = Unpooled.wrappedBuffer(buf1, buf2);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></table></figure>
<h2 id="粘包与半包"><a href="#粘包与半包" class="headerlink" title="粘包与半包"></a>粘包与半包</h2><h3 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h3><p><strong>粘包</strong></p>
<ul>
<li>现象，发送 abc def，接收 abcdef</li>
<li>原因<ul>
<li>应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）</li>
<li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</li>
<li>Nagle 算法：会造成粘包，因为避免了报文头比内容大，积累了一定数据才会发送。</li>
</ul>
</li>
</ul>
<p><strong>半包</strong></p>
<ul>
<li>现象，发送 abcdef，接收 abc def</li>
<li>原因<ul>
<li>应用层：接收方 ByteBuf 小于实际发送数据量</li>
<li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li>
<li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li>
</ul>
</li>
</ul>
<p><strong>本质是因为 TCP 是流式协议，消息无边界</strong></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低</li>
<li>每一条消息采用固定长度，缺点浪费空间</li>
<li>每一条消息采用分隔符，例如 \n，缺点需要转义</li>
<li>每一条消息分为 head 和 body，head 中包含 body 的长度</li>
</ol>
<p><strong>短连接</strong></p>
<p>客户端只发送一次，发送完毕就关闭连接；但是效率太低，只能解决粘包问题，并不能解决半包问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf buf = ctx.alloc().buffer(<span class="number">16</span>);</span><br><span class="line">buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">ctx.writeAndFlush(buf);</span><br><span class="line">ctx.channel().close();</span><br></pre></td></tr></table></figure>
<p><strong>固定长度</strong></p>
<p>让所有数据包长度固定（假设长度为 8 字节）</p>
<p>服务器端加入<code>ch.pipeline().addLast(new FixedLengthFrameDecoder(8));</code></p>
<p>然后客户端需要输入固定长度的消息，长度不够也必须用其他字符补齐</p>
<p><strong>缺点是</strong>，数据包的大小不好把握</p>
<ul>
<li>长度定的太大，浪费</li>
<li>长度定的太小，对某些数据包又显得不够</li>
</ul>
<p><strong>固定分隔符</strong></p>
<p>服务端加入，默认以 \n 或 \r\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常</p>
<p><code>ch.pipeline().addLast(new LineBasedFrameDecoder(1024));</code></p>
<p>客户端在每条消息之后，加入 \n 分隔符</p>
<p>缺点，处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误</p>
<p><strong>预设长度</strong></p>
<p>在发送消息前，先约定用定长字节表示接下来数据的长度，即将消息长度发给服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数：最大长度，长度偏移，长度占用字节，长度调整（在长度后面还有几个字节是内容），剥离字节数（从头剥离的字节数才是内容）</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<h2 id="协议设计与解析"><a href="#协议设计与解析" class="headerlink" title="协议设计与解析"></a>协议设计与解析</h2><h3 id="为什么需要协议？"><a href="#为什么需要协议？" class="headerlink" title="为什么需要协议？"></a>为什么需要协议？</h3><p>TCP/IP 中消息传输基于流的方式，没有边界。</p>
<p>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</p>
<p>如何设计协议呢？其实就是给网络传输的信息加上“标点符号”。但通过分隔符来断句不是很好，因为分隔符本身如果用于传输，那么必须加以区分。因此，下面一种协议较为常用</p>
<p><code>定长字节表示内容长度 + 实际内容</code></p>
<p><strong>Netty支持的协议：</strong></p>
<ol>
<li>TCP/UDP：Netty提供了基于NIO的TCP和UDP编程框架，可以用来构建高性能、高可用性的网络应用。</li>
<li>HTTP/HTTPS：Netty提供了HTTP/HTTPS编程框架，可以用来开发Web服务器和客户端。</li>
<li>WebSocket：Netty提供了WebSocket编程框架，可以用来实现双向通信应用程序，如聊天室等。</li>
<li>SPDY/HTTP2：Netty提供了SPDY和HTTP2编程框架，可以用来实现高效的Web应用程序。</li>
<li>MQTT/CoAP：Netty提供了MQTT和CoAP编程框架，可以用来构建IoT应用程序。</li>
</ol>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><strong>模拟redis协议</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRedis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">// 回车换行</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] LINE = &#123;<span class="number">13</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler());</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                        <span class="comment">// 会在连接建立成功后，会触发Active事件</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ByteBuf buf = ctx.alloc().buffer();</span><br><span class="line">                            buf.writeBytes(<span class="string">&quot;*3&quot;</span>.getBytes());</span><br><span class="line">                            buf.writeBytes(LINE);</span><br><span class="line">                            buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                            buf.writeBytes(LINE);</span><br><span class="line">                            buf.writeBytes(<span class="string">&quot;set&quot;</span>.getBytes());</span><br><span class="line">                            buf.writeBytes(LINE);</span><br><span class="line">                            buf.writeBytes(<span class="string">&quot;$4&quot;</span>.getBytes());</span><br><span class="line">                            buf.writeBytes(LINE);</span><br><span class="line">                            buf.writeBytes(<span class="string">&quot;name&quot;</span>.getBytes());</span><br><span class="line">                            buf.writeBytes(LINE);</span><br><span class="line">                            buf.writeBytes(<span class="string">&quot;$5&quot;</span>.getBytes());</span><br><span class="line">                            buf.writeBytes(LINE);</span><br><span class="line">                            buf.writeBytes(<span class="string">&quot;wang1&quot;</span>.getBytes());</span><br><span class="line">                            buf.writeBytes(LINE);</span><br><span class="line">                            ctx.writeAndFlush(buf);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                            log.debug(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture future = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>,e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>模拟Http协议</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                    <span class="comment">// SimpleChannelInboundHandler可以指定处理的消息类型</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;HttpRequest&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 获取请求</span></span><br><span class="line">                            log.debug(msg.uri());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 返回响应</span></span><br><span class="line">                            DefaultFullHttpResponse response =</span><br><span class="line">                                    <span class="keyword">new</span> DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">byte</span>[] bytes = <span class="string">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>.getBytes();</span><br><span class="line">                            <span class="comment">// 告诉浏览器响应的长度，不然浏览器一直转圈圈</span></span><br><span class="line">                            response.headers().setInt(CONTENT_LENGTH, bytes.length);</span><br><span class="line">                            response.content().writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 写回响应</span></span><br><span class="line">                            ctx.writeAndFlush(response);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自定义协议</strong></p>
<p>协议要素：</p>
<ul>
<li>魔数，用来在第一时间判定是否是无效数据包</li>
<li>版本号，可以支持协议的升级</li>
<li>序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li>
<li>指令类型，是登录、注册、单聊、群聊… 跟业务相关</li>
<li>请求序号，为了双工通信，提供异步能力</li>
<li>正文长度</li>
<li>消息正文</li>
</ul>
<p>编解码器：</p>
<p>根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodec</span> <span class="keyword">extends</span> <span class="title">ByteToMessageCodec</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充，满足2的倍数的长度</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magicNum = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span> version = in.readByte();</span><br><span class="line">        <span class="keyword">byte</span> serializerType = in.readByte();</span><br><span class="line">        <span class="keyword">byte</span> messageType = in.readByte();</span><br><span class="line">        <span class="keyword">int</span> sequenceId = in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bytes));</span><br><span class="line">        Message message = (Message) ois.readObject();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(</span><br><span class="line">    <span class="keyword">new</span> LoggingHandler(),</span><br><span class="line">    <span class="comment">// 解决半包粘包问题</span></span><br><span class="line">    <span class="keyword">new</span> LengthFieldBasedFrameDecoder(</span><br><span class="line">        <span class="number">1024</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> MessageCodec()</span><br><span class="line">);</span><br><span class="line"><span class="comment">// encode</span></span><br><span class="line">LoginRequestMessage message = <span class="keyword">new</span> LoginRequestMessage(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="comment">//        channel.writeOutbound(message);</span></span><br><span class="line"><span class="comment">// decode</span></span><br><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line"><span class="keyword">new</span> MessageCodec().encode(<span class="keyword">null</span>, message, buf);</span><br><span class="line"></span><br><span class="line">ByteBuf s1 = buf.slice(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">ByteBuf s2 = buf.slice(<span class="number">100</span>, buf.readableBytes() - <span class="number">100</span>);</span><br><span class="line">s1.retain(); <span class="comment">// 引用计数 2</span></span><br><span class="line">channel.writeInbound(s1); <span class="comment">// release 1</span></span><br><span class="line">channel.writeInbound(s2);</span><br></pre></td></tr></table></figure>
<p>解读：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230106200134101.png" alt="image-20230106200134101"></p>
<h2 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h2><p><strong>客户端参数优化：</strong></p>
<ul>
<li>通过.option()方法给SocketChannel配置参数</li>
</ul>
<p><strong>服务端参数优化：</strong></p>
<ul>
<li><p>new ServerBootstrap( ).option()给ServerSocketChannel配置参数</p>
</li>
<li><p>new ServerBootstrap( ).childOption()给SocketChannel配置参数</p>
</li>
</ul>
<p><strong>SocketChannel系统参数：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230708154246332.png" alt="image-20230708154246332"></p>
<p><strong>ServerSocketChannel系统参数：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230708154411125.png" alt="image-20230708154411125"></p>
<p><strong>netty功能参数：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230708161404138.png" alt="image-20230708161404138"></p>
<h3 id="重点参数讲解"><a href="#重点参数讲解" class="headerlink" title="重点参数讲解"></a>重点参数讲解</h3><h4 id="CONNECT-TIMEOUT-MILLIS"><a href="#CONNECT-TIMEOUT-MILLIS" class="headerlink" title="CONNECT_TIMEOUT_MILLIS"></a>CONNECT_TIMEOUT_MILLIS</h4><p>属于 SocketChannal 参数</p>
<ul>
<li><p>用在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常</p>
</li>
<li><p>SO_TIMEOUT 主要用在阻塞 IO，阻塞 IO 中 accept，read 等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间</p>
</li>
</ul>
<p><strong>配置：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConnectionTimeout</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">300</span>)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler());</span><br><span class="line">            ChannelFuture future = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">            future.sync().channel().closeFuture().sync(); <span class="comment">// 断点1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.debug(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SO-BACKLOG"><a href="#SO-BACKLOG" class="headerlink" title="SO_BACKLOG"></a>SO_BACKLOG</h4><p>属于 ServerSocketChannal 参数</p>
<p><strong>三次握手过程</strong>：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230110222443034.png" alt="image-20230110222443034" style="zoom: 50%;" />

<ol>
<li>第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列</li>
<li>第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server</li>
<li>第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue 放入 accept queue</li>
</ol>
<p>其中</p>
<ul>
<li>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制</li>
<li>sync queue - 半连接队列<ul>
<li>大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，<strong>逻辑上没有最大值限制，这个设置便被忽略</strong></li>
</ul>
</li>
<li>accept queue - 全连接队列<ul>
<li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li>
<li>其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，<strong>内核会根据传入的 backlog 参数与系统参数，取二者的较小值</strong></li>
</ul>
</li>
</ul>
<h4 id="ulimit-n"><a href="#ulimit-n" class="headerlink" title="ulimit -n"></a>ulimit -n</h4><p>属于操作系统参数，进行TCР连接时，系统为每个TCP连接创建一个socket句柄，也就是一个文件句柄，但是Linux对每个进程打开的文件句柄数量做了限制，如果超出∶报错“Too many open file”。</p>
<ul>
<li>用于限制一个进程能够最大打开的文件描述符的数量</li>
</ul>
<h4 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h4><p>属于 SocketChannal 参数，设置是否启用Nagle算。</p>
<ul>
<li>设置是否不延迟发送消息（true为不开启）</li>
</ul>
<h4 id="SO-SNDBUF-amp-SO-RCVBUF"><a href="#SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="SO_SNDBUF &amp; SO_RCVBUF"></a>SO_SNDBUF &amp; SO_RCVBUF</h4><p>用于设置滑动窗口缓存区大小</p>
<ul>
<li>SO_SNDBUF 属于 SocketChannal 参数，滑动窗口发送缓存区大小</li>
</ul>
<ul>
<li>SO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上），滑动窗口接受缓存区大小</li>
</ul>
<h4 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h4><p>地址重用，解决“Address already in use”，常用开启场景:多网卡（IP）绑定相同端口;让关闭连接释放的端口更早可使用。默认不开启。</p>
<h4 id="ALLOCATOR"><a href="#ALLOCATOR" class="headerlink" title="ALLOCATOR"></a>ALLOCATOR</h4><p>属于 SocketChannal 参数，设置ByteBuf</p>
<ul>
<li>用来分配 ByteBuf， ctx.alloc()</li>
</ul>
<h4 id="RCVBUF-ALLOCATOR"><a href="#RCVBUF-ALLOCATOR" class="headerlink" title="RCVBUF_ALLOCATOR"></a>RCVBUF_ALLOCATOR</h4><p>属于 SocketChannal 参数</p>
<ul>
<li>控制 netty 接收缓冲区大小</li>
<li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定</li>
</ul>
<h2 id="空闲心跳检测"><a href="#空闲心跳检测" class="headerlink" title="空闲心跳检测"></a>空闲心跳检测</h2><p>Netty提供一种空闲心跳检测机制，以防连接假死。</p>
<p><strong>假死的问题：</strong></p>
<ul>
<li>假死的连接占用的资源不能自动释放</li>
<li>向假死的连接发送数据，得到的反馈是发送超时</li>
</ul>
<p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明</span></span><br><span class="line"><span class="comment">IdleStateHandler 是netty 提供的处理空闲状态的处理器</span></span><br><span class="line"><span class="comment">1. long readerIdleTime : 表示多长时间没有读, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">2. long writerIdleTime : 表示多长时间没有写, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">3. long allIdleTime : 表示多长时间没有读写, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>, TimeUnit.SECONDS));</span><br><span class="line"><span class="comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ChannelDuplexHandler() &#123;</span><br><span class="line">    <span class="comment">// 用来触发特殊事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">        <span class="comment">// 触发了读空闲事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;已经 5s 没有读到数据了&quot;</span>);</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>客户端也可以持续发送ping信号：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span></span><br><span class="line"><span class="comment">// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ChannelDuplexHandler() &#123;</span><br><span class="line">    <span class="comment">// 用来触发特殊事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">        <span class="comment">// 触发了写空闲事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">            <span class="comment">//                                log.debug(&quot;3s 没有写数据了，发送一个心跳包&quot;);</span></span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> PingMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="序列化优化"><a href="#序列化优化" class="headerlink" title="序列化优化"></a>序列化优化</h2><p>序列化，反序列化主要用在消息正文的转换上</p>
<ul>
<li>序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）</li>
<li>反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理</li>
</ul>
<h3 id="Java自带的序列化"><a href="#Java自带的序列化" class="headerlink" title="Java自带的序列化"></a>Java自带的序列化</h3><p>Java提供了一种称为序列化（Serialization）的机制，它允许将对象转换为字节序列，以便在网络上传输或将其保存到磁盘上。Java序列化机制提供了一种简单而强大的方式来处理对象的持久性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectInputStream in =</span><br><span class="line">                <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bytes));</span><br><span class="line">            Object object = in.readObject();</span><br><span class="line">            <span class="keyword">return</span> (T) object;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;SerializerAlgorithm.Java 反序列化错误&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">byte</span>[] serialize(T object) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">new</span> ObjectOutputStream(out).writeObject(object);</span><br><span class="line">            <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;SerializerAlgorithm.Java 序列化错误&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中Netty提供的<code>ObjectEncoder</code>和<code>ObjectDecoder</code>就是底层使用的是该Java序列化技术。</p>
</blockquote>
<h3 id="Gson序列化"><a href="#Gson序列化" class="headerlink" title="Gson序列化"></a>Gson序列化</h3><p><strong>Gson</strong>是Google提供的一个Java库，用于在对象和JSON之间进行序列化和反序列化。它提供了简单易用的API，使得将Java对象转换为JSON字符串以及将JSON字符串转换回Java对象变得非常方便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Json &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gson().fromJson(<span class="keyword">new</span> String(bytes, StandardCharsets.UTF_8), clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">byte</span>[] serialize(T object) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gson().toJson(object).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Google-Protobuf序列化"><a href="#Google-Protobuf序列化" class="headerlink" title="Google Protobuf序列化"></a>Google Protobuf序列化</h3><p><strong>Google Protobuf（Protocol Buffers）</strong>是一种语言无关、平台无关的序列化框架，用于结构化数据的序列化和反序列化。它通过定义数据结构的.proto文件来生成相应的代码，可以在多种编程语言中使用。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>性能效率高</strong>：Google Protobuf使用二进制编码，相比于文本格式的JSON，它在序列化和反序列化的过程中占用更少的空间，并且可以更快地进行数据传输和解析。</li>
<li><strong>数据体积小</strong>：Protobuf使用紧凑的二进制编码格式，相对于XML和JSON等文本格式，生成的数据包更小。</li>
<li><strong>跨语言支持</strong>：由于Protobuf是一种语言无关的序列化框架，它提供了对多种编程语言的支持，包括Java、C++、Python等。</li>
<li><strong>灵活的数据定义</strong>：通过.proto文件定义数据结构，可以更加灵活地控制序列化和反序列化过程中的字段选择、默认值、可选性等。</li>
</ul>
<p><strong>基本使用：</strong></p>
<ul>
<li><p>导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.protobuf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>定义proto文件：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> optimize_for = SPEED; <span class="comment">// 加快解析</span></span><br><span class="line"><span class="keyword">option</span> java_package=<span class="string">&quot;com.wht.netty.codec2&quot;</span>;   <span class="comment">//指定生成到哪个包下</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname=<span class="string">&quot;MyDataInfo&quot;</span>; <span class="comment">// 外部类名, 文件名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.protobuf 可以使用message 管理其他的message。最终决定使用哪一个message作为传输对象</span></span><br><span class="line"><span class="comment">2.假设你某个项目需要传输20个对象，你不可能新建20个proto文件吧。此时你就可以</span></span><br><span class="line"><span class="comment">在一个文件里定义20个message，最后再用一个总的message（比方说这里的MyMessage）</span></span><br><span class="line"><span class="comment">来决定在实际传输时真正需要传输哪一个对象</span></span><br><span class="line"><span class="comment">3.因为你实际传输的时候大部分情况传输的都是一个对象，所以下面用oneof进行了限制</span></span><br><span class="line"><span class="comment">4.是否可以传多个对象呢？我个人认为是可以的，比如可以通过map(目前我也不太了解proto的语法)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MyMessage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个枚举类型,DataType如果是0则表示一个Student对象实例，DataType这个名称自定义</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">DataType</span> </span>&#123;</span><br><span class="line">        StudentType = <span class="number">0</span>; <span class="comment">//在proto3 要求enum的编号从0开始</span></span><br><span class="line">        WorkerType = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用data_type 来标识传的是哪一个枚举类型，这里才真正开始定义MyMessage的数据类型</span></span><br><span class="line">    DataType data_type = <span class="number">1</span>;  <span class="comment">//所有后面的数字都只是编号而已</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.oneof关键字 表示每次枚举类型进行传输时，限制最多只能传输一个对象。</span></span><br><span class="line"><span class="comment">    dataBody名称也是自定义的</span></span><br><span class="line"><span class="comment">    2.为什么这里的序号是2呢？因为上面DataType data_type = 1  占了第一个序号了</span></span><br><span class="line"><span class="comment">    3.MyMessage里真正出现的类型只有两个</span></span><br><span class="line"><span class="comment">      ①DataType类型</span></span><br><span class="line"><span class="comment">      ②Student类型或者Worker类型（这两个在真正传输的时候只会有一个出现）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">oneof</span> dataBody &#123;</span><br><span class="line">        Student student = <span class="number">2</span>;  <span class="comment">//注意这后面的数字也都只是编号而已</span></span><br><span class="line">        Worker worker = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="built_in">int32</span> id = <span class="number">1</span>;<span class="comment">//Student类的属性</span></span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">2</span>; <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> name=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int32</span> age=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编译生成java代码：<code>protoc.exe --java_out=.MyMessage.proto</code></p>
</li>
<li><p>服务端（添加解码器）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<span class="comment">//创建一个通道初始化对象(匿名对象)</span></span><br><span class="line">    <span class="comment">//给pipeline 设置处理器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="comment">//在pipeline加入ProtoBufDecoder</span></span><br><span class="line">        <span class="comment">//指定对哪种对象进行解码</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> ProtobufDecoder(MyDataInfo.MyMessage.getDefaultInstance()));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;); <span class="comment">// 给我们的workerGroup 的 EventLoop 对应的管道设置处理器</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span></span><br><span class="line"><span class="comment">    2. Object msg: 就是客户端发送的数据 默认Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MyDataInfo.MyMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//根据dataType 来显示不同的信息</span></span><br><span class="line">        MyDataInfo.MyMessage.DataType dataType = msg.getDataType();</span><br><span class="line">        <span class="keyword">if</span>(dataType == MyDataInfo.MyMessage.DataType.StudentType) &#123;</span><br><span class="line"></span><br><span class="line">            MyDataInfo.Student student = msg.getStudent();</span><br><span class="line">            System.out.println(<span class="string">&quot;学生id=&quot;</span> + student.getId() + <span class="string">&quot; 学生名字=&quot;</span> + student.getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dataType == MyDataInfo.MyMessage.DataType.WorkerType) &#123;</span><br><span class="line">            MyDataInfo.Worker worker = msg.getWorker();</span><br><span class="line">            System.out.println(<span class="string">&quot;工人的名字=&quot;</span> + worker.getName() + <span class="string">&quot; 年龄=&quot;</span> + worker.getAge());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;传输的类型不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>客户端（添加编码器）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="comment">//在pipeline中加入 ProtoBufEncoder</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> ProtobufEncoder());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">            <span class="comment">//当通道就绪就会触发该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">//随机的发送Student 或者 Workder 对象</span></span><br><span class="line">        <span class="keyword">int</span> random = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">        MyDataInfo.MyMessage myMessage = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == random) &#123; <span class="comment">//发送Student 对象</span></span><br><span class="line">        myMessage = MyDataInfo.MyMessage.newBuilder().setDataType(MyDataInfo.MyMessage.DataType.StudentType).setStudent(MyDataInfo.Student.newBuilder().setId(<span class="number">5</span>).setName(<span class="string">&quot;李四&quot;</span>).build()).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 发送一个Worker 对象</span></span><br><span class="line">            myMessage = MyDataInfo.MyMessage.newBuilder().setDataType(MyDataInfo.MyMessage.DataType.WorkerType).setWorker(MyDataInfo.Worker.newBuilder().setAge(<span class="number">20</span>).setName(<span class="string">&quot;王五&quot;</span>).build()).build();</span><br><span class="line">        &#125;</span><br><span class="line">			ctx.writeAndFlush(myMessage);</span><br><span class="line">    		&#125;    </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Netty编解码器"><a href="#Netty编解码器" class="headerlink" title="Netty编解码器"></a>Netty编解码器</h2></li>
</ul>
<p><code>Netty</code> 提供一系列实用的编解码器，他们都实现了 <code>ChannelInboundHadnler</code> 或者 <code>ChannelOutboundHandler</code> 接口。在这些类中，<code>channelRead</code> 方法已经被重写了。</p>
<ol>
<li><p><code>ByteToMessageDecoder</code>：将字节数据解码为消息对象。可以继承该类，并实现decode()方法来自定义解码逻辑。</p>
<p>例如读整数数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 读取可用字节</span></span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 字节不足，等待更多数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取4个字节的数据，并转换为int类型</span></span><br><span class="line">        <span class="keyword">int</span> dataLength = in.readInt();</span><br><span class="line">        <span class="comment">// 检查是否有足够的数据可供读取</span></span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &lt; dataLength) &#123;</span><br><span class="line">            in.resetReaderIndex(); <span class="comment">// 重置读取索引，等待更多数据</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取数据并添加到输出列表</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[dataLength];</span><br><span class="line">        in.readBytes(data);</span><br><span class="line">        out.add(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>MessageToByteEncoder</code>：将消息对象编码为字节数据。可以继承该类，并实现encode()方法来自定义编码逻辑。</p>
<p>例如在数据前面添加一位数据长度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">MyMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, MyMessage message, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将消息对象的数据编码为字节，并写入输出ByteBuf</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = message.getData();</span><br><span class="line">        <span class="keyword">int</span> length = data.length;</span><br><span class="line">        <span class="comment">// 写入数据长度</span></span><br><span class="line">        out.writeInt(length);</span><br><span class="line">        <span class="comment">// 写入数据内容</span></span><br><span class="line">        out.writeBytes(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>FixedLengthFrameDecoder</code>：用于将固定长度的消息从字节流中解码出来。</p>
</li>
<li><p><code>LineBasedFrameDecoder</code>：用于按行切割的方式将字节流解码为消息。</p>
</li>
<li><p><code>LengthFieldBasedFrameDecoder</code>：基于长度字段的帧解码器。可以解决TCP粘包和拆包的问题，通过指定长度字段的位置和长度，将字节数据解码为完整的帧。</p>
</li>
<li><p><code>LengthFieldPrepender</code>：在消息字节前面添加长度字段的编码器。与LengthFieldBasedFrameDecoder配合使用，将消息对象编码为带有长度字段的字节数据。</p>
</li>
<li><p><code>StringDecoder</code>和<code>StringEncoder</code>：字符串解码器和编码器，用于将字节数据和字符串之间进行转换。</p>
</li>
<li><p><code>ObjectDecoder</code>和<code>ObjectEncoder</code>：对象的序列化和反序列化编解码器。可以将Java对象编码为字节数据或将字节数据解码为Java对象。</p>
</li>
<li><p><code>ProtobufDecoder</code>和<code>ProtobufEncoder</code>：Google Protocol Buffers的编解码器，用于将Protobuf消息对象进行序列化和反序列化。</p>
</li>
<li><p><code>ZlibDecoder</code>和<code>ZlibEncoder</code>：用于数据的压缩和解压缩的编解码器。</p>
</li>
</ol>
<h2 id="channelGroup"><a href="#channelGroup" class="headerlink" title="channelGroup"></a>channelGroup</h2><p>在Netty中，<code>ChannelGroup</code>是一个特殊的<code>Channel</code>容器，用于管理一组相关的<code>Channel</code>对象。它提供了方便的方法来对这组<code>Channel</code>执行批量操作，如广播消息或关闭所有<code>Channel</code>。</p>
<p>Netty提供了几种不同的<code>ChannelGroup</code>实现，每种实现都有其自己的特点和适用场景。以下是其中一些常见的实现：</p>
<ol>
<li><p><code>DefaultChannelGroup</code>： </p>
<p><code>DefaultChannelGroup</code>是Netty提供的默认<code>ChannelGroup</code>实现。它使用简单的数据结构来管理<code>Channel</code>，内部使用了一个<code>ConcurrentMap</code>来存储<code>Channel</code>和其对应的唯一标识符。它是线程安全的，适用于大多数场景。</p>
<p><strong>常用方法：</strong></p>
<ul>
<li><code>add(Channel channel)</code>: 将给定的<code>Channel</code>添加到<code>ChannelGroup</code>中。</li>
<li><code>remove(Channel channel)</code>: 从<code>ChannelGroup</code>中移除指定的<code>Channel</code>。</li>
<li><code>write(Object message)</code>: 向<code>ChannelGroup</code>中的所有<code>Channel</code>发送消息。</li>
<li><code>flush()</code>: 刷新<code>ChannelGroup</code>中的所有<code>Channel</code>。</li>
<li><code>close()</code>: 关闭<code>ChannelGroup</code>中的所有<code>Channel</code>。</li>
</ul>
</li>
<li><p><code>DefaultChannelGroupFuture</code>： </p>
<p><code>DefaultChannelGroupFuture</code>是<code>ChannelGroup</code>操作的默认<code>Future</code>实现。它实现了<code>ChannelGroupFuture</code>接口，提供了一些方法来处理<code>Channel</code>操作的完成状态，如等待所有<code>Channel</code>操作完成、获取成功和失败的数量等。</p>
<p><strong>常用方法：</strong></p>
<ul>
<li><code>isSuccess()</code>: 检查<code>ChannelGroupFuture</code>的操作是否成功。</li>
<li><code>isPartialSuccess()</code>: 检查<code>ChannelGroupFuture</code>是否部分成功。</li>
<li><code>isPartialFailure()</code>: 检查<code>ChannelGroupFuture</code>是否部分失败。</li>
<li><code>getGroup()</code>: 获取关联的<code>ChannelGroup</code>。</li>
<li><code>getPendingCount()</code>: 获取等待操作完成的<code>Channel</code>数量。</li>
<li><code>iterator()</code>: 获取迭代器，用于遍历操作结果。</li>
</ul>
</li>
<li><p><code>DefaultChannelGroupPromise</code>：</p>
<p><code>DefaultChannelGroupPromise</code>是<code>ChannelGroup</code>操作的默认<code>Promise</code>实现。它实现了<code>ChannelGroupPromise</code>接口，提供了一些方法来设置和获取操作的结果，如成功、失败和取消等。</p>
<p><strong>常用方法：</strong></p>
<ul>
<li><code>setSuccess()</code>: 标记操作成功。</li>
<li><code>setSuccess(Void result)</code>: 标记操作成功，并设置操作结果。</li>
<li><code>setFailure(Throwable cause)</code>: 标记操作失败，并设置失败原因。</li>
<li><code>setUncancellable()</code>: 将<code>ChannelGroupPromise</code>设置为不可取消。</li>
<li><code>addListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; listener)</code>: 添加操作完成的监听器。</li>
</ul>
</li>
</ol>
<h3 id="事件执行器"><a href="#事件执行器" class="headerlink" title="事件执行器"></a>事件执行器</h3><p>事件执行器（<code>EventExecutor</code>）是用于处理Netty中的事件和任务调度的机制。它负责执行各种操作，例如接收和处理网络数据、处理连接和断开连接事件、执行用户自定义的任务等。</p>
<p>Netty提供了几种不同的事件执行器，每种执行器都有其自己的特点和适用场景。以下是一些常见的事件执行器：</p>
<ol>
<li><p><code>SingleThreadEventExecutor</code>：</p>
<p><code>SingleThreadEventExecutor</code>是一个单线程的事件执行器，它使用一个独立的线程来处理所有的事件和任务。它适用于那些需要保证事件顺序性和线程安全性的场景。</p>
</li>
<li><p><code>MultithreadEventExecutorGroup</code>： </p>
<p><code>MultithreadEventExecutorGroup</code>是一个多线程的事件执行器，它使用一个线程池来处理事件和任务。它可以配置使用固定数量的线程或根据需要动态调整线程数量。它适用于高并发场景，可以提高系统的吞吐量和性能。</p>
</li>
<li><p><code>GlobalEventExecutor</code>：</p>
<p><code>GlobalEventExecutor</code>是一个全局共享的事件执行器，它是一个单例对象。它在整个应用程序中提供了一个共享的事件执行器实例，方便在不同的组件之间共享使用。</p>
</li>
</ol>
<p>总结来说，事件执行器主要用于提供一个事件执行器实例，用于处理所有相关的 <code>ChannelGroup</code> 中的操作。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis事务</title>
    <url>/2023/09/04/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p>Redis 提供了 MULTI、EXEC 两个命令来进行事务操作。</p>
<ul>
<li>MULTI：表示一个事务的开启，之后客户端发过来的命令都会暂存到一个命令队列中，并不会立即执行。</li>
<li>EXEC：当服务器端收到 EXEC 命令后，才会实际执行命令队列中的所有命令。</li>
</ul>
<h2 id="Redis-的事务机制能保证哪些属性？"><a href="#Redis-的事务机制能保证哪些属性？" class="headerlink" title="Redis 的事务机制能保证哪些属性？"></a>Redis 的事务机制能保证哪些属性？</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ol>
<li><p>没有发生错误：那操作可以保证原子性</p>
</li>
<li><p>执行发生错误：需要分3种情况</p>
<ul>
<li><p>在执行 EXEC 命令前，客户端发送的操作命令本身就有错误。（例如语法错误等）</p>
<p>此时，我们还能继续提交命令操作。等到执行了 EXEC 命令之后，Redis 就会拒绝执行所有提交的命令操作。</p>
</li>
<li><p>在执行 EXEC 命令前，命令和操作的数据类型不匹配，但 Redis 实例没有检查出错误。</p>
<p>Redis会对错误命令报错，但还是会把正确的命令执行完。在这种情况下，事务的原子性就无法得到保证了。</p>
<blockquote>
<p>如果有错误语句可以使用<code>DISCAR</code>命令来让事务放弃</p>
</blockquote>
</li>
<li><p>在执行事务的 EXEC 命令时，Redis 实例发生了故障，导致事务执行失败。</p>
<p>如果 Redis 开启了 AOF 日志，使用 redis-check-aof 工具检查 AOF 日志文件，这个工具可以把未完成的事务操作从 AOF 文件中去除。这样可以保证原子性。如果没有则保证不了。</p>
</li>
</ul>
</li>
</ol>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>我们按照命令出错和实例故障的发生时机，分成三种情况来看：</p>
<ol>
<li><p>命令入队时就报错</p>
<p>在这种情况下，事务本身就会被放弃执行，所以可以保证数据库的一致性。</p>
</li>
<li><p>命令入队时没报错，实际执行时报错</p>
<p>在这种情况下，有错误的命令不会被执行，正确的命令可以正常执行，也不会改变数据库的一致性。</p>
</li>
<li><p>EXEC 命令执行时实例发生故障</p>
<ul>
<li>如果我们没有开启 RDB 或 AOF，那么，实例故障重启后，数据都没有了，数据库是一致的。</li>
<li>如果我们使用了 AOF 日志，而事务操作还没有被记录到 AOF 日志时，实例就发生了故障，那么，使用 AOF 日志恢复的数据库数据是一致的。如果只有部分操作被记录到了 AOF 日志，我们可以使用 redis-check-aof 清除事务中已经完成的操作，数据库恢复后也是一致的。</li>
</ul>
</li>
</ol>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>事务执行又可以分成命令入队（EXEC 命令执行前）和命令实际执行（EXEC 命令执行后）两个阶段：</p>
<ol>
<li>并发操作在 EXEC 命令前执行，此时，隔离性的保证要使用 WATCH 机制来实现，否则隔离性无法保证；</li>
<li>并发操作在 EXEC 命令后执行，此时，隔离性可以保证。</li>
</ol>
<blockquote>
<p>WATCH 机制的作用是，在事务执行前，监控一个或多个键的值变化情况，当事务调用 EXEC 命令执行时，WATCH 机制会先检查监控的键是否被其它客户端修改了。如果修改了，就放弃事务执行，避免事务的隔离性被破坏。然后，客户端可以再次执行事务，此时，如果没有并发修改事务数据的操作了，事务就能正常执行，隔离性也得到了保证。</p>
</blockquote>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><ul>
<li>如果 Redis 没有使用 RDB 或 AOF，那么事务的持久化属性肯定得不到保证。</li>
<li>使用了持久化技术：<ul>
<li>如果 Redis 使用了 RDB 模式，那么，在一个事务执行后，而下一次的 RDB 快照还未执行前，如果发生了实例宕机，就没法保证持久性。</li>
<li>如果 Redis 采用了 AOF 模式，因为 AOF 模式的三种配置选项 no、everysec 和 always 都会存在数据丢失的情况（如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险）。</li>
</ul>
</li>
</ul>
<p>所以，不管 Redis 采用什么持久化模式，事务的持久性属性是得不到保证的。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis做缓冲</title>
    <url>/2023/08/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%81%9A%E7%BC%93%E5%86%B2/</url>
    <content><![CDATA[<h1 id="Redis做缓存"><a href="#Redis做缓存" class="headerlink" title="Redis做缓存"></a>Redis做缓存</h1><h2 id="缓存的特征"><a href="#缓存的特征" class="headerlink" title="缓存的特征"></a>缓存的特征</h2><ul>
<li><p><strong>第一个特征</strong>：在一个层次化的系统中，缓存一定是一个快速子系统，数据存在缓存中时，能避免每次从慢速子系统中存取数据。</p>
</li>
<li><p><strong>第二个特征：缓存系统的容量大小总是小于后端慢速系统的，我们不可能把所有数据都放在缓存系统中</strong>。</p>
</li>
</ul>
<h3 id="Redis-缓存处理请求的两种情况"><a href="#Redis-缓存处理请求的两种情况" class="headerlink" title="Redis 缓存处理请求的两种情况"></a>Redis 缓存处理请求的两种情况</h3><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230320205126112.png" alt="image-20230320205126112"></p>
<ul>
<li><p><strong>缓存命中</strong>：Redis 中有相应数据，就直接读取 Redis，性能非常快。</p>
</li>
<li><p><strong>缓存缺失</strong>：Redis 中没有保存相应数据，就从后端数据库中读取数据，性能就会变慢。而且，一旦发生缓存缺失，为了让后续请求能从缓存中读取到数据，我们需要把缺失的数据写入 Redis，这个过程叫作缓存更新。</p>
</li>
</ul>
<blockquote>
<p>因为需要在应用程序新增程序代码来使用缓存，所以，Redis 并不适用于那些无法获得源码的应用。</p>
</blockquote>
<h2 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h2><h3 id="只读缓存"><a href="#只读缓存" class="headerlink" title="只读缓存"></a>只读缓存</h3><p>当 Redis 用作只读缓存时，应用要读取数据的话，会先调用 Redis GET 接口，查询数据是否存在。而所有的数据写请求，会直接发往后端的数据库，在数据库中增删改。对于删改的数据来说，如果 Redis 已经缓存了相应的数据，应用需要把这些缓存的数据删除，Redis 中就没有这些数据了。当应用再次读取这些数据时，会发生缓存缺失，应用会把这些数据从数据库中读出来，并写到缓存中。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230320205822925.png" alt="image-20230320205822925"></p>
<p><strong>优点：</strong></p>
<p>所有最新的数据都在数据库中，而数据库是提供数据可靠性保障的，这些数据不会有丢失的风险。</p>
<p><strong>场景：</strong></p>
<p>当我们需要缓存图片、短视频这些用户只读的数据时，就可以使用只读缓存这个类型了。</p>
<h3 id="读写缓存"><a href="#读写缓存" class="headerlink" title="读写缓存"></a>读写缓存</h3><p>对于读写缓存来说，除了读请求会发送到缓存进行处理（直接在缓存中查询数据是否存在)，所有的写请求也会发送到缓存，在缓存中直接对数据进行增删改操作。</p>
<p>而 Redis 是内存数据库，一旦出现掉电或宕机，内存中的数据就会丢失。这也就是说，应用的最新数据可能会丢失，给应用业务带来风险。</p>
<p><strong>数据可靠性解决方法：</strong></p>
<ul>
<li><p>同步直写：写请求发给缓存的同时，也会发给后端数据库进行处理，等到缓存和数据库都写完数据，才给客户端返回，不过，同步直写会降低缓存的访问性能。</p>
</li>
<li><p>异步写回：则是优先考虑了响应延迟。此时，所有写请求都先在缓存中处理。等到这些增改的数据要被从缓存中淘汰出来时，缓存将它们写回后端数据库。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230320210753379.png" alt="image-20230320210753379"></p>
</li>
</ul>
<p><strong>好处：</strong></p>
<p>得益于 Redis 的高性能访问特性，数据的增删改操作可以在缓存中快速完成，处理结果也会快速返回给业务应用，这就可以提升业务应用的响应速度。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>如果需要对写请求进行加速，我们选择读写缓存；</p>
</li>
<li><p>如果写请求很少，或者是只需要提升读请求的响应速度的话，我们选择只读缓存。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis内存替换策略</title>
    <url>/2023/08/29/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%86%85%E5%AD%98%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="内存替换策略"><a href="#内存替换策略" class="headerlink" title="内存替换策略"></a>内存替换策略</h1><h2 id="策略分类"><a href="#策略分类" class="headerlink" title="策略分类"></a>策略分类</h2><p>Redis 4.0 之前一共实现了 6 种内存淘汰策略，在 4.0 之后，又增加了 2 种策略。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230321160552048.png" alt="image-20230321160552048"></p>
<p>我们可以按照是否会进行数据淘汰把它们分成两类：</p>
<ul>
<li>不进行数据淘汰的策略，只有 noeviction 这一种。</li>
</ul>
<ul>
<li>会进行淘汰的 7 种其他策略。<ul>
<li>在设置了过期时间的数据中进行淘汰，包括 volatile-random、volatile-ttl、volatile-lru、volatile-lfu（Redis  4.0 后新增）四种。</li>
<li>在所有数据范围内进行淘汰，包括 allkeys-lru、allkeys-random、allkeys-lfu（Redis 4.0 后新增）三种。</li>
</ul>
</li>
</ul>
<h2 id="策略详讲"><a href="#策略详讲" class="headerlink" title="策略详讲"></a>策略详讲</h2><p> <strong>noeviction 策略</strong></p>
<p>Redis 在使用的内存空间超过 maxmemory 值时，并不会淘汰数据，也就是设定的 <strong>noeviction 策略</strong>。</p>
<p>对应到 Redis 缓存，也就是指，一旦缓存被写满了，再有写请求来时，Redis 不再提供服务，而是直接返回错误。</p>
<p><strong>基于过期时间的四种策略</strong></p>
<ul>
<li><p>volatile-ttl：在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</p>
</li>
<li><p>volatile-random：就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</p>
</li>
<li><p>volatile-lru： 会使用 LRU 算法筛选设置了过期时间的键值对。</p>
</li>
<li><p>volatile-lfu：会使用 LFU 算法选择设置了过期时间的键值对。</p>
</li>
</ul>
<p><strong>对所有数据的三种策略</strong></p>
<ul>
<li><p>allkeys-random 策略，从所有键值对中随机选择并删除数据；</p>
</li>
<li><p>allkeys-lru 策略，使用 LRU 算法在所有数据中进行筛选。</p>
</li>
<li><p>allkeys-lfu 策略，使用 LFU 算法在所有数据中进行筛选。</p>
</li>
</ul>
<blockquote>
<p><strong>LRU：</strong></p>
<p>LRU 算法的全称是 Least Recently Used，从名字上就可以看出，这是按照最近最少使用的原则来筛选数据，最不常用的数据会被筛选出来，而最近频繁使用的数据会留在缓存中。</p>
<p>不过，LRU 算法在实际实现时，需要用链表管理所有的缓存数据，这会<strong>带来额外的空间开销</strong>。而且，当有数据被访问时，需要在链表上把该数据移动到 MRU 端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。所以，在 Redis 中，LRU 算法被做了简化，以减轻数据淘汰对缓存性能的影响。具体来说，<strong>Redis 默认会记录每个数据的最近一次访问的时间戳</strong>（由键值对数据结构 RedisObject 中的 lru 字段记录）。</p>
<p>**LFU **</p>
<p>在<code>LFU</code>算法中，可以为每个key维护一个计数器。每次key被访问的时候，计数器增大。计数器越大，可以约等于访问越频繁。并且借鉴<code>LRU</code>实现的经验，维护一个待淘汰key的pool。并且记录key最后一个被访问的时间，然后随着时间推移，降低计数器。我们可以通过设置不同的 lfu_log_factor 配置项，来控制计数器值增加的速度，避免 counter 值很快就到 255 了。LFU 策略还使用衰减因子配置项 lfu_decay_time 来控制访问次数的衰减。</p>
</blockquote>
<p><strong>淘汰的键</strong></p>
<p>对于 Redis 来说，它决定了被淘汰的数据后，会把它们删除。即使淘汰的数据是脏数据，Redis 也不会把它们写回数据库。所以，我们在使用 Redis 缓存时，如果数据被修改了，需要在数据修改时就将它写回数据库。否则，这个脏数据被淘汰时，会被 Redis 删除，而数据库里也没有最新的数据了。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis内存碎片问题</title>
    <url>/2023/08/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h1><p>其实，内存碎片的形成有内因和外因两个层面的原因。简单来说，内因是操作系统的内存分配机制，外因是 Redis 的负载特征。</p>
<h2 id="内因：内存分配器的分配策略"><a href="#内因：内存分配器的分配策略" class="headerlink" title="内因：内存分配器的分配策略"></a>内因：内存分配器的分配策略</h2><p>内存分配器的分配策略就决定了操作系统无法做到<strong>“按需分配”</strong>。这是因为，内存分配器一般是按固定大小来分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配。</p>
<p>这样的分配方式本身是为了减少分配次数。但是，如果 Redis 每次向分配器申请的内存空间大小不一样，这种分配方式就会有形成碎片的风险，而这正好来源于 Redis 的外因了。</p>
<h2 id="外因：键值对大小不一样和删改操作"><a href="#外因：键值对大小不一样和删改操作" class="headerlink" title="外因：键值对大小不一样和删改操作"></a>外因：键值对大小不一样和删改操作</h2><p>Redis 通常作为共用的缓存系统或键值数据库对外提供服务，所以，不同业务应用的数据都可能保存在 Redis 中，这就会带来不同大小的键值对。</p>
<p>具体来说，一方面，如果修改后的键值对变大或变小了，就需要占用额外的空间或者释放不用的空间。另一方面，删除的键值对就不再需要内存空间了，此时，就会把空间释放出来，形成空闲空间。</p>
<h2 id="如何判断是否有内存碎片？"><a href="#如何判断是否有内存碎片？" class="headerlink" title="如何判断是否有内存碎片？"></a>如何判断是否有内存碎片？</h2><p>Redis 是内存数据库，内存利用率的高低直接关系到 Redis 运行效率的高低。为了让用户能监控到实时的内存使用情况，Redis 自身提供了 <code>INFO </code>命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO memory</span><br><span class="line"># Memory</span><br><span class="line">used_memory:1073741736</span><br><span class="line">used_memory_human:1024.00M</span><br><span class="line">used_memory_rss:1997159792</span><br><span class="line">used_memory_rss_human:1.86G</span><br><span class="line">…</span><br><span class="line"># 内存碎片率</span><br><span class="line">mem_fragmentation_ratio:1.86</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>mem_fragmentation_ratio 大于 1 但小于 1.5</strong>。这种情况是合理的。这是因为，刚才我介绍的那些因素是难以避免的。</p>
</li>
<li><p><strong>mem_fragmentation_ratio 大于 1.5</strong> 。这表明内存碎片率已经超过了 50%。一般情况下，这个时候，我们就需要采取一些措施来降低内存碎片率了。</p>
</li>
</ul>
<h2 id="如何清理内存碎片？"><a href="#如何清理内存碎片？" class="headerlink" title="如何清理内存碎片？"></a>如何清理内存碎片？</h2><p><strong>1.重启 Redis 实例</strong></p>
<p>当 Redis 发生内存碎片后，一个“简单粗暴”的方法就是<strong>重启 Redis 实例</strong>。当然，这并不是一个“优雅”的方法，毕竟，重启 Redis 会带来两个后果：</p>
<ul>
<li><p>如果 Redis 中的数据没有持久化，那么，数据就会丢失；</p>
</li>
<li><p>即使 Redis 数据持久化了，我们还需要通过 AOF 或 RDB 进行恢复，恢复时长取决于 AOF 或 RDB 的大小，如果只有一个 Redis 实例，恢复阶段无法提供服务。</p>
</li>
</ul>
<p><strong>2.利用Redis 内存碎片自动清理的方法</strong></p>
<p>内存碎片清理，简单来说，就是“搬家让位，合并空间”。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230316145555416.png" alt="image-20230316145555416"></p>
<p><strong>碎片清理是有代价的</strong>，操作系统需要把多份数据拷贝到新位置，把原有空间释放出来，这会带来时间开销。因为 Redis 是单线程，在数据拷贝时，Redis 只能等着，这就导致 Redis 无法及时处理请求，性能就会降低。</p>
<p>那么，有什么办法可以尽量缓解这个问题吗？这就要提到，Redis 专门为自动内存碎片清理功机制设置的参数了。我们可以通过设置参数，来控制碎片清理的开始和结束时机，以及占用的 CPU 比例，从而减少碎片清理对 Redis 本身请求处理的性能影响。</p>
<ol>
<li>Redis 需要启用自动内存碎片清理，可以把 activedefrag 配置项设置为 yes，命令如下：<code>config set activedefrag yes</code></li>
<li>设置清理配置：<ul>
<li><strong>active-defrag-ignore-bytes 100mb</strong>：表示内存碎片的字节数达到 100MB 时，开始清理；</li>
<li><strong>active-defrag-threshold-lower 10</strong>：表示内存碎片空间占操作系统分配给 Redis 的总空间比例达到 10% 时，开始清理。</li>
</ul>
</li>
<li>配置控制清理操作占用的 CPU 时间比例的上、下限：<ul>
<li><strong>active-defrag-cycle-min 25</strong>： 表示自动清理过程所用 CPU 时间的比例不低于 25%，保证清理能正常开展；</li>
<li><strong>active-defrag-cycle-max 75</strong>：表示自动清理过程所用 CPU 时间的比例不高于 75%，一旦超过，就停止清理，从而避免在清理时，大量的内存拷贝阻塞 Redis，导致响应延迟升高。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis哨兵模式</title>
    <url>/2022/10/18/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><p>在 Redis 主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移问题，弥补了主从复制中需要手动让从机成为主机的缺点，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主机。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/202204071044338.png" alt="202204071044338"></p>
<h2 id="哨兵的作用"><a href="#哨兵的作用" class="headerlink" title="哨兵的作用"></a>哨兵的作用</h2><p>哨兵其实就是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、自动故障转移和通知。</p>
<ul>
<li><p>监控</p>
<ul>
<li>周期性地利用ping命令检查 master 和 slave 是否正常运行，判断主从库是否下线。</li>
</ul>
<blockquote>
<p>哨兵对主库的下线判断有“主观下线”和“客观下线”两种：</p>
<ul>
<li><p>主观下线（防止误判）：</p>
<p><strong>哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态</strong>。如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会先把它标记为“主观下线”。</p>
</li>
<li><p>客观下线：</p>
<p><strong>通常会采用多实例组成的集群模式进行部署，这也被称为哨兵集群</strong>。引入多个哨兵实例一起来判断，只有大多数的哨兵实例，都判断主库已经“主观下线”了，主库才会被标记为“客观下线”。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>自动故障转移</p>
<ul>
<li>主库挂了以后，断开 master 与 slave 连接，从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。</li>
</ul>
</li>
<li><p>通知（提醒）</p>
<ul>
<li>哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。</li>
<li>哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上。</li>
</ul>
</li>
</ul>
<h2 id="开启哨兵模式"><a href="#开启哨兵模式" class="headerlink" title="开启哨兵模式"></a>开启哨兵模式</h2><ol>
<li><p>创建哨兵配置文件<code>sentinel-端口号.conf</code></p>
</li>
<li><p>进行配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 哨兵服务端口</span><br><span class="line">port 26379</span><br><span class="line"> </span><br><span class="line"># 哨兵工作信息存储目录</span><br><span class="line">dir &#x2F;tmp</span><br><span class="line"> </span><br><span class="line"># 监控 主 连接字符串 哨兵判挂标准（几个哨兵认定他挂了，就判定为主挂了，通常为哨兵数量的一半加一）</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"> </span><br><span class="line"># 主 连接多长时间无响应，就认定它挂了（默认 30s）</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"> </span><br><span class="line"># 主挂了之后，新的主上任同步数据的路线数量，数值越小，对服务器压力越小</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"> </span><br><span class="line"># 新主同步数据时，多长时间同步完算有效 （默认 180s）</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure></li>
<li><p>启动哨兵：<code>redis-sentinel 哨兵配置文件</code></p>
</li>
</ol>
<blockquote>
<p>如果需要配置哨兵集群，只需要多启动几个哨兵即可。</p>
<p><strong>通信机制：</strong>哨兵实例之间可以相互发现，归功于Redis的提供的 <strong>pub/sub 机制</strong>。</p>
<p>哨兵只要和主库建立起了连接（主库上有一个名为<code>__sentinel__:hello</code>的频道），就可以在主库上发布消息了；同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。</p>
<p>哨兵又通过 INFO 命令发给主库，获得了从库连接信息，也能和从库建立连接，并进行监控了。</p>
</blockquote>
<h2 id="故障修护过程"><a href="#故障修护过程" class="headerlink" title="故障修护过程"></a>故障修护过程</h2><ol>
<li><p><strong>主观下线：</strong></p>
<p>当主服务器发生故障时，此时一个sentinel发现了故障，系统并不会马上进行故障转移过程（这个现象称为主观下线），它会向网络中的其他Sentinel进行确认。</p>
</li>
<li><p><strong>客观下线：</strong></p>
<p>接着其他Sentinel也陆续发现故障，这个时候其中一个Sentinel就会发起投票。一定数量的哨兵(在配置文件中指定)确认Master被标记为主观下线，此时将Master标记为客观下线。</p>
</li>
<li><p><strong>sentinel的leader选举：</strong></p>
<p>要想完成故障切换（将故障master剔除，并将一个slave提升为master）就必须先选举一个leader。</p>
<p>最先发现故障的sentinel向其他哨兵发起请求成为leader，其他哨兵在没有同意别的哨兵的leader请求时，就会把票投给该sentinel。当<strong>半数以上并且大于配置的quorum</strong>的sentinel投票通过后就认定该sentinel为leader。接下来的故障切换有该leader完成。</p>
<blockquote>
<p>需要注意的是，如果哨兵集群只有 2 个实例，此时，一个哨兵要想成为 Leader，必须获得 2 票，而不是 1 票。所以，如果有个哨兵挂掉了，那么，此时的集群是无法进行主从库切换的。因此，通常我们至少会配置 3 个哨兵实例。</p>
</blockquote>
</li>
<li><p><strong>master选举：</strong></p>
<p>leader选好后将故障master剔除，从slave中挑选一个成为master。</p>
<p>我把哨兵选择新主库的过程称为<strong>“筛选 + 打分”</strong>；先按照一定规则在从库中筛选，再按照一定规则进行打分，分数最高则选为新主库。</p>
<p><strong>筛选规则：</strong></p>
<ul>
<li>是否正常运行。</li>
<li>判断它之前的网络连接状态。</li>
</ul>
<p><strong>打分规则：</strong></p>
<ul>
<li>优先级最高的从库得分高。</li>
<li>和旧主库同步程度最接近的从库得分高。</li>
<li>ID 号小的从库得分高。</li>
</ul>
</li>
<li><p>新Master再通过发布订阅模式通知所有sentinel更新监控主机信息。sentinel再通知其他从库和客户端。</p>
</li>
</ol>
<blockquote>
<p>故障的主服务器修复后将成为从服务器继续工作。</p>
</blockquote>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis如何避免单线程模型的阻塞</title>
    <url>/2023/08/15/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%98%BB%E5%A1%9E/</url>
    <content><![CDATA[<h1 id="如何避免单线程模型的阻塞？"><a href="#如何避免单线程模型的阻塞？" class="headerlink" title="如何避免单线程模型的阻塞？"></a>如何避免单线程模型的阻塞？</h1><h2 id="Redis-实例有哪些阻塞点？"><a href="#Redis-实例有哪些阻塞点？" class="headerlink" title="Redis 实例有哪些阻塞点？"></a>Redis 实例有哪些阻塞点？</h2><h3 id="和客户端交互时的阻塞点"><a href="#和客户端交互时的阻塞点" class="headerlink" title="和客户端交互时的阻塞点"></a>和客户端交互时的阻塞点</h3><p><strong>第一个阻塞点：集合全量查询和聚合操作</strong>。</p>
<p>键值对的增删改查操作是 Redis 和客户端交互的主要部分，也是 Redis 主线程执行的主要任务。所以，复杂度高的增删改查操作肯定会阻塞 Redis。</p>
<p><strong>第二个阻塞点：集合元素的删除</strong>。</p>
<p>释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230311163305958.png" alt="image-20230311163305958"></p>
<p><strong>第三个阻塞点：清空数据库</strong>。</p>
<p>既然频繁删除键值对都是潜在的阻塞点了，那么，在 Redis 的数据库级别操作中，清空数据库（例如 FLUSHDB 和 FLUSHALL 操作）必然也是一个潜在的阻塞风险，因为它涉及到删除和释放所有的键值对。</p>
<h3 id="和磁盘交互时的阻塞点"><a href="#和磁盘交互时的阻塞点" class="headerlink" title="和磁盘交互时的阻塞点"></a>和磁盘交互时的阻塞点</h3><p><strong>第四个阻塞点：AOF 日志同步写</strong>。</p>
<p>Redis 直接记录 AOF 日志时，会根据不同的写回策略对数据做落盘保存。如果有大量的写操作需要记录在 AOF 日志中，并同步写回的话，就会阻塞主线程了。</p>
<h3 id="主从节点交互时的阻塞点"><a href="#主从节点交互时的阻塞点" class="headerlink" title="主从节点交互时的阻塞点"></a>主从节点交互时的阻塞点</h3><p>对于从库来说，它在接收了 RDB 文件后，需要使用 FLUSHDB 命令清空当前数据库，这就正好撞上了刚才我们分析的<strong>第三个阻塞点。</strong></p>
<p>并且<strong>加载 RDB 文件就成为了 Redis 的第五个阻塞点</strong>。</p>
<h3 id="切片集群实例交互时的阻塞点"><a href="#切片集群实例交互时的阻塞点" class="headerlink" title="切片集群实例交互时的阻塞点"></a>切片集群实例交互时的阻塞点</h3><p>如果你使用了 Redis Cluster 方案，而且同时正好迁移的是 bigkey 的话，就会造成主线程的阻塞，因为 Redis Cluster 使用了同步迁移。</p>
<blockquote>
<p>我们来总结下刚刚找到的<strong>五个阻塞点：</strong></p>
<ol>
<li>集合全量查询和聚合操作；</li>
<li>bigkey 删除；</li>
<li>清空数据库；</li>
<li>AOF 日志同步写；</li>
<li>从库加载 RDB 文件。</li>
</ol>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>为了避免阻塞式操作，Redis 提供了<strong>异步线程机制。</strong></p>
<p>但是如果是关键路径的操作，例如读必须及时的返回结果，就不能使用异步解决。</p>
<p>而我们刚才总结的第二个阻塞点“bigkey 删除”，和第三个阻塞点“清空数据库”，都是对数据做删除，并不在关键路径上。因此，我们可以使用后台子线程来异步执行删除操作。</p>
<p>对于第四个阻塞点“AOF 日志同步写”来说，为了保证数据可靠性，Redis 实例需要保证 AOF 日志中的操作记录已经落盘，这个操作虽然需要实例等待，但它并不会返回具体的数据结果给实例。所以，我们也可以启动一个子线程来执行 AOF 日志的同步写，而不用让主线程等待 AOF 日志的写完成。</p>
<p>从库要想对客户端提供数据存取服务，就必须把 RDB 文件加载完成。所以，这个操作也属于关键路径上的操作，我们必须让从库的主线程来执行。</p>
<h3 id="异步的子线程机制"><a href="#异步的子线程机制" class="headerlink" title="异步的子线程机制"></a>异步的子线程机制</h3><p>Redis 主线程启动后，会使用操作系统提供的 pthread_create 函数创建 3 个子线程，分别由它们负责 AOF 日志写操作、键值对删除以及文件关闭的异步执行。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230311214611020.png" alt="image-20230311214611020"></p>
<blockquote>
<p>异步的键值对删除和数据库清空操作是 Redis 4.0 后提供的功能，Redis 也提供了新的命令来执行这两个操作。</p>
<p>键值对删除：当你的集合类型中有大量元素（例如有百万级别或千万级别元素）需要删除时，我建议你使用 UNLINK 命令。</p>
<p>清空数据库：可以在 FLUSHDB 和 FLUSHALL 命令后加上 ASYNC 选项，这样就可以让后台子线程异步地清空数据库。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，我想再提一下，集合全量查询和聚合操作、从库加载 RDB 文件是在关键路径上，无法使用异步操作来完成。对于这两个阻塞点，我也给你两个小建议。</p>
<ul>
<li>集合全量查询和聚合操作：可以使用 SCAN 命令，分批读取数据，再在客户端进行聚合计算；</li>
<li>从库加载 RDB 文件：把主库的数据量大小控制在 2~4GB 左右，以保证 RDB 文件能以较快的速度加载。</li>
</ul>
<blockquote>
<p><strong>对于Redis的优化，主要在于两个点：</strong></p>
<ul>
<li>降低对主线程的阻塞</li>
<li>节省内存</li>
</ul>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实现时间序列数据</title>
    <url>/2023/08/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%AE%9E%E7%8E%B0%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="时间序列数据"><a href="#时间序列数据" class="headerlink" title="时间序列数据"></a>时间序列数据</h1><p>例如需要周期性地统计近万台设备的实时状态，包括设备 ID、压力、温度、湿度，以及对应的时间戳。</p>
<p>这些与发生时间相关的一组数据，就是时间序列数据。<strong>这些数据的特点是没有严格的关系模型，记录的信息可以表示成键和值的关系</strong>（例如，一个设备 ID 对应一条记录），所以，并不需要专门用关系型数据库（例如 MySQL）来保存。</p>
<h2 id="基于-Hash-和-Sorted-Set-保存时间序列数据"><a href="#基于-Hash-和-Sorted-Set-保存时间序列数据" class="headerlink" title="基于 Hash 和 Sorted Set 保存时间序列数据"></a>基于 Hash 和 Sorted Set 保存时间序列数据</h2><ol>
<li><p>我们可以把时间戳作为 Hash 集合的 key，把记录的设备状态值作为 Hash 集合的 value。但是，<strong>Hash 类型有个短板：它并不支持对数据进行范围查询。</strong></p>
</li>
<li><p>为了能同时支持按时间戳范围的查询，可以用 Sorted Set 来保存时间序列数据，因为它能够根据元素的权重分数来排序。我们可以把时间戳作为 Sorted Set 集合的元素分数，把时间点上记录的数据作为元素本身。</p>
</li>
</ol>
<p>但是我们又会面临一个新的问题，<strong>也就是我们要解答的第二个问题：如何保证写入 Hash 和 Sorted Set 是一个原子性的操作呢？</strong></p>
<p>这里可以使用redis事务，当多个命令及其参数本身无误时，MULTI 和 EXEC 命令可以保证执行这些命令时的原子性。</p>
<p>但是因为 Sorted Set 只支持范围查询，无法直接进行聚合计算，所以，我们只能先把时间范围内的数据取回到客户端，然后在客户端自行完成聚合计算。这个方法虽然能完成聚合计算，但是会带来一定的潜在风险，也就是<strong>大量数据在 Redis 实例和客户端间频繁传输，这会和其他操作命令竞争网络资源，导致其他操作变慢。</strong></p>
<p><strong>所以如果需要进行大量的聚合计算，同时网络带宽条件不是太好时，Hash 和 Sorted Set 的组合就不太适合了。此时，使用 RedisTimeSeries 就更加合适一些。</strong></p>
<h2 id="基于-RedisTimeSeries-模块保存时间序列数据"><a href="#基于-RedisTimeSeries-模块保存时间序列数据" class="headerlink" title="基于 RedisTimeSeries 模块保存时间序列数据"></a>基于 RedisTimeSeries 模块保存时间序列数据</h2><p>RedisTimeSeries 是 Redis 的一个扩展模块。它专门面向时间序列数据提供了数据类型和访问接口，并且支持在 Redis 实例上直接对数据进行按时间范围的聚合计算。</p>
<p>因为 RedisTimeSeries 不属于 Redis 的内建功能模块，在使用时，我们需要先把它的源码单独编译成动态链接库 redistimeseries.so，再使用 loadmodule 命令进行加载，如下所示：</p>
<p>当用于时间序列数据存取时，RedisTimeSeries 的操作主要有 5 个：</p>
<ul>
<li><p>用 TS.CREATE 命令创建时间序列数据集合；</p>
<p><code>TS.CREATE device:temperature RETENTION 600000 LABELS device_id 1</code></p>
</li>
<li><p>用 TS.ADD 命令插入数据；</p>
<p><code>TS.ADD device:temperature 1596416700 25.1</code></p>
</li>
<li><p>用 TS.GET 命令读取最新数据；</p>
<p><code>TS.GET device:temperature </code></p>
</li>
<li><p>用 TS.MGET 命令按<strong>标签过滤</strong>查询数据集合；</p>
<p><code>TS.MGET FILTER device_id!=2 </code></p>
</li>
<li><p>用 TS.RANGE 支持聚合计算的范围查询。</p>
<p><code>TS.RANGE device:temperature 1596416700 1596417120 AGGREGATION avg 180000</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实现消息队列</title>
    <url>/2023/08/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="Redis实现消息队列"><a href="#Redis实现消息队列" class="headerlink" title="Redis实现消息队列"></a>Redis实现消息队列</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>消息队列在存取消息时，消息队列必须满足的三个需求：</p>
<ol>
<li><p><strong>消息保序</strong></p>
<p>虽然消费者是异步处理消息，但是，消费者仍然需要按照生产者发送消息的顺序来处理消息，避免后发送的消息被先处理了。</p>
</li>
<li><p><strong>重复消息处理</strong></p>
<p>消费者从消息队列读取消息时，有时会因为网络堵塞而出现消息重传的情况。此时，消费者可能会收到多条重复的消息。对于重复的消息，消费者如果多次处理的话，就可能造成一个业务逻辑被多次执行，如果业务逻辑正好是要修改数据，那就会出现数据被多次修改的问题了。</p>
</li>
<li><p><strong>消息可靠性保证</strong></p>
<p>另外，消费者在处理消息的时候，还可能出现因为故障或宕机导致消息没有处理完成的情况。此时，消息队列需要能提供消息可靠性的保证，也就是说，当消费者重启后，可以重新读取消息再次进行处理，否则，就会出现消息漏处理的问题了。</p>
</li>
</ol>
<h2 id="redis实现方案"><a href="#redis实现方案" class="headerlink" title="redis实现方案"></a>redis实现方案</h2><h3 id="List实现"><a href="#List实现" class="headerlink" title="List实现"></a>List实现</h3><ol>
<li><p><strong>消息保序</strong></p>
<p>List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。（即 LPUSH 和RPOP的结合）</p>
<p>为了即使没有新消息写入 List，消费者也要不停地调用 RPOP 命令，这就会导致消费者程序的 CPU 一直消耗在执行 RPOP 命令上，带来不必要的性能损失这个问题，Redis 提供了 BRPOP 命令。<strong>BRPOP 命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据</strong>。</p>
</li>
<li><p><strong>重复消息处理</strong></p>
<p>一方面，消息队列要能给每一个消息提供全局唯一的 ID 号；另一方面，消费者程序要把已经处理过的消息的 ID 号记录下来。</p>
<p>消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理。</p>
<blockquote>
<p>这种处理特性也称为幂等性，幂等性就是指，对于同一条消息，消费者收到一次的处理结果和收到多次的处理结果是一致的。</p>
</blockquote>
</li>
<li><p><strong>消息可靠性保证</strong></p>
<p>为了留存消息，List 类型提供了 BRPOPLPUSH 命令，这个命令的作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存。这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。</p>
</li>
</ol>
<blockquote>
<p><strong>缺点：</strong></p>
<p><strong>生产者消息发送很快，而消费者处理消息的速度比较慢，这就导致 List 中的消息越积越多，给 Redis 的内存带来很大压力</strong>。这个时候，我们希望启动多个消费者程序组成一个消费组，一起分担处理 List 中的消息。但是，List 类型并不支持消费组的实现。</p>
</blockquote>
<h3 id="基于-Streams-的实现"><a href="#基于-Streams-的实现" class="headerlink" title="基于 Streams 的实现"></a>基于 Streams 的实现</h3><p>Streams 是 Redis 专门为消息队列设计的数据类型，它提供了丰富的消息队列操作命令。</p>
<ul>
<li><p>XADD：插入消息，保证有序，可以自动生成全局唯一 ID；</p>
<p><code>XADD mqstream * repo 5</code>消息队列名称后面的*，表示让 Redis 为插入的数据自动生成一个全局唯一的 ID</p>
</li>
<li><p>XREAD：用于读取消息，可以按 ID 读取数据；</p>
<p><code>XREAD BLOCK 100 STREAMS  mqstream 1599203861727-0</code></p>
<p>或者<code>XREAD block 10000 streams mqstream $</code></p>
<p>XRAED 时设定 block 配置项，实现类似于 BRPOP 的阻塞读取操作，我们设置了 block 10000 的配置项，10000 的单位是毫秒，表明 XREAD 在读取最新消息时，如果没有消息到来，XREAD 将阻塞 10000 毫秒（即 10 秒），然后再返回。命令最后的“$”符号表示读取最新的消息。</p>
</li>
<li><p>XREADGROUP：按消费组形式读取消息；</p>
<p><code>XGROUP create mqstream group1 0</code></p>
<p><code>XREADGROUP group group1 consumer1 streams mqstream</code></p>
</li>
<li><p>XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis应对高并发</title>
    <url>/2023/09/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%BA%94%E5%AF%B9%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="应对高并发"><a href="#应对高并发" class="headerlink" title="应对高并发"></a>应对高并发</h1><p>我们在使用 Redis 时，不可避免地会遇到并发访问的问题。</p>
<p>为了保证并发访问的正确性，Redis 提供了两种方法，分别是<strong>加锁</strong>和<strong>原子操作</strong>。</p>
<h2 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h2><p>加锁是一种常用的方法，在读取数据前，客户端需要先获得锁，否则就无法进行操作。当一个客户端获得锁后，就会一直持有这把锁，直到客户端完成数据更新，才释放这把锁。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>如果加锁操作多，会降低系统的并发访问性能。</li>
<li>Redis 客户端要加锁时，需要用到分布式锁，而分布式锁实现复杂，需要用额外的存储系统来提供加解锁操作。</li>
</ul>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ol>
<li><p><strong>基于单个 Redis 节点实现分布式锁</strong></p>
<p>用Redis存锁变量，key为变量名，value为锁的值；例如：<code>lock_key:0</code></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230331202109712.png" alt="image-20230331202109712"></p>
<p>为了保证锁操作的原子性，需要使用原子操作的语句来实现加锁与释放锁。</p>
<p><strong>加锁：</strong><code>SET key value [EX seconds | PX milliseconds]  [NX]</code>例如：<code>SET lock_key unique_value NX PX 10000</code>其中，unique_value 是客户端的唯一标识，可以用一个随机生成的字符串来表示，PX 10000 则表示 lock_key 会在 10s 后过期，以免客户端在这期间发生异常而无法释放锁。</p>
<p><strong>释放锁：</strong>使用lua脚本保证原子性</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">//释放锁 比较unique_value是否相等，避免误释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其中，KEYS[1]表示 lock_key，ARGV[1]是当前客户端的唯一标识</p>
</li>
<li><p><strong>多节点的高可靠分布式锁</strong></p>
<p>基本思路，是让客户端和多个独立的 Redis 实例依次请求加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁了，否则加锁失败。</p>
<p>实现步骤：</p>
<ul>
<li>客户端获取当前时间</li>
<li>客户端按顺序依次向 N 个 Redis 实例执行加锁操作。（这里的加锁操作和在单实例上执行的加锁操作一样）</li>
<li>一旦客户端完成了和所有 Redis 实例的加锁操作，客户端就要计算整个加锁过程的总耗时。</li>
</ul>
<p>客户端只有在满足下面的这两个条件时，才能认为是加锁成功。</p>
<ul>
<li>条件一：客户端从超过半数（大于等于 N/2+1）的 Redis 实例上成功获取到了锁；</li>
<li>条件二：客户端获取锁的总耗时没有超过锁的有效时间，并且剩余有效时间够完成数据操作。</li>
</ul>
<p>如果客户端在和所有实例执行完加锁操作后，没能同时满足这两个条件，那么，客户端向所有 Redis 节点发起释放锁的操作。</p>
</li>
</ol>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p><strong>原子操作是另一种提供并发访问控制的方法</strong>。原子操作是指执行过程保持原子性的操作，而且原子操作执行时并不需要再加锁，实现了无锁操作。这样一来，既能保证并发控制，还能减少对系统并发性能的影响。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>把多个操作在 Redis 中实现成一个操作，也就是<strong>单命令操作</strong>。</p>
<p>虽然 Redis 的单个命令操作可以原子性地执行，但是在实际应用中，数据修改时可能包含多个操作，至少包括读数据、数据增减、写回数据三个操作，这显然就不是单个命令操作了，那该怎么办呢？</p>
<p>Redis 提供了 INCR/DECR 命令，把这三个操作转变为一个原子操作了。INCR/DECR 命令可以对数据进行<strong>增值 / 减值</strong>操作，而且它们本身就是单个命令操作，Redis 在执行它们时，本身就具有互斥性。</p>
<blockquote>
<p>如果操作语句比较复杂，Redis 的单命令操作已经无法保证多个操作的互斥执行了，我们只有使用Lua脚本。</p>
</blockquote>
</li>
<li><p>把多个操作写到一个 <strong>Lua 脚本</strong>中，以原子性方式执行单个 Lua 脚本。</p>
<p>Redis 会把整个 Lua 脚本作为一个整体执行，在执行的过程中不会被其他命令打断，从而保证了 Lua 脚本中操作的原子性。</p>
<p><strong>在编写 Lua 脚本时，你要避免把不需要做并发控制的操作写入脚本中</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据倾斜问题</title>
    <url>/2023/09/12/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h1><p>数据倾斜有两类。</p>
<ul>
<li><strong>数据量倾斜</strong>：在某些情况下，实例上的数据分布不均衡，某个实例上的数据特别多。</li>
<li><strong>数据访问倾斜</strong>：虽然每个集群实例上的数据量相差不大，但是某个实例上的数据是热点数据，被访问得非常频繁。</li>
</ul>
<h2 id="数据量倾斜"><a href="#数据量倾斜" class="headerlink" title="数据量倾斜"></a>数据量倾斜</h2><ol>
<li><p><strong>bigkey 导致倾斜</strong></p>
<p>bigkey 的 value 值很大（String 类型），或者是 bigkey 保存了大量集合元素（集合类型），会导致这个实例的数据量增加，内存资源消耗也相应增加。</p>
<p><strong>解决方法：</strong></p>
<ul>
<li>我们在业务层生成数据时，要尽量避免把过多的数据保存在同一个键值对中。</li>
<li>如果 bigkey 正好是集合类型，我们还有一个方法，就是把 bigkey 拆分成很多个小的集合类型数据，分散保存在不同的实例上。</li>
</ul>
</li>
<li><p><strong>Slot 分配不均衡导致倾斜</strong></p>
<p>如果没有均衡地分配 Slot，就会有大量的数据被分配到同一个 Slot 中，而同一个 Slot 只会在一个实例上分布，这就会导致，大量数据被集中到一个实例上，造成数据倾斜。</p>
<p><strong>解决方法：</strong></p>
<ul>
<li>在分配之前，我们就要避免把过多的 Slot 分配到同一个实例。</li>
<li>如果已经分配，可以对不合理的slot进行迁移</li>
</ul>
</li>
<li><p>Hash Tag导致倾斜</p>
<p>Hash Tag 是指加在键值对 key 中的一对花括号{}。这对括号会把 key 的一部分括起来，客户端在计算 key 的 CRC16 值时，只对 Hash Tag 花括号中的 key 内容进行计算。（也就是同一个Hash Tag会被映射到同一个Slot上）</p>
<p><strong>问题：</strong>但是，使用 Hash Tag 的潜在问题，就是大量的数据可能被集中到一个实例上，导致数据倾斜，集群中的负载不均衡</p>
<p><strong>建议：</strong>如果使用 Hash Tag 进行切片的数据会带来较大的访问压力，就优先考虑避免数据倾斜，最好不要使用 Hash Tag 进行数据切片。</p>
</li>
</ol>
<h2 id="数据访问倾斜"><a href="#数据访问倾斜" class="headerlink" title="数据访问倾斜"></a>数据访问倾斜</h2><p>发生数据访问倾斜的根本原因，就是实例上存在热点数据。</p>
<p><strong>解决方法：</strong></p>
<p>采用<strong>热点数据多副本</strong>的方法，把热点数据复制多份，在每个数据副本的key中增加一个随机前缀，让它和其他副本数据不会映射在同一个Slot中。这样热点数据的访问压力就可以分摊到不同的实例上。</p>
<p>但是这种多副本的方法只能针对只读的热点数据，如果是有读有写的热点数据只能给实例增加资源了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230407161459345.png" alt="image-20230407161459345"></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的AOF日志</title>
    <url>/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E7%9A%84AOF%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h1><p>Redis 的持久化主要有两大机制，即 AOF（Append Only File）日志和 RDB 快照。AOF是写后日志，先执行命令再记录日志。这样就不会存在命令错误和阻塞当前写操作了。</p>
<p><strong>风险：</strong></p>
<ul>
<li>如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。</li>
<li>AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。</li>
</ul>
<h2 id="写回磁盘策略："><a href="#写回磁盘策略：" class="headerlink" title="写回磁盘策略："></a>写回磁盘策略：</h2><ul>
<li><p><strong>Always</strong>：同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</p>
</li>
<li><p><strong>Everysec</strong>：每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</p>
</li>
<li><p><strong>No</strong>：操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230416170054636.png" alt="image-20230416170054636"></p>
</li>
</ul>
<h2 id="AOF重写机制："><a href="#AOF重写机制：" class="headerlink" title="AOF重写机制："></a>AOF重写机制：</h2><p>AOF会随着命令越来越多而变大，这个时候就需要对AOF进行重写。重写机制具有“多变一”功能。旧日志文件中的多条命令，在重写后的新日志中变成了一条命令。</p>
<p>和 AOF 日志由主线程写回不同，重写过程是<strong>由后台子进程 bgrewriteaof</strong> 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。</p>
<ul>
<li><p><strong>重写过程：</strong></p>
<p>每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失（AOF重写缓冲会在重写完成后写入新的AOF文件中）。而且，因为 Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230416170447838.png" alt="image-20230416170447838"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的IO模型</title>
    <url>/2023/07/31/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E7%9A%84IO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Redis的IO-模型"><a href="#Redis的IO-模型" class="headerlink" title="Redis的IO 模型"></a>Redis的IO 模型</h1><p>Redis 采用了<strong>多路复用机制</strong>，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。但是由于是单线程如果线程被阻塞了，就无法进行多路复用了。</p>
<h2 id="多路复用的高性能-I-O-模型"><a href="#多路复用的高性能-I-O-模型" class="headerlink" title="多路复用的高性能 I/O 模型"></a>多路复用的高性能 I/O 模型</h2><p>Redis是基于多路复用的高性能 I/O 模型，<strong>该机制允许内核中，同时存在多个监听套接字和已连接套接字</strong>（使用的非阻塞模式）。并且为了在请求到达时能通知到 Redis 线程，select/epoll 提供了<strong>基于事件的回调机制</strong>，即<strong>针对不同事件的发生，调用相应的处理函数</strong>。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230416162410275.png" alt="image-20230416162410275" style="zoom:67%;" />

<h2 id="Redis6-0新特性"><a href="#Redis6-0新特性" class="headerlink" title="Redis6.0新特性"></a>Redis6.0新特性</h2><p>随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 IO 的处理上，也就是说，<strong>单个主线程处理网络请求的速度跟不上底层网络硬件的速度</strong>。</p>
<ul>
<li><p><strong>单线程结构：</strong></p>
<p>在之前Redis 一直被大家熟知的就是它的单线程架构，虽然有些命令操作可以用后台线程或子进程执行（比如数据删除、快照生成、AOF 重写），但是，从网络 IO 处理到实际的读写命令处理，都是由单个线程完成的。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230418140012737.png" alt="image-20230418140012737" style="zoom:50%;" />
</li>
<li><p><strong>多线程结构：</strong></p>
<p>Redis 的<strong>多 IO 线程只是用来处理网络请求的</strong>，对于读写命令，Redis 仍然使用单线程来处理。这是因为，Redis 处理请求时，网络处理经常是瓶颈，通过多个 IO 线程并行处理网络操作（即使用并行线程处理请求解析、结果响应），可以提升实例的整体处理性能。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230418135955502.png" alt="image-20230418135955502" style="zoom:50%;" />

<blockquote>
<p>相关设置：</p>
<ul>
<li>开启多线程：<code>io-threads-do-reads yes</code></li>
<li>设置多线程数量：<code>io-threads  6</code>（一般来说，<strong>线程个数要小于 Redis 实例所在机器的 CPU 核个数</strong>，例如，对于一个 8 核的机器来说，Redis 官方建议配置 6 个 IO 线程。）</li>
</ul>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的RDB日志</title>
    <url>/2023/08/04/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E7%9A%84RDB%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="RDB日志"><a href="#RDB日志" class="headerlink" title="RDB日志"></a>RDB日志</h1><p>AOF日志记录了每条操作的命令，也正因为<strong>记录的是操作命令</strong>，而不是实际的数据，所以，用 AOF 方法进行故障恢复的时候，需要逐一把操作日志都执行一遍。也正是这个原因，RDB日志内存快照诞生了。</p>
<p>和 AOF 相比，RDB 记录的是某一时刻的数据，执行的是全量快照，并不是操作，所以，在做数据恢复时，我们可以直接把 RDB 文件读入内存，很快地完成恢复。</p>
<p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。</p>
<ul>
<li>save：在主线程中执行，会导致阻塞；</li>
<li>bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。</li>
</ul>
<h2 id="写时复制技术："><a href="#写时复制技术：" class="headerlink" title="写时复制技术："></a>写时复制技术：</h2><p>利用写时复制技术，在执行快照的同时，正常处理写操作。</p>
<p>原理就是如果主线程需要对数据进行修改，则会复制一份副本对副本进行修改</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230417153832275.png" alt="image-20230417153832275" style="zoom:67%;" />

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>AOF日志与RDB日志都有各自的优缺点，没办法做到完全完美。所以Redis 4.0 中提出了一个<strong>混合使用 AOF 日志和内存快照</strong>的方法。</p>
<p>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230417154610499.png" alt="image-20230417154610499" style="zoom:67%;" />

<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的常见的四种统计模式</title>
    <url>/2023/08/06/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E7%9A%84%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="集合类型常见的四种统计模式"><a href="#集合类型常见的四种统计模式" class="headerlink" title="集合类型常见的四种统计模式"></a>集合类型常见的四种统计模式</h1><h2 id="聚合统计"><a href="#聚合统计" class="headerlink" title="聚合统计"></a>聚合统计</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>所谓的聚合统计，就是指统计多个集合元素的聚合结果，包括：统计多个集合的共有元素（交集统计）；把两个集合相比，统计其中一个集合独有的元素（差集统计）；统计多个集合的所有元素（并集统计）。</p>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>统计手机 App 每天的新增用户数和第二天的留存用户数，正好对应了聚合统计。</p>
<p>要完成这个统计任务，我们可以用一个集合记录所有登录过 App 的用户 ID，同时，用另一个集合记录每一天登录过 App 的用户 ID。然后，再对这两个集合做聚合统计。</p>
<ul>
<li>新增用户：两个集合求差集</li>
<li>留存用户：两个集合求交集</li>
</ul>
<blockquote>
<p>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞。所以，我给你分享一个小建议：<strong>你可以从主从集群中选择一个从库，让它专门负责聚合计算，或者是把数据读取到客户端，在客户端来完成聚合统计</strong>，这样就可以规避阻塞主库实例和其他从库实例的风险了。</p>
</blockquote>
<h2 id="排序统计"><a href="#排序统计" class="headerlink" title="排序统计"></a>排序统计</h2><h3 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h3><p>以在电商网站上提供最新评论列表的场景为例。</p>
<p>最新评论列表包含了所有评论中的最新留言，<strong>这就要求集合类型能对元素保序</strong>，也就是说，集合中的元素可以按序排列，这种对元素保序的集合类型叫作有序集合。</p>
<h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>在 Redis 常用的 4 个集合类型中（List、Hash、Set、Sorted Set），List 和 Sorted Set 就属于有序集合。</p>
<p><strong>List 是按照元素进入 List 的顺序进行排序的，而 Sorted Set 可以根据元素的权重来排序</strong>，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。</p>
<p>比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>所以，在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，建议你优先考虑使用 Sorted Set。</p>
<h2 id="二值状态统计"><a href="#二值状态统计" class="headerlink" title="二值状态统计"></a>二值状态统计</h2><h3 id="概念：-2"><a href="#概念：-2" class="headerlink" title="概念："></a>概念：</h3><p><strong>二值状态统计：</strong>这里的二值状态就是指集合元素的取值就只有 0 和 1 两种。</p>
<h3 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h3><p>在签到打卡的场景中，我们只用记录签到（1）或未签到（0），所以它就是非常典型的二值状态。</p>
<p>这个时候，我们就可以选择 Bitmap。这是 Redis 提供的扩展数据类型。</p>
<ul>
<li>记录该用户 8 月 3 号已签到：<code>SETBIT uid:sign:3000:202008 2 1 </code></li>
<li>检查该用户 8 月 3 日是否签到：<code>GETBIT uid:sign:3000:202008 2  </code></li>
<li>统计该用户在 8 月份的签到次数：<code>BITCOUNT uid:sign:3000:202008 </code></li>
</ul>
<p>接下来，你可以再思考一个问题：如果记录了 1 亿个用户 10 天的签到情况，你有办法统计出这 10 天连续签到的用户总数吗？</p>
<p>在介绍具体的方法之前，我们要先知道，Bitmap 支持用 BITOP 命令对多个 Bitmap 按位做“与”“或”“异或”的操作，操作的结果会保存到一个新的 Bitmap 中。</p>
<p>我们对 10 个 Bitmap 做“与”操作，得到的结果也是一个 Bitmap。在这个 Bitmap 中，只有 10 天都签到的用户对应的 bit 位上的值才会是 1。最后，我们可以用 BITCOUNT 统计下 Bitmap 中的 1 的个数，这就是连续签到 10 天的用户总数了。</p>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>所以，如果只需要统计数据的二值状态，例如商品有没有、用户在不在等，就可以使用 Bitmap，因为它只用一个 bit 位就能表示 0 或 1。在记录海量数据时，Bitmap 能够有效地节省内存空间。</p>
<h2 id="基数统计"><a href="#基数统计" class="headerlink" title="基数统计"></a>基数统计</h2><h3 id="概念：-3"><a href="#概念：-3" class="headerlink" title="概念："></a>概念：</h3><p>基数统计：基数统计就是指统计一个集合中不重复的元素个数。对应到我们刚才介绍的场景中，就是统计网页的 UV。</p>
<h3 id="例子：-2"><a href="#例子：-2" class="headerlink" title="例子："></a>例子：</h3><p>网页 UV 的统计有个独特的地方，就是需要去重，一个用户一天内的多次访问只能算作一次。在 Redis 的集合类型中，Set 类型默认支持去重，所以看到有去重需求时，我们可能第一时间就会想到用 Set 类型。</p>
<p>但是，如果 page1 非常火爆，UV 达到了千万，这个时候，一个 Set 就要记录千万个用户 ID。对于一个搞大促的电商网站而言，这样的页面可能有成千上万个，如果每个页面都用这样的一个 Set，就会消耗很大的内存空间。</p>
<p><strong>这时候，就要用到 Redis 提供的 HyperLogLog 了。</strong></p>
<p>HyperLogLog 是一种用于统计基数的数据集合类型，它的最大优势就在于，当集合元素数量非常多时，它计算基数所需的空间总是固定的，而且还很小。</p>
<p>在统计 UV 时，你可以用 PFADD 命令（用于向 HyperLogLog 中添加新元素）把访问页面的每个用户都添加到 HyperLogLog 中：<code>PFADD page1:uv user1 user2 user3 user4 user5</code></p>
<p>接下来，就可以用 PFCOUNT 命令直接获得 page1 的 UV 值了，这个命令的作用就是返回 HyperLogLog 的统计结果：<code>PFCOUNT page1:uv</code></p>
<blockquote>
<p>不过，有一点需要你注意一下，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。这也就意味着，你使用 HyperLogLog 统计的 UV 是 100 万，但实际的 UV 可能是 101 万。虽然误差率不算大，但是，如果你需要精确统计结果的话，最好还是继续用 Set 或 Hash 类型。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230306210619626.png" alt="image-20230306210619626"></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis缓冲区</title>
    <url>/2023/08/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>缓冲区的功能其实很简单，主要就是用一块内存空间来暂时存放命令数据，以免出现因为数据和命令的处理速度慢于发送速度而导致的数据丢失和性能问题。</p>
<p>Redis 是典型的<strong>client-server 架构</strong>，所有的操作命令都需要通过客户端发送给服务器端。所以，缓冲区在 Redis 中的一个主要应用场景，就是在客户端和服务器端之间进行通信时，<strong>用来暂存客户端发送的命令数据，或者是服务器端返回给客户端的数据结果</strong>。此外，缓冲区的另一个主要应用场景，是<strong>在主从节点间进行数据同步时，用来暂存主节点接收的写命令和数据</strong>。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230318172524755.png" alt="image-20230318172524755" style="zoom:67%;" />

<h2 id="输入缓冲区溢出"><a href="#输入缓冲区溢出" class="headerlink" title="输入缓冲区溢出"></a>输入缓冲区溢出</h2><p>可能导致<strong>溢出</strong>的情况主要是下面两种：</p>
<ul>
<li>写入了 bigkey，比如一下子写入了多个百万级别的集合类型数据。</li>
<li>服务器端处理请求的速度过慢，例如，Redis 主线程出现了间歇性阻塞，无法及时处理正常发送的请求，导致客户端发送的请求在缓冲区越积越多。</li>
</ul>
<p>要查看和服务器端相连的每个客户端对输入缓冲区的使用情况，我们可以<strong>使用 CLIENT LIST 命令</strong>：</p>
<p><strong>重点关注两类信息：</strong></p>
<ol>
<li>一类是与服务器端连接的客户端的信息。</li>
<li>另一类是与输入缓冲区相关的三个参数：<ul>
<li>cmd，表示客户端最新执行的命令。这个例子中执行的是 CLIENT 命令。</li>
<li>qbuf，表示输入缓冲区已经使用的大小。这个例子中的 CLIENT 命令已使用了 26 字节大小的缓冲区。</li>
<li>qbuf-free，表示输入缓冲区尚未使用的大小。这个例子中的 CLIENT 命令还可以使用 32742 字节的缓冲区。qbuf 和 qbuf-free 的总和就是，Redis 服务器端当前为已连接的这个客户端分配的缓冲区总大小。这个例子中总共分配了 26 + 32742 = 32768 字节，也就是 32KB 的缓冲区。</li>
</ul>
</li>
</ol>
<p><strong>如何避免：</strong></p>
<p>Redis 并没有提供参数让我们调节客户端输入缓冲区的大小。如果要避免输入缓冲区溢出，那我们就只能从数据命令的发送和处理速度入手，也就是前面提到的避免客户端写入 bigkey，以及避免 Redis 主线程阻塞。</p>
<h2 id="输出缓冲区溢出"><a href="#输出缓冲区溢出" class="headerlink" title="输出缓冲区溢出"></a>输出缓冲区溢出</h2><p>Redis 为每个客户端设置的输出缓冲区也包括两部分：</p>
<ul>
<li>一部分，是一个大小为 16KB 的固定缓冲空间，用来暂存 OK 响应和出错信息</li>
<li>另一部分，是一个可以动态增加的缓冲空间，用来暂存大小可变的响应结果。</li>
</ul>
<p>可能导致溢出的情况主要是下面三种：</p>
<ul>
<li><p>服务器端返回 bigkey 的大量结果。</p>
</li>
<li><p>执行了 MONITOR 命令。</p>
<blockquote>
<p>MONITOR 命令是用来监测 Redis 执行的。执行这个命令之后，就会持续输出监测到的各个命令操作。</p>
<p><strong>MONITOR 命令主要用在调试环境中，不要在线上生产环境中持续使用 MONITOR</strong></p>
</blockquote>
</li>
<li><p>缓冲区大小设置得不合理。</p>
<p>可以通过 client-output-buffer-limit 配置项，来设置缓冲区的大小;</p>
<p>当我们给普通客户端设置缓冲区大小时，通常可以在 Redis 配置文件中进行这样的设置：<code>client-output-buffer-limit normal 0 0 0</code>或者<code>client-output-buffer-limit pubsub 8mb 2mb 60</code></p>
<blockquote>
<p><strong>第一种设置：</strong></p>
<p>其中，normal 表示当前设置的是普通客户端，第 1 个 0 设置的是缓冲区大小限制，第 2 个 0 和第 3 个 0 分别表示缓冲区持续写入量限制和持续写入时间限制。0为不做限制。</p>
<p><strong>第二种设置：</strong></p>
<p>其中，pubsub 参数表示当前是对订阅客户端进行设置；8mb 表示输出缓冲区的大小上限为 8MB，一旦实际占用的缓冲区大小要超过 8MB，服务器端就会直接关闭客户端的连接；2mb 和 60 表示，如果连续 60 秒内对输出缓冲区的写入量超过 2MB 的话，服务器端也会关闭客户端连接。</p>
</blockquote>
</li>
</ul>
<h2 id="主从集群中的缓冲区"><a href="#主从集群中的缓冲区" class="headerlink" title="主从集群中的缓冲区"></a>主从集群中的缓冲区</h2><p>主从集群间的数据复制包括全量复制和增量复制两种。全量复制是同步所有数据，而增量复制只会把主从库网络断连期间主库收到的命令，同步给从库。无论在哪种形式的复制中，为了保证主从节点的数据一致，都会用到缓冲区。</p>
<h3 id="复制缓冲区的溢出问题"><a href="#复制缓冲区的溢出问题" class="headerlink" title="复制缓冲区的溢出问题"></a>复制缓冲区的溢出问题</h3><p>在全量复制过程中，主节点在向从节点传输 RDB 文件的同时，会继续接收客户端发送的写命令请求。这些写命令就会先保存在复制缓冲区中，等 RDB 文件传输完成后，再发送给从节点去执行。主节点上会为每个从节点都维护一个复制缓冲区，来保证主从节点间的数据同步。</p>
<p><strong>问题：</strong>如果在全量复制时，从节点接收和加载 RDB 较慢，同时主节点接收到了大量的写命令，写命令在复制缓冲区中就会越积越多，最终导致溢出。复制缓冲区一旦发生溢出，主节点也会直接关闭和从节点进行复制操作的连接，导致全量复制失败。</p>
<p><strong>解决：</strong>我们可以控制主节点保存的数据量大小，并使用 client-output-buffer-limit 配置项，来设置合理的复制缓冲区大小：<code>config set client-output-buffer-limit slave 512mb 128mb 60</code>，最后我们需要控制从节点的数量，来避免主节点中复制缓冲区占用过多内存的问题。</p>
<blockquote>
<p>其中，slave 参数表明该配置项是针对复制缓冲区的。512mb 代表将缓冲区大小的上限设置为 512MB；128mb 和 60 代表的设置是，如果连续 60 秒内的写入量超过 128MB 的话，也会触发缓冲区溢出。</p>
</blockquote>
<h3 id="复制积压缓冲区的溢出问题"><a href="#复制积压缓冲区的溢出问题" class="headerlink" title="复制积压缓冲区的溢出问题"></a>复制积压缓冲区的溢出问题</h3><p>我们再来看下增量复制时使用的缓冲区，这个缓冲区称为复制积压缓冲区。</p>
<p>主节点在把接收到的写命令同步给从节点时，同时会把这些写命令写入复制积压缓冲区。一旦从节点发生网络闪断，再次和主节点恢复连接后，从节点就会从复制积压缓冲区中，读取断连期间主节点接收到的写命令，进而进行增量同步。</p>
<p><strong>问题：</strong>复制积压缓冲区是一个大小有限的环形缓冲区。当主节点把复制积压缓冲区写满后，会覆盖缓冲区中的旧命令数据。如果从节点还没有同步这些旧命令数据，就会造成主从节点间重新开始执行全量复制。</p>
<p><strong>解决：</strong>为了应对复制积压缓冲区的溢出问题，我们可以调整复制积压缓冲区的大小，也就是设置 repl_backlog_size 这个参数的值。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis缓存</title>
    <url>/2022/10/03/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h1><p>缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</p>
<p>但是缓存也会增加代码复杂度和运营的成本：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220523214414123.png" alt="image-20220523214414123"></p>
<h3 id="缓存的使用"><a href="#缓存的使用" class="headerlink" title="缓存的使用"></a>缓存的使用</h3><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220728155124988.png" alt="image-20220728155124988"></p>
<h4 id="常用的缓存更新策略"><a href="#常用的缓存更新策略" class="headerlink" title="常用的缓存更新策略"></a>常用的缓存更新策略</h4><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p>
<p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p>
<p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p>
<p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p>
<ul>
<li>主动更新的策略：<ul>
<li>人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案（常用）</li>
<li>由系统本身完成，数据库与缓存的问题交由系统本身去处理</li>
<li>调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</li>
</ul>
</li>
</ul>
<blockquote>
<p>最佳的缓存更新策略：</p>
<ol>
<li>低一致性需求:使用Redis自带的内存淘汰机制</li>
<li>高一致性需求:主动更新，并以超时剔除作为兜底方案<ul>
<li>读操作：缓存命中则直接返回，缓存未命中则查询数据库，并写入缓存，设定超时时间</li>
<li>写操作：先写数据库，然后再删除缓存要确保数据库与缓存操作的原子性</li>
</ul>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis缓存与数据库一致性问题</title>
    <url>/2023/08/31/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="缓存与数据库一致性问题"><a href="#缓存与数据库一致性问题" class="headerlink" title="缓存与数据库一致性问题"></a>缓存与数据库一致性问题</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这里的<strong>“一致性”</strong>包含了两种情况：</p>
<ul>
<li><p>缓存中有数据，那么，缓存的数据值需要和数据库中的值相同；</p>
</li>
<li><p>缓存中本身没有数据，那么，数据库中的值必须是最新值。</p>
</li>
</ul>
<p>不符合这两种情况的，就属于缓存和数据库的数据不一致问题了。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h3><p>具体来说，可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中（例如使用 Kafka 消息队列）。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。</p>
<p><strong>两种不同顺序存在的问题：</strong></p>
<ul>
<li><p><strong>情况一：先删除缓存，再更新数据库。</strong></p>
<p><strong>延迟双删</strong>方案：在线程 A 更新完数据库值以后，我们可以让它先 sleep 一小段时间，再进行一次缓存删除操作。</p>
</li>
<li><p><strong>情况二：先更新数据库值，再删除缓存值。</strong></p>
<p>这种情况对业务的影响较小。</p>
</li>
</ul>
<p><strong>总结：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230322151302575.png" alt="image-20230322151302575"></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis缓存击穿</title>
    <url>/2022/10/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</url>
    <content><![CDATA[<h1 id="Redis缓存击穿"><a href="#Redis缓存击穿" class="headerlink" title="Redis缓存击穿"></a>Redis缓存击穿</h1><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>互斥锁</li>
<li>逻辑过期</li>
</ul>
<h2 id="利用锁"><a href="#利用锁" class="headerlink" title="利用锁"></a>利用锁</h2><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能。（我们可以采用tryLock方法 + double check来解决这样的问题。）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/1653328288627.png" alt="1653328288627"></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>没有额外的内存消耗</li>
<li>保证一致性</li>
<li>实现简单</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>线程需要等待，性能受影响</li>
<li>可能有死锁风险</li>
</ul>
<blockquote>
<p>redisTemplate实现互斥锁：（没有考虑原子性，原子性可以使用lua脚本保证）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ID_PREFIX = UUID.randomUUID().toString(<span class="keyword">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeoutSec)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取线程标示</span></span><br><span class="line">String threadId = ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">Boolean success = stringRedisTemplate.opsForValue()</span><br><span class="line">             .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 获取线程标示</span></span><br><span class="line"> String threadId = ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line"> <span class="comment">// 获取锁中的标示</span></span><br><span class="line"> String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line"> <span class="comment">// 判断标示是否一致</span></span><br><span class="line"> <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">     <span class="comment">// 释放锁</span></span><br><span class="line">     stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h2><p>逻辑过期方案可以根本上解决缓存击穿的问题（key到期），因为可以不设置过期时间，并且可以在逻辑过期后删除缓存，不会一直占用内存。</p>
<p><strong>大体流程：</strong>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220802094549939.png" alt="image-20220802094549939"></p>
<blockquote>
<p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p>
</blockquote>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>线程无需等待，性能比较好</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>不保证一致性</li>
<li>有额外内存消耗</li>
<li>实现复杂</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis缓存雪崩</title>
    <url>/2022/10/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/</url>
    <content><![CDATA[<h1 id="Redis缓存雪崩"><a href="#Redis缓存雪崩" class="headerlink" title="Redis缓存雪崩"></a>Redis缓存雪崩</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p>缓存key失效的解决方案：</p>
<ul>
<li>给不同的Key的TTL添加随机值</li>
</ul>
<p>Redis服务宕机的解决方案：</p>
<ul>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/1653327884526.png" alt="1653327884526"></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis集群</title>
    <url>/2022/10/17/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><p>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N即<strong>切片集群</strong>，也叫分片集群。解决了大型单实例持久化阻塞主线程的问题，也方便了扩容问题。</p>
<p>并且Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230419144924701.png" alt="image-20230419144924701"></p>
<h2 id="数据切片和实例的对应分布关系"><a href="#数据切片和实例的对应分布关系" class="headerlink" title="数据切片和实例的对应分布关系"></a>数据切片和实例的对应分布关系</h2><p>切片集群是一种保存大量数据的通用机制，这个机制可以有不同的实现方案。一般使用的是Redis Cluster，这里也讲的是Redis Cluster。</p>
<p>Redis Cluster 方案采用<strong>哈希槽</strong>（Hash Slot，接下来我会直接称之为 Slot），来处理数据和实例之间的映射关系。</p>
<p>在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。</p>
<p><strong>映射过程：</strong></p>
<ul>
<li>根据键值对的 key，按照CRC16 算法计算一个 16 bit 的值</li>
<li>再用这个 16bit 值对 16384 取模，得到的模数代表一个相应编号的哈希槽。</li>
</ul>
<p><strong>哈希槽分摊：</strong></p>
<ul>
<li>可以使用<code>cluster create</code>命令创建集群，自动平均分配</li>
<li>也可以使用<code>cluster meet</code>命令手动建立实例间的连接，形成集群，再使用 <code>cluster addslots </code>命令，指定每个实例上的哈希槽个数。(<strong>在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作</strong>。)</li>
</ul>
<blockquote>
<h3 id="集群的方案选择"><a href="#集群的方案选择" class="headerlink" title="集群的方案选择"></a>集群的方案选择</h3><p>集群方案目前主要有两种：</p>
<ul>
<li>Codis</li>
<li>Redis Cluster</li>
</ul>
<p><strong>两者区别：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230405143841170.png" alt="image-20230405143841170"></p>
<p><strong>选择建议：</strong></p>
<ol>
<li>从稳定性和成熟度来看，Codis 应用得比较早，在业界已经有了成熟的生产部署。虽然 Codis 引入了 proxy 和 Zookeeper，增加了集群复杂度，但是，proxy 的无状态设计和 Zookeeper 自身的稳定性，也给 Codis 的稳定使用提供了保证。而 Redis Cluster 的推出时间晚于 Codis，相对来说，成熟度要弱于 Codis，如果你想选择一个成熟稳定的方案，Codis 更加合适些。</li>
<li>从业务应用客户端兼容性来看，连接单实例的客户端可以直接连接 codis proxy，而原本连接单实例的客户端要想连接 Redis Cluster 的话，就需要开发新功能。所以，如果你的业务应用中大量使用了单实例的客户端，而现在想应用切片集群的话，建议你选择 Codis，这样可以避免修改业务应用中的客户端。</li>
<li>从使用 Redis 新命令和新特性来看，Codis server 是基于开源的 Redis 3.2.8 开发的，所以，Codis 并不支持 Redis 后续的开源版本中的新增命令和数据类型。另外，Codis 并没有实现开源 Redis 版本的所有命令，比如 BITOP、BLPOP、BRPOP，以及和与事务相关的 MUTLI、EXEC 等命令。Codis 官网上列出了不被支持的命令列表，你在使用时记得去核查一下。所以，如果你想使用开源 Redis 版本的新特性，Redis Cluster 是一个合适的选择。</li>
<li>从数据迁移性能维度来看，Codis 能支持异步迁移，异步迁移对集群处理正常请求的性能影响要比使用同步迁移的小。所以，如果你在应用集群时，数据迁移比较频繁的话，Codis 是个更合适的选择。</li>
</ol>
</blockquote>
<h2 id="客户端如何定位数据？"><a href="#客户端如何定位数据？" class="headerlink" title="客户端如何定位数据？"></a>客户端如何定位数据？</h2><p>在定位键值对数据时，它所处的哈希槽是可以通过计算得到的，但是还需要指定哈希槽分布在哪个实例上。</p>
<ul>
<li><p>Redis 实例会<strong>把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散</strong>。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。</p>
</li>
<li><p>客户端收到哈希槽信息后，会把<strong>哈希槽信息缓存在本地</strong>。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。</p>
<blockquote>
<p><strong>当对应关系已经发生变化：</strong></p>
<p>Redis Cluster 方案提供了一种<strong>重定向机制</strong>，如果实例上没有该数据，会用<code>MOVED命令</code>带着新实例地址响应给客户端，收到后<strong>更新本地缓存再重新请求</strong>。</p>
<p><strong>当Slot正在进行迁移：</strong></p>
<p>如果实例上没有该数据，会用<code>ASK命令</code>来返回新实例地址，收到后<strong>不会更新本地缓存</strong>，并发送<code>ASKING命令</code>再发送操作命令。</p>
</blockquote>
</li>
</ul>
<h2 id="无中心化集群的搭建"><a href="#无中心化集群的搭建" class="headerlink" title="无中心化集群的搭建"></a>无中心化集群的搭建</h2><ol>
<li><p>进行每个服务器的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include &#x2F;home&#x2F;bigdata&#x2F;redis.conf  #导入基础配置文件</span><br><span class="line">port 6379 #设置端口</span><br><span class="line">pidfile &quot;&#x2F;var&#x2F;run&#x2F;redis_6379.pid&quot; #设置redis的进程文件</span><br><span class="line">dbfilename &quot;dump6379.rdb&quot;  #设置数据备份文件</span><br><span class="line">dir &quot;&#x2F;home&#x2F;bigdata&#x2F;redis_cluster&quot; #设置数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录</span><br><span class="line">logfile &quot;&#x2F;home&#x2F;bigdata&#x2F;redis_cluster&#x2F;redis_err_6379.log&quot; #设置日志文件地址</span><br><span class="line">cluster-enabled yes #打开集群模式</span><br><span class="line">cluster-config-file nodes-6379.conf #设定节点配置文件名不需要我们创建，由redis自己维护</span><br><span class="line"></span><br><span class="line">cluster-node-timeout 15000 #设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</span><br></pre></td></tr></table></figure></li>
<li><p>启动各个redis服务</p>
</li>
<li><p>合成集群：<code>redis-cli --cluster create --cluster-replicas 1 所有主机ip:端口</code>（每一台主机后跟几个从机,这里写1是一主一从 –replicas 1 采用最简单的方式配置集群，一台主机，一台从机；一般前几个是主后几个是从）</p>
</li>
<li><p>以集群方式连接：<code>redis-cli -c -p 6379 -a 123321</code></p>
</li>
<li><p>进入客户端后可以通过<code>cluster nodes</code>命令查看集群状态</p>
</li>
</ol>
<blockquote>
<p>查询集群中某个插槽的值：<code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code></p>
</blockquote>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>redis缓存穿透</title>
    <url>/2022/10/04/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p>
<p>数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li><strong>缓存空对象</strong><ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
</li>
<li><strong>布隆过滤</strong><ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h3><p>这种解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到数据库了</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220728155727373.png" alt="image-20220728155727373" style="zoom:50%;" />        

<h3 id="布隆过滤"><a href="#布隆过滤" class="headerlink" title="布隆过滤"></a>布隆过滤</h3><p>这种解决方案思路大致是在客户端与Redis中间再加了一层布隆过滤器。</p>
<p>如果布隆过滤器判断存在则放行，否则直接返回，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中。</p>
<p>（布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，利用哈希思想去判断当前这个要查询的这个数据是否存在）</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220728161844570.png" alt="image-20220728161844570" style="zoom:50%;" />

<blockquote>
<p>其余的解决方案：</p>
<ul>
<li>增强id的复杂性，避免被猜测id规律</li>
<li>做好数据的基础格式校验</li>
<li>加强用户权限校验</li>
<li>做好热点参数的限流</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>redis基础</title>
    <url>/2022/10/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/redis%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><ul>
<li><p>简介：Redis是一个开源的key-value存储系统。</p>
</li>
<li><p>特点：</p>
<ul>
<li>数据都在内存中，支持持久化，主要用作备份恢复</li>
<li>除了支持简单的key-value模式，还支持多种数据结构的存储，比如 list、set、hash、zset等。</li>
<li>一般是作为缓存数据库辅助持久化的数据库</li>
</ul>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>去<a href="http://redis.io/">官方</a>下载安装包</p>
</li>
<li><p>上传安装包到/opt下</p>
</li>
<li><p>在linux下安装gcc环境：<code>yum install -y gcc tcl</code></p>
</li>
<li><p>解压 tar -zxvf redis-6.2.1.tar.gz</p>
</li>
<li><p>进入redis目录执行make命令</p>
</li>
<li><p>执行make install 安装</p>
</li>
<li><p>安装目录在/usr/local/bin下</p>
</li>
<li><p>在安装包的目录下备份配置文件<code>cp redis.conf redis.conf.bck</code></p>
</li>
<li><p>修改配置文件（最好不要直接修改原文件，复制到/etc下运行时用复制后的）<code>vim redis.conf</code></p>
<p>修改如下配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行logs</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志.持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">.</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">512mb</span></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>执行redis-server redis.conf 进行后台运行（redis-server是直接前台运行）</p>
</li>
<li><p>设置开机自启动</p>
<ol>
<li><p>新建一个系统服务文件：<code>vi/etc/systemd/system/redis.service</code></p>
</li>
<li><p>写入内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;redis-server</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;forking</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;redis-server &#x2F;opt&#x2F;redis-6.2.1&#x2F;redis.conf</span><br><span class="line">PrivateTmp&#x3D;true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure></li>
<li><p>重载系统服务：<code>systemctl daemon-reload</code></p>
</li>
<li><p>可以使用的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动</span><br><span class="line">systemctl start redis</span><br><span class="line"># 停止</span><br><span class="line">systemctl stop redis</span><br><span class="line"># 重启</span><br><span class="line">systemctl restart redis</span><br><span class="line"># 查看状态</span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure></li>
<li><p>让redis开机自启动：<code>systemctl enable redis</code></p>
</li>
</ol>
</li>
</ol>
<h3 id="连接redis"><a href="#连接redis" class="headerlink" title="连接redis"></a>连接redis</h3><h5 id="使用redis-cli"><a href="#使用redis-cli" class="headerlink" title="使用redis-cli"></a>使用redis-cli</h5><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure>
<p>其中常见的options有：</p>
<ul>
<li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li>
<li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li>
<li><code>-a 123321</code>：指定redis的访问密码 </li>
</ul>
<p>其中的commonds就是Redis的操作命令，例如：</p>
<ul>
<li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li>
</ul>
<h5 id="使用图形化界面"><a href="#使用图形化界面" class="headerlink" title="使用图形化界面"></a>使用图形化界面</h5><p>这个仓库可以找到安装包：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p>
<p>下载后一直next即可</p>
<h2 id="Key键的通用操作"><a href="#Key键的通用操作" class="headerlink" title="Key键的通用操作"></a>Key键的通用操作</h2><ul>
<li>keys *查看当前库所有key  (匹配：keys *1，不建议在生产环境设备上使用)</li>
<li>exists key判断某个key是否存在</li>
<li>type key 查看你的key是什么类型</li>
<li>del key    删除指定的key数据</li>
<li>unlink key  根据value选择非阻塞删除（仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。）</li>
<li>expire key 10  10秒钟：为给定的key设置过期时间</li>
<li>ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期</li>
<li>select命令切换数据库</li>
<li>dbsize查看当前数据库的key的数量</li>
<li>flushdb清空当前库</li>
<li>flushall通杀全部库</li>
</ul>
<h4 id="key的结构"><a href="#key的结构" class="headerlink" title="key的结构"></a>key的结构</h4><p>很多时候为了避免key重复，可以将key设计成 <code>项目名:业务名:类型:id</code>的形式</p>
<p>如：</p>
<table>
<thead>
<tr>
<th align="center">KEY</th>
<th align="center">VALUE</th>
</tr>
</thead>
<tbody><tr>
<td align="center">project:user:1</td>
<td align="center">{“id” :1，”name” : “Jack” ，”age”: 21}</td>
</tr>
<tr>
<td align="center">project:product:1</td>
<td align="center">{ “id” :1，”name” :”小米11”，”price”: 4999}</td>
</tr>
</tbody></table>
<h2 id="Redis数据库键空间"><a href="#Redis数据库键空间" class="headerlink" title="Redis数据库键空间"></a>Redis数据库键空间</h2><p><strong>Redis是一个键值对( key-value pair)数据库服务器</strong>，服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将<strong>这个字典称为键空间( key space )</strong> 。</p>
<p>为了实现从键到值的快速访问，Redis 键空间使用了一个哈希表来保存所有键值对（称为全局哈希表）：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230414162642297.png" alt="image-20230414162642297"></p>
<h3 id="哈希冲突问题："><a href="#哈希冲突问题：" class="headerlink" title="哈希冲突问题："></a>哈希冲突问题：</h3><p>当你往哈希表中写入更多数据时，哈希冲突是不可避免的问题。这里的哈希冲突，也就是指，两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。</p>
<p>Redis为了解决hash冲突问题，Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。</p>
<p>Redis 开始执行 rehash看，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2，<strong>这个过程分为三步：</strong></p>
<ol>
<li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li>
<li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；</li>
<li>释放哈希表 1 的空间。</li>
</ol>
<h3 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h3><p>由于如果在拷贝步骤涉及大量数据，会造成Redis线程阻塞。</p>
<p>简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。</p>
<blockquote>
<p>这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。</p>
</blockquote>
<h2 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h2><h3 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h3><h4 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h4><ul>
<li><p>set  <key><value>添加键值对</p>
</li>
<li><p>get  <key>查询对应键值</p>
</li>
<li><p>append <key><value>将给定的<value> 追加到原值的末尾</p>
</li>
<li><p>strlen <key>获得值的长度</p>
</li>
<li><p>setnx <key><value>只有在 key 不存在时  设置 key 的值</p>
</li>
<li><p>incr <key>将 key 中储存的数字值增1只能对数字值操作，如果为空，新增值为1</p>
</li>
<li><p>decr <key>将 key 中储存的数字值减1只能对数字值操作，如果为空，新增值为-1</p>
</li>
<li><p>incrby / decrby <key>&lt;步长&gt;：将 key 中储存的数字值增减。自定义步长。</p>
</li>
<li><p>incrbyfloat/decrbyfloat <key> 步长：将 key 中储存的浮点数增减。自定义步长。</p>
</li>
<li><p>mset <key1><value1><key2><value2> ….. 同时设置一个或多个 key-value对 </p>
</li>
<li><p>mget <key1><key2><key3> …..同时获取一个或多个 value </p>
</li>
<li><p>msetnx <key1><value1><key2><value2> …同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</p>
</li>
<li><p>getrange <key>&lt;起始位置&gt;&lt;结束位置&gt;</p>
<p>获得值的范围，类似java中的substring，<strong>前包，后包</strong></p>
</li>
<li><p>setrange <key>&lt;起始位置&gt;<value>用 <value> 覆写<key>所储存的字符串值，从&lt;起始位置&gt;开始(<strong>索引从0开始</strong>)。</p>
</li>
<li><p>setex <key>&lt;**过期时间**&gt;<value>设置键值的同时，设置过期时间，单位秒。</p>
</li>
<li><p>getset <key><value>以新换旧，设置了新值同时获得旧值。</p>
</li>
</ul>
<h4 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h4><p>String的数据结构为**简单动态字符串(Simple Dynamic String,缩写SDS)**。</p>
<p><strong>简单动态字符串（ simple dynamic string，SDS)：</strong></p>
<ul>
<li><p>SDS的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">	<span class="comment">//记录buf数组中已使用字节的数量等于sDs所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">	<span class="comment">//记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">	<span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>特点：</p>
<ul>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出，能够进行动态扩展</li>
<li>空间预分配（（当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。）、惰性空间释放</li>
<li>二进制安全，因为使用字节数组保存数据</li>
</ul>
</li>
</ul>
<h3 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<h4 id="常见命令-1"><a href="#常见命令-1" class="headerlink" title="常见命令"></a>常见命令</h4><ul>
<li><p>lpush/rpush <key><value1><value2><value3> …. 从左边/右边插入一个或多个值。</p>
</li>
<li><p>lpop/rpop <key>从左边/右边吐出一个值。值在键在，值光键亡。</p>
</li>
<li><p>rpoplpush <key1><key2>从<key1>列表右边吐出一个值，插到<key2>列表左边。</p>
</li>
<li><p>lrange <key><start><stop>按照索引下标获得元素(从左到右)</p>
</li>
<li><p>lrange mylist 0 -1  0左边第一个，-1右边第一个，（0-1表示获取所有）</p>
</li>
<li><p>lindex <key><index>按照索引下标获得元素(从左到右)</p>
</li>
<li><p>llen <key>获得列表长度 </p>
</li>
<li><p>linsert <key> before <value><newvalue>在<value>的后面插入<newvalue>插入值</p>
</li>
<li><p>lrem <key><n><value>从左边删除n个value(从左到右)</p>
</li>
<li><p>lset<key><index><value>将列表key下标为index的值替换成value</p>
</li>
</ul>
<h4 id="底层结构-1"><a href="#底层结构-1" class="headerlink" title="底层结构"></a>底层结构</h4><p>其底层有ZipList和QuickList两种存储方式。</p>
<ul>
<li>首先在列表元素较少的情况下会使用一块连续的内存存储，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，这个结构是ZipList，也即是压缩列表。</li>
<li>当数据量比较多的时候才会改成QuickList双向链表。既满足了快速的插入删除性能，又不会出现太大的空间冗余。</li>
</ul>
<p><strong>ZipList压缩列表：</strong></p>
<p>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型( sequential )数据结构。一个压缩列表可以包含任意多个节点（ entry )，每个节点可以保存一个字节数组或者一个整数值。</p>
<ul>
<li><p>结构：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230415163358752.png" alt="image-20230415163358752"></p>
<ul>
<li><p> zlbytes：表示列表总字节数</p>
</li>
<li><p>zltail：列表尾的偏移量</p>
</li>
<li><p>zllen：列表中的 entry 个数</p>
</li>
<li><p>entry：</p>
<ul>
<li><p>previous_entry_length：记录了压缩列表中前一个节点的长度</p>
</li>
<li><p>encoding：记录了节点的content属性所保存数据的类型以及长度</p>
</li>
<li><p>content：数据内容</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230415163712815.png" alt="image-20230415163712815" style="zoom:50%;" />
</li>
</ul>
</li>
<li><p>zlend：表示列表结束</p>
</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>要查找定位第一个元素和最后一个元素O(1)，查找其他元素O(N)。</li>
<li>节约空间。</li>
<li>有可能会因为entry内容长度的问题，引发一系列的<strong>连锁更新</strong>，但很少发生。</li>
</ul>
</li>
</ul>
<p><strong>QuickList双向链表</strong></p>
<p>QuickList数据结构是Redis在3.2版本引入的一种新得数据结构，他是一个双端链表，链表中的每个节点都是一个 ZipList</p>
<ul>
<li><p>结构：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230415165300844.png" alt="image-20230415165300844"></p>
<ul>
<li><p>node结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typedf <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//前一个节点</span></span><br><span class="line">    quicklistNode* prev;</span><br><span class="line">    <span class="comment">//后一个节点</span></span><br><span class="line">    quicklistNode* next;</span><br><span class="line">    <span class="comment">//压缩列表</span></span><br><span class="line">    ziplist* zl;	</span><br><span class="line">    <span class="comment">//ziplist大小</span></span><br><span class="line">    int32 size;		</span><br><span class="line">    <span class="comment">//ziplist 中元素数量</span></span><br><span class="line">    int16 count;</span><br><span class="line">    <span class="comment">//编码形式 存储 ziplist 还是进行LZF算法压缩储存的zipList</span></span><br><span class="line">    int2 encoding;			</span><br><span class="line">    ...</span><br><span class="line">&#125;quickListNode</span><br></pre></td></tr></table></figure></li>
<li><p>整个链表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typedf <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span>&#123;</span></span><br><span class="line">    <span class="comment">//指向头结点</span></span><br><span class="line">    quicklistNode* head;</span><br><span class="line">    <span class="comment">//指向尾节点</span></span><br><span class="line">    quicklistNode* tail;</span><br><span class="line">    <span class="comment">//元素总数</span></span><br><span class="line">    <span class="keyword">long</span> count;</span><br><span class="line">    <span class="comment">//quicklistNode节点的个数</span></span><br><span class="line">    <span class="keyword">int</span> nodes;	</span><br><span class="line">    <span class="comment">//压缩算法深度</span></span><br><span class="line">    <span class="keyword">int</span> compressDepth;		</span><br><span class="line">    ...</span><br><span class="line">&#125;quickList</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>比传统链表更省空间，所以能存储大量数据。</li>
<li>还能对数据进行压缩</li>
</ul>
</li>
</ul>
<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的**复杂度都是O(1)**。并且可以自动的去重。</p>
<h4 id="常见命令-2"><a href="#常见命令-2" class="headerlink" title="常见命令"></a>常见命令</h4><ul>
<li><p>sadd <key><value1><value2> ….. 将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</p>
</li>
<li><p>smembers <key>取出该集合的所有值。</p>
</li>
<li><p>sismember <key><value>判断集合<key>是否为含有该<value>值，有1，没有0</p>
</li>
<li><p>scard<key>返回该集合的元素个数。</p>
</li>
<li><p>srem <key><value1><value2> …. 删除集合中的某个元素。</p>
</li>
<li><p>spop <key>随机从该集合中吐出一个值。</p>
</li>
<li><p>srandmember <key><n>随机从该集合中取出n个值。不会从集合中删除 。</p>
</li>
<li><p>smove <source><destination><value>把集合中一个值从一个集合移动到另一个集合</p>
</li>
<li><p>sinter <key1><key2>返回两个集合的交集元素。</p>
</li>
<li><p>sunion <key1><key2>返回两个集合的并集元素。</p>
</li>
<li><p>sdiff <key1><key2>返回两个集合的<strong>差集</strong>元素(key1中的，不包含key2中的)</p>
</li>
</ul>
<h4 id="底层结构-2"><a href="#底层结构-2" class="headerlink" title="底层结构"></a>底层结构</h4><p>Set数据结构是dict字典（用哈希表实现的）和整数数组；</p>
<ul>
<li>当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</li>
<li>其余情况就使用字典。</li>
</ul>
<p><strong>整数数组：</strong></p>
<p>整数集合( intset）是集合键的底层实现之一。</p>
<ul>
<li><p>结构：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230415170258415.png" alt="image-20230415170258415" style="zoom:67%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组，里面按照从小到大的顺序排列，不会有重复项</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure></li>
<li><p>特点：</p>
<ul>
<li>只存整数，保证了数据不重复。</li>
<li>并且会根据数据类型，进行升级降级。</li>
</ul>
</li>
</ul>
<p><strong>字典：</strong></p>
<p>字典，又称为符号表( symbol table)、关联数组( associative array）或映射（map)，是一种用于保存键值对（ key-value pair )的抽象数据结构。</p>
<ul>
<li><p>结构：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230414204548933.png" alt="image-20230414204548933"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry**table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值，总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"><span class="comment">// 一个键值对Entry</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">	<span class="comment">//值</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="keyword">void</span> *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125; v;</span><br><span class="line">	<span class="comment">//指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure></li>
<li><p>特点：</p>
<ul>
<li>快速查找O(1)的复杂度。</li>
<li>不支持范围查找，只能全部遍历很慢。</li>
</ul>
</li>
</ul>
<h3 id="Hash哈希"><a href="#Hash哈希" class="headerlink" title="Hash哈希"></a>Hash哈希</h3><p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。类似Java里面的Map&lt;String,Object&gt;</p>
<h4 id="常见命令-3"><a href="#常见命令-3" class="headerlink" title="常见命令"></a>常见命令</h4><ul>
<li>hset <key><field><value>给<key>集合中的 <field>键赋值<value></li>
<li>hget <key1><field>从<key1>集合<field>取出 value </li>
<li>hmset <key1><field1><value1><field2><value2>… 批量设置hash的值</li>
<li>hexists<key1><field>查看哈希表 key 中，给定域 field 是否存在。 </li>
<li>hgetall <key> ：列出该hash集合的所有field和value</li>
<li>hkeys <key>列出该hash集合的所有field</li>
<li>hvals <key>列出该hash集合的所有value</li>
<li>hincrby <key><field><increment>为哈希表 key 中的域 field 的值加上增量 1  -1</li>
<li>hsetnx <key><field><value>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .</li>
</ul>
<h4 id="底层结构-3"><a href="#底层结构-3" class="headerlink" title="底层结构"></a>底层结构</h4><p>Hash类型对应的数据结构是两种：Ziplist（压缩列表），Hashtable（哈希表）。当field-value长度较短且个数较少时，使用Ziplist，否则使用Hashtable。</p>
<h3 id="Zset集合"><a href="#Zset集合" class="headerlink" title="Zset集合"></a>Zset集合</h3><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p>
<p>不同之处是有序集合的每个成员都关联了一个<strong>评分（score）</strong>,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p>
<h4 id="常见命令-4"><a href="#常见命令-4" class="headerlink" title="常见命令"></a>常见命令</h4><ul>
<li><p>zadd <key><score1><value1><score2><value2>…将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</p>
</li>
<li><p>zrange <key><start><stop> [WITHSCORES]返回有序集 key 中，下标在<start><stop>之间的元素带WITHSCORES，可以让分数一起和值返回到结果集。</p>
</li>
<li><p>zrangebyscore key min max [withscores] [limit offset count]返回有序集 key 中，所有 score 值介于 min 和max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 </p>
</li>
<li><p>zrevrangebyscore key maxmin [withscores] [limit offset count]        同上，改为从大到小排列。 </p>
</li>
<li><p>zincrby <key><increment><value>   为元素的score加上增量</p>
</li>
<li><p>zrem <key><value>删除该集合下，指定值的元素</p>
</li>
<li><p>zcount <key><min><max>统计该集合，分数区间内的元素个数 </p>
</li>
<li><p>zrank <key><value>返回该值在集合中的排名，从0开始。</p>
</li>
</ul>
<h4 id="底层结构-4"><a href="#底层结构-4" class="headerlink" title="底层结构"></a>底层结构</h4><p>zset底层使用了两个数据结构：</p>
<ul>
<li><p><strong>如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员( member）是比较长的字符串时</strong>，Redis就会使用<strong>跳跃表+哈希表</strong>来作为有序集合键的底层实现，这样能保证各方面的性能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span> </span><br><span class="line">	dict *dict; 	<span class="comment">// 字典，保存了从成员到分值的映射关系； </span></span><br><span class="line">	zskiplist *zsl; <span class="comment">// 跳跃表，按分值由小到大保存所有集合元素； </span></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>
<ul>
<li>跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</li>
<li>哈希表的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</li>
</ul>
</li>
<li><p>其余使用ziplist压缩列表：每个 value/score 元素紧凑排列存在entry中，节省内存（<strong>会根据score进行排序，类似于数组排序：先遍历找位置，再后移节点腾出空间</strong>，所以只适用于小规模场景）</p>
</li>
</ul>
<p><strong>跳跃表：</strong></p>
<p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<ul>
<li><p>结构：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230415171501532.png" alt="image-20230415171501532"></p>
<ul>
<li>header：指向跳跃表的表头节点。</li>
<li>tail：指向跳跃表的表尾节点。</li>
<li>level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内)。</li>
<li>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内)。</li>
</ul>
<blockquote>
<p>zskiplistNode跳跃表的节点：</p>
<ul>
<li>层指针(level)：每个层都带有两个属性：<strong>前进指针和跨度</strong>。<ul>
<li>前进指针用于访问位于表尾方向的其他节点。</li>
<li>跨度则记录了前进指针所指向节点和当前节点的距离。</li>
</ul>
</li>
<li>后退指针(backward)：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li>
<li>分值(score)：在跳跃表中，节点按各自所保存的分值从小到大排列。</li>
<li>成员对象(obj)：各个节点中的o1、o2和o3是节点所保存的成员对象。</li>
</ul>
</blockquote>
</li>
<li><p>特点：</p>
<ul>
<li>由于维护了多级索引，查找时间平均为O(logN)。</li>
<li>可以通过顺序性操作来批量处理节点。</li>
</ul>
</li>
</ul>
<blockquote>
<p>跳跃表的排序是通过多层链表结构和随机跳跃算法来实现的。<strong>它不需要像平衡树那样保持完美平衡</strong>，因此在插入、删除和查找元素时可以获得更高的性能。（当插入一个新节点时，Redis 会从最高层链表开始，根据一个随机算法，以一定概率向下跳跃到下一层链表继续查找。这个随机算法的概率分布是一个指数分布，即跳跃到下一层链表的概率会随着层数的增加而逐渐减小。这样就可以在保证数据有序的前提下，尽可能地减少查找、插入和删除元素的时间复杂度。）</p>
</blockquote>
<h2 id="Redis的发布和订阅"><a href="#Redis的发布和订阅" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h2><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。并且可以根据频道来划分（支持任意数量的频道）</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol>
<li><p>客户端订阅频道进行监听</p>
<p><code>SUBSCRIBE channel1</code></p>
</li>
<li><p>发布者发布消息到指定频道</p>
<p><code>publish channel1 hello</code></p>
</li>
<li><p>客户端自动收到发布的消息</p>
</li>
</ol>
<h2 id="Redis6新数据类型"><a href="#Redis6新数据类型" class="headerlink" title="Redis6新数据类型"></a>Redis6新数据类型</h2><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p>（1）  Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</p>
<p>（2）  Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</p>
<h4 id="常见命令-5"><a href="#常见命令-5" class="headerlink" title="常见命令"></a>常见命令</h4><ul>
<li><p>setbit<key><offset><value>设置Bitmaps中某个偏移量的值（0或1）*offset:偏移量从0开始</p>
</li>
<li><p>getbit<key><offset>获取Bitmaps中某个偏移量的值</p>
</li>
<li><p>bitcount<key>[start end] 统计字符串从start字节到end字节比特值为1的数量</p>
</li>
<li><p>bitop and(or/not/xor) <destkey> [key…] bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。</p>
</li>
</ul>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<h4 id="常见命令-6"><a href="#常见命令-6" class="headerlink" title="常见命令"></a>常见命令</h4><ul>
<li><p>pfadd <key>&lt; element&gt; [element …]  添加指定元素到 HyperLogLog 中</p>
</li>
<li><p>pfcount<key> [key …] 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可</p>
</li>
<li><p>pfmerge<destkey><sourcekey> [sourcekey …] 将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</p>
</li>
</ul>
<h3 id="Geospatia"><a href="#Geospatia" class="headerlink" title="Geospatia"></a>Geospatia</h3><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p>
<h4 id="常见命令-7"><a href="#常见命令-7" class="headerlink" title="常见命令"></a>常见命令</h4><ul>
<li>geoadd<key>&lt; longitude&gt;<latitude><member> [longitude latitude member…]  添加地理位置（经度，纬度，名称）</li>
<li>geopos <key><member> [member…] 获得指定地区的坐标值</li>
<li>geodist<key><member1><member2> [m|km|ft|mi ] 获取两个位置之间的直线距离</li>
<li>georadius<key>&lt; longitude&gt;<latitude>radius m|km|ft|mi  以给定的经纬度为中心，找出某一半径内的元素</li>
</ul>
<blockquote>
<p>更多命令见<a href="http://redisdoc.com/">Redis命令参考</a></p>
</blockquote>
<h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><h3 id="连接步骤"><a href="#连接步骤" class="headerlink" title="连接步骤"></a>连接步骤</h3><ol>
<li><p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意需要将redis.conf中的protected-mode配置调成no（设置了密码不用）、以及bind ip的配置给注释掉</p>
</li>
<li><p>并且关闭linux防火墙：<strong>systemctl stop firewalld.service</strong></p>
</li>
<li><p>创建jedis客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.227.130&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//设置密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">//选择库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>进行操作如：<code>jedis.set(key,value)</code>跟redis命令一致</p>
</li>
</ol>
<h3 id="相关基本操作"><a href="#相关基本操作" class="headerlink" title="相关基本操作"></a>相关基本操作</h3><p>大多与redis原本操作一致</p>
<ul>
<li><p>Key通用的操作</p>
<ul>
<li>获取获取key值：jedis.<strong>keys</strong>(“*”)</li>
<li>判断是否存在该key：jedis.<strong>exists</strong>(“k1”)</li>
<li>判断超时时间：jedis.<strong>ttl</strong>(“k1”)</li>
<li>获取key的值：jedis.<strong>get</strong>(“k1”)</li>
</ul>
</li>
<li><p>String类型的操作</p>
<ul>
<li>设置值：jedis.<strong>set</strong>(“k1”, “v1”)</li>
<li>多次设置值：jedis.<strong>mset</strong>(“str1”,”v1”,”str2”,”v2”,”str3”,”v3”)</li>
<li>获取多个值：jedis.<strong>mget</strong>(“str1”,”str2”,”str3”)</li>
</ul>
</li>
<li><p>List类型的操作</p>
<ul>
<li>插入jedis.<strong>lpush</strong>(“k1”,”22”,”333”);</li>
<li>获取所有值：jedis.<strong>lrange</strong>(“mylist”,0,-1);</li>
</ul>
</li>
<li><p>Set类型的操作</p>
<ul>
<li>插入值：jedis.sadd(“orders”, “order01”);</li>
<li>获取值：jedis.<strong>smembers</strong>(“orders”);</li>
<li>删除值：jedis.<strong>srem</strong>(“orders”, “order02”);</li>
</ul>
</li>
<li><p>Hash类型的操作</p>
<ul>
<li>插入值：jedis.<strong>hset</strong>(“hash1”,”userName”,”lisi”);</li>
<li>获取值：jedis.<strong>hget</strong>(“hash1”,”userName”);</li>
<li>批量插入：jedis.<strong>hmset</strong>(“hash2”,map);</li>
<li>批量获取：jedis.<strong>hmget</strong>(“hash2”, “telphone”,”email”);</li>
</ul>
</li>
<li><p>Zset类型的操作</p>
<ul>
<li>插入值：jedis.<strong>zadd</strong>(“zset01”, 100d, “z3”);</li>
<li>获取值：jedis.<strong>zrange</strong>(“zset01”, 0, -1);</li>
</ul>
</li>
</ul>
<h3 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h3><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此使用Jedis连接池代替Jedis的直连方式是比较理想的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisConnectionFacotry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//配置连接池</span></span><br><span class="line">        JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//创建连接池对象</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(poolConfig,</span><br><span class="line">                <span class="string">&quot;192.168.227.130&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;1313&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Springboot集成redis"><a href="#Springboot集成redis" class="headerlink" title="Springboot集成redis"></a>Springboot集成redis</h2><p>SpringBoot是使用的SpringDataRedis来整合的redis（SpringData是Spring中数据操作的模块，包含对各种数据库的集成）</p>
<ul>
<li>提供了RedisTemplate工具类，其中封装了各种对Redis的操作</li>
</ul>
<ul>
<li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li>
<li>提供了RedisTemplate统一API来操作Redis</li>
<li>支持Redis的发布订阅模型</li>
<li>支持Redis哨兵和Redis集群</li>
<li>支持基于Lettuce的响应式编程</li>
<li>支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化</li>
<li>支持基于Redis的JDKCollection实现</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul>
<li><p>导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在配置文件中配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">redis</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">database</span>: <span class="string">0  #Redis数据库索引（默认为0）</span></span><br><span class="line">    <span class="attr">host</span>: <span class="string">192.168.227.130  #Redis服务器地址</span></span><br><span class="line">    <span class="attr">lettuce</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">pool</span>:<span class="string"></span></span><br><span class="line">        <span class="meta">max-active</span>: <span class="string">20   #连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line">        <span class="meta">max-idle</span>: <span class="string">5   #连接池中的最大空闲连接</span></span><br><span class="line">        <span class="meta">max-wait</span>: <span class="string">-1  #最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line">        <span class="meta">min-idle</span>: <span class="string">0  #连接池中的最小空闲连接</span></span><br><span class="line">    <span class="attr">port</span>: <span class="string">6379  #Redis服务器连接端口</span></span><br><span class="line">    <span class="attr">timeout</span>: <span class="string">1800000 #连接超时时间（毫秒）</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">root123456  #验证密码</span></span><br></pre></td></tr></table></figure></li>
<li><p>自定义RedisTemplate（因为RedisTemplate可以接收任意Object作为值写入Redis，但是默认使用的是JDK序列化这样可读性很差）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220727145828091.png" alt="image-20220727145828091"></p>
<p>方式一：（注意一定要导入json依赖或者web的starter）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        GenericJackson2JsonRedisSerializer jsonRedisSerializer = </span><br><span class="line">            							<span class="keyword">new</span> GenericJackson2JsonRedisSerializer();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JSON 序列化器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisSerializer&lt;Object&gt; <span class="title">RedisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">// JavaTimeModule用于处理LocalDate类型</span></span><br><span class="line">        objectMapper.registerModule(<span class="keyword">new</span> JavaTimeModule());</span><br><span class="line">        <span class="comment">// ALL表示序列化对象中的所有成员（包括getter、setter、field等）；ANY表示序列化所有可见度的成员（包括private）</span></span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">// LaissezFaireSubTypeValidator.instance表示：不做验证，允许序列化所有实例</span></span><br><span class="line">        <span class="comment">// ObjectMapper.DefaultTyping.NON_FINAL表示：除了final声明的值和基本类型外，都会在序列化时添加类名标识（final不应被序列化）</span></span><br><span class="line">        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        serializer.setObjectMapper(objectMapper);</span><br><span class="line">        <span class="keyword">return</span> serializer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>使用redisTemplate</p>
<p>redisTemplate的操作对象</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220726223442480.png" alt="image-20220726223442480"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置值到redis</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        <span class="comment">//从redis获取值</span></span><br><span class="line">        String name = (String)redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用StringRedisTemplate</p>
<p>为了节省内存空间，我们可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。这样必须由我们自己手动的来序列化、反序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    <span class="comment">//使用stringRedisTemplate存入自己转换的json</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:3&quot;</span>,JSON.toJSONString(user));</span><br><span class="line">    <span class="comment">//转换获取出来的json字符串</span></span><br><span class="line">    User user1 = JSON.parseObject(stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:3&quot;</span>),User.class);</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更多RedisTemplate的方法<a href="https://blog.csdn.net/ACE_U_005A/article/details/123158686">参考其他博客</a></p>
</blockquote>
</li>
</ul>
<h3 id="Springboot-的缓存抽象"><a href="#Springboot-的缓存抽象" class="headerlink" title="Springboot 的缓存抽象"></a>Springboot 的缓存抽象</h3><p>Spring从3.1开始定义了org.springframework.cache.Cache，Spring从3.1开始定义了org.springframework.cache.Cache<br>和org.springframework.cache.CacheManager接口来统一不同的缓存技术;并支持使用JCache (JSR-107)注解简化我们开发。</p>
<p>每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过;如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。</p>
<p>使用Spring缓存抽象时我们需要关注以下两点：</p>
<ul>
<li>确定方法需要被缓存以及他们的缓存策略</li>
<li>从缓存中读取之前缓存存储的数据</li>
</ul>
<h4 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h4><ul>
<li>Cache：缓存接口，定义缓存操作。实现有:RedisCache、EhCacheCache、ConcurrentMapCache等</li>
<li>CacheManager：缓存管理器,管理各种缓存(Cache)组件</li>
<li>keyGenerator：缓存数据时key生成策略</li>
<li>serialize：缓存数据时value序列化策略</li>
</ul>
<h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><ul>
<li><p>@EnableCaching：开启基于注解的缓存</p>
</li>
<li><p>@Cacheable：主要针对方法配置，能够根据方法的请求参数对其结果进行缓存</p>
<ul>
<li>属性：</li>
<li>cacheNames/value:指正缓存组件的名字</li>
<li>key:缓存数据使用的key，可以用它来指定。默认是使用方法参数的值（编写SpEL; #id;参数id的值#a#p日#root.args[0]）</li>
<li>keyGenerator: key的生成器;可以自己指定key的生成器的组件id（key/keyGenerator:二选一使用）</li>
<li>cacheManager:指定缓存管理器;或者cacheResolver指定获取解析器</li>
<li>condition:指定符合条件的情况下才缓存</li>
<li>unless:否定缓存：当unless指定的条件为true，方法的返回值就不会被缓存<ul>
<li>可以获取到结果进行判断<code>unless =&quot;#result == nuLL&quot;</code></li>
</ul>
</li>
<li>sync:是否使用异步模式</li>
</ul>
</li>
<li><p>@CachePut：保证方法被调用，又希望结果被缓存。(常用于更新方法)</p>
</li>
<li><p>@CacheEvict：方法被调用后清空缓存。(常用于删除方法)</p>
<ul>
<li>可以配置allEntries = true清空所有缓存</li>
<li>beforeInvocation = false:缓存的清除是否在方法之前执行<br>默认代表缓存清除操作是在方法执行之后执行;如果出现异常缓存就不会清除</li>
<li>beforeInvocation = true:<br>代表清除缓存操作是在方法运行之前执行，无论方法是否出现异常，缓存都清除</li>
</ul>
</li>
</ul>
<h4 id="使用Redis当缓存"><a href="#使用Redis当缓存" class="headerlink" title="使用Redis当缓存"></a>使用Redis当缓存</h4><p>springboot默认使用ConcurrentMapCacheManager以及ConcurrentMapCache</p>
<ol>
<li><p>自定义keyGenerator</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置默认键生成类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">keyGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> myKeyGenerator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义键生成类 [类名_方法名_参数]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">KeyGenerator <span class="title">myKeyGenerator</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (target, method, params) -&gt; target.getClass().getSimpleName() + <span class="string">&quot;_&quot;</span></span><br><span class="line">        + method.getName() + <span class="string">&quot;_&quot;</span></span><br><span class="line">        + StringUtils.arrayToDelimitedString(params, <span class="string">&quot;_&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自定义 CacheManager（由于默认缓存管理器还是用jdk序列化的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">redisCacheManager</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">    RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory);</span><br><span class="line">    RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(RedisSerializer.string())) <span class="comment">// 设置键序列化方式</span></span><br><span class="line">            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jsonSerializer)) <span class="comment">// 设置值序列化方式</span></span><br><span class="line">            .entryTtl(Duration.ofHours(<span class="number">1</span>)) <span class="comment">// 设置缓存有效期</span></span><br><span class="line">            .disableCachingNullValues(); <span class="comment">// 不缓存空值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedisCacheManager(redisCacheWriter, redisCacheConfiguration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整配置类"><a href="#完整配置类" class="headerlink" title="完整配置类"></a>完整配置类</h3></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.interceptor.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheWriter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisSerializer&lt;Object&gt; jsonSerializer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义RedisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        GenericJackson2JsonRedisSerializer jsonRedisSerializer =</span><br><span class="line">                <span class="keyword">new</span> GenericJackson2JsonRedisSerializer();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JSON 序列化器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisSerializer&lt;Object&gt; <span class="title">RedisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">// JavaTimeModule用于处理LocalDate类型</span></span><br><span class="line">        objectMapper.registerModule(<span class="keyword">new</span> JavaTimeModule());</span><br><span class="line">        <span class="comment">// ALL表示序列化对象中的所有成员（包括getter、setter、field等）；ANY表示序列化所有可见度的成员（包括private）</span></span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">// LaissezFaireSubTypeValidator.instance表示：不做验证，允许序列化所有实例</span></span><br><span class="line">        <span class="comment">// ObjectMapper.DefaultTyping.NON_FINAL表示：除了final声明的值和基本类型外，都会在序列化时添加类名标识（final不应被序列化）</span></span><br><span class="line">        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        serializer.setObjectMapper(objectMapper);</span><br><span class="line">        <span class="keyword">return</span> serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置默认键生成类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">keyGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myKeyGenerator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义键生成类 [类名_方法名_参数]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">KeyGenerator <span class="title">myKeyGenerator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (target, method, params) -&gt; target.getClass().getSimpleName() + <span class="string">&quot;_&quot;</span></span><br><span class="line">                + method.getName() + <span class="string">&quot;_&quot;</span></span><br><span class="line">                + StringUtils.arrayToDelimitedString(params, <span class="string">&quot;_&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">redisCacheManager</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory);</span><br><span class="line">        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(RedisSerializer.string())) <span class="comment">// 设置键序列化方式</span></span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jsonSerializer)) <span class="comment">// 设置值序列化方式</span></span><br><span class="line">                .entryTtl(Duration.ofHours(<span class="number">1</span>)) <span class="comment">// 设置缓存有效期</span></span><br><span class="line">                .disableCachingNullValues(); <span class="comment">// 不缓存空值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisCacheManager(redisCacheWriter, redisCacheConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wht.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtil</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    <span class="comment">// =============================common============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">del</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">del</span><span class="params">(List&lt;String&gt; keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.delete(keys);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ============================String=============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存获取</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="keyword">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time,</span><br><span class="line">                        TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递增</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">incr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;递增因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">decr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;递减因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ================================Map=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashGet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hget</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title">hmget</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet 并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map  对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除hash表中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hdel</span><span class="params">(String key, Object... item)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForHash().delete(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hHasKey</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要增加几(大于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hincr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要减少记(小于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hdecr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ============================set=============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">sGet</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sHasKey</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入set缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSet</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将set数据放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time   时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSetAndTime</span><span class="params">(String key, <span class="keyword">long</span> time, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().add(key, values);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取set缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sGetSetSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除值为value的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">setRemove</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ===============================list=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">lGet</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lGetListSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0</span></span><br><span class="line"><span class="comment">     *              时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">lGetIndex</span><span class="params">(String key, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lUpdateIndex</span><span class="params">(String key, <span class="keyword">long</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除N个值为value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lRemove</span> <span class="params">(String key,<span class="keyword">long</span> count, Object value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long remove = redisTemplate.opsForList().remove(key, count,value);</span><br><span class="line">            <span class="keyword">return</span> remove;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="事务和锁机制"><a href="#事务和锁机制" class="headerlink" title="事务和锁机制"></a>事务和锁机制</h2><h3 id="Redis事务特性："><a href="#Redis事务特性：" class="headerlink" title="Redis事务特性："></a>Redis事务特性：</h3><ul>
<li><p>单独的隔离操作 ：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 </p>
</li>
<li><p>没有隔离级别的概念 ：队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</p>
</li>
<li><p>不保证原子性 ：事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 </p>
</li>
</ul>
<h3 id="事务相关命令"><a href="#事务相关命令" class="headerlink" title="事务相关命令"></a>事务相关命令</h3><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220526223634699.png" alt="image-20220526223634699"></p>
<ul>
<li>Multi：从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec</li>
<li>Exec：Redis会将之前的命令队列中的命令依次执行</li>
<li>discard：组队的过程中可以通过discard来放弃组队。</li>
</ul>
<h3 id="事务错误机制"><a href="#事务错误机制" class="headerlink" title="事务错误机制"></a>事务错误机制</h3><ol>
<li>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</li>
</ol>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220526225010816.png" alt="image-20220526225010816"></p>
<ol start="2">
<li>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</li>
</ol>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220526225025802.png" alt="image-20220526225025802"></p>
<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p><strong>悲观锁(Pessimistic Lock)</strong>, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p><strong>乐观锁(Optimistic Lock),</strong> 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种check-and-set机制实现事务的。</p>
<h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><ul>
<li><p>watch key1 [key2]：在执行multi之前执行，可以监视一个(或多个) key ，在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p>
</li>
<li><p>unwatch ：取消 WATCH 命令对所有 key 的监视。如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。</p>
</li>
</ul>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>因为Redis的数据是放在内存中的，持久化就是把内存的数据写到磁盘中去,防止服务宕机了内存数据丢失。</p>
<p>Redis 提供了2个不同形式的持久化方式：</p>
<ul>
<li>RDB（Redis DataBase）</li>
<li>AOF（Append Of File）</li>
</ul>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>在指定的时间间隔内将内存中的数据集快照写入磁盘（具体操作：Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件） </p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>默认情况下，Redis 将数据集的快照保存在磁盘上的一个名为<code>dump.rdb</code>.</p>
<p>如果数据集中至少有 M 次更改，您可以将 Redis 配置为每 N 秒保存一次数据集，或者您可以手动调用<a href="https://redis.io/commands/save"><code>SAVE</code></a>or<a href="https://redis.io/commands/bgsave"><code>BGSAVE</code></a>命令</p>
<p>如：<code>save 60 1000</code>：如果至少更改了 1000 个键，则此配置将使 Redis 每 60 秒自动将数据集转储到磁盘</p>
<p>如：<code>bgsave </code>：命令用于在后台异步保存当前数据库的数据到磁盘</p>
<blockquote>
<p>使用场景：</p>
<ul>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高更适合使用</li>
<li>节省磁盘空间</li>
<li>恢复速度快</li>
</ul>
</blockquote>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li>
<li>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>,但是如果数据庞大时还是比较消耗性能。</li>
<li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>以<strong>日志</strong>的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来（AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量），redis 重启的时候就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>因为AOF默认不开启，需要在redis.conf中配置</p>
<p>设置<code>appendonly yes</code></p>
<p>从现在开始，每次 Redis 接收到更改数据集的命令（例如<code>SET</code>时，它都会将其附加到 AOF。当您重新启动 Redis 时，它将重新播放 AOF 以重建状态。</p>
<blockquote>
<p>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失），所以建议两个都启用，不建议单独使用AOF</p>
</blockquote>
<h5 id="AOF的同步频率"><a href="#AOF的同步频率" class="headerlink" title="AOF的同步频率"></a>AOF的同步频率</h5><ul>
<li><code>appendfsync always</code>：始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好</li>
<li><code>appendfsync everysec</code>：每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</li>
<li><code>appendfsync no</code>：redis不主动进行同步，把同步时机交给操作系统。</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li><p>比起RDB占用更多的磁盘空间。</p>
</li>
<li><p>恢复备份速度要慢。</p>
</li>
<li><p>每次读写都同步的话，有一定的性能压力。</p>
</li>
<li><p>存在个别Bug，造成恢复不能。</p>
</li>
</ul>
<h2 id="IO多线程"><a href="#IO多线程" class="headerlink" title="IO多线程"></a>IO多线程</h2><p>Redis6终于支撑多线程了，告别单线程了吗？</p>
<p>IO多线程其实指<strong>客户端交互部分</strong>的<strong>网络IO</strong>交互处理模块<strong>多线程</strong>，而非<strong>执行命令多线程</strong>。Redis6执行命令依然是单线程。</p>
<h3 id="开启多线程"><a href="#开启多线程" class="headerlink" title="开启多线程"></a>开启多线程</h3><ul>
<li><p>进入配置文件</p>
</li>
<li><p>修改配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#是否开启多线程</span><br><span class="line">io-threads-do-reads  yes </span><br><span class="line">#线程数</span><br><span class="line">io-threads 4</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>如何应对变慢的Redis?</title>
    <url>/2023/08/17/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%8F%98%E6%85%A2%E7%9A%84Redis/</url>
    <content><![CDATA[<h1 id="如何应对变慢的Redis？"><a href="#如何应对变慢的Redis？" class="headerlink" title="如何应对变慢的Redis？"></a>如何应对变慢的Redis？</h1><h2 id="如何判断-Redis-是不是真的变慢了？"><a href="#如何判断-Redis-是不是真的变慢了？" class="headerlink" title="如何判断 Redis 是不是真的变慢了？"></a>如何判断 Redis 是不是真的变慢了？</h2><h3 id="查看-Redis-的响应延迟"><a href="#查看-Redis-的响应延迟" class="headerlink" title="查看 Redis 的响应延迟"></a>查看 Redis 的响应延迟</h3><p>当你发现 Redis 命令的执行时间突然就增长到了几秒，基本就可以认定 Redis 变慢了。</p>
<p>这种方法是看 Redis 延迟的绝对值，但是，在不同的软硬件环境下，Redis 本身的绝对性能并不相同。所以需要基于<strong>当前环境下的 Redis 基线性能</strong>做判断。</p>
<blockquote>
<p>所谓的基线性能呢，也就是一个系统在低压力、无干扰下的基本性能，这个性能只由当前的软硬件配置决定。</p>
<p>从 2.8.7 版本开始，redis-cli 命令提供了–intrinsic-latency 选项，可以用来监测和统计测试期间内的最大延迟，这个延迟可以作为 Redis 的基线性能。其中，测试时长可以用–intrinsic-latency 选项的参数来指定。</p>
<p>例如：<code>./redis-cli --intrinsic-latency 120</code>该命令会打印 120 秒内监测到的最大延迟。</p>
<p>如果你想了解网络对 Redis 性能的影响，一个简单的方法是用 iPerf 这样的工具，测量从 Redis 客户端到服务器端的网络延迟。</p>
</blockquote>
<h2 id="如何应对-Redis-变慢？"><a href="#如何应对-Redis-变慢？" class="headerlink" title="如何应对 Redis 变慢？"></a>如何应对 Redis 变慢？</h2><h3 id="Redis-自身操作特性的影响"><a href="#Redis-自身操作特性的影响" class="headerlink" title="Redis 自身操作特性的影响"></a>Redis 自身操作特性的影响</h3><p><strong>1.慢查询优化</strong></p>
<p>如果的确有大量的慢查询命令，有两种处理方式：</p>
<ol>
<li><p><strong>用其他高效命令代替</strong>。比如说，如果你需要返回一个 SET 中的所有成员时，不要使用 SMEMBERS 命令，而是要使用 SSCAN 多次迭代返回，避免一次返回大量数据，造成线程阻塞。</p>
</li>
<li><p><strong>当你需要执行排序、交集、并集操作时，</strong>可以在客户端完成，而不要用 SORT、SUNION、SINTER 这些命令，以免拖慢 Redis 实例**。</p>
</li>
</ol>
<p><strong>2. 过期 key 操作</strong></p>
<p>默认情况下，Redis 每 100 毫秒会删除一些过期 key，具体的算法如下：</p>
<ol>
<li><p>采样 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 个数的 key，并将其中过期的 key 全部删除；</p>
</li>
<li><p>如果超过 25% 的 key 过期了，则重复删除的过程，直到过期 key 的比例降至 25% 以下。</p>
</li>
</ol>
<p>如果是方式一每秒钟删除 200 个过期 key，并不会对 Redis 造成太大影响。算法的第二条是怎么被触发的呢？其中一个重要来源，就是<strong>频繁使用带有相同时间参数的 EXPIREAT 命令设置过期 key</strong>，这就会导致，在同一秒内有大量的 key 同时过期。</p>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>遇到这种情况时，千万不要嫌麻烦，你首先要根据实际业务的使用需求，决定 EXPIREAT 和 EXPIRE 的过期时间参数。其次，如果一批 key 的确是同时过期，你还可以在 EXPIREAT 和 EXPIRE 的过期时间参数上，加上一个一定大小范围内的随机数，这样，既保证了 key 在一个邻近时间范围内被删除，又避免了同时过期造成的压力。</p>
<h3 id="文件系统的影响"><a href="#文件系统的影响" class="headerlink" title="文件系统的影响"></a>文件系统的影响</h3><p>为了保证数据可靠性，Redis 会采用 AOF 日志或 RDB 快照。其中，AOF 日志提供了三种日志写回策略：no、everysec、always。这三种写回策略依赖文件系统的两个系统调用完成，也就是 write 和 fsync。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230315155002449.png" alt="image-20230315155002449"></p>
<p>对于 always 策略来说，Redis 需要确保每个操作记录日志都写回磁盘，如果用后台子线程异步完成，主线程就无法及时地知道每个操作是否已经完成了，这就不符合 always 策略的要求了。所以，always 策略并不使用后台子线程来执行。</p>
<p>还有如果后台子线程执行的 fsync 频繁阻塞的话（比如 AOF 重写占用了大量的磁盘 IO 带宽），主线程也会阻塞，导致 Redis 性能变慢。</p>
<blockquote>
<p>write 只要把日志记录写到内核缓冲区，就可以返回了，并不需要等待日志实际写回到磁盘；而 fsync 需要把日志记录写回到磁盘后才能返回，时间较长。下面这张表展示了三种写回策略所执行的系统调用。</p>
</blockquote>
<h4 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h4><p>如果业务应用对延迟非常敏感，但同时允许一定量的数据丢失，那么，可以把配置项 <code>no-appendfsync-on-rewrite</code> 设置为 yes</p>
<p>这个配置项设置为 yes 时，表示在 AOF 重写时，不进行 fsync 操作。也就是说，Redis 实例把写命令写到内存后，不调用后台线程进行 fsync 操作，就可以直接返回了。当然，如果此时实例发生宕机，就会导致数据丢失。反之，如果这个配置项设置为 no（也是默认配置），在 AOF 重写时，Redis 实例仍然会调用后台线程进行 fsync 操作，这就会给实例带来阻塞。</p>
<blockquote>
<p>如果的确需要高性能，同时也需要高可靠数据保证，我建议你考虑<strong>采用高速的固态硬盘作为 AOF 日志的写入设备。</strong></p>
</blockquote>
<h3 id="操作系统的影响"><a href="#操作系统的影响" class="headerlink" title="操作系统的影响"></a>操作系统的影响</h3><p>再说一个潜在的瓶颈：<strong>操作系统的内存 swap</strong>。</p>
<p>内存 swap 是操作系统里将内存数据在内存和磁盘间来回换入和换出的机制，涉及到磁盘的读写，所以，一旦触发 swap，无论是被换入数据的进程，还是被换出数据的进程，其性能都会受到慢速磁盘读写的影响。</p>
<p>Redis 是内存数据库，内存使用量大，如果没有控制好内存的使用量，或者和其他内存需求大的应用一起运行了，就可能受到 swap 的影响，而导致性能变慢。</p>
<p><strong>解决方案：</strong>增加机器的内存或者使用 Redis 集群。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>按照这些步骤逐一检查，高效地解决问题：</p>
<ol>
<li>获取 Redis 实例在当前环境下的基线性能。</li>
<li>是否用了慢查询命令？如果是的话，就使用其他命令替代慢查询命令，或者把聚合计算命令放在客户端做。</li>
<li>是否对过期 key 设置了相同的过期时间？对于批量删除的 key，可以在每个 key 的过期时间上加一个随机数，避免同时删除。</li>
<li>是否存在 bigkey？ 对于 bigkey 的删除操作，如果你的 Redis 是 4.0 及以上的版本，可以直接利用异步线程机制减少主线程阻塞；如果是 Redis 4.0 以前的版本，可以使用 SCAN 命令迭代删除；对于 bigkey 的集合查询和聚合操作，可以使用 SCAN 命令在客户端完成。</li>
<li>Redis AOF 配置级别是什么？业务层面是否的确需要这一可靠性级别？如果我们需要高性能，同时也允许数据丢失，可以将配置项 no-appendfsync-on-rewrite 设置为 yes，避免 AOF 重写和 fsync 竞争磁盘 IO 资源，导致 Redis 延迟增加。当然， 如果既需要高性能又需要高可靠性，最好使用高速固态盘作为 AOF 日志的写入盘。</li>
<li>Redis 实例的内存使用是否过大？发生 swap 了吗？如果是的话，就增加机器内存，或者是使用 Redis 集群，分摊单机 Redis 的键值对数量和内存压力。同时，要避免出现 Redis 和其他内存需求大的应用共享机器的情况。</li>
<li>在 Redis 实例的运行环境中，是否启用了透明大页机制？如果是的话，直接关闭内存大页机制就行了。</li>
<li>是否运行了 Redis 主从集群？如果是的话，把主库实例的数据量大小控制在 2~4GB，以免主从复制时，从库因加载大的 RDB 文件而阻塞。</li>
<li>是否使用了多核 CPU 或 NUMA 架构的机器运行 Redis 实例？使用多核 CPU 时，可以给 Redis 实例绑定物理核；使用 NUMA 架构时，注意把 Redis 实例和网络中断处理程序运行在同一个 CPU Socket 上。</li>
</ol>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀场景模拟</title>
    <url>/2023/09/10/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<h1 id="秒杀场景"><a href="#秒杀场景" class="headerlink" title="秒杀场景"></a>秒杀场景</h1><h2 id="秒杀场景的负载特征对支撑系统的要求"><a href="#秒杀场景的负载特征对支撑系统的要求" class="headerlink" title="秒杀场景的负载特征对支撑系统的要求"></a>秒杀场景的负载特征对支撑系统的要求</h2><ol>
<li><p>特征是瞬时并发访问量非常高。</p>
<p>一般数据库每秒只能支撑千级别的并发请求，而 Redis 的并发处理能力（每秒处理请求数）能达到万级别，甚至更高。所以，<strong>当有大量并发请求涌入秒杀系统时，我们就需要使用 Redis 先拦截大部分请求，避免大量请求直接发送给数据库，把数据库压垮</strong>。</p>
</li>
<li><p>特征是读多写少，而且读操作是简单的查询操作。</p>
<p>库存查验操作是典型的键值对查询，而 Redis 对键值对查询的高效支持，正好和这个操作的要求相匹配。</p>
</li>
</ol>
<h2 id="秒杀的三个阶段"><a href="#秒杀的三个阶段" class="headerlink" title="秒杀的三个阶段"></a>秒杀的三个阶段</h2><ol>
<li><p><strong>秒杀活动前</strong></p>
<p>在这个阶段，用户会不断刷新商品详情页，这会导致详情页的瞬时请求量剧增。这个阶段的应对方案，一般是尽量<strong>把商品详情页的页面元素静态化，然后使用 CDN 或是浏览器把这些静态化的元素缓存起来</strong>。</p>
</li>
<li><p><strong>秒杀活动开始</strong></p>
<p>这个阶段的操作就是三个：<strong>库存查验</strong>、库存扣减和订单处理。（并发主要是在库存查验操作上）</p>
<ul>
<li><p>库存查验：</p>
<p>为了支撑大量高并发的库存查验请求，我们需要在这个环节使用 Redis 保存库存量，这样一来，请求可以直接从 Redis 中读取库存并进行查验。</p>
</li>
<li><p>库存扣减：</p>
<p>需要使用Redis来执行；</p>
<p>因为放在数据库会出现两个问题：</p>
<ol>
<li><strong>额外的开销</strong>。主要是数据库与Redis同步问题需要额外开销。</li>
<li><strong>下单量超过实际库存量，出现超售</strong>。由于数据库的处理速度较慢，不能及时更新库存余量，这就会导致大量库存查验的请求读取到旧的库存值，并进行下单。</li>
</ol>
</li>
<li><p>订单处理：</p>
<p><strong>这个步骤需要交给后端数据库处理；</strong>订单处理会涉及支付、商品出库、物流等多个关联操作，这些操作本身涉及数据库中的多张数据表，要保证处理的事务性，需要在数据库中完成。而且，订单处理时的请求压力已经不大了，数据库可以支撑这些订单处理请求。</p>
</li>
</ul>
<p>前两个操作需要在Redis中保证原子性（利用lua脚本、分布式锁）。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230406165010285.png" alt="image-20230406165010285"></p>
</li>
<li><p><strong>秒杀活动结束后</strong></p>
<p>在这个阶段，可能还会有部分用户刷新商品详情页，尝试等待有其他用户退单。而已经成功下单的用户会刷新订单详情，跟踪订单的进展。不过，这个阶段中的用户请求量已经下降很多了，服务器端一般都能支撑。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>秒杀系统是一个系统性工程，Redis 实现了对库存查验和扣减这个环节的支撑，除此之外，还有 4 个环节需要我们处理好。</p>
<ol>
<li><strong>前端静态页面的设计</strong>。秒杀页面上能静态化处理的页面元素，我们都要尽量静态化，这样可以充分利用 CDN 或浏览器缓存服务秒杀开始前的请求。</li>
<li><strong>请求拦截和流控</strong>。在秒杀系统的接入层，对恶意请求进行拦截，避免对系统的恶意攻击，例如使用黑名单禁止恶意 IP 进行访问。如果 Redis 实例的访问压力过大，为了避免实例崩溃，我们也需要在接入层进行限流，控制进入秒杀系统的请求数量。</li>
<li><strong>库存信息过期时间处理</strong>。Redis 中保存的库存信息其实是数据库的缓存，为了避免缓存击穿问题，我们不要给库存信息设置过期时间。</li>
<li><strong>数据库订单异常处理</strong>。如果数据库没能成功处理订单，可以增加订单重试功能，保证订单最终能被成功处理。</li>
</ol>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础</title>
    <url>/2022/12/06/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/Docker/Docker%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Docker 是一个开源的应用容器引擎，Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化，解决了运行环境和配置问题的软件容器， 方便做持续集成并有助于整体发布的容器虚拟化技术，达到应用程式跨平台间的无缝接轨运作。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li><p>快速，一致地交付应用程序：Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。</p>
</li>
<li><p>响应式部署和扩展：Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p>
</li>
<li><p>在同一硬件上运行更多工作负载：它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，不像虚拟机一样将整个操作系统进行镜像打包，它只基于一个操作系统核心。</p>
</li>
</ul>
<h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><p>Docker包含三个主要要素：</p>
<ol>
<li><strong>镜像（Image）</strong>：相当于是一个 root 文件系统，比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li>
<li><strong>容器（Container）</strong>：镜像和容器的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。</li>
<li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像，可分为公开仓库（Public）和私有仓库（Private）两种形式；最大的公开仓库是 Docker Hub(<a href="https://hub.docker.com/)%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9B%BD%E5%86%85%E4%B8%80%E8%88%AC%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%EF%BC%88https://cr.console.aliyun.com/%EF%BC%89%E5%92%8C%E8%85%BE%E8%AE%AF%E8%BD%AF%E4%BB%B6%E6%BA%90%EF%BC%88http://mirrors.tencent.com/#/index%EF%BC%89%E3%80%82">https://hub.docker.com/)，但是国内一般使用阿里云镜像仓库（https://cr.console.aliyun.com/）和腾讯软件源（http://mirrors.tencent.com/#/index）。</a></li>
</ol>
<p>大致结构：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220905155313919.png" alt="image-20220905155313919"></p>
<p>名词解释：</p>
<ul>
<li>Docker 客户端(Client)：Docker 客户端通过命令行或者其他工具使用 Docker SDK和Docker 的守护进程通信。</li>
<li>Docker 主机(Host)：一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</li>
<li>Docker Registry：Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库；一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</li>
<li>Docker Machine：Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li><p>首先卸载旧版本(直接执行命令)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure></li>
<li><p>安装gcc相关依赖：<code>yum -y install gcc</code>和<code>yum -y install gcc-c++</code></p>
</li>
<li><p>通过Docker的仓库进行安装：</p>
<ul>
<li>安装需要的软件包：<code>yum install -y yum-utils </code></li>
<li>设置稳定的镜像仓库(阿里云)：<code>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></li>
<li>更新yum软件包索引：<code>yum makecache fast</code></li>
<li>安装docker引擎：<code>yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</code></li>
</ul>
</li>
<li><p>启动Docker：<code>systemctl start docker</code></p>
</li>
<li><p>运行hello-world：<code>docker run hello-world</code></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220905202506360.png" alt="image-20220905202506360"></p>
</li>
</ul>
<blockquote>
<p>卸载：</p>
<ul>
<li><code>systemctl stop docker</code></li>
<li><code>yum remove docker-ce docker-ce-cli containerd.io</code></li>
<li><code>rm -rf /var/lib/docker</code></li>
<li><code>rm -rf /var/lib/containerd</code></li>
</ul>
<p>配置镜像加速器：</p>
<ul>
<li><p>进入<a href="https://www.aliyun.com/">阿里云官网</a></p>
</li>
<li><p>进入容器镜像服务产品</p>
</li>
<li><p>右侧镜像工具中的镜像加速器</p>
</li>
<li><p>复制加速器地址</p>
</li>
<li><p>执行命令：</p>
<ul>
<li><p>创建文件：<code>mkdir -p /etc/docker</code></p>
</li>
<li><p>写入文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://自己id.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启守护进程：<code>systemctl daemon-reload</code></p>
</li>
<li><p>重启docker服务：<code>systemctl restart docker</code></p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="基础相关命令"><a href="#基础相关命令" class="headerlink" title="基础相关命令"></a>基础相关命令</h2><h3 id="帮助启动类命令"><a href="#帮助启动类命令" class="headerlink" title="帮助启动类命令"></a>帮助启动类命令</h3><ul>
<li>启动docker： <code>systemctl start docker</code></li>
<li>停止docker： <code>systemctl stop docker</code></li>
<li>重启docker： <code>systemctl restart docker</code></li>
<li>查看docker状态：<code>systemctl status docker</code></li>
<li>开机启动： <code>systemctl enable docker</code></li>
<li>查看docker概要信息： <code>docker info</code></li>
<li>查看docker总体帮助文档： <code>docker --help</code></li>
<li>查看docker命令帮助文档： <code>docker 具体命令 --help</code></li>
</ul>
<h3 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h3><ul>
<li><p>列出本地主机上的镜像：<code>docker images</code></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220905205552189.png" alt="image-20220905205552189"></p>
<ul>
<li>列出选项说明：<ul>
<li>REPOSITORY：表示镜像的仓库源</li>
<li>TAG：镜像的标签版本号</li>
<li>IMAGE ID：镜像ID</li>
<li>CREATED：镜像创建时间</li>
<li>SIZE：镜像大小</li>
</ul>
</li>
<li>命令参数说明：<ul>
<li>-a :列出本地所有的镜像（含历史映像层）</li>
<li>-q :只显示镜像ID</li>
</ul>
</li>
</ul>
</li>
<li><p>去镜像中查找某个镜像：<code>docker search [OPTIONS] 镜像名字</code></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220905210235697.png" alt="image-20220905210235697"></p>
<ul>
<li>列出选项说明：<ul>
<li>name：镜像名称</li>
<li>description：镜像描述</li>
<li>stars：点赞数</li>
<li>official：是否是官方的</li>
<li>automated：是否自动构建的</li>
</ul>
</li>
<li>OPTIONS说明：<ul>
<li>-limit n：只列出N个镜像，默认25个</li>
</ul>
</li>
</ul>
</li>
<li><p>下载镜像：<code>docker pull 镜像名字[:TAG]</code>( 没有TAG就是最新版)</p>
</li>
<li><p>查看镜像/容器/数据卷所占的空间：<code>docker system df</code></p>
</li>
<li><p>删除镜像：</p>
<ul>
<li>删除单个：<code>docker rmi -f 镜像ID</code></li>
<li>删除多个：<code>docker rmi -f 镜像名1:TAG 镜像名2:TAG</code></li>
<li>删除全部：<code>docker rmi -f $(docker images -qa)</code></li>
</ul>
</li>
<li><p>提交容器副本创建一个新的镜像：<code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code></p>
<ul>
<li>OPTIONS说明：<ul>
<li>-a：提交的镜像作者；</li>
<li>-c：使用Dockerfile指令来创建镜像；</li>
<li>-m：提交时的说明文字；</li>
<li>-p：在commit时，将容器暂停。</li>
</ul>
</li>
<li>例子：将centos7基础镜像添加vim：<ul>
<li>在centos7容器中安装vim：<code>yum install vim</code></li>
<li>提交新镜像：<code>docker commit -m &quot;add vim cmd&quot; -a=&quot;wht&quot; f5d07dbc0e7c myCentos:centos7 </code></li>
<li><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220906193610575.png" alt="image-20220906193610575"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><ul>
<li><p>新建+启动容器：<code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p>
<ul>
<li><p>OPTIONS说明（常用）：</p>
<ul>
<li>–name=”容器新名字”：为容器指定一个名称</li>
<li>-d：后台运行容器并返回容器ID，也即启动守护式容器(后台运行)</li>
<li>-i：以交互模式运行容器，通常与 -t 同时使用</li>
<li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用</li>
<li>-P：随机端口映射，大写P</li>
<li>-p：指定端口映射，小写p</li>
</ul>
</li>
<li><p>案例使用centos7容器：<code>docker run -it centos:centos7 /bin/bash</code></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220906155143483.png" alt="image-20220906155143483"></p>
</li>
</ul>
</li>
<li><p>创建一个新的容器但不启动它：<code>docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p>
<ul>
<li>OPTIONS说明（同run）</li>
<li>例子：<code>docker create  --name myrunoob  nginx:latest</code></li>
</ul>
</li>
<li><p>列出当前所有正在运行的容器：<code>docker ps [OPTIONS]</code></p>
<ul>
<li>OPTIONS说明：<ul>
<li>-a：列出当前所有正在运行的容器+历史上运行过的</li>
<li>-l：显示最近创建的容器</li>
<li>-n：显示最近n个创建的容器</li>
<li>-q：静默模式，只显示容器编号</li>
</ul>
</li>
</ul>
</li>
<li><p>退出容器：</p>
<ul>
<li>exit：exit退出，容器停止</li>
<li>ctrl+p+q：ctrl+p+q退出，容器不停止</li>
</ul>
</li>
<li><p>启动已经停止的容器：<code>docker start 容器ID或者容器名</code></p>
</li>
<li><p>重启容器：<code>docker restart 容器ID或者容器名</code></p>
</li>
<li><p>停止容器：<code>docker stop 容器ID或者容器名</code></p>
</li>
<li><p>强制停止容器：<code>docker kill 容器ID或容器名</code></p>
</li>
<li><p>删除已停止的容器：<code>docker rm 容器ID</code></p>
</li>
<li><p>查看容器日志：<code>docker logs 容器ID</code></p>
</li>
<li><p>查看容器内运行的进程：<code>docker top 容器ID</code></p>
</li>
<li><p>查看容器内部细节：<code>docker inspect 容器ID</code></p>
</li>
<li><p>重新进入容器：</p>
<ul>
<li><code>docker exec -it 容器ID bashShell</code><ul>
<li>案例（重新用命令行形式进入容器）：<code>docker exec -it a2b057419f1f / bin/ bash</code></li>
</ul>
</li>
<li><code>docker attach 容器ID</code></li>
</ul>
<blockquote>
<p>两者区别：</p>
<ul>
<li><p>exec 是在容器中打开新的终端，并且可以启动新的进程 用exit退出，不会导致容器的停止。</p>
</li>
<li><p>attach 直接进入容器启动命令的终端，不会启动新的进程 用exit退出，会导致容器的停止。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>从容器内拷贝文件到主机上：<code>docker cp 容器ID:容器内路径 目的主机路径</code></p>
</li>
<li><p>导入和导出：</p>
<ul>
<li>导出：<code>docker export 容器ID &gt; 文件名.ta</code></li>
<li>导出：<code>cat 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号</code></li>
</ul>
</li>
<li><p>检查容器里文件结构的更改：<code>docker diff [OPTIONS] CONTAINER</code></p>
<ul>
<li>OPTIONS说明：<ul>
<li>-L：保持源目标中的链接</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>更多命令见<a href="https://www.runoob.com/docker/docker-command-manual.html">菜鸟教程</a></p>
</blockquote>
<h2 id="发布本地镜像"><a href="#发布本地镜像" class="headerlink" title="发布本地镜像"></a>发布本地镜像</h2><p>发布大致结构：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220906194207717.png" alt="image-20220906194207717"></p>
<h3 id="发布到阿里云"><a href="#发布到阿里云" class="headerlink" title="发布到阿里云"></a>发布到阿里云</h3><ul>
<li><p>进入阿里云容器镜像服务控制台(<a href="https://cr.console.aliyun.com/cn-hangzhou/instances">https://cr.console.aliyun.com/cn-hangzhou/instances</a>)</p>
</li>
<li><p>进入个人实例：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220906195022024.png" alt="image-20220906195022024" style="zoom:50%;" />
</li>
<li><p>创建命名空间：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220906195052777.png" alt="image-20220906195052777" style="zoom:50%;" />
</li>
<li><p>添加镜像仓库</p>
</li>
<li><p>执行命令将镜像推送到阿里云</p>
<ul>
<li>登录校验：<code>docker login --username=自己账号 registry.cn-hangzhou.aliyuncs.com</code></li>
<li>标记本地镜像，将其归入阿里仓库<code>docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/dockertest-demo/centos7:[镜像版本号]</code></li>
<li>推送到阿里云<code>docker push registry.cn-hangzhou.aliyuncs.com/dockertest-demo/centos7:[镜像版本号]</code></li>
</ul>
</li>
<li><p>拉取：<code>docker pull registry.cn-hangzhou.aliyuncs.com/dockertest-demo/centos7:[镜像版本号]</code></p>
</li>
</ul>
<h3 id="发布私有库"><a href="#发布私有库" class="headerlink" title="发布私有库"></a>发布私有库</h3><p>要搭建自己的私有库，必须通过docker官方的registry来创建。</p>
<ul>
<li><p>首先拉取registry镜像：<code>docker pull registry</code></p>
</li>
<li><p>运行该私有库：<code>docker run -d -p 5000:5000 -v /wht/myregistry/:/tmp/registry --privileged=true registry</code></p>
</li>
<li><p>查询私有库中有什么镜像：<code>curl -XGET http://192.168.111.162:5000/v2/_catalog</code></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220906201201249.png" alt="image-20220906201201249"></p>
</li>
<li><p>标记镜像：<code>docker tag  mycentos:centos7  192.168.227.113:5000/mycentos:1.2</code></p>
</li>
<li><p>修改配置文件使之支持http：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220906201652439.png" alt="image-20220906201652439"></p>
</li>
<li><p>重启docker：<code>systemctl restart docker</code>（注意还需要重新运行私服库）</p>
</li>
<li><p>推送私有库：<code>docker push 192.168.227.113:5000/mycentos:1.2</code></p>
</li>
</ul>
<h3 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a><strong>容器数据卷</strong></h3><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性，设计目的就是数据的持久化。</p>
<p>例如刚才运行的私有库命令：<code>docker run -d -p 5000:5000 -v 主机目录:容器内目录 --privileged=true registry</code>，这样实现了容器内数据与主机中的同步。</p>
<p><strong>命令：</strong></p>
<p><code>docker run -it -v /宿主机目录:/容器内目录:权限 容器名</code></p>
<ul>
<li>权限说明：<ul>
<li>rw：默认值可读可写</li>
<li>ro：容器实例内部被限制，只能读取不能写</li>
</ul>
</li>
</ul>
<p><strong>数据卷继承：</strong></p>
<p><code>docker run -it --privileged=true --volumes-from 父类容器名 容器名</code></p>
<p><strong>特点：</strong></p>
<ul>
<li>数据卷可在容器之间共享或重用</li>
<li>数据卷中的更改可以直接实时生效</li>
<li>数据卷中的更改不会包含在镜像的更新中</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止</li>
</ul>
<h2 id="常用软件安装"><a href="#常用软件安装" class="headerlink" title="常用软件安装"></a>常用软件安装</h2><h3 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h3><ul>
<li><p>查找tomcat镜像：<code>docker search tomcat</code></p>
</li>
<li><p>从远程仓库拉取镜像：<code>docker pull tomcat</code></p>
</li>
<li><p>查看是否有拉取到的tomcat：<code>docker images</code></p>
</li>
<li><p>使用tomcat镜像创建容器实例：<code>docker run -d -p 8080:8080 --name t1 tomcat</code></p>
</li>
<li><p>由于新版tomcat中的webapps中是空的所以需要把webapps.dist目录换成webapps（也完全可以下载8版本：<code>docker pull billygoo/tomcat8-jdk8</code>）</p>
<ul>
<li>进入tomcat容器：<code>docker exec -it tomcat版本号 /bin/bash</code></li>
<li>将webapps删除：<code>rm -r webapps</code></li>
<li>把webapps.dist目录换成webapps：<code>mv webapps.dist webapps</code></li>
</ul>
</li>
<li><p>输入url访问：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220906212249666.png" alt="image-20220906212249666"></p>
</li>
<li><p>安装完成！</p>
</li>
</ul>
<h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><ul>
<li><p>查找mysql镜像：<code>docker search mysql</code></p>
</li>
<li><p>从远程仓库拉取镜像：<code>docker pull mysql:8.0.18</code></p>
</li>
<li><p>查看是否有拉取到的mysql：<code>docker images</code></p>
</li>
<li><p>查看linux是否已经启动了mysql：<code>ps -ef | grep mysql</code></p>
</li>
<li><p>如果已经启动了停止：<code>service mysql stop</code>(开启是<code>service mysql start</code>)</p>
</li>
<li><p>使用镜像运行容器：<code>docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.18</code></p>
</li>
<li><p>查看容器id：<code>docker ps</code></p>
</li>
<li><p>进入容器：<code>docker exec -it 容器id /bin/bash</code></p>
</li>
<li><p>进入容器后进入mysql：<code>mysql -uroot -p</code></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220907170919355.png" alt="image-20220907170919355"></p>
</li>
<li><p>进入后还需要改docker中mysql的字符集：<code>SHOW VARIABLES LIKE &#39;character%&#39;</code>（稍后在配置文件中修改）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220907171712337.png" alt="image-20220907171712337"></p>
</li>
<li><p>退出关闭容器：<code>docker stop 容器id</code></p>
</li>
<li><p>重新开启容器（挂上数据卷）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --privileged&#x3D;true </span><br><span class="line">-v &#x2F;wht&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql </span><br><span class="line">-v &#x2F;wht&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql </span><br><span class="line">-v &#x2F;wht&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d </span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;123456  --name mysql mysql:8.0.18</span><br></pre></td></tr></table></figure></li>
<li><p>安装完成！</p>
</li>
</ul>
<h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><ul>
<li><p>查找redis镜像：<code>docker search redis</code></p>
</li>
<li><p>从远程仓库拉取镜像：<code>docker pull redis:6.2.1</code></p>
</li>
<li><p>查看是否有拉取到的redis：<code>docker images</code></p>
</li>
<li><p>新建本机备份目录：<code>/opt/docker_app/redis</code></p>
</li>
<li><p>并将linux上的redis.conf复制到该备份目录</p>
</li>
<li><p>修改配置文件：</p>
<ul>
<li>关闭后台启动：<code>daemonize no</code>(因为docker会-d将其后台运行)</li>
<li>开启持久化：<code>appendonly yes</code></li>
</ul>
</li>
<li><p>停止本机的redis：<code>systemctl stop redis</code></p>
</li>
<li><p>创建并启动容器(添加数据卷)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run  -p 6379:6379 --name myredis --privileged&#x3D;true -v &#x2F;opt&#x2F;docker_app&#x2F;redis&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -v &#x2F;opt&#x2F;docker_app&#x2F;redis&#x2F;data:&#x2F;data -d redis:6.2.1 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br></pre></td></tr></table></figure></li>
<li><p>进入容器：<code>docker exec -it 运行着Rediis服务的容器ID redis-cli -a密码</code></p>
</li>
<li><p>安装完成！</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220907181432256.png" alt="image-20220907181432256"></p>
</li>
</ul>
<blockquote>
<p>其余更多环境安装详见<a href="https://www.runoob.com/docker/docker-install-ubuntu.html">菜鸟教程</a>或者dockerhub官网(<a href="https://hub.docker.com/)%E4%B8%AD">https://hub.docker.com/)中</a></p>
</blockquote>
<h2 id="MySql主从复制"><a href="#MySql主从复制" class="headerlink" title="MySql主从复制"></a>MySql主从复制</h2><h3 id="创建主mysql服务器容器"><a href="#创建主mysql服务器容器" class="headerlink" title="创建主mysql服务器容器"></a>创建主mysql服务器容器</h3><ul>
<li><p>新建主服务器容器实例端口号3307：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 3307:3306 --name mysql-master \</span><br><span class="line">-v &#x2F;mydata&#x2F;mysql-master&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql \</span><br><span class="line">-v &#x2F;mydata&#x2F;mysql-master&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \</span><br><span class="line">-v &#x2F;mydata&#x2F;mysql-master&#x2F;conf:&#x2F;etc&#x2F;mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;root  \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure></li>
<li><p>进入/mydata/mysql-master/conf目录下新建my.cnf</p>
</li>
<li><p>配置my.cnf：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置server_id，同一局域网中需要唯一</span><br><span class="line">server_id&#x3D;101 </span><br><span class="line">## 指定不需要同步的数据库名称</span><br><span class="line">binlog-ignore-db&#x3D;mysql  </span><br><span class="line">## 开启二进制日志功能</span><br><span class="line">log-bin&#x3D;mall-mysql-bin  </span><br><span class="line">## 设置二进制日志使用内存大小（事务）</span><br><span class="line">binlog_cache_size&#x3D;1M  </span><br><span class="line">## 设置使用的二进制日志格式（mixed,statement,row）</span><br><span class="line">binlog_format&#x3D;mixed  </span><br><span class="line">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span><br><span class="line">expire_logs_days&#x3D;7  </span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors&#x3D;1062</span><br></pre></td></tr></table></figure></li>
<li><p>修改完配置后重启master实例：<code>docker restart mysql-master</code></p>
</li>
<li><p>进入mysql-master容器：<code>docker exec -it mysql-master /bin/bash</code></p>
</li>
<li><p>进入mysql：<code>mysql -uroot -proot</code></p>
</li>
<li><p>master容器实例内创建数据同步用户：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE, REPLICATION CLIENT <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="创建从mysql服务器容器"><a href="#创建从mysql服务器容器" class="headerlink" title="创建从mysql服务器容器"></a>创建从mysql服务器容器</h3></li>
<li><p>新建从服务器容器实例3308：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 3308:3306 --name mysql-slave \</span><br><span class="line">-v &#x2F;mydata&#x2F;mysql-slave&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql \</span><br><span class="line">-v &#x2F;mydata&#x2F;mysql-slave&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \</span><br><span class="line">-v &#x2F;mydata&#x2F;mysql-slave&#x2F;conf:&#x2F;etc&#x2F;mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;root  \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure></li>
<li><p>进入/mydata/mysql-slave/conf目录下新建my.cnf</p>
</li>
<li><p>进行配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置server_id，同一局域网中需要唯一</span><br><span class="line">server_id&#x3D;102</span><br><span class="line">## 指定不需要同步的数据库名称</span><br><span class="line">binlog-ignore-db&#x3D;mysql  </span><br><span class="line">## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</span><br><span class="line">log-bin&#x3D;mall-mysql-slave1-bin  </span><br><span class="line">## 设置二进制日志使用内存大小（事务）</span><br><span class="line">binlog_cache_size&#x3D;1M  </span><br><span class="line">## 设置使用的二进制日志格式（mixed,statement,row）</span><br><span class="line">binlog_format&#x3D;mixed  </span><br><span class="line">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span><br><span class="line">expire_logs_days&#x3D;7  </span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors&#x3D;1062  </span><br><span class="line">## relay_log配置中继日志</span><br><span class="line">relay_log&#x3D;mall-mysql-relay-bin   </span><br><span class="line">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span><br><span class="line">log_slave_updates&#x3D;1  </span><br><span class="line">## slave设置为只读（具有super权限的用户除外）</span><br><span class="line">read_only&#x3D;1</span><br></pre></td></tr></table></figure></li>
<li><p>修改完配置后重启slave实例：<code>docker restart mysql-slave</code></p>
</li>
<li><p>在主数据库中查看主从同步状态：<code>show master status;</code></p>
</li>
<li><p>进入mysql-slave容器：<code>docker exec -it mysql-slave /bin/bash</code></p>
</li>
<li><p>进入数据库：<code>mysql -uroot -proot</code></p>
</li>
<li><p>在从数据库中配置主从复制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">change master to master_host&#x3D;&#39;宿主机ip&#39;, master_user&#x3D;&#39;slave&#39;, master_password&#x3D;&#39;123456&#39;, master_port&#x3D;3307, master_log_file&#x3D;&#39;mall-mysql-bin.000001&#39;, master_log_pos&#x3D;617, master_connect_retry&#x3D;30;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主从复制命令参数说明：</p>
<ul>
<li>master_host：主数据库的IP地址；</li>
<li>master_port：主数据库的运行端口；</li>
<li>master_user：在主数据库创建的用于同步数据的用户账号；</li>
<li>master_password：在主数据库创建的用于同步数据的用户密码；</li>
<li>master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；  </li>
<li>master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；</li>
<li>master_connect_retry：连接失败重试的时间间隔，单位为秒。</li>
</ul>
</blockquote>
</li>
<li><p>在从数据库中查看主从同步状态：<code>show slave status \G;</code></p>
</li>
<li><p>在从数据库中开启主从同步：<code>start slave</code></p>
</li>
<li><p>如果主数据库插入数据，从数据库能够看到说明插入成功</p>
</li>
</ul>
<h2 id="安装redis集群"><a href="#安装redis集群" class="headerlink" title="安装redis集群"></a>安装redis集群</h2><p>当进行分布式存储时，会存在在哪台服务器上存取数据的问题，一般业界有三种落地实现方案</p>
<ol>
<li>哈希取余分区</li>
</ol>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221031211521217.png" alt="image-20221031211521217" style="zoom: 67%;" />

<p>​        公式为hash(key) % N个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。</p>
<ul>
<li><p>优点：</p>
<p>使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡+分而治之的作用。</p>
</li>
<li><p>缺点：</p>
<p>原来规划好的节点，进行扩容或者缩容就比较麻烦了额，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化。</p>
</li>
</ul>
<ol start="2">
<li><p>致性哈希算法分区</p>
<p>提出一致性Hash解决方案。 目的是当服务器个数发生变动时， 尽量减少影响客户端到服务器的映射关系</p>
<p>三大步骤：</p>
<ul>
<li><p>算法构建一致性哈希环：</p>
<p>一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个hash空间[0,2^32-1]，通过适当的逻辑控制将它首尾相连(0 = 2^32),这样让它逻辑上形成了一个环形空间</p>
</li>
<li><p>服务器IP节点映射：</p>
<p>将集群中各个IP节点映射到环上的某一个位置。将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置</p>
</li>
<li><p>key落到服务器的落键规则：</p>
<p>我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置，从此位置沿环顺时针行走，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。</p>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>优点： </p>
<p>有较强的容错性和扩展性</p>
</li>
<li><p>缺点：</p>
<p>Hash环的数据倾斜问题，一致性Hash算法在服务<strong>节点太少时</strong>，容易因为节点分布不均匀而造成<strong>数据倾斜</strong>（被缓存的对象大部分集中缓存在某一台服务器上）问题</p>
</li>
</ul>
<ol start="3">
<li><p>哈希槽分区</p>
<p>为了解决上述方案的数据倾斜问题，出现了哈希槽。</p>
<p>解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽（slot），用于管理数据和节点之间的关系。</p>
<p>实现：</p>
<p>Redis 集群中内置了 16384 个哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在 Redis 集群中放置一个 key-value时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，也就是映射到某个节点上。</p>
</li>
</ol>
<h3 id="开始搭建集群"><a href="#开始搭建集群" class="headerlink" title="开始搭建集群"></a>开始搭建集群</h3><p>集群结构：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221031214436063.png" alt="image-20221031214436063"></p>
<p>实现步骤：</p>
<ul>
<li><p>启动6个redis容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis-node-1 --net host --privileged&#x3D;true -v &#x2F;data&#x2F;redis&#x2F;share&#x2F;redis-node-1:&#x2F;data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6381</span><br><span class="line"> </span><br><span class="line">docker run -d --name redis-node-2 --net host --privileged&#x3D;true -v &#x2F;data&#x2F;redis&#x2F;share&#x2F;redis-node-2:&#x2F;data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6382</span><br><span class="line"> </span><br><span class="line">docker run -d --name redis-node-3 --net host --privileged&#x3D;true -v &#x2F;data&#x2F;redis&#x2F;share&#x2F;redis-node-3:&#x2F;data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6383</span><br><span class="line"> </span><br><span class="line">docker run -d --name redis-node-4 --net host --privileged&#x3D;true -v &#x2F;data&#x2F;redis&#x2F;share&#x2F;redis-node-4:&#x2F;data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6384</span><br><span class="line"> </span><br><span class="line">docker run -d --name redis-node-5 --net host --privileged&#x3D;true -v &#x2F;data&#x2F;redis&#x2F;share&#x2F;redis-node-5:&#x2F;data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6385</span><br><span class="line"> </span><br><span class="line">docker run -d --name redis-node-6 --net host --privileged&#x3D;true -v &#x2F;data&#x2F;redis&#x2F;share&#x2F;redis-node-6:&#x2F;data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6386</span><br></pre></td></tr></table></figure></li>
<li><p>进入redis-node-1并为6台机器构建集群关系：<code>docker exec -it redis-node-1 /bin/bash</code></p>
</li>
<li><p>构建主从关系（每当主机挂了从机会补上，之后主机回来就会变成从机）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster create 192.168.227.130:6381 192.168.227.130:6382 192.168.227.130:6383 192.168.227.130:6384 192.168.227.130:6385 192.168.227.130:6386 --cluster-replicas 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<p>进入docker容器后才能执行一下命令，且注意自己的真实IP地址</p>
<p>TIP：</p>
<p>–cluster-replicas 1 表示为每个master创建一个slave节点</p>
</blockquote>
</li>
<li><p>进入redis：<code>redis-cli -p 6381 -c</code>(-c会进行路由优化，将数据放在指定的槽位)</p>
</li>
<li><p>查看集群状态：<code>cluster info 或者 cluster nodes</code></p>
</li>
<li><p>查看集群信息：<code>redis-cli --cluster check 真实ip地址:6381 </code></p>
</li>
</ul>
<h4 id="主从扩容"><a href="#主从扩容" class="headerlink" title="主从扩容"></a>主从扩容</h4><ul>
<li><p>新建6387、6388两个节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis-node-7 --net host --privileged&#x3D;true -v &#x2F;data&#x2F;redis&#x2F;share&#x2F;redis-node-7:&#x2F;data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6387</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-8 --net host --privileged&#x3D;true -v &#x2F;data&#x2F;redis&#x2F;share&#x2F;redis-node-8:&#x2F;data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6388</span><br></pre></td></tr></table></figure></li>
<li><p>进入6387容器实例内部：<code>docker exec -it redis-node-7 /bin/bash</code></p>
</li>
<li><p>将新增的6387节点(空槽号)作为master节点加入原集群：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node 自己实际IP地址:6387 自己实际IP地址:6381</span><br></pre></td></tr></table></figure></li>
<li><p>检查集群情况第1次：<code>redis-cli --cluster check 真实ip地址:6381</code></p>
</li>
<li><p>重新分派槽号：<code>redis-cli --cluster reshard IP地址:6381</code></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221031225000456.png" alt="image-20221031225000456"></p>
</li>
<li><p>为主节点6387分配从节点6388：<code>redis-cli --cluster add-node ip:新slave端口 ip:新master端口 --cluster-slave --cluster-master-id 新主机节点ID</code></p>
</li>
</ul>
<h4 id="主从缩容"><a href="#主从缩容" class="headerlink" title="主从缩容"></a>主从缩容</h4><p>目的：6387和6388下线</p>
<ul>
<li><p>将6388删除 从集群中将4号从节点6388删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster del-node ip:从机端口 从机6388节点ID</span><br></pre></td></tr></table></figure></li>
<li><p>查看集群信息：<code>redis-cli --cluster check ip:6382</code></p>
</li>
<li><p>将6387的槽号清空，重新分配，本例将清出来的槽号都给6381：<code> redis-cli  --cluster reshard ip:6381 </code></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221031224943151.png" alt="image-20221031224943151"></p>
</li>
<li><p>将6387删除：<code>redis-cli --cluster del-node ip:端口 6387节点ID</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>工具的使用</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>容器技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker高级</title>
    <url>/2022/12/09/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/Docker/Docker%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="Docker高级"><a href="#Docker高级" class="headerlink" title="Docker高级"></a>Docker高级</h1><h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><p>Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p>
<p>构建三部曲：</p>
<ol>
<li>编写Dockerfile文件</li>
<li>docker build命令构建镜像</li>
<li>docker run依镜像运行容器实例</li>
</ol>
<h3 id="常用保留字指令"><a href="#常用保留字指令" class="headerlink" title="常用保留字指令"></a>常用保留字指令</h3><ul>
<li><p>FROM：基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from</p>
</li>
<li><p>MAINTAINER：镜像维护者的姓名和邮箱地址</p>
</li>
<li><p>RUN：容器构建时需要运行的命令</p>
<ul>
<li><p>shell格式：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221101114340053.png" alt="image-20221101114340053"></p>
</li>
<li><p>exec格式：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221101114346992.png" alt="image-20221101114346992"></p>
</li>
</ul>
</li>
<li><p>EXPOSE：当前容器对外暴露出的端口</p>
</li>
<li><p>WORKDIR：指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</p>
</li>
<li><p>USER：指定该镜像以什么样的用户去执行，如果都不指定，默认是root</p>
</li>
<li><p>ENV：用来在构建镜像过程中设置环境变量</p>
</li>
<li><p>ADD：将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</p>
</li>
<li><p>COPY：类似ADD，拷贝文件和目录到镜像中。 将从构建上下文目录中 &lt; 源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置</p>
</li>
<li><p>VOLUME：容器数据卷，用于数据保存和持久化工作</p>
</li>
<li><p>CMD：指定容器启动后的要干的事情</p>
</li>
<li><p>ENTRYPOINT：</p>
<p>也是用来指定一个容器启动时要运行的命令，ENTRYPOINT可以和CMD一起用，一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参。</p>
<p>例如：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221101115936743.png" alt="image-20221101115936743"></p>
</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>安装Centos7镜像具备vim+ifconfig+jdk8</p>
<ul>
<li><p>准备编写Dockerfile文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER wht&lt;136921735@126.com&gt;</span><br><span class="line"> </span><br><span class="line">ENV MYPATH &#x2F;usr&#x2F;local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"> </span><br><span class="line">#安装vim编辑器</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">#安装ifconfig命令查看网络IP</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line">#安装java8及lib库</span><br><span class="line">RUN yum -y install glibc.i686</span><br><span class="line">RUN mkdir &#x2F;usr&#x2F;local&#x2F;java</span><br><span class="line">#ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置</span><br><span class="line">ADD jdk-8u171-linux-x64.tar.gz &#x2F;usr&#x2F;local&#x2F;java&#x2F;</span><br><span class="line">#配置java环境变量</span><br><span class="line">ENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_171</span><br><span class="line">ENV JRE_HOME $JAVA_HOME&#x2F;jre</span><br><span class="line">ENV CLASSPATH $JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib:$CLASSPATH</span><br><span class="line">ENV PATH $JAVA_HOME&#x2F;bin:$PATH</span><br><span class="line"> </span><br><span class="line">EXPOSE 80</span><br><span class="line"> </span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;success--------------ok&quot;</span><br><span class="line">CMD &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure></li>
<li><p>构建镜像：<code>docker build -f Dockerfile -t 新镜像名字:TAG .</code></p>
</li>
<li><p>运行：<code>docker run -it 新镜像名字:TAG</code></p>
</li>
</ul>
<h3 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h3><p>仓库名、标签都是<none>的镜像，俗称dangling image</p>
<ul>
<li>查看虚悬镜像：<code>docker image ls -f dangling=true</code></li>
<li>删除虚悬镜像：<code>docker image prune</code></li>
</ul>
<h3 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h3><ul>
<li><p>将项目打包成jar包，并上传到服务器</p>
</li>
<li><p>编写Dockerfile：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 基础镜像使用java</span><br><span class="line">FROM java:8</span><br><span class="line"># 作者</span><br><span class="line">MAINTAINER wht</span><br><span class="line"># VOLUME 指定临时文件目录为&#x2F;tmp，在主机&#x2F;var&#x2F;lib&#x2F;docker目录下创建了一个临时文件并链接到容器的&#x2F;tmp</span><br><span class="line">VOLUME &#x2F;tmp</span><br><span class="line"># 将jar包添加到容器中并更名为springBoot_docker.jar</span><br><span class="line">ADD docker_boot.jar springBoot_docker.jar</span><br><span class="line"># 运行jar包</span><br><span class="line">RUN bash -c &#39;touch &#x2F;springBoot_docker.jar&#39;</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;&#x2F;springBoot_docker.jar&quot;]</span><br><span class="line">#暴露6001端口作为微服务</span><br><span class="line">EXPOSE 6001</span><br></pre></td></tr></table></figure></li>
<li><p>构建镜像：<code>docker build -t springBoot_docker:1.6</code></p>
</li>
<li><p>运行容器：<code>docker run -d -p 6001:6001 springBoot_docker:1.6</code></p>
</li>
</ul>
<h2 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h2><p>docker启动后，会产生一个名为docker0的虚拟网桥。主要解决容器间的互联和通信以及端口映射、容器IP变动时候通信问题。</p>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ul>
<li><p>创建网络：<code>docker network create 网络名</code>(自定义网络本身就维护好了主机名和ip的对应关系)</p>
</li>
<li><p>查看docker网络模式命令：<code>docker network ls </code>(默认会有三种模式：bridge、host、none)</p>
</li>
<li><p>查看网络源数据：<code>docker network inspect XXX网络名字</code></p>
</li>
<li><p>删除网络：<code>docker network rm XXX网络名字</code></p>
</li>
</ul>
<h3 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h3><ul>
<li><p>bridge模式：为每一个容器分配、设置IP等，并将容器连接到一个docker0，使用–network bridge指定，默认使用docker0</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221102131419291.png" alt="image-20221102131419291"></p>
</li>
<li><p>host模式：容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口，使用–network host指定</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221102131424958.png" alt="image-20221102131424958"></p>
</li>
<li><p>none模式：容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair和网桥连接，IP等，使用–network none指定</p>
</li>
<li><p>container模式：新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP、端口范围等，使用–network container:NAME或者容器ID指定</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221102131442912.png" alt="image-20221102131442912"></p>
</li>
</ul>
<h2 id="Docker-compose容器编排"><a href="#Docker-compose容器编排" class="headerlink" title="Docker-compose容器编排"></a>Docker-compose容器编排</h2><p>Compose 是 Docker 公司推出的一个工具软件，可以管理多个 Docker 容器组成一个应用。你需要定义一个 YAML 格式的配置文件docker-compose.yml，写好多个容器之间的调用关系。然后，只要一个命令，就能同时启动/关闭这些容器， 负责实现对Docker容器集群的快速编排。</p>
<h3 id="Docker-compose-安装"><a href="#Docker-compose-安装" class="headerlink" title="Docker-compose 安装"></a>Docker-compose 安装</h3><p>官网地址：<a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p>
<p>官方下载文档：</p>
<ul>
<li><p>下载安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -L https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.25.4&#x2F;docker-compose-&#96;uname -s&#96;-&#96;uname -m&#96; &gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure></li>
<li><p>给文件权限：<code>chmod +x /usr/local/bin/docker-compose</code></p>
</li>
<li><p>检验是否安装：<code>docker-compose --version</code></p>
</li>
<li><p>卸载：<code>sudo rm / usr/ local/bin/ docker-compose</code></p>
</li>
</ul>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul>
<li><p>重要文件：docker-compose.yml</p>
</li>
<li><p>两要素：</p>
<ul>
<li>服务（service）：一个个应用容器实例，比如订单微服务、库存微服务、mysql容器、nginx容器或者redis容器</li>
<li>工程（project）：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</li>
</ul>
</li>
<li><p>三大步骤：</p>
<ul>
<li>编写Dockerfile定义各个微服务应用并构建出对应的镜像文件</li>
<li>使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务。</li>
<li>最后，执行docker-compose up命令 来启动并运行整个应用程序，完成一键部署上线</li>
</ul>
</li>
</ul>
<h3 id="Compose常用命令"><a href="#Compose常用命令" class="headerlink" title="Compose常用命令"></a>Compose常用命令</h3><ul>
<li>docker-compose -h              # 查看帮助</li>
<li>docker-compose up              # 启动所有docker-compose服务</li>
<li>docker-compose up -d            # 启动所有docker-compose服务并后台运行</li>
<li>docker-compose down             # 停止并删除容器、网络、卷、镜像。</li>
<li>docker-compose exec  yml里面的服务id         # 进入容器实例内部 </li>
<li>docker-compose exec docker-compose.yml文件中写的服务id /bin/bash</li>
<li>docker-compose ps           # 展示当前docker-compose编排过的运行的所有容器</li>
<li>docker-compose top           # 展示当前docker-compose编排过的容器进程</li>
<li>docker-compose logs  yml里面的服务id   # 查看容器输出日志</li>
<li>docker-compose config   # 检查配置</li>
<li>docker-compose config -q # 检查配置，有问题才有输出</li>
<li>docker-compose restart  # 重启服务</li>
<li>docker-compose start   # 启动服务</li>
<li>docker-compose stop    # 停止服务</li>
</ul>
<h3 id="部署实例"><a href="#部署实例" class="headerlink" title="部署实例"></a>部署实例</h3><ul>
<li><p>同样项目打包</p>
</li>
<li><p>编写docker-compose.yml文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 版本</span><br><span class="line">version: &quot;1&quot;</span><br><span class="line"># 镜像中的服务容器</span><br><span class="line">services:</span><br><span class="line">  microService:</span><br><span class="line">  	# 镜像来源</span><br><span class="line">    image: springboot_docker:1.6</span><br><span class="line">    # 容器名（不加默认目录_服务名_序号）</span><br><span class="line">    container_name: ms01</span><br><span class="line">    # 端口映射</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6001:6001&quot;</span><br><span class="line">    # 数据卷</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;app&#x2F;microService:&#x2F;data</span><br><span class="line">    # 网络</span><br><span class="line">    networks: </span><br><span class="line">      - test_net</span><br><span class="line">    # 依赖于谁先启动</span><br><span class="line">    depends_on: </span><br><span class="line">      - redis</span><br><span class="line">      - mysql</span><br><span class="line"> </span><br><span class="line">  redis:</span><br><span class="line">    image: redis:6.0.8</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;app&#x2F;redis&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">      - &#x2F;app&#x2F;redis&#x2F;data:&#x2F;data</span><br><span class="line">    networks: </span><br><span class="line">      - test_net</span><br><span class="line">    # 执行命令</span><br><span class="line">    command: redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line"> </span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    # 配置环境</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: &#39;123456&#39;</span><br><span class="line">      MYSQL_ALLOW_EMPTY_PASSWORD: &#39;no&#39;</span><br><span class="line">      MYSQL_DATABASE: &#39;db2021&#39;</span><br><span class="line">      MYSQL_USER: &#39;root&#39;</span><br><span class="line">      MYSQL_PASSWORD: &#39;123456&#39;</span><br><span class="line">    ports:</span><br><span class="line">       - &quot;3306:3306&quot;</span><br><span class="line">    volumes:</span><br><span class="line">       - &#x2F;app&#x2F;mysql&#x2F;db:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">       - &#x2F;app&#x2F;mysql&#x2F;conf&#x2F;my.cnf:&#x2F;etc&#x2F;my.cnf</span><br><span class="line">       - &#x2F;app&#x2F;mysql&#x2F;init:&#x2F;docker-entrypoint-initdb.d</span><br><span class="line">    networks:</span><br><span class="line">      - test_net</span><br><span class="line">    command: --default-authentication-plugin&#x3D;mysql_native_password #解决外部无法访问</span><br><span class="line"># 创建网络</span><br><span class="line">networks: </span><br><span class="line">   test_net</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于使用同一网络所以可以将ip改为服务名（改了除了重新打包）</p>
</blockquote>
</li>
<li><p>检查docker-compose.yml文件语法是否错误：<code>docker-compose config -q</code></p>
</li>
<li><p>执行docker-compose：<code>docker-compose up -d  </code></p>
</li>
<li><p>停止compose：<code>docker-compose stop</code></p>
</li>
</ul>
<h2 id="Portainer"><a href="#Portainer" class="headerlink" title="Portainer"></a>Portainer</h2><p>Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。</p>
<ul>
<li><p>拉镜像：<code>docker pull lihaixin/portainer</code></p>
</li>
<li><p>启动容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8000:8000 -p 9000:9000 --name portainer     --restart&#x3D;always     -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock     -v portainer_data:&#x2F;data     lihaixin&#x2F;portainer</span><br></pre></td></tr></table></figure></li>
<li><p>第一次登录需创建admin，访问地址：ip:9000</p>
</li>
<li><p>注册并选择监控本地docker</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221102213545348.png" alt="image-20221102213545348"></p>
</li>
<li><p>主页状态：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221102214149100.png" alt="image-20221102214149100"></p>
</li>
</ul>
<h2 id="CIG"><a href="#CIG" class="headerlink" title="CIG"></a>CIG</h2><p>CIG：Docker容器监控之CAdvisor监控收集+InfluxDB存储数据+Granfana展示图表</p>
<blockquote>
<p>一般使用docker stats命令可以很方便的看到当前宿主机上所有容器的CPU,内存以及网络流量等数据，当容器数据太多时就需要CIG了</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li><p>新建目录 <code>mkdir /opt/docker_app/cig</code></p>
</li>
<li><p>新建3件套组合的 docker-compose.yml：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3.1&#39;</span><br><span class="line"> </span><br><span class="line">volumes:</span><br><span class="line">  grafana_data: &#123;&#125;</span><br><span class="line"> </span><br><span class="line">services:</span><br><span class="line"> influxdb:</span><br><span class="line">  image: tutum&#x2F;influxdb:0.9</span><br><span class="line">  restart: always</span><br><span class="line">  environment:</span><br><span class="line">    - PRE_CREATE_DB&#x3D;cadvisor</span><br><span class="line">  ports:</span><br><span class="line">    - &quot;8083:8083&quot;</span><br><span class="line">    - &quot;8086:8086&quot;</span><br><span class="line">  volumes:</span><br><span class="line">    - .&#x2F;data&#x2F;influxdb:&#x2F;data</span><br><span class="line"> </span><br><span class="line"> cadvisor:</span><br><span class="line">  image: google&#x2F;cadvisor</span><br><span class="line">  links:</span><br><span class="line">    - influxdb:influxsrv</span><br><span class="line">  command: -storage_driver&#x3D;influxdb -storage_driver_db&#x3D;cadvisor -storage_driver_host&#x3D;influxsrv:8086</span><br><span class="line">  restart: always</span><br><span class="line">  ports:</span><br><span class="line">    - &quot;8080:8080&quot;</span><br><span class="line">  volumes:</span><br><span class="line">    - &#x2F;:&#x2F;rootfs:ro</span><br><span class="line">    - &#x2F;var&#x2F;run:&#x2F;var&#x2F;run:rw</span><br><span class="line">    - &#x2F;sys:&#x2F;sys:ro</span><br><span class="line">    - &#x2F;var&#x2F;lib&#x2F;docker&#x2F;:&#x2F;var&#x2F;lib&#x2F;docker:ro</span><br><span class="line"> </span><br><span class="line"> grafana:</span><br><span class="line">  user: &quot;104&quot;</span><br><span class="line">  image: grafana&#x2F;grafana</span><br><span class="line">  user: &quot;104&quot;</span><br><span class="line">  restart: always</span><br><span class="line">  links:</span><br><span class="line">    - influxdb:influxsrv</span><br><span class="line">  ports:</span><br><span class="line">    - &quot;3000:3000&quot;</span><br><span class="line">  volumes:</span><br><span class="line">    - grafana_data:&#x2F;var&#x2F;lib&#x2F;grafana</span><br><span class="line">  environment:</span><br><span class="line">    - HTTP_USER&#x3D;admin</span><br><span class="line">    - HTTP_PASS&#x3D;admin</span><br><span class="line">    - INFLUXDB_HOST&#x3D;influxsrv</span><br><span class="line">    - INFLUXDB_PORT&#x3D;8086</span><br><span class="line">    - INFLUXDB_NAME&#x3D;cadvisor</span><br><span class="line">    - INFLUXDB_USER&#x3D;root</span><br><span class="line">    - INFLUXDB_PASS&#x3D;root</span><br></pre></td></tr></table></figure></li>
<li><p>启动compose：<code>docker-compose up -d</code></p>
</li>
<li><p>测试：</p>
<ul>
<li> 浏览cAdvisor收集服务，<a href="http://ip:8080/">http://ip:8080/</a></li>
<li> 浏览influxdb存储服务，<a href="http://ip:8083/">http://ip:8083/</a></li>
<li> 浏览grafana展现服务，<a href="http://ip:3000/">http://ip:3000</a>  (ip+3000端口的方式访问,默认帐户密码（admin/admin）)</li>
</ul>
</li>
<li><p>在grafana配置数据源：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221102220325003.png" alt="image-20221102220325003"></p>
<ul>
<li><p>选择influxdb数据源：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221102220347802.png" alt="image-20221102220347802"></p>
</li>
<li><p>配置细节：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221102220425099.png" alt="image-20221102220425099"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221102220430381.png" alt="image-20221102220430381"></p>
</li>
</ul>
<p>​            <img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221102220440089.png" alt="image-20221102220440089"></p>
<ul>
<li><p>配置面板panel：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221102220509873.png" alt="image-20221102220509873"></p>
<p>​        <img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221102220516309.png" alt="image-20221102220516309"></p>
<p>​        <img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221102220523022.png" alt="image-20221102220523022"></p>
<p>​        <img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221102220529509.png" alt="image-20221102220529509"></p>
<p>​        <img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221102220534624.png" alt="image-20221102220534624"></p>
<p>​        <img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20221102220541842.png" alt="image-20221102220541842"></p>
</li>
</ul>
</li>
<li><p>部署完成</p>
</li>
</ul>
]]></content>
      <categories>
        <category>工具的使用</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>容器技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的介绍与简单使用</title>
    <url>/2021/02/25/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/Git/Git%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Git的介绍和简单使用"><a href="#Git的介绍和简单使用" class="headerlink" title="Git的介绍和简单使用"></a>Git的介绍和简单使用</h1><h2 id="Git的概述"><a href="#Git的概述" class="headerlink" title="Git的概述"></a>Git的概述</h2><ul>
<li><p>Git的描述：Git是一个开源的分布式版本控制系统</p>
</li>
<li><p>作用：可以有效、高速地处理从很小到非常大的项目版本管理。</p>
</li>
<li><p>优点：</p>
<ul>
<li><p>适合分布式开发，强调个体。</p>
</li>
<li><p>公共服务器压力和数据量都不会太大。</p>
</li>
<li><p>速度快、灵活。</p>
</li>
<li><p>任意两个开发者之间可以很容易的解决冲突。</p>
</li>
<li><p>离线工作。</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。</li>
</ul>
</li>
</ul>
<h2 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h2><p>在<a href="https://git-scm.com/">官网</a>下载，然后一直next即可。</p>
<h2 id="Git的本地结构"><a href="#Git的本地结构" class="headerlink" title="Git的本地结构"></a>Git的本地结构</h2><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230330085042132.png" alt="image-20230330085042132">    </p>
<h2 id="Git的基本命令"><a href="#Git的基本命令" class="headerlink" title="Git的基本命令"></a>Git的基本命令</h2><ul>
<li>初始化本地仓库：git init</li>
<li>添加文件：git add</li>
<li>提交文件： git commit -m “备注” </li>
<li>查看本地仓库状态：git status</li>
<li>查看提交日志：<ul>
<li>git log</li>
<li>git log –pretty=oneline</li>
<li>git log –oneline</li>
<li>git reflog (常用)</li>
</ul>
</li>
<li>进入历史版本：git reset –hard 版本号 (hard 可以换成mixed 暂存区和本地库同步调整,soft 只有本地库调整)</li>
<li>比对工作区和暂存区：git diff </li>
<li>创建分支：git branch 分支名</li>
<li>查看分支：git branch -v</li>
<li>切换分支：git checkout 分支名</li>
<li>删除分支：git branch –D 分支名</li>
<li>合并分支：git merge 分支名</li>
<li>推送操作：git push 远程仓库地址 分支名</li>
<li>克隆操作：git clone 远程仓库地址</li>
<li>给远程仓库地址起别名：git remote add 别名 地址</li>
<li>查看别名：git remote -v</li>
<li>拉取代码：git fetch</li>
<li>拉取并合并代码：git pull </li>
</ul>
<h2 id="SSH免密登录"><a href="#SSH免密登录" class="headerlink" title="SSH免密登录"></a>SSH免密登录</h2><ol>
<li><p>进入用户主目录：cd ~</p>
</li>
<li><p>再创建ssh目录：ssh-keygen -t rsa -C (输入github邮箱)</p>
</li>
<li><p>打开id_rad.pub文件将内容复制</p>
</li>
<li><p>粘贴到github 的settings中添加</p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具使用</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>版本控制</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx(一)</title>
    <url>/2022/11/21/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/Nginx/Nginx-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="Nginx-1"><a href="#Nginx-1" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Nginx（“engine x”）一个具有高性能的<strong>HTTP</strong>和<strong>反向代理</strong>的<strong>WEB服务器</strong>，同时也是一个<strong>POP3/SMTP/IMAP</strong>代理服务器</p>
<blockquote>
<p><strong>HTTP</strong>：HTTP是超文本传输协议的缩写，是用于从WEB服务器传输超文本到本地浏览器的传输协议，也是互联网上应用最为广泛的一种网络协议。</p>
<p><strong>反向代理</strong>：反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。（就相当于去代理服务器而不是客户端）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220729094609211.png" alt="image-20220729094609211"></p>
<p><strong>POP3/SMTP/IMAP：</strong></p>
<ul>
<li>OP3(Post Offic Protocol 3)邮局协议的第三个版本</li>
<li>SMTP(Simple Mail Transfer Protocol)简单邮件传输协议</li>
<li>IMAP(Internet Mail Access Protocol)交互式邮件存取协议</li>
</ul>
</blockquote>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>速度更快、并发更高：Nginx采用了多进程和I/O多路复用(epoll)的底层实现</li>
<li>配置简单，扩展性强：Nginx的设计极具扩展性，它本身就是由很多模块组成，这些模块的使用可以通过配置文件的配置来添加。</li>
<li>高可靠性：Nginx采用的是多进程模式运行，其中有一个master主进程和N多个worker进程，worker进程的数量我们可以手动设置，每个worker进程之间都是相互独立提供服务，并且master主进程可以在某一个worker进程出错时，快速去”拉起”新的worker进程提供服务。</li>
<li>热部署：Nginx也提供了热部署功能，即可以在Nginx不停止的情况下，对Nginx进行文件升级、更新配置和更换日志文件等功能</li>
<li>成本低、BSD许可证</li>
</ul>
<h3 id="常用功能模块"><a href="#常用功能模块" class="headerlink" title="常用功能模块"></a>常用功能模块</h3><ol>
<li>静态资源部署</li>
<li>反向代理</li>
<li>负载均衡（轮询、加权轮询、ip_hash、url_hash、fair）</li>
<li>Web缓存</li>
<li>环境部署（高可用的环境）</li>
<li>用户认证模块…</li>
</ol>
<blockquote>
<p>核心文件：</p>
<ul>
<li>nginx二进制可执行文件</li>
<li>nginx.conf配置文件</li>
<li>error.log错误的日志记录</li>
<li>access.log访问日志记录</li>
</ul>
</blockquote>
<h2 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h2><p>Nginx的下载<a href="http://nginx.org/en/download.html">官方网站</a></p>
<h4 id="安装前环境："><a href="#安装前环境：" class="headerlink" title="安装前环境："></a>安装前环境：</h4><p>需要安装GCC编译器、PCRE、zlib、OpenSSL</p>
<p>命令：<code>yum install -y gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel</code></p>
<h4 id="安装方式一：Nginx的源码简单安装"><a href="#安装方式一：Nginx的源码简单安装" class="headerlink" title="安装方式一：Nginx的源码简单安装"></a>安装方式一：Nginx的源码简单安装</h4><p>(1)进入官网查找需要下载版本的链接地址，然后使用wget命令进行下载或者下载好上传到linux上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure>
<p>(2)进入目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;mysoft</span><br></pre></td></tr></table></figure>
<p>(3)解压缩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xzf nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure>
<p>(4)进入资源文件中，发现configure</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure>
<p>(5)编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>(6)安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>


<h4 id="安装方式二：yum安装"><a href="#安装方式二：yum安装" class="headerlink" title="安装方式二：yum安装"></a>安装方式二：yum安装</h4><p>使用源码进行简单安装，我们会发现安装的过程比较繁琐，需要提前准备GCC编译器、PCRE兼容正则表达式库、zlib压缩库、OpenSSL安全通信的软件库包，然后才能进行Nginx的安装。</p>
<p>（1）安装yum-utils</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum  install -y yum-utils</span><br></pre></td></tr></table></figure>
<p>（2）添加yum源文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;yum.repos.d&#x2F;nginx.repo</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[nginx-stable]</span><br><span class="line">name&#x3D;nginx stable repo</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;$releasever&#x2F;$basearch&#x2F;</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;nginx.org&#x2F;keys&#x2F;nginx_signing.key</span><br><span class="line">module_hotfixes&#x3D;true</span><br><span class="line"></span><br><span class="line">[nginx-mainline]</span><br><span class="line">name&#x3D;nginx mainline repo</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;mainline&#x2F;centos&#x2F;$releasever&#x2F;$basearch&#x2F;</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">enabled&#x3D;0</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;nginx.org&#x2F;keys&#x2F;nginx_signing.key</span><br><span class="line">module_hotfixes&#x3D;true</span><br></pre></td></tr></table></figure>
<p>（3）查看是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list | grep nginx</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/1581416861684.png" alt="1581416861684"></p>
<p>（4）使用yum进行安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yun install -y nginx</span><br></pre></td></tr></table></figure>
<p>（5）查看nginx的安装位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">where is nginx</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/1581416981939.png" alt="1581416981939"></p>
<p>（6）启动测试</p>
<ul>
<li><p>进入二进制命令目录：<code>cd /usr/local/nginx/sbin</code></p>
</li>
<li><p>启动nginx：<code>./nginx</code></p>
</li>
<li><p>输入ip进入nginx：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220812150647433.png" alt="image-20220812150647433"></p>
</li>
</ul>
<h4 id="将Nginx设置为系统服务"><a href="#将Nginx设置为系统服务" class="headerlink" title="将Nginx设置为系统服务"></a>将Nginx设置为系统服务</h4><p>把Nginx应用服务设置成为系统服务，方便对Nginx服务的启动和停止等相关操作，具体实现步骤:</p>
<p>(1) 在<code>/usr/lib/systemd/system</code>目录下添加nginx.service,内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;nginx web service</span><br><span class="line">Documentation&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;docs&#x2F;</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;forking</span><br><span class="line">PIDFile&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid</span><br><span class="line">ExecStartPre&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -t -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br><span class="line">ExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload</span><br><span class="line">ExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s stop</span><br><span class="line">PrivateTmp&#x3D;true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;default.target</span><br></pre></td></tr></table></figure>
<p>(2)添加完成后如果权限有问题需要进行权限设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 755 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service</span><br></pre></td></tr></table></figure>
<p>(3)使用系统命令来操作Nginx服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动: systemctl start nginx</span><br><span class="line">停止: systemctl stop nginx</span><br><span class="line">重启: systemctl restart nginx</span><br><span class="line">重新加载配置文件: systemctl reload nginx</span><br><span class="line">查看nginx状态: systemctl status nginx</span><br><span class="line">开机启动: systemctl enable nginx</span><br></pre></td></tr></table></figure>
<h4 id="将Nginx配置为环境变量"><a href="#将Nginx配置为环境变量" class="headerlink" title="将Nginx配置为环境变量"></a>将Nginx配置为环境变量</h4><p>(1)修改<code>/etc/profile</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line">在最后一行添加</span><br><span class="line">export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin</span><br></pre></td></tr></table></figure>
<p>(2)使之立即生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p>(3)执行nginx命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -V</span><br></pre></td></tr></table></figure>
<h4 id="安装方式三：docker安装"><a href="#安装方式三：docker安装" class="headerlink" title="安装方式三：docker安装"></a>安装方式三：docker安装</h4><ul>
<li><p>拉镜像：<code>docker pull nginx:xxx</code></p>
</li>
<li><p>创建Nginx配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建挂载目录</span><br><span class="line">mkdir -p &#x2F;opt&#x2F;docker_app&#x2F;ngnix&#x2F;conf</span><br><span class="line">mkdir -p &#x2F;opt&#x2F;docker_app&#x2F;ngnix&#x2F;log</span><br><span class="line">mkdir -p &#x2F;opt&#x2F;docker_app&#x2F;ngnix&#x2F;html</span><br></pre></td></tr></table></figure></li>
<li><p>创建容器并复制出配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生成容器</span><br><span class="line">docker run --name nginx -p 9001:80 -d nginx</span><br><span class="line"># 将容器nginx.conf文件复制到宿主机</span><br><span class="line">docker cp nginx:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf &#x2F;opt&#x2F;docker_app&#x2F;ngnix&#x2F;conf&#x2F;nginx.conf</span><br><span class="line"># 将容器conf.d文件夹下内容复制到宿主机</span><br><span class="line">docker cp nginx:&#x2F;etc&#x2F;nginx&#x2F;conf.d &#x2F;opt&#x2F;docker_app&#x2F;ngnix&#x2F;conf&#x2F;conf.d</span><br><span class="line"># 将容器中的html文件夹复制到宿主机</span><br><span class="line">docker cp nginx:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html &#x2F;opt&#x2F;docker_app&#x2F;ngnix&#x2F;html</span><br></pre></td></tr></table></figure></li>
<li><p>将刚才容器删除：<code>docker rm -f nginx</code></p>
</li>
<li><p>正式创建容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 80:80 --name nginx --privileged&#x3D;true --restart&#x3D;always -v &#x2F;opt&#x2F;docker_app&#x2F;ngnix&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf -v &#x2F;opt&#x2F;docker_app&#x2F;ngnix&#x2F;conf&#x2F;conf.d:&#x2F;etc&#x2F;nginx&#x2F;conf.d -v &#x2F;opt&#x2F;docker_app&#x2F;ngnix&#x2F;log:&#x2F;var&#x2F;log&#x2F;nginx -v &#x2F;opt&#x2F;docker_app&#x2F;ngnix&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html -d nginx</span><br></pre></td></tr></table></figure></li>
<li><p>浏览器输入ip进行访问</p>
</li>
</ul>
<h2 id="Nginx目录结构"><a href="#Nginx目录结构" class="headerlink" title="Nginx目录结构"></a>Nginx目录结构</h2><p>通过tree命令进行目录结构的查看（注意需要<code>yum install -y tree</code>）</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220812151753138.png" alt="image-20220812151753138" style="zoom: 67%;" />

<ul>
<li><p>fastcgi.conf:fastcgi相关配置文件</p>
</li>
<li><p>fastcgi.conf.default:fastcgi.conf的备份文件</p>
</li>
<li><p>fastcgi_params:fastcgi的参数文件</p>
</li>
<li><p>fastcgi_params.default:fastcgi的参数备份文件</p>
</li>
<li><p>scgi_params:scgi的参数文件</p>
</li>
<li><p>scgi_params.default：scgi的参数备份文件</p>
</li>
<li><p>uwsgi_params:uwsgi的参数文件</p>
</li>
<li><p>uwsgi_params.default:uwsgi的参数备份文件</p>
</li>
<li><p>mime.types:记录的是HTTP协议中的Content-Type的值和文件后缀名的对应关系</p>
</li>
<li><p>mime.types.default:mime.types的备份文件</p>
</li>
<li><p>nginx.conf:这个是Nginx的核心配置文件，这个文件非常重要，也是我们即将要学习的重点</p>
</li>
<li><p>nginx.conf.default:nginx.conf的备份文件</p>
</li>
<li><p>koi-utf、koi-win、win-utf这三个文件都是与编码转换映射相关的配置文件，用来将一种编码转换成另一种编码</p>
</li>
<li><p>html:存放nginx自带的两个静态的html页面</p>
</li>
<li><p>50x.html:访问失败后的失败页面</p>
</li>
<li><p>index.html:成功访问的默认首页</p>
</li>
<li><p>logs:记录入门的文件，当nginx服务器启动后，这里面会有 access.log error.log 和nginx.pid三个文件出现。</p>
</li>
<li><p>sbin:是存放执行程序文件nginx</p>
</li>
<li><p>nginx是用来控制Nginx的启动和停止等相关的命令。</p>
</li>
</ul>
<h2 id="Nginx相关命令"><a href="#Nginx相关命令" class="headerlink" title="Nginx相关命令"></a>Nginx相关命令</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul>
<li><p>首先查看：ps -ef | grep nginx</p>
</li>
<li><p>调用命令为<code>kill -signal PID</code></p>
<ol>
<li><p>发送TERM/INT信号给master进程，会将Nginx服务立即关闭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kill -TERM PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`</span><br><span class="line">kill -INT PID / kill -INT `cat /usr/local/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure></li>
<li><p>发送QUIT信号给master进程，master进程会控制所有的work进程不再接收新的请求，等所有请求处理完后，在把进程都关闭掉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kill -QUIT PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure></li>
<li><p>发送HUP信号给master进程，master进程会把控制旧的work进程不再接收新的请求，等处理完请求后将旧的work进程关闭掉，然后根据nginx的配置文件重新启动新的work进程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kill -HUP PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure></li>
<li><p>发送USR1信号给master进程，告诉Nginx重新开启日志文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kill -USR1 PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure></li>
<li><p>发送USR2信号给master进程，告诉master进程要平滑升级，这个时候，会重新开启对应的master进程和work进程，整个系统中将会有两个master进程，并且新的master进程的PID会被记录在<code>/usr/local/nginx/logs/nginx.pid</code>而之前的旧的master进程PID会被记录在<code>/usr/local/nginx/logs/nginx.pid.oldbin</code>文件中，接着再次发送QUIT信号给旧的master进程，让其处理完请求后再进行关闭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kill -USR2 PID / kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`</span><br><span class="line"></span><br><span class="line">kill -QUIT PID / kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`</span><br></pre></td></tr></table></figure>
<ol start="6">
<li><p>发送WINCH信号给master进程,让master进程控制不让所有的work进程在接收新的请求了，请求处理完后关闭work进程。注意master进程不会被关闭掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kill -WINCH PID /kill -WINCH`cat /usr/local/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3></li>
</ol>
</li>
</ol>
</li>
</ul>
<p>通过帮助命令查看全部其他命令：<code>nginx -h</code></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220812155841704.png" alt="image-20220812155841704"></p>
<ul>
<li><p>?和-h:显示帮助信息</p>
</li>
<li><p>-v:打印版本号信息并退出</p>
</li>
<li><p>-V:打印版本号信息和配置信息并退出</p>
</li>
<li><p>-t:测试nginx的配置文件语法是否正确并退出</p>
</li>
<li><p>-T:测试nginx的配置文件语法是否正确并列出用到的配置文件信息然后退出</p>
</li>
<li><p>-q:在配置测试期间禁止显示非错误消息</p>
</li>
<li><p>-s:signal信号，后面可以跟 ：</p>
<ul>
<li>stop[快速关闭，类似于TERM/INT信号的作用]</li>
<li>quit[优雅的关闭，类似于QUIT信号的作用] </li>
<li>reopen[重新打开日志文件类似于USR1信号的作用] </li>
<li>reload[类似于HUP信号的作用]</li>
</ul>
</li>
<li><p>-p:prefix，指定Nginx的prefix路径，(默认为: /usr/local/nginx/)</p>
</li>
<li><p>-c:filename,指定Nginx的配置文件路径,(默认为: conf/nginx.conf)</p>
</li>
<li><p>-g:用来补充Nginx配置文件，向Nginx服务指定启动时应用全局的配置</p>
</li>
</ul>
<h3 id="ngnix更新案例"><a href="#ngnix更新案例" class="headerlink" title="ngnix更新案例"></a>ngnix更新案例</h3><h5 id="使用Nginx安装目录的make命令完成升级"><a href="#使用Nginx安装目录的make命令完成升级" class="headerlink" title="使用Nginx安装目录的make命令完成升级"></a>使用Nginx安装目录的make命令完成升级</h5><p>第一步:将1.14.2版本的sbin目录下的nginx进行备份</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin</span><br><span class="line">mv nginx nginxold</span><br></pre></td></tr></table></figure>
<p>第二步:将Nginx1.16.1安装目录编译后的objs目录下的nginx文件，拷贝到原来<code>/usr/local/nginx/sbin</code>目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;nginx&#x2F;core&#x2F;nginx-1.16.1&#x2F;objs</span><br><span class="line">cp nginx &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin</span><br></pre></td></tr></table></figure>
<p>第三步:进入到安装目录，执行<code>make upgrade</code></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/1581494652284.png" alt="1581494652284"></p>
<p>第四步:查看是否更新成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx -v</span><br></pre></td></tr></table></figure>
<h2 id="Nginx-conf"><a href="#Nginx-conf" class="headerlink" title="Nginx.conf"></a>Nginx.conf</h2><p>大致结构：</p>
<p>默认有三大块：全局块、events块、http块。</p>
<p>http块中可以配置多个server块，每个server块又可以配置多个location块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指令名	指令值;  #全局块，主要设置Nginx服务器整体运行的配置指令</span><br><span class="line"></span><br><span class="line">#events块,主要设置,Nginx服务器与用户的网络连接,这一部分对Nginx服务器的性能影响较大</span><br><span class="line">events &#123;	 </span><br><span class="line">    指令名	指令值;</span><br><span class="line">&#125;</span><br><span class="line">#http块，是Nginx服务器配置中的重要部分，代理、缓存、日志记录、第三方模块配置...             </span><br><span class="line">http &#123;		</span><br><span class="line">    指令名	指令值;</span><br><span class="line">    server &#123; #server块，是Nginx配置和虚拟主机相关的内容</span><br><span class="line">        指令名	指令值;</span><br><span class="line">        location &#x2F; &#123; </span><br><span class="line">        #location块，基于Nginx服务器接收请求字符串与location后面的值进行匹配，对特定请求进行处理</span><br><span class="line">            指令名	指令值;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置文件的语法规则：</p>
<ol>
<li>配置文件由指令与指令块构成；</li>
<li>每条指令以 <code>;</code> 分号结尾，指令与参数间以空格符号分隔；</li>
<li>指令块以 <code>&#123;&#125;</code> 大括号将多条指令组织在一起；</li>
<li><code>include</code> 语句允许组合多个配置文件以提升可维护性；</li>
<li>使用 <code>#</code> 符号添加注释，提高可读性；</li>
<li>使用 <code>$</code> 符号使用变量；</li>
<li>部分指令的参数支持正则表达式；</li>
</ol>
</blockquote>
<h3 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h3><h4 id="user指令"><a href="#user指令" class="headerlink" title="user指令"></a>user指令</h4><p>用于配置运行Nginx服务器的worker进程的用户和用户组，默认值为nobody。使用user指令可以指定启动运行工作进程的用户及用户组，这样对于系统的权限访问控制的更加精细，也更加安全。</p>
<p><code>user user [group];</code></p>
<h4 id="work-process指令"><a href="#work-process指令" class="headerlink" title="work process指令"></a>work process指令</h4><p>master_process:用来指定是否开启工作进程。默认值为on</p>
<p><code>master_process on\off;</code></p>
<p>worker_processes:用于配置Nginx生成工作进程的数量，默认为1，这个是Nginx服务器实现并发处理服务的关键所在。理论上来说workder process的值越大，可以支持的并发处理量也越多，但事实上这个值的设定是需要受到来自服务器自身的限制，建议将该值和服务器CPU的内核数保存一致。</p>
<p><code>  worker_processes num/auto;</code></p>
<p>如果将worker_processes设置成2，则会看到如下内容:</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/1581563242526.png" alt="1581563242526"></p>
<h4 id="daemon命令"><a href="#daemon命令" class="headerlink" title="daemon命令"></a>daemon命令</h4><p>daemon：设定Nginx是否以守护进程的方式启动，默认on。</p>
<p>守护式进程是linux后台执行的一种服务进程，特点是独立于控制终端，不会随着终端关闭而停止。</p>
<p><code>daemon on\off;</code></p>
<h4 id="pid命令"><a href="#pid命令" class="headerlink" title="pid命令"></a>pid命令</h4><p>用来配置Nginx当前master进程的进程号ID存储的文件路径，默认为/usr/local/nginx/logs/nginx.pid，（docker中pid在/var/run/nginx.pid）</p>
<p><code>  pid file;</code></p>
<h4 id="error-log命令"><a href="#error-log命令" class="headerlink" title="error_log命令"></a>error_log命令</h4><p>用来配置Nginx的错误日志存放路径，默认为error_log logs/error.log error;同样docker中在/var/log/nginx/error.log</p>
<p><code>error_log  file [日志级别];</code></p>
<blockquote>
<p>其中日志级别的值有：debug|info|notice|warn|error|crit|alert|emerg，这块建议大家设置的时候不要设置成info以下的等级，因为会带来大量的磁盘I/O消耗，影响Nginx的性能。</p>
</blockquote>
<h4 id="include命令"><a href="#include命令" class="headerlink" title="include命令"></a>include命令</h4><p>用来引入其他配置文件，使Nginx的配置更加灵活</p>
<p><code>  include file;</code></p>
<p>例如：默认配置文件 <code>/etc/nginx/nginx.conf</code> 的 http 模块中有一句 <code>include /etc/nginx/conf.d/*.conf</code></p>
<blockquote>
<p>Nginx 有一些常用的全局变量，你可以在配置的任何位置使用它们，如下：</p>
<ol>
<li><code>$host</code>：请求信息中的 <code>Host</code>，如果请求中没有 <code>Host</code> 行，则等于设置的服务器名，不包含端口</li>
<li><code>$request_method</code>：客户端请求类型，如 <code>GET</code>、<code>POST</code></li>
<li><code>$remote_addr</code>：客户端的 <code>IP</code> 地址</li>
<li><code>$args</code>： 请求中的参数</li>
<li><code>$arg_PARAMETER</code>：<code>GET</code> 请求中变量名 PARAMETER 参数的值，例如：<code>$http_user_agent</code>(Uaer-Agent 值)</li>
<li><code>$content_length</code>： 请求头中的 <code>Content-length</code> 字段</li>
<li><code>$http_user_agent</code>：客户端agent信息</li>
<li><code>$http_cookie</code>：客户端cookie信息</li>
<li><code>$remote_addr</code>：客户端的IP地址</li>
<li><code>$remote_port</code>：客户端的端口</li>
<li><code>$http_user_agent</code>：客户端agent信息</li>
<li><code>$server_protocol</code>：请求使用的协议，如 <code>HTTP/1.0</code>、<code>HTTP/1.1</code></li>
<li><code>$server_addr</code>： 服务器地址</li>
<li><code>$server_name</code>：服务器名称</li>
<li><code>$server_port</code>：服务器的端口号</li>
<li><code>$scheme</code>：HTTP 方法（如http，https）</li>
</ol>
</blockquote>
<h3 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h3><h4 id="accept-mutex"><a href="#accept-mutex" class="headerlink" title="accept_mutex"></a>accept_mutex</h4><p>用来设置Nginx网络连接序列化，默认值off</p>
<p><code>accept_mutex on\off;</code></p>
<p>这个配置主要可以用来解决常说的”惊群”问题。大致意思是在某一个时刻，客户端发来一个请求连接，Nginx后台是以多进程的工作模式，也就是说有多个worker进程会被同时唤醒，但是最终只会有一个进程可以获取到连接，如果每次唤醒的进程数目太多，就会影响Nginx的整体性能。如果将上述值设置为on(开启状态)，将会对多个Nginx进程接收连接进行序列号，一个个来唤醒接收，就防止了多个进程对连接的争抢。</p>
<h4 id="multi-accept"><a href="#multi-accept" class="headerlink" title="multi_accept"></a>multi_accept</h4><p>用来设置是否允许同时接收多个网络连接，默认值multi_accept off;</p>
<p>如果multi_accept被禁止了，nginx一个工作进程只能同时接受一个新的连接。否则，一个工作进程可以同时接受所有的新连接</p>
<p><code>  multi_accept on\off;</code></p>
<h4 id="worker-connections"><a href="#worker-connections" class="headerlink" title="worker_connections"></a>worker_connections</h4><p>用来配置单个worker进程最大的连接数,默认值worker_commections 512;</p>
<p>这里的连接数不仅仅包括和前端用户建立的连接数，而是包括所有可能的连接数。另外，number值不能大于操作系统支持打开的最大文件句柄数量。</p>
<p><code>worker_connections number;</code></p>
<h4 id="use"><a href="#use" class="headerlink" title="use"></a>use</h4><p>用来设置Nginx服务器选择哪种事件驱动来处理网络消息。</p>
<p><code>  use method;</code></p>
<p>这些值的选择，我们也可以在编译的时候使用</p>
<p><code>--with-select_module</code>、<code>--without-select_module</code>、</p>
<p><code> --with-poll_module</code>、<code> --without-poll_module</code>来设置是否需要将对应的事件驱动模块编译到Nginx的内核。</p>
<h3 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h3><h4 id="定义MIME-Type"><a href="#定义MIME-Type" class="headerlink" title="定义MIME-Type"></a>定义MIME-Type</h4><p>我们都知道浏览器中可以显示的内容有HTML、XML、GIF等种类繁多的文件、媒体等资源，浏览器为了区分这些资源，就需要使用MIME Type。所以说MIME Type是网络资源的媒体类型。Nginx作为web服务器，也需要能够识别前端请求的资源类型。</p>
<p>在Nginx的配置文件中，默认有两行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include mime.types; # docker中在&#x2F;etc&#x2F;nginx&#x2F;mime.types</span><br><span class="line">default_type application&#x2F;octet-stream;</span><br></pre></td></tr></table></figure>
<p>（1）default_type:用来配置Nginx响应前端请求默认的MIME类型。默认值为default_type text/plain；</p>
<p>在default_type之前还有一句<code>include mime.types</code>,include之前我们已经介绍过，相当于把mime.types文件中MIMT类型与相关类型文件的文件后缀名的对应关系加入到当前的配置文件中。</p>
<p><code>default_type mime-type;</code></p>
<blockquote>
<p>案例：有些时候请求某些接口的时候需要返回指定的文本字符串或者json字符串，如果逻辑非常简单或者干脆是固定的字符串，那么可以使用nginx快速实现，这样就不用编写程序响应请求了，可以减少服务器资源占用并且响应性能非常快。</p>
<p>实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;get_text &#123;</span><br><span class="line">	#这里也可以设置成text&#x2F;plain</span><br><span class="line"> default_type text&#x2F;html;</span><br><span class="line"> return 200 &quot;This is nginx&#39;s text&quot;;</span><br><span class="line">&#125;</span><br><span class="line">location &#x2F;get_json&#123;</span><br><span class="line"> default_type application&#x2F;json;</span><br><span class="line"> return 200 &#39;&#123;&quot;name&quot;:&quot;TOM&quot;,&quot;age&quot;:18&#125;&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="自定义服务日志"><a href="#自定义服务日志" class="headerlink" title="自定义服务日志"></a>自定义服务日志</h4><p>Nginx中日志的类型分access.log、error.log。</p>
<p>access.log:用来记录用户所有的访问请求。</p>
<p>error.log:记录nginx本身运行时的错误信息，不会记录用户的访问请求。</p>
<p>Nginx服务器支持对服务日志的格式、大小、输出等进行设置，需要使用到两个指令，分别是access_log和log_format指令。</p>
<p>（1）access_log:用来设置用户访问日志的相关属性，默认值access_log logs/access.log combined;</p>
<p>​    <code>  access_log path[format[buffer=size]]</code></p>
<p>（2）log_format:用来指定日志的输出格式，默认值  log_format combined “…”;</p>
<p>​    <code>  log_format name [escape=default\json\none] string....;</code></p>
<h4 id="其他配置指令"><a href="#其他配置指令" class="headerlink" title="其他配置指令"></a>其他配置指令</h4><p>（1）sendfile:用来设置Nginx服务器是否使用sendfile()传输文件，该属性打开可以大大提高Nginx处理静态资源的性能，并且可以同时配置<code>tcp_nopush on</code>和<code>tcp_nodelay on</code>来提高处理静态资源的性能，默认值：<code>sendfile off;</code></p>
<p><code>  sendfile on\off；</code></p>
<p>（2）keepalive_timeout:用来设置长连接的超时时间，默认值<code>  keepalive_timeout 75s;</code></p>
<p>​    <code>  keepalive_timeout time;</code></p>
<blockquote>
<p>我们都知道HTTP是一种无状态协议，客户端向服务端发送一个TCP请求，服务端响应完毕后断开连接。<br>如何客户端向服务端发送多个请求，每个请求都需要重新创建一次连接，效率相对来说比较多，使用keepalive模式，可以告诉服务器端在处理完一个请求后保持这个TCP连接的打开状态，若接收到来自这个客户端的其他请求，服务端就会利用这个未被关闭的连接，而不需要重新创建一个新连接，提升效率，但是这个连接也不能一直保持，这样的话，连接如果过多，也会是服务端的性能下降，这个时候就需要我们进行设置其的超时时间。</p>
</blockquote>
<p>（3）keepalive_requests:用来设置一个keep-alive连接使用的次数，默认值<code>keepalive_requests 100;</code></p>
<pre><code>  `keepalive_requests number;`
</code></pre>
<h3 id="server块和location块"><a href="#server块和location块" class="headerlink" title="server块和location块"></a>server块和location块</h3><p>server 块可以包含多个 location 块，location 指令用于匹配 uri</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">		# 配置监听端口和主机名称</span><br><span class="line">		listen 8081;</span><br><span class="line">		# 配置的域名</span><br><span class="line">		server_name localhost;</span><br><span class="line">		# 配置请求处理日志存放路径</span><br><span class="line">		access_log &#x2F;home&#x2F;www&#x2F;myweb&#x2F;server1&#x2F;logs&#x2F;access.log server1;</span><br><span class="line">		# 配置错误页面</span><br><span class="line">		error_page 404 &#x2F;404.html;</span><br><span class="line">		# 配置处理&#x2F;server1&#x2F;location1请求的location</span><br><span class="line">		location &#x2F;server1&#x2F;location1&#123;</span><br><span class="line">			root &#x2F;home&#x2F;www&#x2F;myweb;</span><br><span class="line">			index index_sr1_location1.html;</span><br><span class="line">		&#125;</span><br><span class="line">		#配置处理&#x2F;server1&#x2F;location2请求的location</span><br><span class="line">		location &#x2F;server1&#x2F;location2&#123;</span><br><span class="line">			root &#x2F;home&#x2F;www&#x2F;myweb;</span><br><span class="line">			index index_sr1_location2.html;</span><br><span class="line">		&#125;</span><br><span class="line">		#配置错误页面转向</span><br><span class="line">		location &#x3D; &#x2F;404.html &#123;</span><br><span class="line">			root &#x2F;home&#x2F;www&#x2F;myweb;</span><br><span class="line">			index 404.html;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>后文会进行详细介绍</p>
</blockquote>
<h2 id="Nginx静态资源部署"><a href="#Nginx静态资源部署" class="headerlink" title="Nginx静态资源部署"></a>Nginx静态资源部署</h2><h3 id="Nginx静态资源的配置指令"><a href="#Nginx静态资源的配置指令" class="headerlink" title="Nginx静态资源的配置指令"></a>Nginx静态资源的配置指令</h3><h4 id="listen指令"><a href="#listen指令" class="headerlink" title="listen指令"></a>listen指令</h4><p>listen：用来配置监听端口，默认值为listen *:80 | *:8000</p>
<p><code>listen address[:port] [default_server]...;或者listen port [default_server]...;</code></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen 127.0.0.1:8000; &#x2F;&#x2F; listen localhost:8000 监听指定的IP和端口</span><br><span class="line">listen 127.0.0.1;	&#x2F;&#x2F;监听指定IP的所有端口</span><br><span class="line">listen 8000;	&#x2F;&#x2F;监听指定端口上的连接</span><br><span class="line">listen *:8000;	&#x2F;&#x2F;监听指定端口上的连接</span><br></pre></td></tr></table></figure>
<blockquote>
<p>default_server属性是标识符，用来将此虚拟主机设置成默认主机。所谓的默认主机指的是如果没有匹配到对应的address:port，则会默认执行的。如果不指定默认使用的是第一个server。</p>
</blockquote>
<h4 id="server-name指令"><a href="#server-name指令" class="headerlink" title="server_name指令"></a>server_name指令</h4><p>server_name：用来设置虚拟主机服务名称，默认值为server_name  “”;</p>
<p><code>server_name  name ...;</code></p>
<p>三种配合方式：</p>
<ul>
<li>精确匹配：<code>server_name www.123.cn www.1234.cn;</code></li>
<li>使用通配符配置：<code>server_name  *.123.cn    www.1234.*;</code>(需要注意的是通配符不能出现在域名的中间，只能出现在首段或尾段)</li>
<li>使用正则表达式配置：<code>server_name ~^www\.(\w+)\.com$;</code></li>
</ul>
<blockquote>
<p>匹配执行顺序为：</p>
<ol>
<li>准确匹配server_name</li>
<li>通配符在开始时匹配server_name成功</li>
<li>通配符在结束时匹配server_name成功</li>
<li>正则表达式匹配server_name成功</li>
<li>被默认的default_server处理，如果没有指定默认找第一个server</li>
</ol>
</blockquote>
<h4 id="location指令"><a href="#location指令" class="headerlink" title="location指令"></a>location指令</h4><p>location:用来设置请求的URI。</p>
<p><code>location [  =  |   ~  |  ~*   |   ^~   |@ ] uri&#123;...&#125;</code></p>
<p>属性介绍:</p>
<ul>
<li>不带符号，要求必须以指定模式开始</li>
<li>= :  用于不包含正则表达式的uri前，必须与指定的模式精确匹配</li>
<li>^~：用于不含正则表达式的 uri； 前，表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找</li>
<li>~ ： 用于表示当前uri中包含了正则表达式，并且区分大小写</li>
<li>~*:  用于表示当前uri中包含了正则表达式，并且不区分大小写</li>
</ul>
<h4 id="root-指令"><a href="#root-指令" class="headerlink" title="root 指令"></a>root 指令</h4><p>root：设置请求的根目录，默认值root html;</p>
<p><code>root path;</code></p>
<h4 id="alias指令"><a href="#alias指令" class="headerlink" title="alias指令"></a>alias指令</h4><p>alias：用来更改location的URI</p>
<p><code>alias path;</code></p>
<blockquote>
<p>alias指令与root指令的区别在于：</p>
<p>root的处理结果是: root路径+location路径<br>alias的处理结果是:使用alias路径替换location路径<br>alias是一个目录别名的定义，root则是最上层目录的含义。<br>如果location路径是以/结尾,则alias也必须是以/结尾，root没有要求</p>
</blockquote>
<h4 id="index指令"><a href="#index指令" class="headerlink" title="index指令"></a>index指令</h4><p>index:设置网站的默认首页，默认值index index.html;</p>
<p><code>  index file ...;</code></p>
<h4 id="error-page指令"><a href="#error-page指令" class="headerlink" title="error_page指令"></a>error_page指令</h4><p>error_page:设置网站的错误页面</p>
<p><code>error_page code ... [=[response]] uri;</code></p>
<p>例子：</p>
<p>（1）可以指定具体跳转的地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	error_page 404 http:&#x2F;&#x2F;www.baidu.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）可以指定重定向地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	error_page 404 &#x2F;50x.html;</span><br><span class="line">	error_page 500 502 503 504 &#x2F;50x.html;</span><br><span class="line">	location &#x3D;&#x2F;50x.html&#123;</span><br><span class="line">		root html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）使用location的@符合完成错误信息展示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	error_page 404 @jump_to_error;</span><br><span class="line">	location @jump_to_error &#123;</span><br><span class="line">		default_type text&#x2F;plain;</span><br><span class="line">		return 404 &#39;Not Found Page...&#39;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可选项<code>=[response]</code>的作用是用来将相应代码更改为另外一个</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	error_page 404 &#x3D;200 &#x2F;50x.html;</span><br><span class="line">	location &#x3D;&#x2F;50x.html&#123;</span><br><span class="line">		root html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">这样的话，当返回404找不到对应的资源的时候，在浏览器上可以看到，最终返回的状态码是200，这块需要注意下，编写error_page后面的内容，404后面需要加空格，200前面不能加空格</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="静态资源优化配置指令"><a href="#静态资源优化配置指令" class="headerlink" title="静态资源优化配置指令"></a>静态资源优化配置指令</h3><h4 id="sendﬁle指令"><a href="#sendﬁle指令" class="headerlink" title="sendﬁle指令"></a>sendﬁle指令</h4><p>sendﬁle：用来开启高效的文件传输模式，默认值为sendﬁle oﬀ;</p>
<p><code>sendﬁle on|oﬀ;</code></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/1587665814562.png" alt="1587665814562"></p>
<h4 id="tcp-nopush指令"><a href="#tcp-nopush指令" class="headerlink" title="tcp_nopush指令"></a>tcp_nopush指令</h4><p>tcp_nopush：该指令必须在sendfile打开的状态下才会生效，主要是用来提升网络包的传输’效率’，默认值为tcp_nopush oﬀ;</p>
<p><code>tcp_nopush on|off;</code></p>
<h4 id="tcp-nodelay指令"><a href="#tcp-nodelay指令" class="headerlink" title="tcp_nodelay指令"></a>tcp_nodelay指令</h4><p>tcp_nodelay：该指令必须在keep-alive连接开启的情况下才生效，来提高网络包传输的’实时性’，默认值为  tcp_nodelay on;</p>
<p><code>  tcp_nodelay on|off;</code></p>
<blockquote>
<p>TCP_NOPUSH可以与TCP_NODELAY一起设置(在linux2.5.9以后的版本中两者是可以兼容的)，它比单独配置TCP_NODELAY具有更强的性能。</p>
</blockquote>
<h3 id="静态资源的压缩"><a href="#静态资源的压缩" class="headerlink" title="静态资源的压缩"></a>静态资源的压缩</h3><h4 id="Gzip模块配置指令"><a href="#Gzip模块配置指令" class="headerlink" title="Gzip模块配置指令"></a>Gzip模块配置指令</h4><h5 id="gzip指令"><a href="#gzip指令" class="headerlink" title="gzip指令"></a>gzip指令</h5><p>gzip指令：该指令用于开启或者关闭gzip功能，默认值为  gzip off;</p>
<p><code>  gzip on|off;</code></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">   gzip on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="gzip-buffers指令"><a href="#gzip-buffers指令" class="headerlink" title="gzip_buffers指令"></a>gzip_buffers指令</h5><p>gzip_buffers指令：该指令用于处理请求压缩的缓冲区数量和大小。，默认值为  gzip_buffers 32 4k|16 8k;</p>
<p><code>  gzip_buffers number size;;</code></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip_buffers 4 16K;	  #缓存空间大小</span><br></pre></td></tr></table></figure>
<h5 id="gzip-disable指令"><a href="#gzip-disable指令" class="headerlink" title="gzip_disable指令"></a>gzip_disable指令</h5><p>gzip_disable指令：针对不同种类客户端发起的请求，可以选择性地开启和关闭Gzip功能。</p>
<p><code>  gzip_disable regex ...;</code></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br></pre></td></tr></table></figure>
<h5 id="gzip-types指令"><a href="#gzip-types指令" class="headerlink" title="gzip_types指令"></a>gzip_types指令</h5><p>gzip_types指令：该指令可以根据响应页的MIME类型选择性地开启Gzip压缩功能，默认值为  gzip_types text/html;</p>
<p><code>  gzip_types mime-type ...;</code></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">	gzip_types application&#x2F;javascript;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="gzip-comp-level指令"><a href="#gzip-comp-level指令" class="headerlink" title="gzip_comp_level指令"></a>gzip_comp_level指令</h5><p>gzip_comp_level指令：该指令用于设置Gzip压缩程度，级别从1-9,1表示要是程度最低，要是效率最高，9刚好相反，压缩程度最高，但是效率最低最费时间。，默认值为    gzip_comp_level 1;</p>
<p><code>  gzip_comp_level level;</code></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">	gzip_comp_level 6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="gzip-vary指令"><a href="#gzip-vary指令" class="headerlink" title="gzip_vary指令"></a>gzip_vary指令</h5><p>gzip_vary指令：该指令用于设置使用Gzip进行压缩发送是否携带“Vary:Accept-Encoding”头域的响应头部。主要是告诉接收方，所发送的数据经过了Gzip压缩处理，默认值为    gzip_vary off;</p>
<p><code>  gzip_vary on|off;</code></p>
<h5 id="gzip-http-version指令"><a href="#gzip-http-version指令" class="headerlink" title="gzip_http_version指令"></a>gzip_http_version指令</h5><p>gzip_http_version指令：针对不同的HTTP协议版本，可以选择性地开启和关闭Gzip功能，默认值为gzip_http_version 1.1;</p>
<p><code>  gzip_http_version 1.0|1.1;</code></p>
<h5 id="gzip-min-length指令"><a href="#gzip-min-length指令" class="headerlink" title="gzip_min_length指令"></a>gzip_min_length指令</h5><p>gzip_min_length指令：该指令针对传输数据的大小，可以选择性地开启和关闭Gzip功能，默认值为      gzip_min_length 20;</p>
<p><code> gzip_min_length length;</code></p>
<h5 id="gzip-proxied指令"><a href="#gzip-proxied指令" class="headerlink" title="gzip_proxied指令"></a>gzip_proxied指令</h5><p>gzip_proxied指令：该指令设置是否对服务端返回的结果进行Gzip压缩，默认值为    gzip_proxied off;</p>
<p><code>  gzip_proxied  off|expired|no-cache|no-store|private|no_last_modified|no_etag|auth|any;</code></p>
<p>属性说明：</p>
<ul>
<li>off - 关闭Nginx服务器对后台服务器返回结果的Gzip压缩</li>
<li>expired - 启用压缩，如果header头中包含 “Expires” 头信息</li>
<li>no-cache - 启用压缩，如果header头中包含 “Cache-Control:no-cache” 头信息</li>
<li>no-store - 启用压缩，如果header头中包含 “Cache-Control:no-store” 头信息</li>
<li>private - 启用压缩，如果header头中包含 “Cache-Control:private” 头信息</li>
<li>no_last_modified - 启用压缩,如果header头中不包含 “Last-Modified” 头信息</li>
<li>no_etag - 启用压缩 ,如果header头中不包含 “ETag” 头信息</li>
<li>auth - 启用压缩 , 如果header头中包含 “Authorization” 头信息</li>
<li>any - 无条件启用压缩</li>
</ul>
<blockquote>
<p>前面在讲解sendfile的时候，提到过，开启sendfile以后，在读取磁盘上的静态资源文件的时候，可以减少拷贝的次数，可以不经过用户进程将静态文件通过网络设备发送出去，但是Gzip要想对资源压缩，是需要经过用户进程进行操作的。</p>
<p>可以使用ngx_http_gzip_static_module模块的gzip_static指令来解决。</p>
<p>安装ngx_http_gzip_static_module</p>
<p>(1)查询当前Nginx的配置参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -V</span><br></pre></td></tr></table></figure>

<p>(2)将nginx安装目录下sbin目录中的nginx二进制文件进行更名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin</span><br><span class="line">mv nginx nginxold</span><br></pre></td></tr></table></figure>

<p>(3) 进入Nginx的安装目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;root&#x2F;nginx&#x2F;core&#x2F;nginx-1.16.1</span><br></pre></td></tr></table></figure>

<p>(4)执行make clean清空之前编译的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure>

<p>(5)使用configure来配置参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --with-http_gzip_static_module</span><br></pre></td></tr></table></figure>

<p>(6)使用make命令进行编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>(7) 将objs目录下的nginx二进制执行文件移动到nginx安装目录下的sbin目录中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv objs&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin</span><br></pre></td></tr></table></figure>

<p>(8)执行更新命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make upgrade</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h3><h5 id="Nginx缓存的执行流程"><a href="#Nginx缓存的执行流程" class="headerlink" title="Nginx缓存的执行流程"></a>Nginx缓存的执行流程</h5><p>（1）用户首次通过浏览器发送请求到服务端获取数据，客户端是没有对应的缓存，所以需要发送request请求来获取数据；</p>
<p>（2）服务端接收到请求后，获取服务端的数据及服务端缓存的允许后，返回200的成功状态码并且在响应头上附上对应资源以及缓存信息；</p>
<p>（3）当用户再次访问相同资源的时候，客户端会在浏览器的缓存目录中查找是否存在响应的缓存文件</p>
<p>（4）如果没有找到对应的缓存文件，则走(2)步</p>
<p>（5）如果有缓存文件，接下来对缓存文件是否过期进行判断，过期的判断标准是(Expires),</p>
<p>（6）如果没有过期，则直接从本地缓存中返回数据进行展示</p>
<p>（7）如果Expires过期，接下来需要判断缓存文件是否发生过变化</p>
<p>（8）判断的标准有两个，一个是ETag(Entity Tag),一个是Last-Modified</p>
<p>（9）判断结果是未发生变化，则服务端返回304，直接从缓存文件中获取数据</p>
<p>（10）如果判断是发生了变化，重新从服务端获取数据，并根据缓存协商(服务端所设置的是否需要进行缓存数据的设置)来进行数据缓存。</p>
<h4 id="Nginx缓存相关指令"><a href="#Nginx缓存相关指令" class="headerlink" title="Nginx缓存相关指令"></a>Nginx缓存相关指令</h4><h5 id="expires指令"><a href="#expires指令" class="headerlink" title="expires指令"></a>expires指令</h5><p>expires:该指令用来控制页面缓存的作用。可以通过该指令控制HTTP应答中的“Expires”和”Cache-Control”，默认值为expires off;</p>
<p><code>expires [modified] time</code> 或者<code>expires epoch\|max\|off;</code></p>
<h5 id="add-header指令"><a href="#add-header指令" class="headerlink" title="add_header指令"></a>add_header指令</h5><p>add_header指令是用来添加指定的响应头和响应值。</p>
<p><code>add_header name value [always];</code></p>
<h5 id="Cache-Control指令"><a href="#Cache-Control指令" class="headerlink" title="Cache-Control指令"></a>Cache-Control指令</h5><p>Cache-Control作为响应头信息，可以设置如下值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-control: must-revalidate</span><br><span class="line">Cache-control: no-cache</span><br><span class="line">Cache-control: no-store</span><br><span class="line">Cache-control: no-transform</span><br><span class="line">Cache-control: public</span><br><span class="line">Cache-control: private</span><br><span class="line">Cache-control: proxy-revalidate</span><br><span class="line">Cache-Control: max-age&#x3D;&lt;seconds&gt;</span><br><span class="line">Cache-control: s-maxage&#x3D;&lt;seconds&gt;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>must-revalidate</td>
<td>可缓存但必须再向源服务器进行确认</td>
</tr>
<tr>
<td>no-cache</td>
<td>缓存前必须确认其有效性</td>
</tr>
<tr>
<td>no-store</td>
<td>不缓存请求或响应的任何内容</td>
</tr>
<tr>
<td>no-transform</td>
<td>代理不可更改媒体类型</td>
</tr>
<tr>
<td>public</td>
<td>可向任意方提供响应的缓存</td>
</tr>
<tr>
<td>private</td>
<td>仅向特定用户返回响应</td>
</tr>
<tr>
<td>proxy-revalidate</td>
<td>要求中间缓存服务器对缓存的响应有效性再进行确认</td>
</tr>
<tr>
<td>max-age=&lt;秒&gt;</td>
<td>响应最大Age值</td>
</tr>
<tr>
<td>s-maxage=&lt;秒&gt;</td>
<td>公共缓存服务器响应的最大Age值</td>
</tr>
</tbody></table>
<h3 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h3><p>使用add_header指令，该指令可以用来添加一些头信息</p>
<h4 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;getUser&#123;</span><br><span class="line">    add_header Access-Control-Allow-Origin *;</span><br><span class="line">    add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE;</span><br><span class="line">    default_type application&#x2F;json;</span><br><span class="line">    return 200 &#39;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;TOM&quot;,&quot;age&quot;:18&#125;&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重点是需要添加两个头信息，一个是<code>Access-Control-Allow-Origin</code>,<code>Access-Control-Allow-Methods</code></p>
</blockquote>
<h3 id="静态资源防盗链"><a href="#静态资源防盗链" class="headerlink" title="静态资源防盗链"></a>静态资源防盗链</h3><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>通过valid_referers指令</p>
<p><code>valid_referers none\|blocked\|server_names\|string...</code></p>
<p>属性说明：</p>
<ul>
<li><p>none: 如果Header中的Referer为空，允许访问</p>
</li>
<li><p>blocked:在Header中的Referer不为空，但是该值被防火墙或代理进行伪装过，如不带”http://“ 、”https://“等协议头的资源允许访问。</p>
</li>
<li><p>server_names:指定具体的域名或者IP</p>
</li>
<li><p>string: 可以支持正则表达式和*的字符串。如果是正则表达式，需要以<code>~</code>开头表示，例如</p>
</li>
</ul>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;images &#123;</span><br><span class="line">           valid_referers none blocked www.baidu.com 192.168.200.222 *.example.com example.*  www.example.org  ~\.google\.;</span><br><span class="line">           if ($invalid_referer)&#123;</span><br><span class="line">                return 403;</span><br><span class="line">           &#125;</span><br><span class="line">           root &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>nginx会通就过查看referer自动和valid_referers后面的内容进行匹配，如果匹配到了就将$invalid_referer变量置0，如果没有匹配到，则将$invalid_referer变量置为1，匹配的过程中不区分大小写。</p>
</blockquote>
<h3 id="Rewrite功能"><a href="#Rewrite功能" class="headerlink" title="Rewrite功能"></a>Rewrite功能</h3><p>Rewrite是Nginx服务器提供的一个重要基本功能，是Web服务器产品中几乎必备的功能。主要的作用是用来实现URL的重写。</p>
<h4 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h4><h5 id="set指令"><a href="#set指令" class="headerlink" title="set指令"></a>set指令</h5><p>set：该指令用来设置一个新的变量。</p>
<p><code>set $variable value;</code>(变量名称要用”$”作为变量的第一个字符，且不能与Nginx服务器预设的全局变量同名。)</p>
<blockquote>
<p>Rewrite常用全局变量</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$args</td>
<td>变量中存放了请求URL中的请求指令。比如<a href="http://192.168.200.133:8080/?arg1=value1&amp;args2=value2%E4%B8%AD%E7%9A%84&quot;arg1=value1&amp;arg2=value2&quot;%EF%BC%8C%E5%8A%9F%E8%83%BD%E5%92%8C$query_string%E4%B8%80%E6%A0%B7">http://192.168.200.133:8080?arg1=value1&amp;args2=value2中的&quot;arg1=value1&amp;arg2=value2&quot;，功能和$query_string一样</a></td>
</tr>
<tr>
<td>$http_user_agent</td>
<td>变量存储的是用户访问服务的代理信息(如果通过浏览器访问，记录的是浏览器的相关版本信息)</td>
</tr>
<tr>
<td>$host</td>
<td>变量存储的是访问服务器的server_name值</td>
</tr>
<tr>
<td>$document_uri</td>
<td>变量存储的是当前访问地址的URI。比如<a href="http://192.168.200.133/server?id=10&amp;name=zhangsan%E4%B8%AD%E7%9A%84&quot;/server&quot;%EF%BC%8C%E5%8A%9F%E8%83%BD%E5%92%8C$uri%E4%B8%80%E6%A0%B7">http://192.168.200.133/server?id=10&amp;name=zhangsan中的&quot;/server&quot;，功能和$uri一样</a></td>
</tr>
<tr>
<td>$document_root</td>
<td>变量存储的是当前请求对应location的root值，如果未设置，默认指向Nginx自带html目录所在位置</td>
</tr>
<tr>
<td>$content_length</td>
<td>变量存储的是请求头中的Content-Length的值</td>
</tr>
<tr>
<td>$content_type</td>
<td>变量存储的是请求头中的Content-Type的值</td>
</tr>
<tr>
<td>$http_cookie</td>
<td>变量存储的是客户端的cookie信息，可以通过add_header Set-Cookie ‘cookieName=cookieValue’来添加cookie数据</td>
</tr>
<tr>
<td>$limit_rate</td>
<td>变量中存储的是Nginx服务器对网络连接速率的限制，也就是Nginx配置中对limit_rate指令设置的值，默认是0，不限制。</td>
</tr>
<tr>
<td>$remote_addr</td>
<td>变量中存储的是客户端的IP地址</td>
</tr>
<tr>
<td>$remote_port</td>
<td>变量中存储了客户端与服务端建立连接的端口号</td>
</tr>
<tr>
<td>$remote_user</td>
<td>变量中存储了客户端的用户名，需要有认证模块才能获取</td>
</tr>
<tr>
<td>$scheme</td>
<td>变量中存储了访问协议</td>
</tr>
<tr>
<td>$server_addr</td>
<td>变量中存储了服务端的地址</td>
</tr>
<tr>
<td>$server_name</td>
<td>变量中存储了客户端请求到达的服务器的名称</td>
</tr>
<tr>
<td>$server_port</td>
<td>变量中存储了客户端请求到达服务器的端口号</td>
</tr>
<tr>
<td>$server_protocol</td>
<td>变量中存储了客户端请求协议的版本，比如”HTTP/1.1”</td>
</tr>
<tr>
<td>$request_body_file</td>
<td>变量中存储了发给后端服务器的本地文件资源的名称</td>
</tr>
<tr>
<td>$request_method</td>
<td>变量中存储了客户端的请求方式，比如”GET”,”POST”等</td>
</tr>
<tr>
<td>$request_filename</td>
<td>变量中存储了当前请求的资源文件的路径名</td>
</tr>
<tr>
<td>$request_uri</td>
<td>变量中存储了当前请求的URI，并且携带请求参数，比如<a href="http://192.168.200.133/server?id=10&amp;name=zhangsan%E4%B8%AD%E7%9A%84&quot;/server?id=10&amp;name=zhangsan&quot;">http://192.168.200.133/server?id=10&amp;name=zhangsan中的&quot;/server?id=10&amp;name=zhangsan&quot;</a></td>
</tr>
</tbody></table>
</blockquote>
<h5 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h5><p>if：该指令用来支持条件判断，并根据条件判断结果选择不同的Nginx配置。</p>
<p><code>if  (condition)&#123;...&#125;</code></p>
<p>支持写法：</p>
<ol>
<li>变量名。如果变量名对应的值为空或者是0，if都判断为false,其他条件为true。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ($param)&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. 使用&quot;&#x3D;&quot;和&quot;!&#x3D;&quot;比较变量和字符串是否相等，满足条件为true，不满足为false</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ($request_method &#x3D; POST)&#123;</span><br><span class="line">	return 405;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：此处和Java不太一样的地方是字符串不需要添加引号。</p>
<ol start="3">
<li><p>使用正则表达式对变量进行匹配，匹配成功返回true，否则返回false。变量与正则表达式之间使用”<del>“,”</del><em>“,”!<del>“,”!</del>\</em>“来连接。</p>
<p>“~”代表匹配正则表达式过程中区分大小写，</p>
<p>“~*“代表匹配正则表达式过程中不区分大小写</p>
<p>“!<del>“和”!</del>*“刚好和上面取相反值，如果匹配上返回false,匹配不上返回true</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE)&#123;</span><br><span class="line">	#$http_user_agent的值中是否包含MSIE字符串，如果包含返回true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：正则表达式字符串一般不需要加引号，但是如果字符串中包含”}”或者是”;”等字符时，就需要把引号加上。</p>
<ol start="4">
<li><p>判断请求的文件是否存在使用”-f”和”!-f”,</p>
<p>当使用”-f”时，如果请求的文件存在返回true，不存在返回false。</p>
<p>当使用”!f”时，如果请求文件不存在，但该文件所在目录存在返回true,文件和目录都不存在返回false,如果文件存在返回false</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (-f $request_filename)&#123;</span><br><span class="line">	#判断请求的文件是否存在</span><br><span class="line">&#125;</span><br><span class="line">if (!-f $request_filename)&#123;</span><br><span class="line">	#判断请求的文件是否不存在</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><p>判断请求的目录是否存在使用”-d”和”!-d”,</p>
<p>当使用”-d”时，如果请求的目录存在，if返回true，如果目录不存在则返回false</p>
<p>当使用”!-d”时，如果请求的目录不存在但该目录的上级目录存在则返回true，该目录和它上级目录都不存在则返回false,如果请求目录存在也返回false.</p>
</li>
<li><p>判断请求的目录或者文件是否存在使用”-e”和”!-e”</p>
<p>当使用”-e”,如果请求的目录或者文件存在时，if返回true,否则返回false.</p>
<p>当使用”!-e”,如果请求的文件和文件所在路径上的目录都不存在返回true,否则返回false</p>
</li>
<li><p>判断请求的文件是否可执行使用”-x”和”!-x”</p>
<p>当使用”-x”,如果请求的文件可执行，if返回true,否则返回false</p>
<p>当使用”!-x”,如果请求文件不可执行，返回true,否则返回false</p>
</li>
</ol>
<h5 id="break指令"><a href="#break指令" class="headerlink" title="break指令"></a>break指令</h5><p>break：该指令用于中断当前相同作用域中的其他Nginx配置。与该指令处于同一作用域的Nginx配置中，位于它前面的指令配置生效，位于后面的指令配置无效。</p>
<p>例子：</p>
<figure class="highlight plain"><figcaption><span>/&#123;</span></figcaption><table><tr><td class="code"><pre><span class="line">location &#x2F;&#123;</span><br><span class="line">	if ($param)&#123;</span><br><span class="line">		set $id $1;</span><br><span class="line">		break;</span><br><span class="line">		limit_rate 10k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="return指令"><a href="#return指令" class="headerlink" title="return指令"></a>return指令</h5><p>return：该指令用于完成对请求的处理，直接向客户端返回响应状态代码。在return后的所有Nginx配置都是无效的。</p>
<p><code>return code [text];</code>或者<code>return code URL;</code>或者<code>return URL;</code></p>
<p>属性说明：</p>
<ul>
<li><p>code:为返回给客户端的HTTP状态代理。可以返回的状态代码为0~999的任意HTTP状态代理</p>
</li>
<li><p>text:为返回给客户端的响应体内容，支持变量的使用</p>
</li>
<li><p>URL:为返回给客户端的URL地址</p>
</li>
</ul>
<h5 id="rewrite指令"><a href="#rewrite指令" class="headerlink" title="rewrite指令"></a>rewrite指令</h5><p>rewrite：该指令通过正则表达式的使用来改变URI。可以同时存在一个或者多个指令，按照顺序依次对URL进行匹配和处理。</p>
<p><code>rewrite regex replacement [flag];</code></p>
<p>属性说明：</p>
<ul>
<li><p>regex:用来匹配URI的正则表达式</p>
</li>
<li><p>replacement:匹配成功后，用于替换URI中被截取内容的字符串。如果该字符串是以”http://“或者”https://“开头的，则不会继续向下对URI进行其他处理，而是直接返回重写后的URI给客户端。</p>
</li>
<li><p>flag:用来设置rewrite对URI的处理行为，可选值有如下：</p>
<ul>
<li>last：终止继续在本location块中处理接收到的URI，并将此处重写的URI作为一个新的URI，使用各location块进行处理。该标志将重写后的URI重写在server块中执行，为重写后的URI提供了转入到其他location块的机会。</li>
<li>break：将此处重写的URI作为一个新的URI,在本块中继续进行处理。该标志将重写后的地址在当前的location块中执行，不会将新的URI转向其他的location块。</li>
<li>redirect：将重写后的URI返回给客户端，状态码为302，指明是临时重定向URl,主要用在replacement变量不是以”http:/“或者”https:/“”开头的情况。</li>
<li>permanent：将重写后的URI返回给客户端，状态码为301，指明是临时重定向URl,主要用在replacement变量不是以”http:/“或者”https://“开头的情况。</li>
</ul>
</li>
</ul>
<h5 id="rewrite-log指令"><a href="#rewrite-log指令" class="headerlink" title="rewrite_log指令"></a>rewrite_log指令</h5><p>rewrite_log：该指令配置是否开启URL重写日志的输出功能。</p>
<p><code>  rewrite_log on|off;</code>(开启后，URL重写的相关日志将以notice级别输出到error_log指令配置的日志文件汇总。)</p>
]]></content>
      <categories>
        <category>工具的使用</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx(二)代理服务</title>
    <url>/2022/11/23/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/Nginx/Nginx-%E4%BA%8C-%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="Nginx代理服务"><a href="#Nginx代理服务" class="headerlink" title="Nginx代理服务"></a>Nginx代理服务</h1><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>正向代理是一个位于客户端和目标服务器之间的代理服务器（中间服务器）。为了从目标服务器取得内容，客户端向代理服务器发送一个请求，<strong>并且指定目标服务器</strong>，之后代理向目标服务器转发请求，将获得的内容返回给客户端。正向代理的情况下，客户端必须要进行一些特殊的设置才能使用。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220817223642983.png" alt="image-20220817223642983"></p>
<p>在代理服务器中进行设置（这样让客户端直接向代理服务器发请求）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen  82;</span><br><span class="line">        resolver 8.8.8.8;</span><br><span class="line">        location &#x2F;&#123;</span><br><span class="line">                proxy_pass http:&#x2F;&#x2F;$host$request_uri;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>Nginx反向代理模块的指令是由<code>ngx_http_proxy_module</code>模块进行解析，该模块在安装Nginx的时候已经自己加装到Nginx中了</p>
<h3 id="基本的相关指令"><a href="#基本的相关指令" class="headerlink" title="基本的相关指令"></a>基本的相关指令</h3><h4 id="proxy-pass指令"><a href="#proxy-pass指令" class="headerlink" title="proxy_pass指令"></a>proxy_pass指令</h4><p>proxy_pass：该指令用来设置被代理服务器地址，可以是主机名称、IP地址加端口号形式。</p>
<p><code>proxy_pass URL;</code>(URL:为要设置的被代理服务器地址，包含传输协议(<code>http</code>,<code>https://</code>)、主机名称或IP地址加端口号、URI等要素。)</p>
<h4 id="proxy-set-header指令"><a href="#proxy-set-header指令" class="headerlink" title="proxy_set_header指令"></a>proxy_set_header指令</h4><p>proxy_set_header：该指令可以更改Nginx服务器接收到的客户端请求的请求头信息，然后将新的请求头发送给代理的服务器</p>
<p><code>proxy_set_header field value;</code></p>
<h4 id="proxy-redirect指令"><a href="#proxy-redirect指令" class="headerlink" title="proxy_redirect指令"></a>proxy_redirect指令</h4><p>proxy_redirect：该指令是用来重置头信息中的”Location”和”Refresh”的值。</p>
<p><code>proxy_redirect redirect replacement;</code>或<code>proxy_redirect default;</code>或<code>proxy_redirect off;</code></p>
<h3 id="Nginx的SSL相关指令"><a href="#Nginx的SSL相关指令" class="headerlink" title="Nginx的SSL相关指令"></a>Nginx的SSL相关指令</h3><h4 id="ssl指令"><a href="#ssl指令" class="headerlink" title="ssl指令"></a>ssl指令</h4><p>ssl:该指令用来在指定的服务器开启HTTPS,可以使用 listen 443 ssl,后面这种方式更通用些，默认值off。</p>
<p><code>ssl on|off;</code></p>
<h4 id="ssl-certificate指令"><a href="#ssl-certificate指令" class="headerlink" title="ssl_certificate指令"></a>ssl_certificate指令</h4><p>ssl_certificate:为当前这个虚拟主机指定一个带有PEM格式证书的证书。</p>
<p><code>ssl_certificate file;</code></p>
<h4 id="ssl-certificate-key指令"><a href="#ssl-certificate-key指令" class="headerlink" title="ssl_certificate_key指令"></a>ssl_certificate_key指令</h4><p>ssl_certificate_key:该指令用来指定PEM secret key文件的路径</p>
<p><code>ssl_ceritificate_key file;</code></p>
<h4 id="ssl-session-cache指令"><a href="#ssl-session-cache指令" class="headerlink" title="ssl_session_cache指令"></a>ssl_session_cache指令</h4><p>ssl_session_cache:该指令用来配置用于SSL会话的缓存</p>
<p><code>ssl_sesion_cache off|none|[builtin[:size]] [shared:name:size];</code></p>
<p>属性说明：</p>
<ul>
<li>off:禁用会话缓存，客户端不得重复使用会话</li>
<li>none:禁止使用会话缓存，客户端可以重复使用，但是并没有在缓存中存储会话参数</li>
<li>builtin:内置OpenSSL缓存，仅在一个工作进程中使用。</li>
<li>shared:所有工作进程之间共享缓存，缓存的相关信息用name和size来指定</li>
</ul>
<h4 id="ssl-session-timeout指令"><a href="#ssl-session-timeout指令" class="headerlink" title="ssl_session_timeout指令"></a>ssl_session_timeout指令</h4><p>ssl_session_timeout：开启SSL会话功能后，设置客户端能够反复使用储存在缓存中的会话参数时间。</p>
<p><code>ssl_session_timeout time;</code></p>
<h4 id="ssl-ciphers指令"><a href="#ssl-ciphers指令" class="headerlink" title="ssl_ciphers指令"></a>ssl_ciphers指令</h4><p>ssl_ciphers:指出允许的密码，密码指定为OpenSSL支持的格式</p>
<p><code>ssl_ciphers ciphers;</code></p>
<h4 id="ssl-prefer-server-ciphers指令"><a href="#ssl-prefer-server-ciphers指令" class="headerlink" title="ssl_prefer_server_ciphers指令"></a>ssl_prefer_server_ciphers指令</h4><p>ssl_prefer_server_ciphers：该指令指定是否服务器密码优先客户端密码</p>
<p><code>ssl_perfer_server_ciphers on|off;</code></p>
<h3 id="缓冲区的相关指令"><a href="#缓冲区的相关指令" class="headerlink" title="缓冲区的相关指令"></a>缓冲区的相关指令</h3><h4 id="proxy-buffering指令"><a href="#proxy-buffering指令" class="headerlink" title="proxy_buffering指令"></a>proxy_buffering指令</h4><p>proxy_buffering :该指令用来开启或者关闭代理服务器的缓冲区，默认值为on。</p>
<p><code>proxy_buffering on|off;</code></p>
<h4 id="proxy-buffers-指令"><a href="#proxy-buffers-指令" class="headerlink" title="proxy_buffers:指令"></a>proxy_buffers:指令</h4><p>proxy_buffers:该指令用来指定单个连接从代理服务器读取响应的缓存区的个数和大小。</p>
<p><code>proxy_buffers number size;</code></p>
<p>属性说明：</p>
<ul>
<li>number:缓冲区的个数</li>
<li>size:每个缓冲区的大小，缓冲区的总大小就是number*size</li>
</ul>
<h4 id="proxy-buffer-size指令"><a href="#proxy-buffer-size指令" class="headerlink" title="proxy_buffer_size指令"></a>proxy_buffer_size指令</h4><p>proxy_buffer_size:该指令用来设置从被代理服务器获取的第一部分响应数据的大小。保持与proxy_buffers中的size一致即可，当然也可以更小。</p>
<p><code>proxy_buffer_size size;</code></p>
<h4 id="proxy-busy-buffers-size指令"><a href="#proxy-busy-buffers-size指令" class="headerlink" title="proxy_busy_buffers_size指令"></a>proxy_busy_buffers_size指令</h4><p>proxy_busy_buffers_size：该指令用来限制同时处于BUSY状态的缓冲总大小。</p>
<p><code>proxy_busy_buffers_size size;</code></p>
<h4 id="proxy-temp-path指令"><a href="#proxy-temp-path指令" class="headerlink" title="proxy_temp_path指令"></a>proxy_temp_path指令</h4><p>proxy_temp_path:当缓冲区存满后，仍未被Nginx服务器完全接受，响应数据就会被临时存放在磁盘文件上，该指令设置文件路径</p>
<p><code>proxy_temp_path  path;</code>（注意path最多设置三层。  ）</p>
<h4 id="proxy-temp-file-write-size指令"><a href="#proxy-temp-file-write-size指令" class="headerlink" title="proxy_temp_file_write_size指令"></a>proxy_temp_file_write_size指令</h4><p>proxy_temp_file_write_size：该指令用来设置磁盘上缓冲文件的大小。</p>
<p><code>proxy_temp_file_write_size size;</code></p>
<blockquote>
<p>通用网站的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_buffering on;</span><br><span class="line">proxy_buffer_size 4 32k;</span><br><span class="line">proxy_busy_buffers_size 64k;</span><br><span class="line">proxy_temp_file_write_size 64k;</span><br></pre></td></tr></table></figure></blockquote>
]]></content>
      <categories>
        <category>工具的使用</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx(三)负载均衡</title>
    <url>/2022/11/24/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/Nginx/nginx-%E4%B8%89-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h1 id="Nginx负载均衡"><a href="#Nginx负载均衡" class="headerlink" title="Nginx负载均衡"></a>Nginx负载均衡</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>早期的网站流量和业务功能都比较简单，单台服务器足以满足基本的需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也跟着越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器进行性能的水平扩展及避免单点故障出现。</p>
<p>负载均衡就是一种将不同用户的请求流量分发到不同的服务器上的技术</p>
<h3 id="具体作用："><a href="#具体作用：" class="headerlink" title="具体作用："></a>具体作用：</h3><p>1、解决服务器的高并发压力，提高应用程序的处理性能。</p>
<p>2、提供故障转移，实现高可用。</p>
<p>3、通过添加或减少服务器数量，增强网站的可扩展性。</p>
<p>4、在负载均衡器上进行过滤，可以提高系统的安全性。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="手动选择"><a href="#手动选择" class="headerlink" title="手动选择"></a>手动选择</h3><p>这种方式比较原始，只要实现的方式就是在网站主页上面提供不同线路、不同服务器链接方式，让用户来选择自己访问的具体服务器，来实现负载均衡。</p>
<h3 id="DNS轮询"><a href="#DNS轮询" class="headerlink" title="DNS轮询"></a>DNS轮询</h3><p>大多域名注册商都支持对同一个主机名添加多条A记录，这就是DNS轮询，DNS服务器将解析请求按照A记录的顺序，随机分配到不同的IP上，这样就能完成简单的负载均衡。DNS轮询的成本非常低，在一些不重要的服务器，被经常使用。</p>
<blockquote>
<p>相当于一个域名绑定多个ip，让DNS进行轮询。</p>
<p>但是这种方式有两个缺点：</p>
<ol>
<li>可靠性低</li>
<li>负载均衡不均衡</li>
</ol>
</blockquote>
<h3 id="四-七层负载均衡"><a href="#四-七层负载均衡" class="headerlink" title="四/七层负载均衡"></a>四/七层负载均衡</h3><p>所谓四层负载均衡指的是OSI七层模型中的传输层，主要是基于IP+PORT的负载均衡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实现四层负载均衡的方式：</span><br><span class="line">硬件：F5 BIG-IP、Radware等</span><br><span class="line">软件：LVS、Nginx、Hayproxy等</span><br></pre></td></tr></table></figure>
<p>所谓的七层负载均衡指的是在应用层，主要是基于虚拟的URL或主机IP的负载均衡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实现七层负载均衡的方式：</span><br><span class="line">软件：Nginx、Hayproxy等</span><br></pre></td></tr></table></figure>
<blockquote>
<p>四层和七层负载均衡的区别：</p>
<ul>
<li>四层负载均衡数据包是在底层就进行了分发，而七层负载均衡数据包则在最顶端进行分发，所以四层负载均衡的效率比七层负载均衡的要高。</li>
<li>四层负载均衡不识别域名，而七层负载均衡识别域名。</li>
</ul>
</blockquote>
<h4 id="Nginx七层负载均衡"><a href="#Nginx七层负载均衡" class="headerlink" title="Nginx七层负载均衡"></a>Nginx七层负载均衡</h4><p>Nginx要实现七层负载均衡需要用到proxy_pass代理模块配置。Nginx默认安装支持这个模块，我们不需要再做任何处理。Nginx的负载均衡是在Nginx的反向代理基础上把用户的请求根据指定的算法分发到一组【upstream虚拟服务池】。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/1590248160635.png" alt="1590248160635"></p>
<h5 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h5><h6 id="upstream指令"><a href="#upstream指令" class="headerlink" title="upstream指令"></a>upstream指令</h6><p>upstream：该指令是用来定义一组服务器，它们可以是监听不同端口的服务器，并且也可以是同时监听TCP和Unix socket的服务器。服务器可以指定不同的权重，默认为1。</p>
<p><code>  upstream name &#123;...&#125;</code></p>
<h6 id="server指令"><a href="#server指令" class="headerlink" title="server指令"></a>server指令</h6><p>server：该指令用来指定后端服务器的名称和一些参数，可以使用域名、IP、端口或者unix socket</p>
<p><code>  server name [paramerters]</code></p>
<h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><ol>
<li><p>设置三台服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen   9001;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    default_type text&#x2F;html;</span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">    	return 200 &#39;&lt;h1&gt;192.168.200.146:9001&lt;&#x2F;h1&gt;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen   9002;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    default_type text&#x2F;html;</span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">    	return 200 &#39;&lt;h1&gt;192.168.200.146:9002&lt;&#x2F;h1&gt;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen   9003;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    default_type text&#x2F;html;</span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">    	return 200 &#39;&lt;h1&gt;192.168.200.146:9003&lt;&#x2F;h1&gt;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置负载均衡器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">	server 192.168.200.146:9091;</span><br><span class="line">	server 192.168.200.146:9092;</span><br><span class="line">	server 192.168.200.146:9093;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	listen 8083;</span><br><span class="line">	server_name localhost;</span><br><span class="line">	location &#x2F;&#123;</span><br><span class="line">		proxy_pass http:&#x2F;&#x2F;backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>代理服务器在负责均衡调度中的状态设置有以下几个：</strong></p>
<table>
<thead>
<tr>
<th>状态</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td>down</td>
<td>将该服务器标记为永久不可用，那么该代理服务器将不参与负载均衡。(该状态一般会对需要停机维护的服务器进行设置。)</td>
</tr>
<tr>
<td>backup</td>
<td>预留的备份服务器，默认为10秒，写法<code>fail_timeout=time</code></td>
</tr>
<tr>
<td>max_fails</td>
<td>允许请求失败的次数，默认为1，写法<code>max_fails=number</code></td>
</tr>
<tr>
<td>fail_timeout</td>
<td>经过max_fails失败后, 服务暂停时间</td>
</tr>
<tr>
<td>max_conns</td>
<td>限制最大的接收连接数，默认为0，写法<code>max_conns=number</code></td>
</tr>
</tbody></table>
<p><strong>负载均衡策略配置</strong></p>
<table>
<thead>
<tr>
<th>算法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>轮询</td>
<td>每个请求会按时间顺序逐个分配到不同的后端服务器。轮询不需要额外的配置。默认方式</td>
</tr>
<tr>
<td>weight</td>
<td>用来设置服务器的权重，默认为1，权重数据越大，被分配到请求的几率越大；写法<code>weight=number:</code></td>
</tr>
<tr>
<td>ip_hash</td>
<td>依据ip分配方式，将某个客户端IP的请求通过哈希算法定位到同一台后端服务器上（但是使用ip_hash指令无法保证后端服务器的负载均衡，可能导致有些后端服务器接收到的请求多，有些后端服务器接收的请求少，而且设置后端服务器权重等方法将不起作用。）</td>
</tr>
<tr>
<td>least_conn</td>
<td>依据最少连接方式，把请求转发给连接数较少的后端服务器</td>
</tr>
<tr>
<td>url_hash</td>
<td>依据URL分配方式，按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，要配合缓存命中来使用。</td>
</tr>
<tr>
<td>fair</td>
<td>可以根据页面大小、加载时间长短智能的进行负载均衡（需要添加<code>nginx-upstream-fair</code>）</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ol>
<h5 id="配置案例"><a href="#配置案例" class="headerlink" title="配置案例"></a>配置案例</h5><h6 id="案例一：对所有请求实现一般轮询规则的负载均衡"><a href="#案例一：对所有请求实现一般轮询规则的负载均衡" class="headerlink" title="案例一：对所有请求实现一般轮询规则的负载均衡"></a>案例一：对所有请求实现一般轮询规则的负载均衡</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">	server 192.168.200.146:9001;</span><br><span class="line">	server 192.168.200.146:9002;</span><br><span class="line">	server 192.168.200.146:9003;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	listen 8083;</span><br><span class="line">	server_name localhost;</span><br><span class="line">	location &#x2F;&#123;</span><br><span class="line">		proxy_pass http:&#x2F;&#x2F;backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="案例二：对所有请求实现加权轮询规则的负载均衡"><a href="#案例二：对所有请求实现加权轮询规则的负载均衡" class="headerlink" title="案例二：对所有请求实现加权轮询规则的负载均衡"></a>案例二：对所有请求实现加权轮询规则的负载均衡</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">	server 192.168.200.146:9001 weight&#x3D;7;</span><br><span class="line">	server 192.168.200.146:9002 weight&#x3D;5;</span><br><span class="line">	server 192.168.200.146:9003 weight&#x3D;3;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	listen 8083;</span><br><span class="line">	server_name localhost;</span><br><span class="line">	location &#x2F;&#123;</span><br><span class="line">		proxy_pass http:&#x2F;&#x2F;backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="案例三：对特定资源实现负载均衡"><a href="#案例三：对特定资源实现负载均衡" class="headerlink" title="案例三：对特定资源实现负载均衡"></a>案例三：对特定资源实现负载均衡</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream videobackend&#123;</span><br><span class="line">	server 192.168.200.146:9001;</span><br><span class="line">	server 192.168.200.146:9002;</span><br><span class="line">&#125;</span><br><span class="line">upstream filebackend&#123;</span><br><span class="line">	server 192.168.200.146:9003;</span><br><span class="line">	server 192.168.200.146:9004;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	listen 8084;</span><br><span class="line">	server_name localhost;</span><br><span class="line">	location &#x2F;video&#x2F; &#123;</span><br><span class="line">		proxy_pass http:&#x2F;&#x2F;videobackend;</span><br><span class="line">	&#125;</span><br><span class="line">	location &#x2F;file&#x2F; &#123;</span><br><span class="line">		proxy_pass http:&#x2F;&#x2F;filebackend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="案例四：对不同域名实现负载均衡"><a href="#案例四：对不同域名实现负载均衡" class="headerlink" title="案例四：对不同域名实现负载均衡"></a>案例四：对不同域名实现负载均衡</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream itcastbackend&#123;</span><br><span class="line">	server 192.168.200.146:9001;</span><br><span class="line">	server 192.168.200.146:9002;</span><br><span class="line">&#125;</span><br><span class="line">upstream itheimabackend&#123;</span><br><span class="line">	server 192.168.200.146:9003;</span><br><span class="line">	server 192.168.200.146:9004;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	listen	8085;</span><br><span class="line">	server_name www.baidu.cn;</span><br><span class="line">	location &#x2F; &#123;</span><br><span class="line">		proxy_pass http:&#x2F;&#x2F;baidubackend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	listen	8086;</span><br><span class="line">	server_name www.tenxun.cn;</span><br><span class="line">	location &#x2F; &#123;</span><br><span class="line">		proxy_pass http:&#x2F;&#x2F;tenxunbackend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="案例五：实现带有URL重写的负载均衡"><a href="#案例五：实现带有URL重写的负载均衡" class="headerlink" title="案例五：实现带有URL重写的负载均衡"></a>案例五：实现带有URL重写的负载均衡</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">	server 192.168.200.146:9001;</span><br><span class="line">	server 192.168.200.146:9002;</span><br><span class="line">	server 192.168.200.146:9003;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	listen	80;</span><br><span class="line">	server_name localhost;</span><br><span class="line">	location &#x2F;file&#x2F; &#123;</span><br><span class="line">		rewrite ^(&#x2F;file&#x2F;.*) &#x2F;server&#x2F;$1 last;</span><br><span class="line">	&#125;</span><br><span class="line">	location &#x2F; &#123;</span><br><span class="line">		proxy_pass http:&#x2F;&#x2F;backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Nginx四层负载均衡"><a href="#Nginx四层负载均衡" class="headerlink" title="Nginx四层负载均衡"></a>Nginx四层负载均衡</h4><p>Nginx在1.9之后，增加了一个stream模块，用来实现四层协议的转发、代理、负载均衡等。stream模块的用法跟http的用法类似，允许我们配置一组TCP或者UDP等协议的监听，然后通过proxy_pass来转发我们的请求，通过upstream添加多个后端服务，实现负载均衡。</p>
<h5 id="添加stream模块的支持"><a href="#添加stream模块的支持" class="headerlink" title="添加stream模块的支持"></a>添加stream模块的支持</h5><p>Nginx默认是没有编译这个模块的，需要使用到stream模块，那么需要在编译的时候加上<code>--with-stream</code>。</p>
<p>完成添加<code>--with-stream</code>的实现步骤:</p>
<ul>
<li>将原有/usr/local/nginx/sbin/nginx进行备份</li>
<li>拷贝nginx之前的配置信息</li>
<li>在nginx的安装源码进行配置指定对应模块  ./configure –with-stream</li>
<li>通过make模板进行编译</li>
<li>将objs下面的nginx移动到/usr/local/nginx/sbin下</li>
<li>在源码目录下执行  make upgrade进行升级，这个可以实现不停机添加新模块的功能</li>
</ul>
<h5 id="Nginx四层负载均衡的指令"><a href="#Nginx四层负载均衡的指令" class="headerlink" title="Nginx四层负载均衡的指令"></a>Nginx四层负载均衡的指令</h5><h6 id="stream指令"><a href="#stream指令" class="headerlink" title="stream指令"></a>stream指令</h6><p>stream：该指令提供在其中指定流服务器指令的配置文件上下文。和http指令同级。</p>
<p><code>stream &#123; ... &#125;</code></p>
<h6 id="upstream指令-1"><a href="#upstream指令-1" class="headerlink" title="upstream指令"></a>upstream指令</h6><p>upstream：该指令和http的upstream指令是类似的。</p>
<h5 id="配置案例-1"><a href="#配置案例-1" class="headerlink" title="配置案例"></a>配置案例</h5><p>nginx.conf配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">        upstream redisbackend &#123;</span><br><span class="line">                server 192.168.200.146:6379;</span><br><span class="line">                server 192.168.200.146:6378;</span><br><span class="line">        &#125;</span><br><span class="line">        upstream tomcatbackend &#123;</span><br><span class="line">        		server 192.168.200.146:8080;</span><br><span class="line">        &#125;</span><br><span class="line">        server &#123;</span><br><span class="line">                listen  81;</span><br><span class="line">                proxy_pass redisbackend;</span><br><span class="line">        &#125;</span><br><span class="line">        server &#123;</span><br><span class="line">        		listen	82;</span><br><span class="line">        		proxy_pass tomcatbackend;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/1604495169905.png" alt="1604495169905"></p>
<p>很明显我们需要两台以上的Nginx服务器对外提供服务，这样的话就可以解决其中一台宕机了，另外一台还能对外提供服务，但是如果是两台Nginx服务器的话，会有两个IP地址，用户该访问哪台服务器，用户怎么知道哪台是好的，哪台是宕机了的?</p>
<p>这里使用Keepalived来解决该问题</p>
<h3 id="Keepalived"><a href="#Keepalived" class="headerlink" title="Keepalived"></a>Keepalived</h3><p>Keepalived 软件由 C 编写的，最初是专为 LVS 负载均衡软件设计的，Keepalived 软件主要是通过 VRRP 协议实现高可用功能。</p>
<h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><ul>
<li>keepalived的安装</li>
</ul>
<ol>
<li><p>从官方网站下载keepalived,官网地址<a href="https://keepalived.org/">https://keepalived.org/</a></p>
</li>
<li><p>将下载的资源上传到服务器</p>
<pre><code>keepalived-2.0.20.tar.gz
</code></pre>
</li>
<li><p>创建keepalived目录，方便管理资源</p>
<pre><code>mkdir keepalived
</code></pre>
</li>
<li><p>将压缩文件进行解压缩，解压缩到指定的目录</p>
<pre><code>tar -zxf keepalived-2.0.20.tar.gz -C keepalived/
</code></pre>
</li>
<li><p>对keepalived进行配置，编译和安装</p>
<pre><code>cd keepalived/keepalived-2.0.20
./configure --sysconf=/etc --prefix=/usr/local
make &amp;&amp; make install
</code></pre>
<p>安装完成后，有两个文件需要我们认识下，一个是 <code>/etc/keepalived/keepalived.conf</code>(keepalived的系统配置文件，我们主要操作的就是该文件)，一个是/usr/local/sbin目录下的<code>keepalived</code>,是系统配置脚本，用来启动和关闭keepalived</p>
<blockquote>
<p>Keepalived配置文件介绍：</p>
<p>里面会分三部，第一部分是global全局配置、第二部分是vrrp相关配置、第三部分是LVS相关配置（这里没有用到）。</p>
<ul>
<li><p>global全局部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">   #通知邮件，当keepalived发生切换时需要发email给具体的邮箱地址</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     1369281736@qq.com</span><br><span class="line">   &#125;</span><br><span class="line">   #设置发件人的邮箱信息</span><br><span class="line">   notification_email_from 315850054@qq.com</span><br><span class="line">   #指定smpt服务地址</span><br><span class="line">   smtp_server 192.168.200.1</span><br><span class="line">   #指定smpt服务连接超时时间</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   #运行keepalived服务器的一个标识，可以用作发送邮件的主题信息</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line"></span><br><span class="line">   #默认是不跳过检查。检查收到的VRRP通告中的所有地址可能会比较耗时，设置此命令的意思是，如果通告与接收的上一个通告来自相同的master路由器，则不执行检查(跳过检查)</span><br><span class="line">   vrrp_skip_check_adv_addr</span><br><span class="line">   #严格遵守VRRP协议。</span><br><span class="line">   vrrp_strict</span><br><span class="line">   #在一个接口发送的两个免费ARP之间的延迟。可以精确到毫秒级。默认是0</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   #在一个网卡上每组na消息之间的延迟时间，默认为0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>VRRP部分（该部分可以包含以下四个子模块：vrrp_script、vrrp_sync_group、garp_group、vrrp_instance）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#设置keepalived实例的相关信息，VI_1为VRRP实例名称</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER  		#有两个值可选MASTER主 BACKUP备</span><br><span class="line">    interface ens33		#vrrp实例绑定的接口，用于发送VRRP包[当前服务器使用的网卡名称]</span><br><span class="line">    virtual_router_id 51#指定VRRP实例ID，范围是0-255</span><br><span class="line">    priority 100		#指定优先级，优先级高的将成为MASTER</span><br><span class="line">    advert_int 1		#指定发送VRRP通告的间隔，单位是秒</span><br><span class="line">    authentication &#123;	#vrrp之间通信的认证信息</span><br><span class="line">        auth_type PASS	#指定认证方式。PASS简单密码认证(推荐)</span><br><span class="line">        auth_pass 1111	#指定认证使用的密码，最多8位</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123; #虚拟IP地址设置虚拟IP地址，供用户访问使用，可设置多个，一行一个</span><br><span class="line">        192.168.200.222</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li><p>对两个nginx服务器的keepalived进行配置</p>
<p>主服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">        1369281736@qq.com</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from 315850054@qq.com</span><br><span class="line">   smtp_server 192.168.200.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id keepalived1</span><br><span class="line">   vrrp_skip_check_adv_addr</span><br><span class="line">   vrrp_strict</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.200.222</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>副服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">        1369281736@qq.com</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from 315850054@qq.com</span><br><span class="line">   smtp_server 192.168.200.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id keepalived2</span><br><span class="line">   vrrp_skip_check_adv_addr</span><br><span class="line">   vrrp_strict</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 90</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.200.222</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>分别启动两台服务器的keepalived</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;sbin</span><br><span class="line">.&#x2F;keepalived</span><br></pre></td></tr></table></figure>
<p>搭建后的结构：</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/1604495442179.png" alt="1604495442179"></p>
<blockquote>
<p>这样虚拟IP(VIP)会在MASTER节点上，当MASTER节点上的keepalived出问题以后，因为BACKUP无法收到MASTER发出的VRRP状态通过信息，就会直接升为MASTER。VIP也会”漂移”到新的MASTER。</p>
<p><strong>问题优化：</strong></p>
<p>keepalived只能做到对网络故障和keepalived本身的监控，即当出现网络故障或者keepalived本身出现问题时，进行切换。但是这些还不够，我们还需要监控keepalived所在服务器上的其他业务，比如Nginx,如果Nginx出现异常了，仅仅keepalived保持正常，是无法完成系统的正常工作的，因此需要根据业务进程的运行状态决定是否需要进行主备切换，这个时候，我们可以通过编写脚本对业务进程进行检测监控。</p>
<p><strong>实现：</strong></p>
<ol>
<li>在keepalived配置文件中添加对应的配置像</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vrrp_script 脚本名称</span><br><span class="line">&#123;</span><br><span class="line">    script &quot;脚本位置&quot;</span><br><span class="line">    interval 3 #执行时间间隔</span><br><span class="line">    weight -20 #动态调整vrrp_instance的优先级</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写脚本</li>
</ol>
<p>ck_nginx.sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">num&#x3D;&#96;ps -C nginx --no-header | wc -l&#96;</span><br><span class="line">if [ $num -eq 0 ];then</span><br><span class="line"> &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br><span class="line"> sleep 2</span><br><span class="line"> if [ &#96;ps -C nginx --no-header | wc -l&#96; -eq 0 ]; then</span><br><span class="line">  killall keepalived</span><br><span class="line"> fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>Linux ps命令用于显示当前进程 (process) 的状态。</p>
<p>-C(command) :指定命令的所有进程</p>
<p>–no-header 排除标题</p>
<ol start="3">
<li>为脚本文件设置权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 755 ck_nginx.sh</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>将脚本添加到</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vrrp_script ck_nginx &#123;</span><br><span class="line">   script &quot;&#x2F;etc&#x2F;keepalived&#x2F;ck_nginx.sh&quot; #执行脚本的位置</span><br><span class="line">   interval 2		#执行脚本的周期，秒为单位</span><br><span class="line">   weight -20		#权重的计算方式</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 10</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.200.111</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">      ck_nginx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>工具的使用</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx(五)动静分离</title>
    <url>/2022/11/28/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/Nginx/nginx-%E4%BA%94-%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="Nginx动静分离"><a href="#Nginx动静分离" class="headerlink" title="Nginx动静分离"></a>Nginx动静分离</h1><p>因为Nginx在处理静态资源的时候，效率是非常高的，而且Nginx的并发访问量也是名列前茅，而Tomcat则相对比较弱一些，所以把静态资源交个Nginx后，可以减轻Tomcat服务器的访问压力并提高静态资源的访问速度。动静分离以后，降低了动态资源和静态资源的耦合度。如动态资源宕机了也不影响静态资源的展示。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>使用Nginx的反向代理，将请求转给Tomcat进行处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream webservice &#123;</span><br><span class="line">	server 192.168.200.146:8080; # web服务器的地址</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">    listen		80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location &#x2F;demo &#123;</span><br><span class="line">    	proxy_pass http:&#x2F;&#x2F;webservice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>1.将demo.war项目中的静态资源都删除掉，重新打包生成一个war包</p>
<p>2.将war包部署到tomcat中，把之前部署的内容删除掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进入到tomcat的webapps目录下，将之前的内容删除掉</span><br><span class="line">将新的war包复制到webapps下</span><br><span class="line">将tomcat启动</span><br></pre></td></tr></table></figure>
<p>3.在Nginx所在服务器创建如下目录，并将对应的静态资源放入指定的位置</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/1604493947499.png" alt="1604493947499"></p>
<p>其中index.html页面的内容如下:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">           $.get(<span class="string">&#x27;http://192.168.200.133/demo/getAddress&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">               $(<span class="string">&quot;#msg&quot;</span>).html(data);</span></span><br><span class="line">           &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/logo.png&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Nginx如何将请求转发到后端服务器<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/mv.png&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4.配置Nginx的静态资源与动态资源的访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream webservice&#123;</span><br><span class="line">   server 192.168.200.146:8080;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #动态资源</span><br><span class="line">        location &#x2F;demo &#123;</span><br><span class="line">                proxy_pass http:&#x2F;&#x2F;webservice;</span><br><span class="line">        &#125;</span><br><span class="line">        #静态资源</span><br><span class="line">        location ~&#x2F;.*\.(png|jpg|gif|js)&#123;</span><br><span class="line">                root html&#x2F;web;</span><br><span class="line">                gzip on;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html&#x2F;web;</span><br><span class="line">            index  index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具的使用</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx(六)制作下载站点</title>
    <url>/2022/11/29/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/Nginx/nginx-%E5%85%AD-%E5%88%B6%E4%BD%9C%E4%B8%8B%E8%BD%BD%E7%AB%99%E7%82%B9/</url>
    <content><![CDATA[<h1 id="制作下载站点"><a href="#制作下载站点" class="headerlink" title="制作下载站点"></a>制作下载站点</h1><h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><h3 id="相关命令："><a href="#相关命令：" class="headerlink" title="相关命令："></a>相关命令：</h3><ul>
<li><p>autoindex：启用或禁用目录列表输出 <code>autoindex on\|off;</code></p>
</li>
<li><p>autoindex_exact_size:对应HTLM格式，指定是否在目录列表展示文件的详细大小 <code>autoindex_exact_size  on|off;</code></p>
</li>
<li><p>autoindex_format：设置目录列表的格式 <code>autoindex_format html|xml|json|jsonp;</code></p>
</li>
<li><p>autoindex_localtime:对应HTML格式，是否在目录列表上显示时间 <code>autoindex_localtime on | off;</code></p>
</li>
</ul>
<h3 id="具体配置："><a href="#具体配置：" class="headerlink" title="具体配置："></a>具体配置：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;download&#123;</span><br><span class="line">    root &#x2F;usr&#x2F;local;</span><br><span class="line">    autoindex on;</span><br><span class="line">    autoindex_exact_size on;</span><br><span class="line">    autoindex_format html;</span><br><span class="line">    autoindex_localtime on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h2><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220823152020540.png" alt="image-20220823152020540"></p>
<blockquote>
<p>如果需要对下载资源进行权限验证可以配置来进行用户认证</p>
<ul>
<li><p>相关指令：</p>
<ul>
<li>auth_basic:使用“ HTTP基本认证”协议启用用户名和密码的验证 <code>auth_basic string|off;</code></li>
<li>auth_basic_user_file:指定用户名和密码所在文件 <code>auth_basic_user_file file;</code></li>
</ul>
</li>
<li><p>例子：</p>
<p>进行配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;download&#123;</span><br><span class="line">    root &#x2F;usr&#x2F;local;</span><br><span class="line">    autoindex on;</span><br><span class="line">    autoindex_exact_size on;</span><br><span class="line">    autoindex_format html;</span><br><span class="line">    autoindex_localtime on;</span><br><span class="line">    auth_basic &#39;please input your auth&#39;;</span><br><span class="line">    auth_basic_user_file htpasswd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安装httpd-tools：<code>yum install -y httpd-tools</code></p>
<p>生成账户密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x htpasswd -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;htpasswd username &#x2F;&#x2F;创建一个新文件记录用户名和密码htpasswd -b &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;htpasswd username password &#x2F;&#x2F;在指定文件新增一个用户名和密码htpasswd -D &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;htpasswd username &#x2F;&#x2F;从指定文件删除一个用户信息htpasswd -v &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;htpasswd username &#x2F;&#x2F;验证用户名和密码是否正确</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>工具的使用</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx(四)缓存集成</title>
    <url>/2022/11/26/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/Nginx/nginx-%E5%9B%9B-%E7%BC%93%E5%AD%98%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<h1 id="缓存集成"><a href="#缓存集成" class="headerlink" title="缓存集成"></a>缓存集成</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx是从0.7.48版开始提供缓存功能。Nginx是基于Proxy Store来实现的，其原理是把URL及相关组合当做Key,在使用MD5算法对Key进行哈希，得到硬盘上对应的哈希目录路径，从而将缓存内容保存在该目录中。</p>
<h2 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h2><h3 id="proxy-cache指令"><a href="#proxy-cache指令" class="headerlink" title="proxy_cache指令"></a>proxy_cache指令</h3><p>proxy_cache：该指令用来开启或关闭代理缓存，如果是开启则自定使用哪个缓存区来进行缓存。</p>
<p><code>proxy_cache zone_name|off;</code></p>
<p>属性说明：</p>
<ul>
<li>zone_name：指定使用缓存区的名称</li>
</ul>
<h3 id="proxy-cache-path指令"><a href="#proxy-cache-path指令" class="headerlink" title="proxy_cache_path指令"></a>proxy_cache_path指令</h3><p>proxy_cache_path：该指定用于设置缓存文件的存放路径</p>
<p><code>proxy_cache_path path [levels=number] keys_zone=zone_name:zone_size [inactive=time]\[max_size=size]; </code> </p>
<p>属性说明：</p>
<ul>
<li><p>path:缓存路径地址,如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;proxy_cache</span><br></pre></td></tr></table></figure></li>
<li><p>levels: 指定该缓存空间对应的目录，最多可以设置3层，每层取值为1|2如 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">levels&#x3D;1:2   缓存空间有两层目录，第一次是1个字母，第二次是2个字母</span><br><span class="line">举例说明:</span><br><span class="line">itheima[key]通过MD5加密以后的值为 43c8233266edce38c2c9af0694e2107d</span><br><span class="line">levels&#x3D;1:2   最终的存储路径为&#x2F;usr&#x2F;local&#x2F;proxy_cache&#x2F;d&#x2F;07</span><br><span class="line">levels&#x3D;2:1:2 最终的存储路径为&#x2F;usr&#x2F;local&#x2F;proxy_cache&#x2F;7d&#x2F;0&#x2F;21</span><br><span class="line">levels&#x3D;2:2:2 最终的存储路径为??&#x2F;usr&#x2F;local&#x2F;proxy_cache&#x2F;7d&#x2F;10&#x2F;e2</span><br></pre></td></tr></table></figure></li>
<li><p>keys_zone:用来为这个缓存区设置名称和指定大小，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keys_zone&#x3D;itcast:200m  缓存区的名称是itcast,大小为200M,1M大概能存储8000个keys</span><br></pre></td></tr></table></figure></li>
<li><p>inactive:指定缓存的数据多次时间未被访问就将被删除，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inactive&#x3D;1d   缓存数据在1天内没有被访问就会被删除</span><br></pre></td></tr></table></figure></li>
<li><p>max_size:设置最大缓存空间，如果缓存空间存满，默认会覆盖缓存时间最长的资源，如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">max_size&#x3D;20g</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="proxy-cache-key指令"><a href="#proxy-cache-key指令" class="headerlink" title="proxy_cache_key指令"></a>proxy_cache_key指令</h3><p>proxy_cache_key：该指令用来设置web缓存的key值，Nginx会根据key值MD5哈希存缓存。</p>
<p><code>proxy_cache_key key;</code></p>
<h3 id="proxy-cache-valid指令"><a href="#proxy-cache-valid指令" class="headerlink" title="proxy_cache_valid指令"></a>proxy_cache_valid指令</h3><p>proxy_cache_valid：该指令用来对不同返回状态码的URL设置不同的缓存时间。</p>
<p><code>proxy_cache_valid [code ...] time;</code></p>
<h3 id="proxy-cache-min-uses指令"><a href="#proxy-cache-min-uses指令" class="headerlink" title="proxy_cache_min_uses指令"></a>proxy_cache_min_uses指令</h3><p>proxy_cache_min_uses：该指令用来设置资源被访问多少次后被缓存，默认值  proxy_cache_min_uses 1。</p>
<p><code>proxy_cache_min_uses number;</code></p>
<h3 id="proxy-cache-methods指令"><a href="#proxy-cache-methods指令" class="headerlink" title="proxy_cache_methods指令"></a>proxy_cache_methods指令</h3><p>proxy_cache_methods：该指令用户设置缓存哪些HTTP方法，默认值  proxy_cache_methods GET HEAD。</p>
<p><code>proxy_cache_methods GET|HEAD|POST;</code></p>
<h3 id="proxy-no-cache指令"><a href="#proxy-no-cache指令" class="headerlink" title="proxy_no_cache指令"></a>proxy_no_cache指令</h3><p>proxy_no_cache：该指令是用来定义不将数据进行缓存的条件。</p>
<p><code>proxy_no_cache string ...;</code></p>
<p>例子：</p>
<p><code>proxy_no_cache $cookie_nocache $arg_nocache $arg_comment;</code></p>
<h3 id="proxy-cache-bypass指令"><a href="#proxy-cache-bypass指令" class="headerlink" title="proxy_cache_bypass指令"></a>proxy_cache_bypass指令</h3><p>proxy_cache_bypass：该指令是用来设置不从缓存中获取数据的条件。</p>
<p><code>proxy_cache_bypass string ...;</code></p>
<p>例子：</p>
<p><code>proxy_cache_bypass $cookie_nocache $arg_nocache $arg_comment;</code></p>
<blockquote>
<p>$cookie_nocache：指的是当前请求的cookie中键的名称为nocache对应的值<br>$arg_nocache和$arg_comment：指的是当前请求的参数中属性名为nocache和comment对应的属性值</p>
</blockquote>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>缓存配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">	proxy_cache_path &#x2F;usr&#x2F;local&#x2F;proxy_cache levels&#x3D;2:1 keys_zone&#x3D;wht666:200m inactive&#x3D;1d max_size&#x3D;20g;</span><br><span class="line">	upstream backend&#123;</span><br><span class="line">		server 192.168.200.146:8080;</span><br><span class="line">	&#125;</span><br><span class="line">	server &#123;</span><br><span class="line">		listen       8080;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">        	proxy_cache cache;</span><br><span class="line">            proxy_cache_key $scheme$proxy_host$request_uris;</span><br><span class="line">            proxy_cache_min_uses 5;</span><br><span class="line">            proxy_cache_valid 200 5d;</span><br><span class="line">            proxy_cache_valid 404 30s;</span><br><span class="line">            proxy_cache_valid any 1m;</span><br><span class="line">            add_header nginx-cache &quot;$upstream_cache_status&quot;;</span><br><span class="line">        	proxy_pass http:&#x2F;&#x2F;backend&#x2F;js&#x2F;;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h2><h3 id="方式一-删除对应的缓存目录"><a href="#方式一-删除对应的缓存目录" class="headerlink" title="方式一:删除对应的缓存目录"></a>方式一:删除对应的缓存目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf &#x2F;usr&#x2F;local&#x2F;proxy_cache&#x2F;......</span><br></pre></td></tr></table></figure>
<h3 id="方式二-使用第三方扩展模块"><a href="#方式二-使用第三方扩展模块" class="headerlink" title="方式二:使用第三方扩展模块"></a>方式二:使用第三方扩展模块</h3><h4 id="ngx-cache-purge"><a href="#ngx-cache-purge" class="headerlink" title="ngx_cache_purge"></a>ngx_cache_purge</h4><p>（1）下载ngx_cache_purge模块对应的资源包，并上传到服务器上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ngx_cache_purge-2.3.tar.gz</span><br></pre></td></tr></table></figure>
<p>（2）对资源文件进行解压缩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxf ngx_cache_purge-2.3.tar.gz</span><br></pre></td></tr></table></figure>
<p>（3）修改文件夹名称，方便后期配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv ngx_cache_purge-2.3 purge</span><br></pre></td></tr></table></figure>
<p>（4）查询Nginx的配置参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -V</span><br></pre></td></tr></table></figure>
<p>（5）进入Nginx的安装目录，使用./configure进行参数配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --add-module&#x3D;&#x2F;root&#x2F;nginx&#x2F;module&#x2F;purge</span><br></pre></td></tr></table></figure>
<p>（6）使用make进行编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>（7）将nginx安装目录的nginx二级制可执行文件备份</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginxold</span><br></pre></td></tr></table></figure>
<p>（8）将编译后的objs中的nginx拷贝到nginx的sbin目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp objs&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin</span><br></pre></td></tr></table></figure>
<p>（9）使用make进行升级</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make upgrade</span><br></pre></td></tr></table></figure>
<p>（10）在nginx配置文件中进行如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	location ~&#x2F;purge(&#x2F;.*) &#123;</span><br><span class="line">		proxy_cache_purge 缓存名称 缓存的key值;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（11）访问 <a href="http://ip:端口/purge/资源名">http://ip:端口/purge/资源名</a> 来清除该资源缓存</p>
]]></content>
      <categories>
        <category>工具的使用</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用markdown</title>
    <url>/2021/02/23/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/markdown/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8markdown/</url>
    <content><![CDATA[<h1 id="Markdown简单使用-typora"><a href="#Markdown简单使用-typora" class="headerlink" title="Markdown简单使用(typora)"></a>Markdown简单使用(typora)</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[TOC]如下</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230322091949852.png" alt="image-20230322091949852"></p>
<h2 id="1-如何写代码块"><a href="#1-如何写代码块" class="headerlink" title="1.如何写代码块"></a>1.如何写代码块</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.代码块语法</span></span><br><span class="line">​```java (语言类型)</span><br></pre></td></tr></table></figure>
<h2 id="2-标题"><a href="#2-标题" class="headerlink" title="2.标题"></a>2.标题</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题  </span><br></pre></td></tr></table></figure>
<h2 id="3-字体"><a href="#3-字体" class="headerlink" title="3.字体"></a>3.字体</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加粗</span></span><br><span class="line">**字**</span><br><span class="line"><span class="comment">//删除线</span></span><br><span class="line">~~字~~</span><br><span class="line"><span class="comment">//斜体</span></span><br><span class="line"> *字*</span><br></pre></td></tr></table></figure>
<ul>
<li>加粗：<strong>字</strong></li>
<li>删除线：<del>字</del></li>
<li>斜体：<em>字</em></li>
</ul>
<h2 id="4-引用"><a href="#4-引用" class="headerlink" title="4.引用"></a>4.引用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;引用<span class="number">1</span></span><br><span class="line">&gt;&gt;引用<span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;引用<span class="number">3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用1</p>
<blockquote>
<p>引用2</p>
</blockquote>
<blockquote>
<blockquote>
<p>引用3</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="5-分割线"><a href="#5-分割线" class="headerlink" title="5.分割线"></a>5.分割线</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">分割线<span class="number">1</span>：---</span><br><span class="line">分割线<span class="number">2</span>：***</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<h2 id="6-图片插入"><a href="#6-图片插入" class="headerlink" title="6.图片插入"></a>6.图片插入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在线图片/本地图偏</span></span><br><span class="line">![我的照片](路径) --照片</span><br></pre></td></tr></table></figure>
<h2 id="7-超链接"><a href="#7-超链接" class="headerlink" title="7.超链接"></a>7.超链接</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[说明](超链接url地址)</span><br></pre></td></tr></table></figure>
<h2 id="8-列表"><a href="#8-列表" class="headerlink" title="8.列表"></a>8.列表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无序列表</span></span><br><span class="line">-目录<span class="number">1</span></span><br><span class="line">-目录<span class="number">2</span></span><br><span class="line"><span class="comment">//有序列表</span></span><br><span class="line">数字键+.标题</span><br></pre></td></tr></table></figure>
<ul>
<li>无序目录1</li>
</ul>
<ol>
<li>有序目录2</li>
</ol>
<h2 id="9-表格"><a href="#9-表格" class="headerlink" title="9.表格"></a>9.表格</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一般使用右键插入列表！！</span><br></pre></td></tr></table></figure>
<h2 id="10-补充"><a href="#10-补充" class="headerlink" title="10.补充"></a>10.补充</h2><p>markdown支持html语法，会对相应标签进行解析！所以html标签也适用哦</p>
]]></content>
      <categories>
        <category>工具使用</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>typora</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger2</title>
    <url>/2022/11/11/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/swagger2/Swagger2/</url>
    <content><![CDATA[<h1 id="Swagger2"><a href="#Swagger2" class="headerlink" title="Swagger2"></a>Swagger2</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于目前大趋势，都是进行前后端的开发模式。在这样的背景下，前后端的交流是必不可少的。相信无论是前端还是后端开发，都或多或少地被接口文档折磨过。前端经常抱怨后端给的接口文档与实际情况不一致。后端又觉得编写及维护接口文档会耗费不少精力，经常来不及更新。</p>
<p><a href="https://swagger.io/">Swagger</a>的诞生完美的解决了上述问题，你只需要按照它的规范去定义接口及接口相关的信息。再通过Swagger衍生出来的一系列项目和工具，就可以做到生成各种格式的接口文档，生成多种语言的客户端和服务端的代码，以及在线接口调试页面等等</p>
<h2 id="所提供的开源工具"><a href="#所提供的开源工具" class="headerlink" title="所提供的开源工具"></a>所提供的开源工具</h2><ol>
<li><p><strong>Swagger Codegen</strong>: 通过Codegen 可以将描述文件生成html格式和cwiki形式的接口文档，同时也能生成多钟语言的服务端和客户端的代码。支持通过jar包，docker，node等方式在本地化执行生成。也可以在后面的Swagger Editor中在线生成。</p>
</li>
<li><p><strong>Swagger UI</strong>:提供了一个可视化的UI页面展示描述文件。接口的调用方、测试、项目经理等都可以在该页面中对相关接口进行查阅和做一些简单的接口请求。该项目支持在线导入描述文件和本地部署UI项目。</p>
</li>
<li><p><strong>Swagger Editor</strong>: 类似于markendown编辑器的编辑Swagger描述文件的编辑器，该编辑支持实时预览描述文件的更新效果。也提供了在线编辑器和本地部署编辑器两种方式。</p>
</li>
<li><p><strong>Swagger Inspector</strong>: 感觉和postman差不多，是一个可以对接口进行测试的在线版的postman。比在Swagger UI里面做接口请求，会返回更多的信息，也会保存你请求的实际请求参数等数据。</p>
</li>
<li><p><strong>Swagger Hub</strong>：集成了上面所有项目的各个功能，你可以以项目和版本为单位，将你的描述文件上传到Swagger Hub中。在Swagger Hub中可以完成上面项目的所有工作，需要注册账号，分免费版和收费版。</p>
</li>
</ol>
<h2 id="SpringBoot集成Swagger2"><a href="#SpringBoot集成Swagger2" class="headerlink" title="SpringBoot集成Swagger2"></a>SpringBoot集成Swagger2</h2><h3 id="SpringFox"><a href="#SpringFox" class="headerlink" title="SpringFox"></a>SpringFox</h3><p>SpringFox是Spring 基于swagger规范，可以将基于SpringMVC和Spring Boot项目的项目代码，自动生成JSON格式的描述文件，提供控制层中各个请求的测试界面等。本身不是属于Swagger官网提供的。</p>
<p>Spring-fox利用自身AOP特性，把Swagger集成进来，底层还是Swagger。但是使用起来确方便很多。所以在实际开发中，都是直接使用spring-fox。</p>
<h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><ol>
<li><p>开启Swagger2的自动配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span> <span class="comment">//springfox提供的一个注解，代表swagger2相关技术开启，会扫描当前类所在包，及子包中所有的类型中注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>进行swagger-ui页面：<code>http://localhost:8011/swagger-ui.html</code></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220808221828680.png" alt="image-20220808221828680"></p>
</li>
<li><p>可以点击try it out进行请求的模拟</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220808222516418.png" alt="image-20220808222516418"></p>
</li>
</ol>
<h4 id="swagger配置"><a href="#swagger配置" class="headerlink" title="swagger配置"></a>swagger配置</h4><h5 id="修改api文档顶部主体内容"><a href="#修改api文档顶部主体内容" class="headerlink" title="修改api文档顶部主体内容"></a>修改api文档顶部主体内容</h5><ul>
<li><p>创建配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwagggerConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Docket类型的对象，交由spring容器管理</span></span><br><span class="line"><span class="comment">     * Docket是Swagger中的全局配置对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//指定swagger版本</span></span><br><span class="line">        Docket docket = <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//api帮助文档的描述信息</span></span><br><span class="line">        ApiInfo apiInfo =</span><br><span class="line">                <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                        .contact( <span class="comment">//主体内容：发布者名称、发布者网站地址、发布者邮箱</span></span><br><span class="line">                                <span class="keyword">new</span> Contact(<span class="string">&quot;wht&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;http://www.wht.com&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;1369281736@qq.com&quot;</span>)</span><br><span class="line">                        )</span><br><span class="line">                        <span class="comment">//文档题目</span></span><br><span class="line">                        .title(<span class="string">&quot;SwaggerApi学习帮助文档&quot;</span>)</span><br><span class="line">                        <span class="comment">//文档描述</span></span><br><span class="line">                        .description(<span class="string">&quot;一个简单学习使用Swagger2的文档&quot;</span>)</span><br><span class="line">                        <span class="comment">//文档版本</span></span><br><span class="line">                        .version(<span class="string">&quot;1.1&quot;</span>)</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">        docket.apiInfo(apiInfo);</span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> docket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>效果：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220808224633617.png" alt="image-20220808224633617"></p>
</li>
</ul>
<h5 id="配置扫描接口"><a href="#配置扫描接口" class="headerlink" title="配置扫描接口"></a>配置扫描接口</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docket</span><br><span class="line">    <span class="comment">//获取Docket中的选择器，返回ApiSeletorBuilder</span></span><br><span class="line">    .select()</span><br><span class="line">    <span class="comment">//指定扫描的规则</span></span><br><span class="line">    <span class="comment">//指定扫描com.wht.controller包及其子包</span></span><br><span class="line">    .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.wht.controller&quot;</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除了basePackage的扫描策略还有其他的：</p>
<ul>
<li>any() ：扫描所有，项目中的所有接口都会被扫描到</li>
<li>none()： 不扫描接口</li>
<li>withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)： 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求</li>
<li>withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation) ： 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口</li>
</ul>
</blockquote>
<h5 id="添加请求路径过滤器"><a href="#添加请求路径过滤器" class="headerlink" title="添加请求路径过滤器"></a>添加请求路径过滤器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.wht.controller&quot;</span>))</span><br><span class="line"><span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/user开头的接口</span></span><br><span class="line">.paths(PathSelectors.ant(<span class="string">&quot;/user/**&quot;</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除了ant()风格的扫描策略还有其他的：</p>
<ul>
<li>any() ：任何请求都扫描</li>
<li>none()：任何请求都不扫描</li>
<li>regex(final String pathRegex)：通过正则表达式控制</li>
</ul>
</blockquote>
<h5 id="根据环境动态展示swagger"><a href="#根据环境动态展示swagger" class="headerlink" title="根据环境动态展示swagger"></a>根据环境动态展示swagger</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 设置要显示swagger的环境</span></span><br><span class="line">   Profiles of = Profiles.of(<span class="string">&quot;dev&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">   <span class="comment">// 判断当前是否处于该环境</span></span><br><span class="line">   <span class="comment">// 通过 enable() 接收此参数判断是否要显示</span></span><br><span class="line">   <span class="keyword">boolean</span> flag = environment.acceptsProfiles(of);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .enable(flag) <span class="comment">//配置是否启用Swagger，如果是false，在浏览器将无法访问</span></span><br><span class="line">      .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.wht.controller&quot;</span>))</span><br><span class="line">       <span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/user开头的接口</span></span><br><span class="line">      .paths(PathSelectors.ant(<span class="string">&quot;/user/**&quot;</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h5><p>如果没有对分组进行配置，默认只有default分组，可以通过groupName(“组名”)进行分组</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220810170657262.png" alt="image-20220810170657262"></p>
<blockquote>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;group2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;group3&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><ul>
<li>@Api(tags = “xxx模块说明”) ：对模块进行描述</li>
<li>@ApiOperation(“xxx接口说明”)：对api接口的描述</li>
<li>@ApiModel(“xxxPOJO说明”)：对javaBean进行描述</li>
<li>@ApiModelProperty(value = “xxx属性说明”,hidden = true)：对javaBean的属性进行描述</li>
<li>@ApiParam(“xxx参数说明”)：对方法参数进行描述</li>
<li>@ApiIgnore：加在方法或类上不生成文档</li>
<li>@ApiImplicitParam(name  = “参数名”,value = “参数描述”, required = “是否必要” , paramType = “参数类型”)：加在接口上用于描述接口中的参数</li>
<li>@ApiImplicitParams(name = {@ApiImplicitParam(),@ApiImplicitParam()})：定义多个参数</li>
</ul>
]]></content>
      <categories>
        <category>工具的使用</category>
        <category>Swagger</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>VueCLI</title>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF/vue/VueCLI/</url>
    <content><![CDATA[<h1 id="VueCLI"><a href="#VueCLI" class="headerlink" title="VueCLI"></a>VueCLI</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CLI是Command-Line Interface，翻译为命令行界面，但是俗称脚手架。<br>Vue CLI是一个官方发布vue.js项目脚手架，使用vue-cli可以快速搭建Vue开发环境以及对应的webpacki配置，</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>全局安装@vue/cli：npm install -g @vue/cli</li>
<li>切换到要创建项目的目录进行创建：vue create XXXX  (vue cli3)/ vue init webpack 项目名称（vue cli2）</li>
<li>启动项目：npm run serve</li>
</ol>
<h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><h4 id="方式一：通过vue-ui修改"><a href="#方式一：通过vue-ui修改" class="headerlink" title="方式一：通过vue ui修改"></a>方式一：通过vue ui修改</h4><ol>
<li><p>进入vue ui后导入项目</p>
</li>
<li><p>可以管理相应的依赖和插件</p>
</li>
<li><p>在配置项，配置相关配置</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220629171510192.png" alt="image-20220629171510192"></p>
</li>
</ol>
<h4 id="方式二：直接创建配置文件配置"><a href="#方式二：直接创建配置文件配置" class="headerlink" title="方式二：直接创建配置文件配置"></a>方式二：直接创建配置文件配置</h4><ol>
<li><p>创建vue.config.js文件（名称必须固定）</p>
</li>
<li><p>直接在文件中修改配置文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@vue/cli-service&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  <span class="comment">// 选项</span></span><br><span class="line">  pages:&#123;</span><br><span class="line">    index:&#123;</span><br><span class="line">      entry:<span class="string">&#x27;src/main.js&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//关闭语法检查</span></span><br><span class="line">  lintOnSave:<span class="literal">false</span></span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>VueJs</title>
    <url>/2022/08/31/%E5%89%8D%E7%AB%AF/vue/VueJs/</url>
    <content><![CDATA[<h1 id="Vuejs基础"><a href="#Vuejs基础" class="headerlink" title="Vuejs基础"></a>Vuejs基础</h1><p>Vue (是一套用于构建用户界面的浙进式框架。与其它大型框架不同的是，Vue被设计为可以白底向上逐层应用。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工贝链以及各种支持类库结合使用时，Vue也完全能够为复杂的单页应用提供驱动。</p>
<h3 id="Vue初体验"><a href="#Vue初体验" class="headerlink" title="Vue初体验"></a>Vue初体验</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>初体验<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;message&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in movies&quot;</span>&gt;</span></span><br><span class="line">                &#123;&#123;item&#125;&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">                el:<span class="string">&#x27;#app&#x27;</span>,<span class="comment">//用于挂载要管理的元素</span></span></span><br><span class="line"><span class="javascript">                data:&#123; <span class="comment">//定义数据</span></span></span><br><span class="line"><span class="javascript">                    message:<span class="string">&#x27;你好啊&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                    movies:[<span class="string">&#x27;少年派&#x27;</span>,<span class="string">&#x27;星际穿越&#x27;</span>]</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Vue中的MVVM"><a href="#Vue中的MVVM" class="headerlink" title="Vue中的MVVM"></a>Vue中的MVVM</h3><h4 id="MVVM的概念"><a href="#MVVM的概念" class="headerlink" title="MVVM的概念"></a>MVVM的概念</h4><p>​    MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。</p>
<h4 id="Vue中MVVM："><a href="#Vue中MVVM：" class="headerlink" title="Vue中MVVM："></a>Vue中MVVM：</h4><p>通过ViewModel将view和model分隔。ViewModel的主要作用：</p>
<ol>
<li>将model生成的数据与view进行绑定，并且对model中的数据进行实时监听保证view中的数据最新。</li>
<li>对view的DOM进行监听，如果发生某个事件会调用model中相应的回调。</li>
</ol>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220626183439079.png" style="zoom:67%;" />

<h3 id="Vue实例中的基本选项"><a href="#Vue实例中的基本选项" class="headerlink" title="Vue实例中的基本选项"></a>Vue实例中的基本选项</h3><ul>
<li><p>el：</p>
<ul>
<li>类型：string|HTMLElement</li>
<li>作用：Vue实例管理的DOM</li>
</ul>
</li>
<li><p>data：</p>
<ul>
<li>类型：Object|Function</li>
<li>作用：Vue实例对应的数据对象</li>
</ul>
</li>
<li><p>methods：</p>
<ul>
<li>类型：[key:string]：Function</li>
<li>作用：定义属于Vue的一些方法，可以在其他地方调用，也可以在指令中使用。</li>
</ul>
</li>
<li><p>生命周期函数：</p>
<ul>
<li>类型：如beforeCreate: function(){}等….(详细如下<a href="#jump1">Vue生命周期</a>介绍)</li>
</ul>
</li>
<li><p>computed（计算属性）：</p>
<ul>
<li>类型：[key:string]：function(){}</li>
<li>作用：将属性进行加工处理，并返回</li>
<li>使用：<code>&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt;</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed:&#123;  <span class="comment">//计算属性</span></span><br><span class="line">  	<span class="comment">// 完整写法</span></span><br><span class="line">  	fullName:&#123;</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      	<span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">      	<span class="built_in">console</span>.log(<span class="string">&quot;fullName被人修改了哦!!&quot;</span>);</span><br><span class="line">      	<span class="keyword">const</span> arr = value.split(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">      	<span class="built_in">this</span>.firstName = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.lastName = arr[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只有考虑读取才能使用这个简写</span></span><br><span class="line">    <span class="function"><span class="title">fullName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>filters(过滤器)：</p>
<ul>
<li>类型：key:string(value){}</li>
<li>作用：将数据进行过滤并返回过滤后的结果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line">filters:&#123;</span><br><span class="line">    <span class="function"><span class="title">timeFormater</span>(<span class="params">value,str</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dayjs(value).format(str)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">&lt;h3&gt;现在是:&#123;&#123;time | timeFormater(<span class="string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>)&#125;&#125;&lt;/h3&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>watch(属性监视)：</p>
<ul>
<li>类型：key(newValue,oldValue):{}</li>
<li>作用：监视属性的变化</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch:&#123; <span class="comment">//同样可以检测普通属性和计算属性</span></span><br><span class="line">    <span class="comment">// isHot:&#123;</span></span><br><span class="line">    <span class="comment">//     deep:true, //深度监视 监视多级结构中所有属性的变化</span></span><br><span class="line">    <span class="comment">//     immediate:true, //初始化时调用一下</span></span><br><span class="line">    <span class="comment">//     handler(newValue,oldValue)&#123;//当isHot发生变化时调用</span></span><br><span class="line">    <span class="comment">//         console.log(&quot;天气发生变化&quot;+oldValue+newValue);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 只需要handler时可以简写</span></span><br><span class="line">    <span class="function"><span class="title">isHot</span>(<span class="params">newValue,oldValue</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;天气发生变化&quot;</span>+oldValue+newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 写法2 </span></span><br><span class="line">vm.$watch(<span class="string">&#x27;isHot&#x27;</span>,&#123;</span><br><span class="line">    immediate:<span class="literal">true</span>, <span class="comment">//初始化时调用一下</span></span><br><span class="line">    <span class="function"><span class="title">handler</span>(<span class="params">newValue,oldValue</span>)</span>&#123;<span class="comment">//当isHot发生变化时调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ul>
<blockquote>
<p>其余可以参考<a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE">官方网站</a></p>
</blockquote>
<h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a><span id="jump1">Vue生命周期</span></h3><blockquote>
<p>Vue官方生命周期图例：</p>
</blockquote>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220626190200058.png" style="zoom:67%;" />

<h4 id="Vue各个生命周期阶段介绍："><a href="#Vue各个生命周期阶段介绍：" class="headerlink" title="Vue各个生命周期阶段介绍："></a>Vue各个生命周期阶段介绍：</h4><ol>
<li>beforeCreate：刚刚初始化事件但数据代理还未开始时，并且无法通过vm访问到data中的数据和methods中的方法</li>
<li>created：完成数据检测和数据代理之后调用，并且可以通过vm访问到data中的数据和methods中的方法</li>
<li>beforeMount：在Vue解析模板并生成虚拟DOM但还不能显示解析好的内容后调用，页面呈现的是未经Vue编译的DOM,对DOM的操作最终会失效</li>
<li>mounted：Vue完成模板的解析并把初试真实DOM元素放入页面后（挂载完毕），页面中呈现的是经过Vue编译的DOM</li>
<li>beforeUpdate：当更新数据时，重新解析模板之前调用，数据是新的页面是旧的</li>
<li>updated：当模板解析页面与数据同步之后调用，Vue会生成新的虚拟DOM随后与旧的DOM进行比较完成更新页面渲染</li>
<li>beforeDestroy：调用Vue.$destory()会完全销毁一个实例，清除它与其他实例的链接,解绑它的全部指令和事件监听器，在摧毁之前调用data、methods都可用,但是对数据的更新之后将不会触发更新了</li>
<li>destroyed：Vue完成销毁之后调用</li>
</ol>
<h3 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h3><h4 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h4><ul>
<li><p>v-once：只会动态渲染一次，动态渲染以后就是静态资源了</p>
</li>
<li><p>v-clock：标识延迟加载的标签，如果vue加载完毕后就关闭</p>
</li>
<li><p>v-html：用于嵌入html代码</p>
</li>
<li><p>v-pre：直接静态渲染不进行解析加快编译</p>
</li>
<li><p>v-text：往标签中写入文本数据</p>
</li>
<li><p>v-bind：动态绑定属性（可以绑定href、src、class、style等）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;imgURL&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;imgURL&quot;</span>&gt;</span>  <span class="comment">&lt;!-- 简写 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 动态添加类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active:isActive&#125;&quot;</span>&gt;</span>文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[&#x27;a&#x27;,&#x27;b&#x27;]&quot;</span>&gt;</span>文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- 数组语法 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 动态绑定样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;fontSize: fsize+&#x27;px&#x27;&#125;&quot;</span>&gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;styleObj&quot;</span>&gt;</span>222<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>v-for：用于遍历</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 遍历数组--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(p,index) in persons&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;p.id&quot;</span>&gt;</span><span class="comment">&lt;!-- p为元素，index为索引 添加key提高DOM渲染的效率--&gt;</span></span><br><span class="line">        &#123;&#123;index+1&#125;&#125;:&#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 遍历对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,key,index) in person&quot;</span>&gt;</span><span class="comment">&lt;!-- value为对象属性值，key为对象属性名 index为索引--&gt;</span></span><br><span class="line">        &#123;&#123;index+1&#125;&#125;:&#123;&#123;key&#125;&#125;-&#123;&#123;value&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>v-on:事件：绑定事件(简写为@)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;root&quot;</span>&gt;</span><br><span class="line">        &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;学习&lt;/h2&gt;</span><br><span class="line">        &lt;button v-on:click=<span class="string">&quot;showInfo1&quot;</span>&gt;点我提示信息&lt;/button&gt;</span><br><span class="line">        &lt;button @click=<span class="string">&quot;showInfo2($event,66)&quot;</span>&gt;点我提示信息&lt;/button&gt;</span><br><span class="line">        &lt;!-- keyup事件后面加哪个键</span><br><span class="line">            回车：enter</span><br><span class="line">            删除：<span class="keyword">delete</span></span><br><span class="line">            退出：esc</span><br><span class="line">            空格：space</span><br><span class="line">            换行：tab（特殊需要配合keydown如：ctrl,alt,shift,meta）</span><br><span class="line">            上：up</span><br><span class="line">            下：down</span><br><span class="line">            左：left</span><br><span class="line">            右：right</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;按下回车提示输入&quot;</span> @keyup.enter=<span class="string">&quot;showInfo&quot;</span>&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">        Vue.config.productionTip = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">            <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span>&#123;</span><br><span class="line">                    name:<span class="string">&#x27;我家&#x27;</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                <span class="function"><span class="title">showInfo1</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(event.target.innerText);</span><br><span class="line">                    alert(<span class="string">&quot;你好啊1~&quot;</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="title">showInfo2</span>(<span class="params">event,number</span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(event);</span><br><span class="line">                    <span class="built_in">console</span>.log(number);</span><br><span class="line">                    alert(<span class="string">&quot;你好啊2~&quot;</span>+number);</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="title">showInfo</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">                    <span class="comment">// if(event.keyCode !== 13) return  </span></span><br><span class="line">                    <span class="built_in">console</span>.log(event.target.value);</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>并且还有可以在事件后面添加修饰符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">1.</span>prevent阻止跳转</span><br><span class="line">            <span class="number">2.</span>stop阻止事件冒泡(事件向上传递)</span><br><span class="line">            <span class="number">3.</span>once事件只触发一次</span><br><span class="line">            <span class="number">4.</span>capture使用事件的捕获模式(以由外向内执行事件)</span><br><span class="line">            <span class="number">5.</span>self只有event.target是当前操作的元素才会触发事件</span><br><span class="line">            <span class="number">6.</span>passive事件的默认行为立即执行，无需等待事件回调执行完毕</span><br><span class="line">       --&gt;</span><br><span class="line">       &lt;a href=<span class="string">&quot;http://www.baidu.com&quot;</span> @click.prevent=<span class="string">&quot;showInfo&quot;</span>&gt;点击超链接咯&lt;/a&gt;</span><br><span class="line">       &lt;div @click=<span class="string">&quot;showInfo&quot;</span>&gt;</span><br><span class="line">           &lt;button @click.stop=<span class="string">&quot;showInfo&quot;</span>&gt;点我提示信息&lt;/button&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">       &lt;button @click.once=<span class="string">&quot;showInfo&quot;</span>&gt;点我提示信息&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>v-if/v-else-if/v-else：判断是否满足条件，不满足则不会渲染该元素及其子元素</p>
</li>
<li><p>v-show：判断是否满足条件进行隐藏展示,适合多次频繁切换</p>
</li>
<li><p>v-model：进行表单数据的双向绑定 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-model结合radio --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- v-model结合checkbox --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;篮球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>篮球</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;足球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>足球</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;乒乓球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>乒乓球</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;羽毛球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>羽毛球</span><br><span class="line"><span class="comment">&lt;!-- v-model结合select --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>请选择校区<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;beijing&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;shenzhen&quot;</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;wuhan&quot;</span>&gt;</span>武汉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修饰符：</p>
<ul>
<li>lazy：可以让数据在失去焦点或者回车时才会更新</li>
<li>number：可以让在输入的内容自动转成数字类型</li>
<li>trim：可以过滤左右两边的空格</li>
</ul>
</li>
</ul>
<h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><p>有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用自定义指令 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>放大后的n值是:<span class="tag">&lt;<span class="name">span</span> <span class="attr">v-big</span>=<span class="string">&quot;n&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-fbind:value</span>=<span class="string">&quot;n&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义指令 --&gt;</span></span><br><span class="line">directives:&#123;</span><br><span class="line">	big(element,binding)&#123; //简写方式只会在 bind 和 update 时触发相同行为</span><br><span class="line">		element.innerText = binding.value*10</span><br><span class="line">	&#125;,</span><br><span class="line">	fbind:&#123;</span><br><span class="line">        //指令和元素成功绑定时</span><br><span class="line">        bind(element,binding)&#123;</span><br><span class="line">        	element.value = binding.value;</span><br><span class="line">		&#125;,</span><br><span class="line">        //指令所在元素被插入页面时</span><br><span class="line">        insert(element,binding)&#123;</span><br><span class="line">            element.focus();  </span><br><span class="line">        &#125;,</span><br><span class="line">        //指令所在的模板被重新解析时</span><br><span class="line">        update(element,binding)&#123;</span><br><span class="line">            element.value = binding.value;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="相关的钩子函数"><a href="#相关的钩子函数" class="headerlink" title="相关的钩子函数"></a>相关的钩子函数</h5><ul>
<li><p><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>
</li>
<li><p><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p>
</li>
<li><p><code>update</code>：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</p>
</li>
<li><p><code>componentUpdated</code>：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</p>
</li>
<li><p><code>unbind</code>：只调用一次，指令与元素解绑时调用。</p>
</li>
</ul>
<h5 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h5><p>指令钩子函数会被传入以下参数：</p>
<ul>
<li><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM。</li>
<li><code>binding</code>：一个对象，包含以下 property：<ul>
<li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li>
<li><code>value</code>：指令的绑定值。</li>
<li><code>oldValue</code>：指令绑定的前一个值，仅在 <strong>update</strong>和 <strong>componentUpdated</strong> 钩子中可用。无论值是否改变都可用。</li>
<li><code>expression</code>：字符串形式的指令表达式。</li>
<li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li>
<li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>&#123; foo: true, bar: true &#125;</code>。</li>
</ul>
</li>
<li><code>vnode</code>：Vue 编译生成的虚拟节点。</li>
<li><code>oldVnode</code>：上一个虚拟节点，仅在 <strong>update</strong>和 <strong>componentUpdated</strong> 钩子中可用。</li>
</ul>
<blockquote>
<p>除了 <code>el</code> 之外，其它参数都应该是只读的，切勿进行修改。</p>
</blockquote>
<h5 id="动态指令参数"><a href="#动态指令参数" class="headerlink" title="动态指令参数"></a>动态指令参数</h5><p>指令的参数可以是动态的。例如，在 <code>v-mydirective:[argument]=&quot;value&quot;</code> 中，<code>argument</code> 参数可以根据组件实例数据进行更新！并且可以通过<code>binding.arg</code>获取</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex</title>
    <url>/2022/09/13/%E5%89%8D%E7%AB%AF/vue/Vuex/</url>
    <content><![CDATA[<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><ol>
<li><p>概念：</p>
<p>专门在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
</li>
<li><p>使用场景：共享数据</p>
<ol>
<li>多个组件依赖同一状态</li>
<li>来自不同组件的行为需要变更同一状态</li>
</ol>
</li>
<li><p>原理图：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220417110641002.png" alt="image-20220417110641002"></p>
<p>vuex由三个部分组成：Actions、Mutations、State，并统一由store来管理</p>
<p>Actions：接收Vue Components 对共享数据的操作并commit给Mutations（还有一个很重要的作用是可以只接收操作，但是数据可以在Actions中向后端请求或者有一定的业务逻辑）</p>
<p>Mutations：按照Actions提交的操作对共享数据进行相应具体的操作（同样允许Vue Components直接调用commit越过Mutations）</p>
<p>State：存储共享数据</p>
</li>
</ol>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><ul>
<li><p>安装vuex：npm i vuex (如果是vue2 只能安装npm i vuex@3)</p>
</li>
<li><p>创建store来管理vuex的三个主要对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在main.js中引入store 因为js名叫index所以可以省略</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">	render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">	store,</span><br><span class="line">	<span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		Vue.prototype.$bus = <span class="built_in">this</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>src中store文件夹中的index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该文件用于创建Vuex中最为核心的store</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//应用Vuex插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions——用于响应组件中的动作，可以用于异步操作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">	<span class="function"><span class="title">add</span>(<span class="params">context,value</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;actions中的add被调用了&#x27;</span>)</span><br><span class="line">		context.commit(<span class="string">&#x27;ADD&#x27;</span>,value)</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="title">sub</span>(<span class="params">context,value</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;actions中的sub被调用了&#x27;</span>)</span><br><span class="line">		context.commit(<span class="string">&#x27;SUB&#x27;</span>,value)</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="title">addOdd</span>(<span class="params">context,value</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;actions中的addOdd被调用了&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span>(context.state.sum % <span class="number">2</span>)&#123;</span><br><span class="line">			context.commit(<span class="string">&#x27;ADD&#x27;</span>,value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="title">addWait</span>(<span class="params">context,value</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;actions中的addWait被调用了&#x27;</span>)</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">			context.commit(<span class="string">&#x27;ADD&#x27;</span>,value)</span><br><span class="line">		&#125;,<span class="number">500</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备mutations——用于操作数据（state）并且必须是同步方法</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">	<span class="function"><span class="title">ADD</span>(<span class="params">state,value</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;mutations中的ADD被调用了&#x27;</span>)</span><br><span class="line">		state.sum += value</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="title">SUB</span>(<span class="params">state,value</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;mutations中的SUB被调用了&#x27;</span>)</span><br><span class="line">		state.sum -= value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备state——用于存储数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">	sum:<span class="number">0</span> <span class="comment">//当前的和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备getters——用于将state中的数据进行加工</span></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">	<span class="function"><span class="title">bigSum</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state.sum*<span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//可以直接获取getters的数据再加工</span></span><br><span class="line">    <span class="function"><span class="title">bigSum2</span>(<span class="params">state,getters</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getters.bigSum*<span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//可以通过函数获取组件调用getters传来的参数</span></span><br><span class="line">	<span class="function"><span class="title">bigSum3</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> state.sum*num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">	actions,</span><br><span class="line">	mutations,</span><br><span class="line">	state,</span><br><span class="line">	getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>使用vuex:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;当前求和为：&#123;&#123;$store.state.sum&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;h3&gt;当前求和放大10倍为：&#123;&#123;$store.getters.bigSum&#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">    increment()&#123;</span><br><span class="line">    this.$store.commit(&#39;ADD&#39;,this.n)</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement()&#123;</span><br><span class="line">    this.$store.commit(&#39;SUB&#39;,this.n)</span><br><span class="line">    &#125;,</span><br><span class="line">    incrementOdd()&#123;</span><br><span class="line">    this.$store.dispatch(&#39;addOdd&#39;,this.n)</span><br><span class="line">    &#125;,</span><br><span class="line">    incrementWait()&#123;</span><br><span class="line">    this.$store.dispatch(&#39;addWait&#39;,this.n)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="mapState、mapGetters、mapActions、mapMutaions"><a href="#mapState、mapGetters、mapActions、mapMutaions" class="headerlink" title="mapState、mapGetters、mapActions、mapMutaions"></a>mapState、mapGetters、mapActions、mapMutaions</h4></blockquote>
<p>作用：自动生成相关属性，用于简化模板语法</p>
<p>用法：写在各个组件的计算属性中</p>
<ul>
<li>mapState</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//借助mapState生成计算属性，从state中读取数据。（对象写法）</span></span><br><span class="line">...mapState(&#123;<span class="attr">he</span>:<span class="string">&#x27;sum&#x27;</span>,<span class="attr">xuexiao</span>:<span class="string">&#x27;school&#x27;</span>,<span class="attr">xueke</span>:<span class="string">&#x27;subject&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line"><span class="comment">//借助mapState生成计算属性，从state中读取数据。（数组写法，但必须与属性名一致）</span></span><br><span class="line">...mapState([<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br></pre></td></tr></table></figure>
<ul>
<li>mapGetters</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//借助mapGetters生成计算属性，从getters中读取数据。（对象写法）</span></span><br><span class="line">...mapGetters(&#123;<span class="attr">bigSum</span>:<span class="string">&#x27;bigSum&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//借助mapGetters生成计算属性，从getters中读取数据。（数组写法）</span></span><br><span class="line">...mapGetters([<span class="string">&#x27;bigSum&#x27;</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>mapActions（注意使用方法时需要带相应的参数）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//借助mapActions生成对应的方法，方法中会调用dispatch去联系actions(对象写法)</span></span><br><span class="line">...mapActions(&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//借助mapActions生成对应的方法，方法中会调用dispatch去联系actions(数组写法)</span></span><br><span class="line"> ...mapActions([<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="string">&#x27;jiaWait&#x27;</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>mapMutations（注意使用方法时需要带相应的参数）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//借助mapMutations生成对应的方法，方法中会调用commit去联系mutations(对象写法)</span></span><br><span class="line">...mapMutations(&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line"><span class="comment">//借助mapMutations生成对应的方法，方法中会调用commit去联系mutations(数组写法)</span></span><br><span class="line">...mapMutations([<span class="string">&#x27;JIA&#x27;</span>,<span class="string">&#x27;JIAN&#x27;</span>]),</span><br></pre></td></tr></table></figure>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3></li>
</ul>
<p>Vue使用单一状态树,那么也意味着很多状态都会交给Vuex来管理.当应用变得非常复杂时,store对象就有可能变得相当臃肿.为了解决这个问题, Vuex允许我们将store分割成模块(Module),而每个模块拥有自己的state、mutations、actions、getters等</p>
<ol>
<li>模块化的定义：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">    state:&#123;...&#125;,</span><br><span class="line">    mutations:&#123;...&#125;,</span><br><span class="line">    actions:&#123;...&#125;,</span><br><span class="line">    getters:&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">    state:&#123;...&#125;,</span><br><span class="line">    mutations:&#123;...&#125;,</span><br><span class="line">    actions:&#123;...&#125;,</span><br><span class="line">    getters:&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">             </span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules:&#123;</span><br><span class="line">          a:moduleA,</span><br><span class="line">          b:moduleB</span><br><span class="line">    &#125;         </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>模块化使用：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取模块中的state</span></span><br><span class="line"><span class="comment">//1.直接获取</span></span><br><span class="line"><span class="built_in">this</span>.$store.state.a.属性名</span><br><span class="line"><span class="comment">//2.用mapstate,但是必须给每个模块配置namespaced:true</span></span><br><span class="line">...mapState(<span class="string">&#x27;a&#x27;</span>,[<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>])</span><br><span class="line"><span class="comment">//获取模块中的getters</span></span><br><span class="line"><span class="comment">//1.直接获取</span></span><br><span class="line"><span class="built_in">this</span>.$store.getters[<span class="string">&#x27;a/bigSum&#x27;</span>]</span><br><span class="line"><span class="comment">//2.mapGetters,但是必须给每个模块配置namespaced:true</span></span><br><span class="line">...mapGetters(<span class="string">&#x27;a&#x27;</span>,[<span class="string">&#x27;bigSum&#x27;</span>])</span><br><span class="line"><span class="comment">//获取模块中的actions</span></span><br><span class="line"><span class="comment">//1.直接获取</span></span><br><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;模块名/addOdd&#x27;</span>,<span class="built_in">this</span>.n)</span><br><span class="line"><span class="comment">//2.mapActions,但是必须给每个模块配置namespaced:true</span></span><br><span class="line">...mapActions(<span class="string">&#x27;a&#x27;</span>,[<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="string">&#x27;jiaWait&#x27;</span>])</span><br><span class="line"><span class="comment">//获取模块中的mutations</span></span><br><span class="line"><span class="comment">//1.直接获取</span></span><br><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&#x27;模块名/ADD&#x27;</span>,<span class="built_in">this</span>.n)</span><br><span class="line"><span class="comment">//2.mapMutations,但是必须给每个模块配置namespaced:true</span></span><br><span class="line">...mapMutations(<span class="string">&#x27;a&#x27;</span>,[<span class="string">&#x27;JIA&#x27;</span>,<span class="string">&#x27;JIAN&#x27;</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue响应式方法</title>
    <url>/2022/09/09/%E5%89%8D%E7%AB%AF/vue/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Vue响应式"><a href="#Vue响应式" class="headerlink" title="Vue响应式"></a>Vue响应式</h1><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><p>响应式的效果就是，数据驱动视图。只用按照普通的语法，改变一个数据，相应的视图就自动更新。保证试图中的数据与组件中的数据同步。</p>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><ol>
<li><p>通过Object.defineProperty来实现监听数据的改变和读取（属性中的getter和setter⽅法） 实现数据劫持</p>
</li>
<li><p>观察者模式（发布者-订阅者）</p>
<ul>
<li>观察者(订阅者) – Watcher：<br>update()：当事件发⽣时，具体要做的事情</li>
<li>目标(发布者) – Dep:<br>①subs 数组：存储所有的观察者<br>②addSub()：添加观察者<br>③notify()：当事件发⽣，调⽤所有观察者的 update() 方法 </li>
</ul>
</li>
<li><p>当数据发⽣改变通过发布者订阅者模式来进行通知进行界面刷新</p>
</li>
</ol>
<h2 id="具体响应式方法"><a href="#具体响应式方法" class="headerlink" title="具体响应式方法"></a>具体响应式方法</h2><h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><ul>
<li>push()：该方法是在数组最后添加数据，并返回数组长度</li>
<li>pop()：删除最后一个元素，并返回删除的元素值</li>
<li>shift()：删除数组的第一个元素，返回第一个删除的值</li>
<li>unshift()：向数组开头添加元素，返回数组长度</li>
<li>reverse()：翻转数组</li>
<li>sort(function(a,b){return a-b})：数组排序升序/b-a降序</li>
<li>splice(index,howmany,arr1,arr2…) ：用于添加或删除数组中的元素。从index位置开始删除howmany个元素，并将arr1、arr2…数据从index位置依次插入。howmany为0时，则不删除元素。<br>原数组改变。</li>
</ul>
<h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><ul>
<li>Vue.set(对象,’属性’,’属性值’)：为对象动态添加属性</li>
<li>Vue.delete(对象,’属性值’)：动态的删除对象的属性</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue异步请求</title>
    <url>/2022/09/10/%E5%89%8D%E7%AB%AF/vue/Vue%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h3 id="Vue发送异步请求"><a href="#Vue发送异步请求" class="headerlink" title="Vue发送异步请求"></a>Vue发送异步请求</h3><ul>
<li><p>使用axios发送（常用）</p>
<ul>
<li><p>安装axios：npm i axios</p>
</li>
<li><p>引入axios：import axios from ‘axios’</p>
</li>
<li><p>发送请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;http://localhost:5000/students&#x27;</span>).then(</span><br><span class="line">          response =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;请求成功了&#x27;</span>,response.data)</span><br><span class="line">          &#125;,</span><br><span class="line">          error =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;请求失败了&#x27;</span>,error.message)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用vue-resource发送</p>
<ul>
<li><p>安装vue-resource：npm i vue-resource</p>
</li>
<li><p>使用该插件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入插件</span></span><br><span class="line"><span class="keyword">import</span> vueResource <span class="keyword">from</span> <span class="string">&#x27;vue-resource&#x27;</span></span><br><span class="line"><span class="comment">//使用插件</span></span><br><span class="line">Vue.use(vueResource)</span><br></pre></td></tr></table></figure></li>
<li><p>发送请求：(跟axios一样)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$http.get(<span class="string">`https://api.github.com/search/users?q=<span class="subst">$&#123;<span class="built_in">this</span>.keyWord&#125;</span>`</span>).then(</span><br><span class="line">					response =&gt; &#123;</span><br><span class="line">						<span class="built_in">console</span>.log(<span class="string">&#x27;请求成功了&#x27;</span>)</span><br><span class="line">						<span class="comment">//请求成功后更新List的数据</span></span><br><span class="line">						<span class="built_in">this</span>.$bus.$emit(<span class="string">&#x27;updateListData&#x27;</span>,&#123;<span class="attr">isLoading</span>:<span class="literal">false</span>,<span class="attr">errMsg</span>:<span class="string">&#x27;&#x27;</span>,<span class="attr">users</span>:response.data.items&#125;)</span><br><span class="line">					&#125;,</span><br><span class="line">					error =&gt; &#123;</span><br><span class="line">						<span class="comment">//请求后更新List的数据</span></span><br><span class="line">						<span class="built_in">this</span>.$bus.$emit(<span class="string">&#x27;updateListData&#x27;</span>,&#123;<span class="attr">isLoading</span>:<span class="literal">false</span>,<span class="attr">errMsg</span>:error.message,<span class="attr">users</span>:[]&#125;)</span><br><span class="line">					&#125;</span><br><span class="line">				)</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h4 id="解决跨域请求"><a href="#解决跨域请求" class="headerlink" title="解决跨域请求"></a>解决跨域请求</h4><ol>
<li>cors（由后端处理，带一个响应头出来让浏览器知道允许该请求带走数据）</li>
<li>jsonp（只能解决get请求，而且需要前后端都操作）</li>
<li>配置代理服务器（实现方式有：1.nginx 2. vue-cli）</li>
</ol>
<h5 id="Vue-cli配置代理"><a href="#Vue-cli配置代理" class="headerlink" title="Vue-cli配置代理"></a>Vue-cli配置代理</h5><p>利用代理服务器来解决跨域问题，让代理服务器与前端保持同源，然后代理服务器直接与后端服务器交互（不受同源策略约束）</p>
<h6 id="实现方式1："><a href="#实现方式1：" class="headerlink" title="实现方式1："></a>实现方式1：</h6><ol>
<li><p>修改vue-cli的全局配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;配置开启中间代理服务器（并指定该服务器与后端哪个服务器交互）</span><br><span class="line">&#x2F;&#x2F;并且只有当请求的资源代理服务器中没有时才会与后端服务器交互（一定要防止代理服务器顶替了需要向后端请求的资源）</span><br><span class="line">&#x2F;&#x2F;所以不太灵活</span><br><span class="line">devServer:&#123;</span><br><span class="line">    proxy:&#39;http:&#x2F;&#x2F;localhost:5000&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>重启vue-cli</p>
</li>
<li><p>重新发送请求(注意端口是自己前端服务器的端口)</p>
</li>
</ol>
<h6 id="实现方式2："><a href="#实现方式2：" class="headerlink" title="实现方式2："></a>实现方式2：</h6><ol>
<li><p>修改vue-cli的全局配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#39;&#x2F;api&#39;请求前缀跟在端口号后面，如果请求带了该前缀表示需要向后端请求 并且可以配置多个前缀</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      &#39;&#x2F;api&#39;: &#123;</span><br><span class="line">        target: &#39;http:&#x2F;&#x2F;localhost:5000&#39;, </span><br><span class="line">        pathRewrite:&#123;&#39;^&#x2F;api&#39;:&#39;&#39;&#125;, &#x2F;&#x2F;清除请求前缀</span><br><span class="line">        ws: true,  &#x2F;&#x2F;用于支持websocket</span><br><span class="line">        changeOrigin: true &#x2F;&#x2F;是否谎报请求路径</span><br><span class="line">      &#125;,</span><br><span class="line">      &#39;&#x2F;demo&#39;: &#123;</span><br><span class="line">        target: &#39;http:&#x2F;&#x2F;localhost:5001&#39;, </span><br><span class="line">        pathRewrite:&#123;&#39;^&#x2F;demo&#39;:&#39;&#39;&#125;, &#x2F;&#x2F;清除请求前缀</span><br><span class="line">        ws: true,  &#x2F;&#x2F;用于支持websocket</span><br><span class="line">        changeOrigin: true &#x2F;&#x2F;是否谎报请求路径</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>重启vue-cli</p>
</li>
<li><p>重新发送请求(注意端口是自己前端服务器的端口，并且端口后面需要加代理前缀)</p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title>vue_Router</title>
    <url>/2022/09/11/%E5%89%8D%E7%AB%AF/vue/vue-Router/</url>
    <content><![CDATA[<h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><p>vue-router是Vue.js官方的路由插件,它和vue.js是深度集成的,适合用于构建单页面应用。专门用于单页面Web应用实现局部页面更新的插件库。</p>
<p><strong>主要功能：</strong></p>
<ul>
<li>嵌套路由映射</li>
<li>动态路由选择</li>
<li>模块化、基于组件的路由配置</li>
<li>路由参数、查询、通配符</li>
<li>展示由 Vue.js 的过渡系统提供的过渡效果</li>
<li>细致的导航控制</li>
<li>自动激活 CSS 类的链接</li>
<li>HTML5 history 模式或 hash 模式</li>
<li>可定制的滚动行为</li>
<li>URL 的正确编码</li>
</ul>
<h2 id="安装和使用vue-router"><a href="#安装和使用vue-router" class="headerlink" title="安装和使用vue-router"></a>安装和使用vue-router</h2><p>步骤一：安装vue-router</p>
<ul>
<li>npm install vue-router –save</li>
</ul>
<p>步骤二：在模块化项目中使用它</p>
<ul>
<li>导入路由对象，并调用Vue.use(VueRouter)</li>
<li>创建路由实例，并传入路由映射配置</li>
<li>在Vue实例中挂载创建的路由实例</li>
</ul>
<h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><ol>
<li><p>在src目录下创建router文件夹以及index.js（用于配置路由的相关信息）</p>
<p>index.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该文件专门用于创建整个应用的路由器</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//引入组件</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露一个路由器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">	routes:[</span><br><span class="line">        &#123;</span><br><span class="line">			path:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">            <span class="comment">//进行重定向到首页</span></span><br><span class="line">			redirect: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			path:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">			component:About</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			path:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">			component:Home</span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">    <span class="comment">//设置改变路径的模式 hash/history</span></span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>懒加载写法（用到哪个组件就引入哪个组件）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(../components/Home)</span><br><span class="line"><span class="keyword">const</span> About = <span class="function">() =&gt;</span> <span class="keyword">import</span>(../components/About)</span><br><span class="line"><span class="comment">//其余不变</span></span><br></pre></td></tr></table></figure></li>
<li><p>在main.js中引入路由</p>
<p>main.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入Vue</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入App</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="comment">//引入VueRouter</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//引入路由器,自动会导入index.js</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭Vue的生产提示</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"><span class="comment">//应用vue-router插件</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">	render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">	router:router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>在App.vue中使用路由</p>
<p>App.vue：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;list-group&quot;&gt;</span><br><span class="line">		  &lt;!-- 原始html中我们使用a标签实现页面的跳转 --&gt;</span><br><span class="line">          &lt;!-- &lt;a class&#x3D;&quot;list-group-item active&quot; href&#x3D;&quot;.&#x2F;about.html&quot;&gt;About&lt;&#x2F;a&gt; --&gt;</span><br><span class="line">          &lt;!-- &lt;a class&#x3D;&quot;list-group-item&quot; href&#x3D;&quot;.&#x2F;home.html&quot;&gt;Home&lt;&#x2F;a&gt; --&gt;</span><br><span class="line"></span><br><span class="line">		  &lt;!-- Vue中借助router-link标签实现路由的切换并且会被渲染成a标签--&gt;</span><br><span class="line">		  &lt;router-link  to&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;router-link&gt;</span><br><span class="line">          &lt;router-link  to&#x3D;&quot;&#x2F;home&quot;&gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line">          &lt;!-- 指定组件的呈现位置 --&gt;</span><br><span class="line">          &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">		name:&#39;App&#39;,</span><br><span class="line">	&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="router-link标签属性"><a href="#router-link标签属性" class="headerlink" title="router-link标签属性"></a>router-link标签属性</h3></li>
</ol>
<ul>
<li>tag=”button”：标签样式</li>
<li>replace：开始replace模式：路由标签中加一个replace即可。（浏览器历史记录有两种方式：push和replace；并且默认是push方式；）</li>
<li>active-class：设置对应路由匹配成功时的类名，不然默认会使用router-link-active类名（也可以在路由配置中加linkActiveClass配置效果一样）</li>
</ul>
<h3 id="编程式路由"><a href="#编程式路由" class="headerlink" title="编程式路由"></a>编程式路由</h3><ul>
<li><p>简写版：<code>this.$router.push/replace(&#39;/home&#39;)</code></p>
</li>
<li><p>详细版：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 绑定事件 --&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;pushShow(m)&quot;</span>&gt;push查看&lt;/button&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;replaceShow(m)&quot;</span>&gt;replace查看&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">pushShow</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">            path:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">            query:&#123;</span><br><span class="line">                id:m.id,</span><br><span class="line">                title:m.title</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">replaceShow</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$router.replace(&#123;</span><br><span class="line">        	path:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">       	 	query:&#123;</span><br><span class="line">                 id:m.id,</span><br><span class="line">                 title:m.title</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>操作与一级路由一致，只不过只是将需要嵌入的组件写在路由组件里面</p>
<p>编写路由规则,注意子路由不加 <strong>”/“</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//引入组件</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;../pages/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../pages/Home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> News <span class="keyword">from</span> <span class="string">&#x27;../pages/News&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Message <span class="keyword">from</span> <span class="string">&#x27;../pages/Message&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露一个路由器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">	routes:[</span><br><span class="line">		&#123;</span><br><span class="line">			path:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">			component:About</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			path:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">			component:Home,</span><br><span class="line">			children:[</span><br><span class="line">				&#123;</span><br><span class="line">					path:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">					component:News,</span><br><span class="line">				&#125;,</span><br><span class="line">				&#123;</span><br><span class="line">					path:<span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">					component:Message,</span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在路由组件中写路由标签(注意需要带着父路由的路径)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&lt;h2&gt;Home组件内容&lt;&#x2F;h2&gt;</span><br><span class="line">		&lt;div&gt;</span><br><span class="line">			&lt;ul class&#x3D;&quot;nav nav-tabs&quot;&gt;</span><br><span class="line">				&lt;li&gt;</span><br><span class="line">					&lt;router-link class&#x3D;&quot;list-group-item&quot; active-class&#x3D;&quot;active&quot; to&#x3D;&quot;&#x2F;home&#x2F;news&quot;&gt;News&lt;&#x2F;router-link&gt;</span><br><span class="line">				&lt;&#x2F;li&gt;</span><br><span class="line">				&lt;li&gt;</span><br><span class="line">					&lt;router-link class&#x3D;&quot;list-group-item&quot; active-class&#x3D;&quot;active&quot; to&#x3D;&quot;&#x2F;home&#x2F;message&quot;&gt;Message&lt;&#x2F;router-link&gt;</span><br><span class="line">				&lt;&#x2F;li&gt;</span><br><span class="line">			&lt;&#x2F;ul&gt;</span><br><span class="line">			&lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">		&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<h3 id="路由params参数"><a href="#路由params参数" class="headerlink" title="路由params参数"></a>路由params参数</h3><ol>
<li><p>方式一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#96;&#x2F;home&#x2F;message&#x2F;detail&#x2F;$&#123;m.id&#125;&#x2F;$&#123;m.title&#125;&#96;&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;&#x2F;router-link&gt;</span><br><span class="line">&#x2F;&#x2F;vue配置</span><br><span class="line">&#123;</span><br><span class="line">	path:&#39;detail&#x2F;:id&#x2F;:title&#39;,</span><br><span class="line">	component:Detail,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方式二(注意这里就不能写path了只能用name指定路由)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 跳转路由并携带params参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123;</span><br><span class="line">                  name:&#39;xiangqing&#39;,</span><br><span class="line">                  params:&#123;</span><br><span class="line">                    id:m.id,</span><br><span class="line">                    title:m.title</span><br><span class="line">                  &#125;</span><br><span class="line">                  &#125;&quot;&gt;</span><br><span class="line">    &#123;&#123;m.title&#125;&#125;</span><br><span class="line">&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure>
<p>获得路径参数：<code>this.$route.params.参数</code></p>
</li>
</ol>
<h3 id="路由query参数"><a href="#路由query参数" class="headerlink" title="路由query参数"></a>路由query参数</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 方式1： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;`/home/message/detail?id=$&#123;m.id&#125;&amp;title=$&#123;m.title&#125;`&quot;</span>&gt;</span>&#123;&#123;m.title&#125;&#125;<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 方式2：跳转路由并携带query参数，to的对象写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">                  path:&#x27;/home/message/detail&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="string">                  query:&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">                  id:m.id,</span></span></span><br><span class="line"><span class="tag"><span class="string">                  title:m.title</span></span></span><br><span class="line"><span class="tag"><span class="string">                  &#125;</span></span></span><br><span class="line"><span class="tag"><span class="string">                  &#125;&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;m.title&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>获取query参数：</p>
<ul>
<li><code>&lt;li&gt;消息编号：&#123;&#123;$route.query.id&#125;&#125;&lt;/li&gt;</code></li>
<li><code>&lt;li&gt;消息标题：&#123;&#123;$route.query.title&#125;&#125;&lt;/li&gt;</code></li>
</ul>
<h3 id="路由props属性"><a href="#路由props属性" class="headerlink" title="路由props属性"></a>路由props属性</h3><p>路由配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">        path:<span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line">            component:Detail,</span><br><span class="line"></span><br><span class="line">                <span class="comment">//props的第一种写法，值为对象，该对象中的所有key-value都会以props的形式传给Detail组件。</span></span><br><span class="line">                <span class="comment">// props:&#123;a:1,b:&#x27;hello&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//props的第二种写法，值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数，以props的形式传给Detail组件。</span></span><br><span class="line">                <span class="comment">// props:true</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//props的第三种写法，值为函数</span></span><br><span class="line">                <span class="function"><span class="title">props</span>(<span class="params">$route</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    id:$route.query.id,</span><br><span class="line">                    title:$route.query.title,</span><br><span class="line">                    a:<span class="number">1</span>,</span><br><span class="line">                    b:<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组件接收：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;ul&gt;</span><br><span class="line">		&lt;li&gt;消息编号：&#123;&#123;id&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">		&lt;li&gt;消息标题：&#123;&#123;title&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">	&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">		name:&#39;Detail&#39;,</span><br><span class="line">		props:[&#39;id&#39;,&#39;title&#39;],</span><br><span class="line">	&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><ul>
<li><p>全局路由守卫</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建并暴露一个路由器</span></span><br><span class="line"><span class="keyword">const</span> router =  <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes:[</span><br><span class="line">        &#123;</span><br><span class="line">            name:<span class="string">&#x27;xinwen&#x27;</span>,</span><br><span class="line">            path:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">            component:News,</span><br><span class="line">            meta:&#123;<span class="attr">isAuth</span>:<span class="literal">true</span>,<span class="attr">title</span>:<span class="string">&#x27;新闻&#x27;</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局前置路由守卫————初始化的时候被调用、每次路由切换之前被调用</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;前置路由守卫&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">    <span class="keyword">if</span>(to.meta.isAuth)&#123; <span class="comment">//判断是否需要鉴权</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;school&#x27;</span>)===<span class="string">&#x27;cy&#x27;</span>)&#123;</span><br><span class="line">            next()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            alert(<span class="string">&#x27;学校名不对，无权限查看！&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局后置路由守卫————初始化的时候被调用、每次路由切换之后被调用</span></span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;后置路由守卫&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">    <span class="built_in">document</span>.title = to.meta.title || <span class="string">&#x27;系统&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure></li>
<li><p>独享路由守卫（只有前置没有后置）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name:<span class="string">&#x27;xinwen&#x27;</span>,</span><br><span class="line">    path:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">    component:News,</span><br><span class="line">    meta:&#123;<span class="attr">isAuth</span>:<span class="literal">true</span>,<span class="attr">title</span>:<span class="string">&#x27;新闻&#x27;</span>&#125;,</span><br><span class="line">    beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;独享路由守卫&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">        <span class="keyword">if</span>(to.meta.isAuth)&#123; <span class="comment">//判断是否需要鉴权</span></span><br><span class="line">             <span class="keyword">if</span>(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;school&#x27;</span>)===<span class="string">&#x27;cy&#x27;</span>)&#123;</span><br><span class="line">                   next()</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  alert(<span class="string">&#x27;学校名不对，无权限查看！&#x27;</span>)</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             next()</span><br><span class="line">        &#125;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>组件内路由守卫</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过路由规则，进入该组件时被调用</span></span><br><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;About--beforeRouteEnter&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">    <span class="keyword">if</span>(to.meta.isAuth)&#123; <span class="comment">//判断是否需要鉴权</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;school&#x27;</span>)===<span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line">            next()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            alert(<span class="string">&#x27;学校名不对，无权限查看！&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过路由规则，离开该组件时被调用</span></span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;About--beforeRouteLeave&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">   next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="缓存路由组件"><a href="#缓存路由组件" class="headerlink" title="缓存路由组件"></a>缓存路由组件</h3><p>keep-alive是 Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 缓存多个路由组件 include中只能写组件名--&gt;</span><br><span class="line">&lt;!-- &lt;keep-alive :include&#x3D;&quot;[&#39;News&#39;,&#39;Message&#39;]&quot;&gt; --&gt;</span><br><span class="line">				</span><br><span class="line">&lt;!-- 缓存一个路由组件 --&gt;</span><br><span class="line">&lt;keep-alive include&#x3D;&quot;News&quot;&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br></pre></td></tr></table></figure>
<h3 id="有关路由的生命周期钩子"><a href="#有关路由的生命周期钩子" class="headerlink" title="有关路由的生命周期钩子"></a>有关路由的生命周期钩子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 当该路由组件被激活时调用--&gt;</span><br><span class="line">activated() &#123;</span><br><span class="line">			console.log(&#39;News组件被激活了&#39;)</span><br><span class="line">			this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">				console.log(&#39;@&#39;)</span><br><span class="line">				this.opacity -&#x3D; 0.01</span><br><span class="line">				if(this.opacity &lt;&#x3D; 0) this.opacity &#x3D; 1</span><br><span class="line">			&#125;,16)</span><br><span class="line">		&#125;</span><br><span class="line">&lt;!-- 当该路由组件失活时调用--&gt;                                    </span><br><span class="line">deactivated() &#123;</span><br><span class="line">	console.log(&#39;News组件失活了&#39;)</span><br><span class="line">	clearInterval(this.timer)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue实现动画</title>
    <url>/2022/09/07/%E5%89%8D%E7%AB%AF/vue/vue%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h1 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="方式1："><a href="#方式1：" class="headerlink" title="方式1："></a>方式1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;button @click&#x3D;&quot;isShow &#x3D; !isShow&quot;&gt;显示&#x2F;隐藏&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;!-- apper默认开始就显示动画 --&gt;</span><br><span class="line">      &lt;transition name&#x3D;&quot;hello&quot; appear&gt;</span><br><span class="line">          &lt;h1 v-show&#x3D;&quot;isShow&quot;&gt;你好呀！&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;&#x2F;transition&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#39;Test&#39;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            isShow:true,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    h1&#123;</span><br><span class="line">        background-color: aqua;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .hello-enter-active&#123;</span><br><span class="line">        animation: move 1s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .hello-leave-active&#123;</span><br><span class="line">        animation: move 1s reverse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @keyframes move&#123;</span><br><span class="line">        from&#123;</span><br><span class="line">            transform: translateX(-100%);</span><br><span class="line">        &#125;</span><br><span class="line">        to&#123;</span><br><span class="line">            transform: translateX(0px);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<h3 id="方式2："><a href="#方式2：" class="headerlink" title="方式2："></a>方式2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;button @click&#x3D;&quot;isShow &#x3D; !isShow&quot;&gt;显示&#x2F;隐藏&lt;&#x2F;button&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;transition-group name&#x3D;&quot;hello&quot; appear&gt;</span><br><span class="line">          &lt;h1 v-show&#x3D;&quot;!isShow&quot; key&#x3D;&quot;1&quot;&gt;你好呀！&lt;&#x2F;h1&gt;</span><br><span class="line">          &lt;h1 v-show&#x3D;&quot;isShow&quot; key&#x3D;&quot;2&quot;&gt;你好2呀！&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;&#x2F;transition-group&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#39;Test2&#39;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            isShow:true,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    h1&#123;</span><br><span class="line">        background-color: aqua;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* 进入的起点与离开的终点 *&#x2F;</span><br><span class="line">    .hello-enter,.hello-leave-to&#123;</span><br><span class="line">        transform: translateX(-100%);</span><br><span class="line">    &#125;</span><br><span class="line">    .hello-enter-active,.hello-leave-active&#123;</span><br><span class="line">        transition: 0.5s linear;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* 进入的终点离开的起点 *&#x2F;</span><br><span class="line">    .hello-enter-to,.hello-leave&#123;</span><br><span class="line">        transform: translateX(0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<h2 id="第三方动画库"><a href="#第三方动画库" class="headerlink" title="第三方动画库"></a>第三方动画库</h2><ul>
<li><p>Animate.css</p>
<ol>
<li><p>安装css库：npm install animate.css</p>
</li>
<li><p>直接引入样式：import ‘animate.css’</p>
</li>
<li><p>配置属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;transition-group </span><br><span class="line">    appear</span><br><span class="line">    name&#x3D;&quot;animate__animated animate__bounce&quot; </span><br><span class="line">    enter-active-class&#x3D;&quot;animate__swing&quot;</span><br><span class="line">    leave-active-class&#x3D;&quot;animate__backOutLeft&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件化</title>
    <url>/2022/09/01/%E5%89%8D%E7%AB%AF/vue/vue%E7%BB%84%E4%BB%B6%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Vue组件化"><a href="#Vue组件化" class="headerlink" title="Vue组件化"></a>Vue组件化</h1><h3 id="组件化的诞生"><a href="#组件化的诞生" class="headerlink" title="组件化的诞生"></a>组件化的诞生</h3><p>由于之前的传统页面编写方式存在的问题：</p>
<ul>
<li>依赖关系混乱不好维护</li>
<li>代码复用性低</li>
</ul>
<p>所以Vue提供了组件化的方式: 每个组件有自己相应的css、html、js等代码,体现了组件的封装，解决了传统方式存在的问题</p>
<h3 id="组件化的基本使用"><a href="#组件化的基本使用" class="headerlink" title="组件化的基本使用"></a>组件化的基本使用</h3><p>具体步骤：</p>
<ol>
<li>使用组件构造器创建组件</li>
<li>注册组件</li>
<li>使用组件</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mycpn</span>&gt;</span><span class="tag">&lt;/<span class="name">mycpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app2&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//1.使用组件构造器创建组件</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> cpnc = Vue.extend(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//自定义的模板</span></span></span><br><span class="line">        template:`</span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            	<span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            	<span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="comment">//2.注册组件，并起标签名（该组件为全局组件可以在多个vue实例中使用）</span></span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">&#x27;mycpn&#x27;</span>,cpnc)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            message:<span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app2 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&#x27;#app2&#x27;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            message:<span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line"><span class="javascript">            <span class="comment">//cpn使用组件时的标签名</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//这种为局部组件</span></span></span><br><span class="line">            cpn:cpnc</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p> 语法糖写法：<code>Vue.component(&#39;mycpn&#39;,&#123;template:</code><div><h2>我是标题</h2></div><code>&#125;)</code></p>
</blockquote>
<h3 id="组件的嵌套"><a href="#组件的嵌套" class="headerlink" title="组件的嵌套"></a>组件的嵌套</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">school</span>&gt;</span><span class="tag">&lt;/<span class="name">school</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">        Vue.config.productionTip = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> student = Vue.extend(&#123;</span></span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>学生姓名：</span><span class="template-variable">&#123;&#123;<span class="name">stuName</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>学生年龄：</span><span class="template-variable">&#123;&#123;<span class="name">age</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="javascript">                    stuName:<span class="string">&#x27;小王&#x27;</span>,</span></span><br><span class="line">                    age:18</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> school = Vue.extend(&#123;</span></span><br><span class="line">            template:`</span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>学校名称：</span><span class="template-variable">&#123;&#123;<span class="name">schoolName</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>学校地址：</span><span class="template-variable">&#123;&#123;<span class="name">address</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">student</span>&gt;</span><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="javascript">                    schoolName:<span class="string">&#x27;家里蹲&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                    address:<span class="string">&#x27;屋头&#x27;</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="comment">//组件的嵌套</span></span></span><br><span class="line">            components:&#123;</span><br><span class="line">                student</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&#x27;#root&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="comment">//局部注册</span></span></span><br><span class="line">            components:&#123;</span><br><span class="line">                school</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="模板的抽离"><a href="#模板的抽离" class="headerlink" title="模板的抽离"></a>模板的抽离</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 抽离模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用模板 --&gt;</span></span><br><span class="line">template:&#x27;#cpn&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h3><h4 id="父组件向子组件通信"><a href="#父组件向子组件通信" class="headerlink" title="父组件向子组件通信"></a>父组件向子组件通信</h4><p>通过props向子组件传递数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子组件利用props属性接收</span></span><br><span class="line"><span class="comment">//方式1以数组的方式接收</span></span><br><span class="line">props:[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;sex&#x27;</span>,<span class="string">&#x27;age&#x27;</span>] 简单接收</span><br><span class="line"><span class="comment">//方式2对象得复杂写法，可以进行类型的限制</span></span><br><span class="line">props:&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    age:<span class="built_in">Number</span>,</span><br><span class="line">    sex:<span class="built_in">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式3最复杂写法</span></span><br><span class="line">props:&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>, <span class="comment">//类型</span></span><br><span class="line">        required:<span class="literal">true</span> <span class="comment">//是否必要的</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age:&#123;</span><br><span class="line">        type:<span class="built_in">Number</span>,</span><br><span class="line">        <span class="keyword">default</span>:<span class="number">99</span> <span class="comment">//默认值</span></span><br><span class="line">    &#125;,</span><br><span class="line">    sex:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        required:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父组件以标签属性传值,注意不使用v-bind会直接以字符串形式传递</span></span><br><span class="line">&lt;Student :name=<span class="string">&quot;李四&quot;</span> :sex=<span class="string">&quot;女&quot;</span> :age=<span class="string">&quot;18&quot;</span>/&gt; </span><br></pre></td></tr></table></figure>
<h4 id="子组件向父组件通信"><a href="#子组件向父组件通信" class="headerlink" title="子组件向父组件通信"></a>子组件向父组件通信</h4><p>通过自定义事件向父组件发送数据</p>
<p>子组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;stu&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>学生名:&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>性别：&#123;&#123;sex&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sendName&quot;</span>&gt;</span>把学生名传给app<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;unbind&quot;</span>&gt;</span>解绑事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name:<span class="string">&#x27;Student&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="javascript">           name:<span class="string">&#x27;张三&#x27;</span>,</span></span><br><span class="line"><span class="javascript">           sex:<span class="string">&#x27;男&#x27;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">sendName</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//触发绑定的getName事件,并传参</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$emit(<span class="string">&#x27;getName&#x27;</span>,<span class="built_in">this</span>.name);</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">unbind</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//解绑事件(只适用单个事件,多个参数传[]数据,不传参数就等于解绑所有自定义事件)</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$off(<span class="string">&#x27;getName&#x27;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>父组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 给子组件绑定一个自定义事件：实现子给父传数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Student</span> <span class="attr">v-on:getName</span>=<span class="string">&quot;getStudentName&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--@click.native表明该事件为原生事件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">ref</span>=<span class="string">&quot;student&quot;</span> @<span class="attr">click.native</span>=<span class="string">&quot;show&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Student <span class="keyword">from</span> <span class="string">&#x27;./components/Student.vue&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name:<span class="string">&#x27;App&#x27;</span>,</span></span><br><span class="line">    components: &#123; Student &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        msg:<span class="string">&#x27;你好啊！！！&#x27;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">getStudentName</span>(<span class="params">name</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;学生名：&quot;</span>+name);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//同样可以绑定事件</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$refs.student.$on(<span class="string">&#x27;getName&#x27;</span>,<span class="built_in">this</span>.getStudentName)</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="父子组件之间的访问"><a href="#父子组件之间的访问" class="headerlink" title="父子组件之间的访问"></a>父子组件之间的访问</h3><h4 id="父组件访问子组件"><a href="#父组件访问子组件" class="headerlink" title="父组件访问子组件"></a>父组件访问子组件</h4><p>使用$children或$refs</p>
<ol>
<li><code>this.$children</code>获得子组件数组</li>
<li><code>this.refs</code>获取标有ref属性的子组件数组，若是原生DOM则获取的是原生DOM元素</li>
</ol>
<h4 id="子组件访问父组件"><a href="#子组件访问父组件" class="headerlink" title="子组件访问父组件"></a>子组件访问父组件</h4><p> 使用$parent</p>
<ol>
<li><code>this.$parent</code>获得父组件（不常用）</li>
</ol>
<h4 id="访问根组件"><a href="#访问根组件" class="headerlink" title="访问根组件"></a>访问根组件</h4><p>使用$root</p>
<ol>
<li><code>this.$root</code>获得根组件</li>
</ol>
<h3 id="组件之间的访问"><a href="#组件之间的访问" class="headerlink" title="组件之间的访问"></a>组件之间的访问</h3><h4 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h4><p>可以任意组件间进行通信</p>
<p>总线特点：</p>
<pre><code> 1. 对于所有组件都可见
 2. 可以调用$on、$off、$emit
</code></pre>
<p>Vue的原型对象刚好符合(最好放在这里)</p>
<ul>
<li><p>在main.js中布局全局事件总线</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入Vue</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入App</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="comment">//关闭Vue的生产提示</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const demo = Vue.extend(&#123;&#125;)</span></span><br><span class="line"><span class="comment">// Vue.prototype.x = new demo()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Vue.prototype.$bus = <span class="built_in">this</span>  <span class="comment">//布局全局事件总线</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>进行组件间通信</p>
<p>组件1（接收方，给总线绑定事件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;stu&quot;&gt;</span><br><span class="line">      &lt;h2&gt;学生名:&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;h2&gt;性别：&#123;&#123;sex&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#39;Student&#39;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">           name:&#39;张三&#39;,</span><br><span class="line">           sex:&#39;男&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        this.$bus.$on(&#39;hello&#39;,((data)&#x3D;&gt;&#123;</span><br><span class="line">            console.log(&#39;我是Student组件，收到了数据&#39;,data)</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy()&#123;</span><br><span class="line">        this.$bus.$off(&#39;hello&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .stu&#123;</span><br><span class="line">        background-color: aquamarine;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<p>组件2发送数据方（调用接收方给总线绑定的事件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;school&quot;&gt;</span><br><span class="line">      &lt;h2&gt;学校名称:&#123;&#123;schoolName&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;button @click&#x3D;&quot;sendSchoolName&quot;&gt;把学校名给student组件&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#39;School&#39;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">           schoolName:&#39;家里蹲&#39;,</span><br><span class="line">           address:&#39;屋头&#39; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        sendSchoolName()&#123;</span><br><span class="line">            this.$bus.$emit(&#39;hello&#39;, this.schoolName)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .school&#123;</span><br><span class="line">        background-color: aquamarine;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<h4 id="消息订阅与发布"><a href="#消息订阅与发布" class="headerlink" title="消息订阅与发布"></a>消息订阅与发布</h4></li>
</ul>
<p>同样用于任意组件间通信</p>
<p>基于pubsub-js </p>
<ol>
<li><p>安装pubsub-js ： npm i pubsub-js</p>
</li>
<li><p>引入js ：import pubsub from ‘pubsub-js’</p>
</li>
<li><p>接收数据方需要订阅消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mounted()&#123;</span><br><span class="line">        this.pubId &#x3D; pubsub.subscribe(&#39;hello&#39;,(msgName,data)&#x3D;&gt;&#123;</span><br><span class="line">            console.log(&#39;有人发布了&#39;+msgName+&#39;消息&#39;,+data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeCreate()&#123;</span><br><span class="line">        pubsub.unsubscribe(this.pubId)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>发送数据方需要发布消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">        sendSchoolName()&#123;</span><br><span class="line">            pubsub.publish(&#39;hello&#39;,666)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3></li>
<li><p>语法：<code>this.$nextTick(&#39;xxx&#39;,数据)</code></p>
</li>
<li><p>作用：在下一次DOM更新结束后执行其指定的回调</p>
</li>
</ol>
<h3 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h3><p>插槽的作用：</p>
<ol>
<li>组件的插槽也是为了让我们封装的组件更加具有扩展性。</li>
<li>让使用者可以决定组件内部的一些内容到底展示什么。</li>
</ol>
<h4 id="1-默认插槽"><a href="#1-默认插槽" class="headerlink" title="1.默认插槽"></a>1.默认插槽</h4><p>子组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;category&quot;&gt;</span><br><span class="line">		&lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;&#x2F;h3&gt;</span><br><span class="line">		&lt;!-- 定义一个插槽（挖个坑，等着组件的使用者进行填充） --&gt;</span><br><span class="line">		&lt;slot&gt;我是一些默认值，当使用者没有传递具体结构时，我会出现&lt;&#x2F;slot&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<p>父组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">		&lt;Category title&#x3D;&quot;美食&quot; &gt;</span><br><span class="line">			&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;s3.ax1x.com&#x2F;2021&#x2F;01&#x2F;16&#x2F;srJlq0.jpg&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">		&lt;&#x2F;Category&gt;</span><br><span class="line"></span><br><span class="line">		&lt;Category title&#x3D;&quot;游戏&quot; &gt;</span><br><span class="line">			&lt;ul&gt;</span><br><span class="line">				&lt;li v-for&#x3D;&quot;(g,index) in games&quot; :key&#x3D;&quot;index&quot;&gt;&#123;&#123;g&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">			&lt;&#x2F;ul&gt;</span><br><span class="line">		&lt;&#x2F;Category&gt;</span><br><span class="line"></span><br><span class="line">		&lt;Category title&#x3D;&quot;电影&quot;&gt;</span><br><span class="line">			&lt;video controls src&#x3D;&quot;http:&#x2F;&#x2F;clips.vorwaerts-gmbh.de&#x2F;big_buck_bunny.mp4&quot;&gt;&lt;&#x2F;video&gt;</span><br><span class="line">		&lt;&#x2F;Category&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-具名插槽"><a href="#2-具名插槽" class="headerlink" title="2.具名插槽"></a>2.具名插槽</h4><p>子组件中的插槽加个name，以便引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;slot name&#x3D;&quot;center&quot;&gt;我是一些默认值，当使用者没有传递具体结构时，我会出现1&lt;&#x2F;slot&gt;</span><br><span class="line">&lt;slot name&#x3D;&quot;footer&quot;&gt;我是一些默认值，当使用者没有传递具体结构时，我会出现2&lt;&#x2F;slot&gt;</span><br></pre></td></tr></table></figure>
<p>父组件中的组件用slot属性指明插入哪个插槽(同样可以用v-slot:center)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Category title&#x3D;&quot;美食&quot; &gt;</span><br><span class="line">	&lt;img slot&#x3D;&quot;center&quot; src&#x3D;&quot;https:&#x2F;&#x2F;s3.ax1x.com&#x2F;2021&#x2F;01&#x2F;16&#x2F;srJlq0.jpg&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">	&lt;a slot&#x3D;&quot;footer&quot; href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;更多美食&lt;&#x2F;a&gt;</span><br><span class="line">&lt;&#x2F;Category&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3-作用域插槽"><a href="#3-作用域插槽" class="headerlink" title="3.作用域插槽"></a>3.作用域插槽</h4><p>子组件可以通过slot向插槽使用者传输数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;category&quot;&gt;</span><br><span class="line">		&lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;&#x2F;h3&gt;</span><br><span class="line">		&lt;slot :games&#x3D;&quot;games&quot; msg&#x3D;&quot;hello&quot;&gt;我是默认的一些内容&lt;&#x2F;slot&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<p>父组件 必须用template标签包裹，不然接收不到数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">		&lt;Category title&#x3D;&quot;游戏&quot;&gt;</span><br><span class="line">			&lt;template scope&#x3D;&quot;wht&quot;&gt;</span><br><span class="line">				&lt;ul&gt;</span><br><span class="line">					&lt;li v-for&#x3D;&quot;(g,index) in wht.games&quot; :key&#x3D;&quot;index&quot;&gt;&#123;&#123;g&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">				&lt;&#x2F;ul&gt;</span><br><span class="line">			&lt;&#x2F;template&gt;</span><br><span class="line">		&lt;&#x2F;Category&gt;</span><br><span class="line"></span><br><span class="line">		&lt;Category title&#x3D;&quot;游戏&quot;&gt;</span><br><span class="line">			&lt;template scope&#x3D;&quot;&#123;games&#125;&quot;&gt;</span><br><span class="line">				&lt;ol&gt;</span><br><span class="line">					&lt;li style&#x3D;&quot;color:red&quot; v-for&#x3D;&quot;(g,index) in games&quot; :key&#x3D;&quot;index&quot;&gt;&#123;&#123;g&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">				&lt;&#x2F;ol&gt;</span><br><span class="line">			&lt;&#x2F;template&gt;</span><br><span class="line">		&lt;&#x2F;Category&gt;</span><br><span class="line"></span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<h3 id="mixin混入"><a href="#mixin混入" class="headerlink" title="mixin混入"></a>mixin混入</h3><p>混合js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mixin = &#123;</span><br><span class="line">    methods:&#123;</span><br><span class="line">        <span class="function"><span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="built_in">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>局部混合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;引入混合(局部混合)</span><br><span class="line">import &#123;mixin&#125; from &#39;..&#x2F;mixin&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#39;Student&#39;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">           name:&#39;张三&#39;,</span><br><span class="line">           sex:&#39;男&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">   mixins:[mixin]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>全局混入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;全局混合</span><br><span class="line">import &#123;mixin&#125; from &#39;.&#x2F;mixin&#39;</span><br><span class="line">Vue.mixin(mixin)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD设计流程</title>
    <url>/2023/09/18/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/DDD/DDD%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h1><h2 id="战略设计"><a href="#战略设计" class="headerlink" title="战略设计"></a>战略设计</h2><p>战略设计是根据用户旅程分析，找出<strong>领域对象</strong>和<strong>聚合根</strong>，对<strong>实体</strong>和<strong>值对象</strong>进行聚类组成<strong>聚合</strong>，<strong>划分限界上下文</strong>，<strong>建立领域模型</strong>的过程。</p>
<p>战略设计采用的方法是事件风暴，包括：产品愿景、场景分析、领域建模和微服务拆分等几个主要过程。</p>
<h3 id="产品愿景"><a href="#产品愿景" class="headerlink" title="产品愿景"></a>产品愿景</h3><p>事件风暴时，所有参与者针对每一个要点，在贴纸上写出自己的意见，贴到白板上。事件风暴主持者会对每个贴纸，讨论并对发散的意见进行收敛和统一，形成产品愿景图。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230821112711283.png" alt="image-20230821112711283" style="zoom:50%;" />

<p>产品愿景分析对于初创系统明确系统建设重点，统一团队建设目标和建立通用语言是很有价值的。但如果你的系统目标和需求非常清晰，这一步可以忽略。</p>
<h3 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h3><p>场景分析是从用户视角出发，探索业务领域中的典型场景，产出领域中需要支撑的场景分类、用例操作以及不同子域之间的依赖关系，用以支撑领域建模。</p>
<p><strong>方法：</strong></p>
<p>项目团队成员一起用事件风暴分析，根据不同角色的旅程和场景分析，尽可能全面地梳理从前端操作到后端业务逻辑发生的所有<strong>操作、命令、领域事件以及外部依赖关系</strong>等信息。</p>
<p><strong>例如：</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230821112949225.png" alt="image-20230821112949225" style="zoom:50%;" />

<h3 id="领域建模"><a href="#领域建模" class="headerlink" title="领域建模"></a>领域建模</h3><p>领域建模是通过对业务和问题域进行分析，建立领域模型。向上通过限界上下文指导微服务边界设计，向下通过聚合指导实体对象设计。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>找出领域实体和值对象等领域对象；</li>
<li>找出聚合根，根据实体、值对象与聚合根的依赖关系，建立聚合；</li>
<li>根据业务及语义边界等因素，定义限界上下文。</li>
</ol>
<h3 id="微服务的拆分"><a href="#微服务的拆分" class="headerlink" title="微服务的拆分"></a>微服务的拆分</h3><p>理论上一个限界上下文就可以设计为一个微服务，但还需要综合考虑多种外部因素，比如：职责单一性、敏态与稳态业务分离、非功能性需求（如弹性伸缩、版本发布频率和安全等要求）、软件包大小、团队沟通效率和技术异构等非业务要素。</p>
<h2 id="战术设计"><a href="#战术设计" class="headerlink" title="战术设计"></a>战术设计</h2><p>战术设计是根据领域模型进行微服务设计的过程。这个阶段主要梳理微服务内的领域对象，梳理领域对象之间的关系，确定它们在代码模型和分层架构中的位置，建立领域模型与微服务模型的映射关系，以及服务之间的依赖关系。</p>
<p>战术设计包括以下两个阶段：<strong>分析微服务领域对象</strong>和<strong>设计微服务代码结构</strong>。</p>
<h3 id="分析微服务领域对象"><a href="#分析微服务领域对象" class="headerlink" title="分析微服务领域对象"></a>分析微服务领域对象</h3><p>领域模型有很多领域对象，但是这些对象带有比较重的业务属性。要完成从领域模型到微服务的落地，还需要进一步的分析和设计。在事件风暴基础上，我们进一步细化领域对象以及它们的关系，补充事件风暴可能遗漏的业务和技术细节。</p>
<h3 id="服务的识别和设计"><a href="#服务的识别和设计" class="headerlink" title="服务的识别和设计"></a>服务的识别和设计</h3><p>我们可以将命令作为服务识别和设计的起点；具体步骤如下：</p>
<ol>
<li>根据命令设计应用服务，确定应用服务的功能，服务集合，组合和编排方式。服务集合中的服务包括领域服务或其它微服务的应用服务。</li>
<li>根据应用服务功能要求设计领域服务，定义领域服务。这里需要注意：应用服务可能是由多个聚合的领域服务组合而成的。</li>
<li>根据领域服务的功能，确定领域服务内的实体以及功能。</li>
<li>设计实体基本属性和方法。</li>
</ol>
<h3 id="聚合中的对象"><a href="#聚合中的对象" class="headerlink" title="聚合中的对象"></a>聚合中的对象</h3><p>逐一对聚合中的对象进行详细分析，确定出对象中属性，画出请假聚合对象关系图。</p>
<p><strong>例如：</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230821113837407.png" alt="image-20230821113837407" style="zoom:50%;" />

<blockquote>
<p>值对象同时被聚合根和实体引用。这类值对象的数据来<strong>源于其它聚合，不可修改，可重复使用</strong>。将这种对象设计为值对象而不是实体，可以提高系统性能，降低数据库实体关联的复杂度，所以我一般建议优先设计为值对象。</p>
</blockquote>
<h3 id="微服务内的对象清单"><a href="#微服务内的对象清单" class="headerlink" title="微服务内的对象清单"></a>微服务内的对象清单</h3><p>在确定各领域对象的属性后，我们就可以设计各领域对象在代码模型中的代码对象（包括代码对象的包名、类名和方法名），建立领域对象与代码对象的一一映射关系了。根据这种映射关系，相关人员可快速定位到业务逻辑所在的代码位置。</p>
<p><strong>例如：</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230821113932516.png" alt="image-20230821113932516"  />

<h3 id="设计微服务代码结构"><a href="#设计微服务代码结构" class="headerlink" title="设计微服务代码结构"></a>设计微服务代码结构</h3><p>根据 DDD 的代码模型和各领域对象所在的包、类和方法，我们可以定义出请假微服务的代码结构，设计代码对象。</p>
<ul>
<li><p><strong>应用层代码结构：</strong></p>
<p>应用层包括：应用服务、DTO 以及事件发布相关代码。</p>
<blockquote>
<p>如果应用服务逻辑复杂的话，一个应用服务就可以构建一个类，这样可以避免一个类的代码过于庞大，不利于维护。</p>
</blockquote>
</li>
<li><p><strong>领域层代码结构：</strong></p>
<p>领域层包括一个或多个聚合的实体类、事件实体类、领域服务以及工厂、仓储相关代码。一个聚合对应一个聚合代码目录，聚合之间在代码上完全隔离，聚合之间通过应用层协调。</p>
</li>
</ul>
<h2 id="后续的工作"><a href="#后续的工作" class="headerlink" title="后续的工作"></a>后续的工作</h2><ol>
<li><strong>详细设计</strong><br>在完成领域模型和微服务设计后，我们还需要对微服务进行详细的设计。主要设计以下内容：实体属性、数据库表和字段、实体与数据库表映射、服务参数规约及功能实现等。</li>
<li><strong>代码开发和测试</strong><br>开发人员只需要按照详细的设计文档和功能要求，找到业务功能对应的代码位置，完成代码开发就可以了。代码开发完成后，开发人员要编写单元测试用例，基于挡板模拟依赖对象完成服务测试。</li>
</ol>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>DDD领域模型</category>
      </categories>
      <tags>
        <tag>DDD领域模型</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD领域模型基础</title>
    <url>/2023/09/16/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/DDD/DDD%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="领域驱动设计（DDD）"><a href="#领域驱动设计（DDD）" class="headerlink" title="领域驱动设计（DDD）"></a>领域驱动设计（DDD）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>DDD 核心思想是通过领域驱动设计方法定义领域模型，从而确定业务和应用边界，保证业务模型与代码模型的一致性。</p>
<p>按照 DDD 方法设计出的微服务的<strong>业务和应用边界</strong>都非常合理，可以很好地实现微服务内部和外部的<strong>“高内聚、低耦合”</strong>。</p>
<p><strong>为什么 DDD 适合微服务？</strong></p>
<p>DDD 不是架构，而是一种架构设计方法论，它通过边界划分将复杂业务领域简单化，帮我们设计出清晰的领域和应用边界，可以很容易地实现架构演进。</p>
<h3 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h3><ul>
<li><p><strong>领域和子域：</strong></p>
<p>在研究和解决业务问题时，DDD 会按照一定的规则将业务领域进行细分，当领域细分到一定的程度后，DDD 会将问题范围限定在特定的边界内，在这个边界内建立领域模型，进而用代码实现该领域模型，解决相应的业务问题。</p>
<p><strong>DDD 的领域就是这个边界内要解决的业务问题域，而子域就是领域再细分，对应一个更小的问题域或更小的业务范围。</strong></p>
<blockquote>
<p>每一个细分的领域都会有一个知识体系，也就是 DDD 的领域模型。</p>
</blockquote>
</li>
<li><p><strong>核心域、通用域和支撑域：</strong></p>
<p>子域可以根据自身重要性和功能属性划分为三类子域，它们分别是：核心域、通用域和支撑域。</p>
<ul>
<li><strong>核心域：</strong>决定产品和公司核心竞争力的子域是核心域，它是业务成功的主要因素和公司的核心竞争力。</li>
<li><strong>通用域：</strong>没有太多个性化的诉求，同时被多个子域使用的通用功能子域是通用域。</li>
<li><strong>支撑域：</strong>既不包含决定产品和公司核心竞争力的功能，也不包含通用功能的子域，它就是支撑域。</li>
</ul>
</li>
<li><p><strong>限界上下文：</strong></p>
<p>DDD 在战略设计上提出了“限界上下文”这个概念，用来确定语义所在的领域边界。</p>
<p>限界上下文的定义就是：用来封装通用语言和领域对象，提供上下文环境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性。</p>
</li>
<li><p><strong>实体和值对象：</strong></p>
<p>这两个概念都是领域模型中的领域对象；实体和值对象是组成领域模型的基础单元。</p>
<ul>
<li><strong>实体：</strong>实体是指那些具有唯一标识的领域对象，这些对象在业务中有明确定义的生命周期和状态。在DDD中，实体是指在整个系统中具有唯一标识并具有业务意义的对象。</li>
<li><strong>值对象：</strong>值对象（Value Object）是另一个重要的概念，它与实体（Entity）不同，值对象没有唯一的标识符，而是根据其属性值来比较和区分。值对象通常用于描述实体的属性或组合数据，它们在系统中是不可变的，即一旦创建，就不能被修改。</li>
</ul>
</li>
<li><p><strong>聚合和聚合根：</strong></p>
<ul>
<li><p><strong>聚合：</strong>领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。</p>
<p>聚合就是由业务和逻辑紧密关联的实体和值对象组合而成的，聚合是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化。</p>
</li>
<li><p><strong>聚合根：</strong>聚合根的主要目的是为了避免由于复杂数据模型缺少统一的业务规则控制，而导致聚合、实体之间数据不一致性的问题。</p>
<blockquote>
<p>如果把聚合比作组织，那<strong>聚合根就是这个组织的负责人</strong>。聚合根也称为根实体，它不仅是实体，还是聚合的管理者。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>领域事件：</strong></p>
<p>在<strong>事件风暴（Event Storming）</strong>时，我们发现除了命令和操作等业务行为以外，还有一种非常重要的事件，<strong>这种事件发生后通常会导致进一步的业务操作</strong>，在 DDD 中这种事件被称为领域事件。领域事件的引入可以帮助实现解耦和业务分析，支持系统中的事件驱动架构。</p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>领域事件是不可变的</strong>：一旦领域事件被创建并发布，其内容就不能再被修改。这样可以确保事件的可靠性和一致性。</li>
<li><strong>事件的发布和订阅</strong>：在DDD中，领域事件通过发布和订阅机制进行传递。当一个领域事件发生时，相关的订阅者可以接收到该事件并做出相应的处理。</li>
<li><strong>支持业务驱动</strong>：领域事件的设计应该紧密关联业务场景，它们描述了在业务领域中发生的重要业务动作和决策。</li>
<li><strong>与聚合根密切相关</strong>：通常，领域事件与聚合根（Aggregate Root）的操作和状态变化相关联。聚合根是DDD中的一个重要概念，用于保持领域对象的一致性和完整性。</li>
<li><strong>事件溯源</strong>：领域事件还可以用于实现事件溯源（Event Sourcing），通过将所有状态变化表示为一系列事件，可以回溯和重建系统的状态。</li>
</ol>
</li>
</ul>
<h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><p>DDD 分层架构就是优化后的四层架构；从上到下依次是：用户接口层、应用层、领域层和基础层。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230729151056570.png" alt="image-20230729151056570" style="zoom: 80%;" />

<ol>
<li><p>用户接口层：</p>
<p>用户接口层负责向用户显示信息和解释用户指令。这里的用户可能是：用户、程序、自动化测试和批处理脚本等等。</p>
</li>
<li><p>应用层：</p>
<p>应用层是很薄的一层，理论上不应该有业务规则或逻辑，主要面向用例和流程相关的操作。但应用层又位于领域层之上，因为领域层包含多个聚合，所以它可以协调多个聚合的服务和领域对象完成服务编排和组合，协作完成业务操作。</p>
<blockquote>
<p>此外，应用层也是微服务之间交互的通道，它可以调用其它微服务的应用服务，完成微服务之间的服务组合和编排。在设计和开发时，不要将本该放在领域层的业务逻辑放到应用层中实现。</p>
<p>在微服务内部，实体的方法被领域服务组合和封装，领域服务又被应用服务组合和封装。</p>
</blockquote>
</li>
<li><p>领域层：</p>
<p>领域层的作用是实现企业核心业务逻辑，通过各种校验手段保证业务的正确性。领域层主要体现领域模型的业务能力，它用来表达业务概念、业务状态和业务规则。</p>
<p>领域层包含聚合根、实体、值对象、领域服务等领域模型中的领域对象。</p>
</li>
<li><p>基础层：</p>
<p>基础层是贯穿所有层的，它的作用就是为其它各层提供通用的技术和基础服务，包括第三方工具、驱动、消息中间件、网关、文件、缓存以及数据库等。比较常见的功能还是提供数据库持久化。</p>
<p>基础层包含基础服务，它采用依赖倒置设计，封装基础资源服务，实现应用层、领域层与基础层的解耦，降低外部资源变化对应用的影响。</p>
</li>
</ol>
<blockquote>
<p>优化后的 DDD 分层架构模型就属于严格分层架构，<strong>任何层只能对位于其直接下方的层产生依赖。</strong></p>
<p><strong>传统MVC到DDD四层架构的变化：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230730153752752.png" alt="image-20230730153752752"></p>
</blockquote>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>微服务一级目录是按照 DDD 分层架构的分层职责来定义的。从下面这张图中，我们可以看到，在代码模型里分别为用户接口层、应用层、领域层和基础层，建立了 interfaces、application、domain 和 infrastructure 四个一级代码目录。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230804154123361.png" alt="image-20230804154123361"></p>
<h3 id="Interfaces（用户接口层）"><a href="#Interfaces（用户接口层）" class="headerlink" title="Interfaces（用户接口层）"></a>Interfaces（用户接口层）</h3><p>它主要存放用户接口层与前端交互、展现数据相关的代码。前端应用通过这一层的接口，向应用服务获取展现所需的数据。这一层主要用来处理用户发送的 Restful 请求，解析用户输入的配置文件，并将数据传递给 Application 层。数据的组装、数据传输格式以及 Facade 接口等代码都会放在这一层目录里。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230804154222799.png" alt="image-20230804154222799"></p>
<ul>
<li><strong>Assembler：</strong>实现 DTO 与领域对象之间的相互转换和数据交换。一般来说 Assembler 与 DTO 总是一同出现。</li>
<li><strong>Dto：</strong>它是数据传输的载体，内部不存在任何业务逻辑，我们可以通过 DTO 把内部的领域对象与外界隔离。</li>
<li><strong>Facade：</strong>提供较粗粒度的调用接口，将用户请求委派给一个或多个应用服务进行处理。</li>
</ul>
<h3 id="Application（应用层）"><a href="#Application（应用层）" class="headerlink" title="Application（应用层）"></a>Application（应用层）</h3><p>它主要存放应用层服务组合和编排相关的代码。应用服务向下基于微服务内的领域服务或外部微服务的应用服务完成服务的编排和组合，向上为用户接口层提供各种应用数据展现支持服务。应用服务和事件等代码会放在这一层目录里。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230804154319920.png" alt="image-20230804154319920"></p>
<ul>
<li><p><strong>Event（事件）：</strong>这层目录主要存放事件相关的代码。它包括两个子目录：publish 和 subscribe。</p>
<ul>
<li>publish ：主要存放事件发布相关代码。</li>
<li>subscribe：主要存放事件订阅相关代码。</li>
</ul>
</li>
<li><p><strong>Service（应用服务）：</strong></p>
<p>这层的服务是应用服务。应用服务会对多个领域服务或外部应用服务进行封装、编排和组合，对外提供粗粒度的服务。应用服务主要实现服务组合和编排，是一段独立的业务逻辑。</p>
</li>
</ul>
<h3 id="Domain（领域层）"><a href="#Domain（领域层）" class="headerlink" title="Domain（领域层）"></a>Domain（领域层）</h3><p>它主要存放领域层核心业务逻辑相关的代码。领域层可以包含多个聚合代码包，它们共同实现领域模型的核心业务逻辑。聚合以及聚合内的实体、方法、领域服务和事件等代码会放在这一层目录里。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230804154506906.png" alt="image-20230804154506906"></p>
<ul>
<li><p><strong>Aggregate（聚合）：</strong></p>
<p>它是聚合软件包的根目录，可以根据实际项目的聚合名称命名，比如权限聚合。在聚合内定义聚合根、实体和值对象以及领域服务之间的关系和边界。聚合内实现高内聚的业务逻辑，它的代码可以独立拆分为微服务。</p>
</li>
<li><p><strong>Entity（实体）：</strong></p>
<p>它存放聚合根、实体、值对象以及工厂模式（Factory）相关代码。实体类采用充血模型，同一实体相关的业务逻辑都在实体类代码中实现。跨实体的业务逻辑代码在领域服务中实现。</p>
</li>
<li><p><strong>Event（事件）：</strong>它存放事件实体以及与事件活动相关的业务逻辑代码。</p>
</li>
<li><p><strong>Service（领域服务）：</strong></p>
<p>它存放领域服务代码。一个领域服务是多个实体组合出来的一段业务逻辑。你可以将聚合内所有领域服务都放在一个领域服务类中，你也可以把每一个领域服务设计为一个类。</p>
</li>
<li><p><strong>Repository（仓储）：</strong>它存放所在聚合的查询或持久化领域对象的代码，通常包括仓储接口和仓储实现方法。</p>
</li>
</ul>
<h3 id="Infrastructure（基础层）"><a href="#Infrastructure（基础层）" class="headerlink" title="Infrastructure（基础层）"></a>Infrastructure（基础层）</h3><p>它主要存放基础资源服务相关的代码，为其它各层提供的通用技术能力、三方软件包、数据库服务、配置和基础资源服务的代码都会放在这一层目录里。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230804154933251.png" alt="image-20230804154933251"></p>
<ul>
<li><strong>Config：</strong>主要存放配置相关代码。</li>
<li><strong>Util：</strong>主要存放平台、开发框架、消息、数据库、缓存、文件、总线、网关、第三方类库、通用算法等基础代码，你可以为不同的资源类别建立不同的子目录。</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>DDD领域模型</category>
      </categories>
      <tags>
        <tag>DDD领域模型</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB</title>
    <url>/2023/01/04/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB/</url>
    <content><![CDATA[<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MongoDB是一个开源、高性能、无模式的文档型数据库，当初的设计就是用于简化开发和方便扩展，是NoSQL数据库产品中的一种。是最像关系型数据库（MySQL）的非关系型数据库。<br>它支持的数据结构非常松散，是一种类似于 JSON 的 格式叫BSON，所以它既可以存储比较复杂的数据类型，又相当的灵活。</p>
<p>MongoDB中的记录是一个文档，它是一个由字段和值对（field:value）组成的数据结构。MongoDB文档类似于JSON对象，即一个文档认为就是一个对象。字段的数据类型是字符型，它的值除了使用基本的一些类型外，还可以包括其他文档、普通数组和文档数组。</p>
<h3 id="常见运用场景"><a href="#常见运用场景" class="headerlink" title="常见运用场景"></a>常见运用场景</h3><p>MongoDB常用于对数据操作具有“三高”需求的场景，可以理解为高性能版mysql主要解决海量数据的访问效率问题，不像redis用于处理数据量较小的高性能操作上。</p>
<p>场景的主要特点：</p>
<ul>
<li><p>数据量大</p>
</li>
<li><p>写入操作频繁（读写都很频繁）</p>
</li>
<li><p>价值较低的数据，对事务性要求不高</p>
</li>
</ul>
<blockquote>
<p>解释：“三高”需求：<br>• High performance - 对数据库高并发读写的需求。<br>• Huge Storage - 对海量数据的高效率存储和访问的需求。<br>• High Scalability &amp;&amp; High Availability- 对数据库的高可扩展性和高可用性的需求。</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Docker方式安装"><a href="#Docker方式安装" class="headerlink" title="Docker方式安装"></a>Docker方式安装</h3><ul>
<li><p>查找mongoDB镜像：<code>docker search mongo</code></p>
</li>
<li><p>从远程仓库拉取镜像：<code>docker pull mongo:5.0.5</code></p>
</li>
<li><p>查看是否有拉取到的mongoDB：<code>docker images</code></p>
</li>
<li><p>新建本机备份目录：<code>/opt/docker_app/mongoDB/data</code></p>
</li>
<li><p>创建并启动容器(添加数据卷)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run  -p 27017:27017 --name myMongoDB --privileged&#x3D;true --restart&#x3D;always -v &#x2F;opt&#x2F;docker_app&#x2F;mongoDB&#x2F;data:&#x2F;data&#x2F;db -d mongo:5.0.5 --auth</span><br></pre></td></tr></table></figure></li>
<li><p>进入容器：<code>docker exec -it 容器id /bin/bash</code></p>
</li>
<li><p>进入数据库：<code>mongo</code></p>
</li>
<li><p>创建用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#切换数据库</span><br><span class="line">use admin; </span><br><span class="line"></span><br><span class="line">#创建用户</span><br><span class="line">db.createUser(&#123; user:&#39;root&#39;,pwd:&#39;123456&#39;,roles:[ &#123; role:&#39;userAdminAnyDatabase&#39;, db: &#39;admin&#39;&#125;,&quot;readWriteAnyDatabase&quot;]&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>安装完毕</p>
</li>
</ul>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>MongoDB有三大主要概念：库、集合、文档</p>
<h3 id="库-DataBase"><a href="#库-DataBase" class="headerlink" title="库(DataBase)"></a>库(DataBase)</h3><p>mongodb中的库就类似于传统关系型数据库中库的概念，用来通过不同库隔离不同应用数据。mongodb中可以建立多个数据库。每一个库都有自己的集合和权限，不同的数据库也放置在不同的文件中。默认的数据库为”test”，数据库存储在启动指定的data目录中。</p>
<h3 id="集合-Collection"><a href="#集合-Collection" class="headerlink" title="集合(Collection)"></a>集合(Collection)</h3><p>集合就是MongoDB文档组，类似于RDBMS(关系数据库管理系统: RelationalDatabase Management System)中的表的概念。</p>
<p>集合存在于数据库中，一个库中可以创建多个集合。每个集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。</p>
<h3 id="文档-Document"><a href="#文档-Document" class="headerlink" title="文档(Document)"></a>文档(Document)</h3><p>文档集合中一条条记录，是一组键值(key-value)对(即BSON)。MongoDB的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是MongoDB非常突出的特点。</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>MongoDB的最小存储单位就是文档(document)对象。文档(document)对象对应于关系型数据库的行。数据在MongoDB中以BSON（Binary-JSON）文档的格式存储在磁盘上。</p>
<p>BSON：是一种类json的一种二进制形式的存储格式，简称Binary JSON。BSON和JSON一样，支持<br>内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型。</p>
<h3 id="BSON数据类型"><a href="#BSON数据类型" class="headerlink" title="BSON数据类型"></a>BSON数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>UTF-8字符串都可表示为字符串类型的数据</td>
<td>{“x” : “foobar”}</td>
</tr>
<tr>
<td>整数</td>
<td>Int32 Int64,一般我们用Int32</td>
<td>{“x”:1}</td>
</tr>
<tr>
<td>对象</td>
<td>类似于Python里的字典，key是唯一的</td>
<td>{“x”:{“english”:90}}</td>
</tr>
<tr>
<td>时间戳</td>
<td>从1970到现在的时间戳</td>
<td>{“x”:1528183743111}</td>
</tr>
<tr>
<td>时间</td>
<td>默认时间为标准时间（UTC）</td>
<td>{“x”:ISODate(“2018-06-05T15:28:33.705+08:00”)}</td>
</tr>
<tr>
<td>对象id</td>
<td>对象id是文档的12字节的唯一 ID</td>
<td>{“X” :ObjectId() }</td>
</tr>
<tr>
<td>布尔值</td>
<td>真或者假：true或者false</td>
<td>{“x”:true}</td>
</tr>
<tr>
<td>数组</td>
<td>值的集合或者列表可以表示成数组</td>
<td>{“x” ： [“a”, “b”, “c”]}</td>
</tr>
<tr>
<td>64位浮点数</td>
<td>shell中的数字就是这一种类型</td>
<td>{“x”：3.14159，”y”：3}</td>
</tr>
<tr>
<td>null</td>
<td>表示空值或者未定义的对象</td>
<td>{“x”:null}</td>
</tr>
<tr>
<td>undefined</td>
<td>文档中也可以使用未定义类型</td>
<td>{“x”:undefined}</td>
</tr>
<tr>
<td>正则表达式</td>
<td>文档中可以包含正则表达式，采用JavaScript的正则表达式语法</td>
<td>{“x” ： /foobar/i}</td>
</tr>
<tr>
<td>代码</td>
<td>文档中还可以包含JavaScript代码</td>
<td>{“x” ： function() { /* …… */ }}</td>
</tr>
</tbody></table>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ul>
<li><p>选择/创建数据库：<code>use 数据库名</code></p>
</li>
<li><p>查看该权限下所能查看的所有数据库：<code>show dbs</code>或者<code>show databases</code></p>
</li>
<li><p>查看当前正在使用的数据库 <code>db</code>（MongoDB 中默认的数据库为 test）</p>
</li>
<li><p>删除数据库：<code>db.dropDatabase()</code></p>
</li>
</ul>
<blockquote>
<p>MongoDB有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p>
<ul>
<li>admin： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li>
<li>local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li>
<li>config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li>
</ul>
</blockquote>
<h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><h3 id="相关命令-1"><a href="#相关命令-1" class="headerlink" title="相关命令"></a>相关命令</h3><ul>
<li><p>集合的显示创建：<code>db.createCollection(&#39;&#39;集合名&#39;,[option])</code>（隐式创建：当向一个集合中插入一个文档的时候，如果集合不存在，则会自动创建集合。）    </p>
<ul>
<li>option说明：<ul>
<li>capped：(可选)如果为true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。当该值为true时，必须指定size参数。</li>
<li>size：(可选)为固定集合指定一个最大值，即字节数。如果capped为true，也需要指定该字段。</li>
<li>max：(可选)指定固定集合中包含文档的最大数量。</li>
</ul>
</li>
</ul>
</li>
<li><p>查看当前库中的集合：<code>show collections</code>或者<code>show tables</code></p>
</li>
<li><p>删除集合：<code>db.集合名.drop()</code></p>
</li>
</ul>
<h2 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h2><h3 id="相关命令-2"><a href="#相关命令-2" class="headerlink" title="相关命令"></a>相关命令</h3><ul>
<li><p>单条文档插入：<code>db.collection.insert(json格式的文档,[option])</code></p>
<ul>
<li>option说明：<ul>
<li>writeConcern：可选的。写入策略，默认为1，即要求确认写操作，0为不要求</li>
<li>ordered：可选。默认为true，如果为真，则按顺序插入数组中的文档，如果其中一个文档出现错误，MongoDB将返回而不处理数组中的其余文档。如果为假，则执行无序插入，如果其中一个文档出现错误，则继续处理数组中的主文档。</li>
</ul>
</li>
</ul>
</li>
<li><p>多条文档插入：<code>db.collection.insertMany([文档,文档],[option])</code></p>
<ul>
<li>option与上述一致</li>
</ul>
</li>
<li><p>用js脚本插入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++ )&#123;</span><br><span class="line">    db.users.insert(&#123;<span class="string">&quot;_id&quot;</span>:i,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;wht&quot;</span>+i&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：</p>
<ul>
<li>集合如果不存在，则会隐式创建</li>
<li>mongo中的数字，默认情况下是double类型，如果要存整型，必须使用函数NumberInt(整型数字)，否则取出来就有问题了。</li>
<li>插入当前日期使用new Date()</li>
<li>插入的数据没有指定_id ，会自动生成主键值</li>
<li>如果某字段没值，可以赋值为null，或不写该字段。</li>
</ul>
<p>注意：</p>
<ol>
<li>文档中的键/值对是有序的。</li>
<li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</li>
<li>MongoDB区分类型和大小写。</li>
<li>MongoDB的文档不能有重复的键。</li>
<li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</li>
</ol>
</blockquote>
</li>
<li><p>查询集合中所有文档：<code>db.collection.find()</code></p>
</li>
<li><p>删除文档：<code>db.集合名称.remove(&lt;query&gt;,[option])</code></p>
<ul>
<li>query：删除的文档查询条件<ul>
<li>例子：</li>
<li>删除所有文档：<code>db.users.remove(&#123;&#125;)</code></li>
<li>删除id为1的文档：<code>db.users.remove(&#123;_id:1&#125;)</code></li>
</ul>
</li>
<li>option说明：<ul>
<li>justOne:可选如果设为true或1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。</li>
<li>writeConcern:可选抛出异常的级别。</li>
</ul>
</li>
</ul>
</li>
<li><p>更新文档：<code>db.collection.update(&lt;query&gt;, &lt;update&gt;, [options])</code></p>
<ul>
<li>query：更新的选择条件。可以使用与find（）方法中相同的查询选择器，类似sql update查询内where后面的。</li>
<li>update：update : update的对象和一些更新的操作符（如s,$inc…）等，也可以理解为sqlupdate查询内set后面的</li>
<li>option说明：<ul>
<li>upsert:可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li>
<li>multi：multi:可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li>
<li>writeConcern:可选抛出异常的级别。</li>
</ul>
</li>
<li>例子：<ul>
<li>将之前的文档完全覆盖：<code>db.users.update(&#123;_id:&quot;1&quot;&#125;,&#123;name:&quot;张三&quot;&#125;)</code></li>
<li>局部修改保留其他字段：<code>db.users.update(&#123;_id:&quot;1&quot;&#125;,&#123;$set:&#123;name:&quot;张三&quot;&#125;&#125;)</code></li>
<li>批量的修改：<code>db.users.update(&#123;_id:&quot;1&quot;&#125;,&#123;$set:&#123;name:&quot;张三&quot;&#125;&#125;,&#123;multi:true&#125;)</code></li>
<li>实现对某列值在原有值的基础上进行增加或减少：<code>db.users.update(&#123;_id:&quot;1&quot;&#125;,&#123;$inc:&#123;age:NumberInt(1)&#125;&#125;)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>复杂查询：<code>db.collection.find(&lt;query&gt;, [projection])</code>(加上.pretty()格式化返回的查询数据，如果只查询符合条件的第一条则使用findOne)</p>
<ul>
<li><p>参数说明</p>
<ul>
<li>query : 可选，使用查询操作符指定查询条件</li>
<li>projection∶可选，使用投影操作符指定返回的键。查询时返回文档中所有键值，只需省略该参数即可（默认省略)。<ul>
<li>例子：</li>
<li>只显示符合条件的数据的姓名以及主键：<code>db.users.find(&#123;_id:1&#125;,&#123;name:1&#125;)</code>（1为显示，0为不显示）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>正则表达式查询：</strong><code>db.集合.find(&#123;字段:/正则表达式/&#125;)</code></p>
<ul>
<li>例子：</li>
<li>查询以专家开头的名字：<code>db.users.find(&#123;name:/^专家/&#125;)</code></li>
</ul>
</li>
<li><p><strong>比较查询：</strong><code>db.集合名称.find(&#123; &quot;field&quot; : &#123; 比较运算符: value &#125;&#125;)</code></p>
<ul>
<li>比较运算符：<ul>
<li>$gt：大于</li>
<li>$lt：小于</li>
<li>$gte：大于等于</li>
<li>$lte：小于等于</li>
<li>$ne：不等于</li>
</ul>
</li>
<li>例子：</li>
<li>查询_id小于5的数据：<code>db.users.find(&#123;_id:&#123;$lt:5&#125;&#125;)</code></li>
</ul>
</li>
<li><p><strong>包含查询：</strong><code>db.集合名称.find(&#123; &quot;field&quot; : &#123; 包含运算符: [val1,val2] &#125;&#125;)</code></p>
<ul>
<li>包含运算符：<ul>
<li>$in：包含</li>
<li>$nin：不包含</li>
</ul>
</li>
<li>例子：</li>
<li>查询_id为0,2的数据：<code>db.users.find(&#123;_id:&#123;$in:[0,2]&#125;&#125;)</code></li>
</ul>
</li>
<li><p><strong>条件连接查询：</strong><code>db.集合名称.find(&#123; 连接运算符 : [&#123;&quot;字段1&quot;:条件&#125;,&#123;&quot;字段2&quot;:条件&#125;]&#125;)</code></p>
<ul>
<li><p>条件连接运算符：</p>
<ul>
<li>$and：与</li>
<li>$or：或</li>
</ul>
</li>
<li><p>例子：</p>
</li>
<li><p>查询_id为0或者为2的数据：<code>db.users.find(&#123;$or:[&#123;&quot;_id&quot;:0&#125;,&#123;&quot;_id&quot;:2&#125;]&#125;)</code></p>
</li>
</ul>
</li>
<li><p><strong>数组查询：</strong><code>db.users.find(&#123;数组名:&quot;条件&quot;&#125;)</code></p>
<ul>
<li>$size：可以根据数组长度查询</li>
<li>例子</li>
<li>查询likes数组长度为3的数据：<code>db.users.find(&#123;likes:&#123;$size:3&#125;&#125;)</code></li>
</ul>
</li>
<li><p><strong>统计查询：</strong><code>db.collection.count(query, options)</code></p>
<ul>
<li>例子：</li>
<li>统计集合中总记录数：<code>db.users.count()</code></li>
<li>统计name以wht开头的记录数：<code>db.users.count(&#123;name:/^wht/&#125;)</code></li>
</ul>
</li>
<li><p><strong>排序查询：</strong><code>db.COLLECTION_NAME.find().sort(&#123;KEY:排序方式&#125;)</code></p>
</li>
</ul>
</li>
<li><p>排序说明：1为升序，-1为降序</p>
</li>
<li><p><strong>分页查询：</strong><code>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)</code></p>
<ul>
<li><p>使用limit()方法来读取指定数量的数据</p>
</li>
<li><p>使用skip()方法来跳过指定数量的数据</p>
</li>
<li><p><strong>去重：</strong><code>db.集合.distinct(&#39;字段&#39;)</code></p>
</li>
<li><p><strong>以数据类型查询：</strong><code>db.集合名称.find(&quot;likes&quot;:&#123;$type:&quot;String&quot;&#125;)</code></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>更多文档操作见官网(<a href="https://www.mongodb.com/docs/manual/crud/">https://www.mongodb.com/docs/manual/crud/</a>)</p>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引支持在MongoDB中高效地执行查询。如果没有索引，MongoDB必须执行全集合扫描，即扫描集合中的每个文档，以选择与查询语句匹配的文档。这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。</p>
<p>如果查询存在适当的索引，MongoDB可以使用该索引限制必须检查的文档数。</p>
<p>MongoDB索引使用B树数据结构（确切的说是B-Tree，MySQL是B+Tree）</p>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ul>
<li><p>单字段索引：MongoDB支持在文档的单个字段上创建用户定义的升序/降序索引，称为单字段索引（Single Field Index）。</p>
</li>
<li><p>复合索引：MongoDB还支持多个字段的用户定义索引，即复合索引（Compound Index），并且复合索引中列出的字段顺序具有重要意义。</p>
</li>
<li><p>其他索引：地理空间索引（Geospatial Index）、文本索引（Text Indexes）、哈希索引（Hashed Indexes）。</p>
<ul>
<li>地理空间索引：为了支持对地理空间坐标数据的有效查询，MongoDB提供了两种特殊的索引：返回结果时使用平面几何的二维索引和返回结果时使用球面几何的二维球面索引。</li>
<li>文本索引：MongoDB提供了一种文本索引类型，支持在集合中搜索字符串内容。这些文本索引不存储特定于语言的停止词（例如“the”、“a”、“or”），而将集合中的词作为词干，只存储根词。</li>
<li>哈希索引：为了支持基于散列的分片，MongoDB提供了散列索引类型，它对字段值的散列进行索引。这些索引在其范围内的值分布更加随机，但只支持相等匹配，不支持基于范围的查询。</li>
</ul>
</li>
</ul>
<h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><ul>
<li>查看集合中的所有索引数组：<code>db.collection.getIndexes()</code></li>
<li>创建索引：<code>db.collection.createIndex(索引键值对, options)</code><ul>
<li>options说明：<ul>
<li>background：建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加<br>“background” 可选参数。 “background” 默认值为false。</li>
<li>unique：建立的索引是否唯一。指定为true创建唯一索引。默认值为false。</li>
<li>name：索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名<br>称。</li>
<li>sparse：对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 false。</li>
<li>expireAfterSeconds：指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。</li>
<li>weights：索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。</li>
<li>default_language：对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语。</li>
<li>anguage_override：对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为language.</li>
</ul>
</li>
</ul>
</li>
<li>移除单个索引：<code>db.collection.dropIndex(索引名称)</code></li>
<li>移除所有索引：<code>db.collection.dropIndexes()</code></li>
<li>查看索引所占大小：<code>db.集合名称.getIndexSize()</code></li>
</ul>
<h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><p>MongoDB 中聚合(aggregate)主要用于处理数据(诸如统计平均值，求和等)，并返回计算后的数据结果。</p>
<p>有点类似 <strong>SQL</strong> 语句中的 *<em>count(\</em>)**。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>MongoDB中聚合的方法使用aggregate()。</p>
<p><strong>语法：</strong><code>db.COLLECTION_NAME.aggregate([&#123;$group : &#123;_id : &quot;$分组字段&quot;, 结果名称 : &#123;聚合方式 : 1&#125;&#125;&#125;])</code></p>
<ul>
<li>聚合方式说明：<ul>
<li>$sum：计算总和<ul>
<li>例子：<code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : &quot;$likes&quot;&#125;&#125;&#125;])</code></li>
</ul>
</li>
<li>$avg：计算平均值<ul>
<li>例子：<code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$avg : &quot;$likes&quot;&#125;&#125;&#125;])</code></li>
</ul>
</li>
<li>$min：获取集合中所有文档对应值得最小值<ul>
<li>例子：<code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$min : &quot;$likes&quot;&#125;&#125;&#125;])</code></li>
</ul>
</li>
<li>$max：获取集合中所有文档对应值得最大值<ul>
<li>例子：<code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$max : &quot;$likes&quot;&#125;&#125;&#125;])</code></li>
</ul>
</li>
<li>$push：将值加入一个数组中，不会判断是否有重复的值<ul>
<li>例子：<code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, url : &#123;$push: &quot;$url&quot;&#125;&#125;&#125;])</code></li>
</ul>
</li>
<li>$addToSet：将值加入一个数组中，会判断是否有重复的值，若相同的值在数组中已经存在了，则不加入。<ul>
<li>例子：<code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, url : &#123;$addToSet : &quot;$url&quot;&#125;&#125;&#125;])</code></li>
</ul>
</li>
<li>$first：根据资源文档的排序获取第一个文档数据<ul>
<li>例子：<code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, first_url : &#123;$first : &quot;$url&quot;&#125;&#125;&#125;])</code></li>
</ul>
</li>
<li>$last：根据资源文档的排序获取最后一个文档数据<ul>
<li>例子：<code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, last_url : &#123;$last : &quot;$url&quot;&#125;&#125;&#125;])</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul>
<li><p>导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#数据源配置</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">    <span class="attr">mongodb:</span></span><br><span class="line">      <span class="comment"># 主机地址</span></span><br><span class="line">      <span class="comment">#host: 192.168.227.111</span></span><br><span class="line">      <span class="comment"># 数据库</span></span><br><span class="line">      <span class="comment">#database: demo</span></span><br><span class="line">      <span class="comment"># 默认端口是27017</span></span><br><span class="line">      <span class="comment">#port: 27017</span></span><br><span class="line">      <span class="comment"># 用户名</span></span><br><span class="line">      <span class="comment">#username: root</span></span><br><span class="line">      <span class="comment"># 密码</span></span><br><span class="line">      <span class="comment">#password: 123456</span></span><br><span class="line">      <span class="comment">#如果设有权限校验只能uri方式,因为上述方法默认连接的权限机制是 mechanism=SCRAM-SHA-256</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">mongodb://root:123456@192.168.227.111:27017/demo</span></span><br></pre></td></tr></table></figure>
<h3 id="集合操作-1"><a href="#集合操作-1" class="headerlink" title="集合操作"></a>集合操作</h3></li>
<li><p>创建集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMongoDB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!mongoTemplate.collectionExists(<span class="string">&quot;testCollection&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">//创建集合，如果存在会报错</span></span><br><span class="line">        mongoTemplate.createCollection(<span class="string">&quot;testCollection&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除集合</span></span><br><span class="line">mongoTemplate.dropCollection(<span class="string">&quot;testCollection&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="文档操作-1"><a href="#文档操作-1" class="headerlink" title="文档操作"></a>文档操作</h3></li>
</ul>
<h4 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h4><ul>
<li><code>@Document</code><ul>
<li>修饰范围：用在类上，可以省略，如果省略，则默认使用类名小写映射集合</li>
<li>作用：用来映射这个类的一个对象为mongo中一条文档数据</li>
<li>属性：(value、collection)用来指定操作的集合名称</li>
</ul>
</li>
<li><code>@Id</code><ul>
<li>修饰范围：用在成员变量、方法上</li>
<li>作用：用来将成员变量的值映射为文档的_id的值</li>
</ul>
</li>
<li><code>@Field</code><ul>
<li>修饰范围：用在成员变量、方法上</li>
<li>作用：用来将成员变量以及值映射为文档中一个key、value对</li>
<li>属性：( name 、value )用来指定在文档中key的名称,默认为成员变量名</li>
</ul>
</li>
<li><code>@Transient</code><ul>
<li>修饰范围：用在成员变量、方法上</li>
<li>作用：用来指定改成员变量，不参与文档的序列化</li>
</ul>
</li>
<li><code>@Indexed</code><ul>
<li>修饰范围：用在成员变量、方法上</li>
<li>作用：用来添加了一个单字段的索引</li>
</ul>
</li>
<li><code>@CompoundIndex</code><ul>
<li>修饰范围：用在成员变量、方法上</li>
<li>作用：用来添加了一个复合索引</li>
</ul>
</li>
</ul>
<p>构造文档实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Document(&quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@Field(&quot;username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double salary;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h4><ul>
<li><p>添加文档：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">6200.0</span>, LocalDate.of(<span class="number">2000</span>, <span class="number">6</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="comment">//方式一：save</span></span><br><span class="line">    mongoTemplate.save(user);</span><br><span class="line">    <span class="comment">//方式二：insert</span></span><br><span class="line">    mongoTemplate.insert(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>save与insert的区别：</p>
<ul>
<li><p>save：批处理操作时: insert可以一次性插入整个数据，效率较高;save需遍历整个数据，一次插入或更新，效率较低。</p>
</li>
<li><p>insert：插入重复数据时: insert 报 DuplicateKeyException提示主键重复;save对已存在的数据进行更新。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>查询文档：</p>
<ul>
<li><p>查询所有：<code>mongoTemplate.findAll(User.class);</code>或者<code>mongoTemplate.findAll(User.class,&quot;集合名称&quot;);</code></p>
</li>
<li><p>根据_id查询：<code>mongoTemplate.findById(1, User.class);</code></p>
</li>
<li><p>条件查询：需要设置Criteria</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220912175758182.png" alt="image-20220912175758182"></p>
<ul>
<li><p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 3.条件查询</span></span><br><span class="line">        <span class="comment">//如果不设置条件则为全部查询</span></span><br><span class="line">        List&lt;User&gt; users1 = mongoTemplate.find(<span class="keyword">new</span> Query(), User.class);</span><br><span class="line">        users1.forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置Criteria条件</span></span><br><span class="line">        <span class="comment">// 等值查询</span></span><br><span class="line">        Query query = <span class="keyword">new</span> Query().addCriteria(Criteria.where(<span class="string">&quot;name&quot;</span>).is(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">        List&lt;User&gt; users2 = mongoTemplate.find(query, User.class);</span><br><span class="line">        users2.forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// &gt;,&lt; &gt;= &lt;= 查询</span></span><br><span class="line">        mongoTemplate.find(<span class="keyword">new</span> Query(Criteria.where(<span class="string">&quot;salary&quot;</span>).gte(<span class="number">5200.0</span>)), User.class);</span><br><span class="line">        <span class="comment">// and查询</span></span><br><span class="line">        System.out.println(mongoTemplate.find(<span class="keyword">new</span> Query(Criteria.where(<span class="string">&quot;name&quot;</span>).is(<span class="string">&quot;张三&quot;</span>).and(<span class="string">&quot;salary&quot;</span>).gte(<span class="number">5200.0</span>)),User.class));</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// or查询</span></span><br><span class="line">        Criteria criteria = <span class="keyword">new</span> Criteria();</span><br><span class="line">        criteria.orOperator(</span><br><span class="line">                Criteria.where(<span class="string">&quot;name&quot;</span>).is(<span class="string">&quot;张三&quot;</span>),</span><br><span class="line">                Criteria.where(<span class="string">&quot;id&quot;</span>).is(<span class="number">3</span>)</span><br><span class="line">        );</span><br><span class="line">        System.out.println(mongoTemplate.find(<span class="keyword">new</span> Query(criteria),User.class));</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// and和or连用</span></span><br><span class="line">        System.out.println(mongoTemplate.find(<span class="keyword">new</span> Query(Criteria.where(<span class="string">&quot;id&quot;</span>).in(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">                .orOperator(Criteria.where(<span class="string">&quot;salary&quot;</span>).gte(<span class="number">5000.0</span>))),User.class));</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 排序查询</span></span><br><span class="line">        System.out.println(mongoTemplate.find(<span class="keyword">new</span> Query().with(Sort.by(Sort.Order.desc(<span class="string">&quot;id&quot;</span>))), User.class));</span><br><span class="line">        <span class="comment">// 分页查询</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(mongoTemplate.find(<span class="keyword">new</span> Query().with(Sort.by(Sort.Order.desc(<span class="string">&quot;id&quot;</span>)))</span><br><span class="line">                .skip(<span class="number">0</span>).limit(<span class="number">2</span>), User.class));</span><br><span class="line">        <span class="comment">// 统计查询</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(mongoTemplate.count(<span class="keyword">new</span> Query(), User.class));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        <span class="comment">//参数说明：1.查询条件 2. 去重字段 3.文档类型 4. 去重字段返回类型</span></span><br><span class="line">        System.out.println(mongoTemplate.findDistinct(<span class="keyword">new</span> Query(),<span class="string">&quot;name&quot;</span>, User.class,String.class));</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 以原生json方式查询</span></span><br><span class="line">        System.out.println(mongoTemplate.find(<span class="keyword">new</span> BasicQuery(<span class="string">&quot;&#123;name:&#x27;张三&#x27;&#125;&quot;</span>),User.class));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>更新文档：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Update update = <span class="keyword">new</span> Update();</span><br><span class="line">    update.set(<span class="string">&quot;salary&quot;</span>, <span class="number">8000</span>);</span><br><span class="line">    <span class="comment">// 更新匹配到的第一条数据</span></span><br><span class="line">    mongoTemplate.updateFirst(Query.query(Criteria.where(<span class="string">&quot;name&quot;</span>).is(<span class="string">&quot;张三&quot;</span>)),update,User.class);</span><br><span class="line">    <span class="comment">// 更新多条</span></span><br><span class="line">    mongoTemplate.updateMulti(Query.query(Criteria.where(<span class="string">&quot;name&quot;</span>).is(<span class="string">&quot;张三&quot;</span>)),update,User.class);</span><br><span class="line">    <span class="comment">// 插入更新</span></span><br><span class="line">    update.setOnInsert(<span class="string">&quot;id&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    UpdateResult updateResult = mongoTemplate.upsert(Query.query(Criteria.where(<span class="string">&quot;name&quot;</span>).is(<span class="string">&quot;666&quot;</span>)), update, User.class);</span><br><span class="line">    <span class="comment">//获取修改数</span></span><br><span class="line">    System.out.println(updateResult.getModifiedCount());</span><br><span class="line">    <span class="comment">//获取匹配数量</span></span><br><span class="line">    System.out.println(updateResult.getMatchedCount());</span><br><span class="line">    <span class="comment">//获取upsert的id</span></span><br><span class="line">    System.out.println(updateResult.getUpsertedId());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除文档</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRemove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//删除所有</span></span><br><span class="line">    <span class="comment">// mongoTemplate.remove(new Query(),User.class);</span></span><br><span class="line">    <span class="comment">// 条件删除</span></span><br><span class="line">    mongoTemplate.remove(Query.query(Criteria.where(<span class="string">&quot;id&quot;</span>).is(<span class="number">0</span>)),User.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MongoDB集群和安全"><a href="#MongoDB集群和安全" class="headerlink" title="MongoDB集群和安全"></a>MongoDB集群和安全</h2></li>
</ul>
<h3 id="副本集-Replica-Sets"><a href="#副本集-Replica-Sets" class="headerlink" title="副本集-Replica Sets"></a>副本集-Replica Sets</h3><p>MongoDB中的副本集（Replica Set）是一组维护相同数据集的mongod服务。 副本集可提供冗余和高可用性，是所有生产部署的基础。副本集类似于有自动故障恢复功能的主从集群，但是副本集的区别在于没有固定的主节点。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220912204630152.png" alt="image-20220912204630152"></p>
<p><strong>三种主要角色：</strong></p>
<ul>
<li>主要成员（Primary）：主要接收所有写操作。就是主节点。</li>
<li>副本成员（Replicate）：从主节点通过复制操作以维护相同的数据集，即备份数据，不可写操作，但可以读操作（但需要配置）。是默认的一种从节点类型。</li>
<li>仲裁者（Arbiter）：不保留任何数据的副本，只具有投票选举作用。当然也可以将仲裁服务器维护为副本集的一部分，即副本成员同时也可以是仲裁者。也是一种从节点类型。</li>
</ul>
<blockquote>
<p>如果你的副本+主节点的个数是偶数，建议加一个仲裁者，形成奇数，容易满足大多数的投票。<br>如果你的副本+主节点的个数是奇数，可以不加仲裁者。</p>
</blockquote>
<h4 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h4><ol>
<li><p>创建数据目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">副本集1</span></span><br><span class="line">mkdir -p /opt/docker_app/mongoDB/DBdata/dbSlave1</span><br><span class="line"><span class="meta">#</span><span class="bash">副本集2</span></span><br><span class="line">mkdir -p /opt/docker_app/mongoDB/DBdata/dbSlave2</span><br><span class="line"><span class="meta">#</span><span class="bash">主节点</span></span><br><span class="line">mkdir -p /opt/docker_app/mongoDB/data</span><br></pre></td></tr></table></figure></li>
<li><p>启动容器(–replSet为集群名称)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">主节点</span></span><br><span class="line">docker run  -p 27017:27017 --name myMongoDB --network bridge --privileged=true --restart=always -v /opt/docker_app/mongoDB/data:/data/db -d mongo:5.0.5 --replSet rs</span><br><span class="line"><span class="meta">#</span><span class="bash">副本集1</span></span><br><span class="line">docker run  -p 27018:27017 --name myMongoDBSlave1 --network bridge --privileged=true --restart=always -v /opt/docker_app/mongoDB/DBdata/dbSlave1:/data/db -d mongo:5.0.5 --replSet rs</span><br><span class="line"><span class="meta">#</span><span class="bash">副本集2</span></span><br><span class="line">docker run  -p 27019:27017 --name myMongoDBSlave2 --network bridge --privileged=true --restart=always -v /opt/docker_app/mongoDB/DBdata/dbSlave2:/data/db -d mongo:5.0.5 --replSet rs</span><br></pre></td></tr></table></figure></li>
<li><p>查看状态：<code>docker ps -a</code></p>
</li>
<li><p>进入你想创建为主节点的容器：<code>docker exec -it 容器id mongo</code></p>
</li>
<li><p>添加从节点并初始化</p>
<p><code>rs.initiate()</code>这是初始化，直接初始化可以直接将当前节点变为主节点，然后可以在通过<code>rs.add(host, 是否是仲裁者)</code>添加，但是要注意，添加成功后，查看时会看到展示的是一个数组，数组中是一个节点一个集合，集合中有元素，元素有<code>_id</code>，这个_id的值必须是顺序下来，且主节点应该是0。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rs.initiate(&#123;_id:&quot;rs&quot;,version:1,members:[&#123;_id:0,host:&quot;192.168.227.130:27017&quot;&#125;,&#123;_id:1,host:&quot;192.168.227.130:27018&quot;&#125;,&#123;_id:2,host:&quot;192.168.227.130:27019&quot;&#125;]&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>查看状态：<code>rs.status()</code>（<code>rs.isMaster()</code>可以查看是否是主节点，<code>rs.secondaryOk()</code>可以允许从节点开启读权限）</p>
</li>
<li><p>如果进入从节点之后显示<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220912213227426.png" alt="image-20220912213227426">则表示创建成功！</p>
</li>
</ol>
<blockquote>
<p>修改主节点选举优先级：</p>
<p>1）先将配置导入cfg变量：<code>cfg=rs.conf()</code><br>2）然后修改值（ID号默认从0开始）：<code>cfg.members[1].priority=2</code><br>3）重新加载配置 ：<code>rs.reconfig(cfg)</code><br>稍等片刻会重新开始选举。</p>
</blockquote>
<h4 id="springData连接副本集"><a href="#springData连接副本集" class="headerlink" title="springData连接副本集"></a>springData连接副本集</h4><ul>
<li><p>配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">uri:</span> <span class="string">mongodb://root:123456@ip1:27017,ip2:27018,ip3:27019/demo?secondaryOk=true&amp;replicaSet=rs</span></span><br></pre></td></tr></table></figure>
<h3 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h3></li>
</ul>
<p>分片（sharding）是一种跨多台机器分布数据的方法， 将其分散存在不同的机器上的过程。将数据分散到不同的机器上，不需要功能强大的大型计算机就可以储存更多的数据，处理更多的负载。MongoDB就是使用分片来支持具有非常大的数据集和高吞吐量操作的水平扩展部署。</p>
<p><strong>主要组件：</strong></p>
<ul>
<li>分片（存储）：每个分片包含分片数据的子集。 每个分片都可以部署为副本集。</li>
<li>mongos（路由）：mongos充当查询路由器，在客户端应用程序和分片集群之间提供接口。</li>
<li>config servers（“调度”的配置）：配置服务器存储群集的元数据和配置设置。 从MongoDB 3.4开<br>始，必须将配置服务器部署为副本集（CSRS）。</li>
</ul>
<p><strong>架构：</strong></p>
<p>​        <img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220913141519801.png" alt="image-20220913141519801" style="zoom:67%;" /></p>
<ul>
<li>Shard：用于存储实际的数据块，实际生产环境中一个shard server角色可由几台机器组个一个replica set承担，防止主机单点故障</li>
<li>Config Server：mongod实例,存储了整个ClusterMetadata</li>
<li>Query Routers：前端路由，客户端由此接入，且让整个集群看上去像单―数据库，前端应用可以透明使用</li>
<li>Shard Key：片键，设置分片时需要在集合中选一个键,用该键的值作为拆分数据的依据,这个片键称之为(shard key)，片键的选取很重要,片键的选取决定了数据散列是否均匀</li>
</ul>
<h4 id="搭建-1"><a href="#搭建-1" class="headerlink" title="搭建"></a>搭建</h4><p><strong>搭建目标：</strong>1个路由节点 + 1个主Config Server以及2个从节点 + 1个主分片节点以及1个从节点 + 1个主分片节点以及1个从节点。总共8个服务节点。（全部利用docker创建容器）</p>
<ol>
<li><p>集群规划</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">- Router: 27026</span><br><span class="line"></span><br><span class="line">- Config Server:27025</span><br><span class="line">- Config Repl1:27024</span><br><span class="line">- Config Repl2:27023</span><br><span class="line"></span><br><span class="line">- Shard Server1:27017 </span><br><span class="line">- Shard Repl1:27018 </span><br><span class="line"></span><br><span class="line">- Shard Server2:27019 </span><br><span class="line">- Shard Repl2:27020</span><br></pre></td></tr></table></figure></li>
<li><p>创建数据目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> shard1</span></span><br><span class="line">mkdir -p /opt/docker_app/mongoDB/cluster/s0</span><br><span class="line">mkdir -p /opt/docker_app/mongoDB/cluster/s0-repl</span><br><span class="line"><span class="meta">#</span><span class="bash"> shard2</span></span><br><span class="line">mkdir -p /opt/docker_app/mongoDB/cluster/s1</span><br><span class="line">mkdir -p /opt/docker_app/mongoDB/cluster/s1-repl</span><br><span class="line"><span class="meta">#</span><span class="bash"> Config Server</span></span><br><span class="line">mkdir -p /opt/docker_app/mongoDB/cluster/config0</span><br><span class="line">mkdir -p /opt/docker_app/mongoDB/cluster/config0-repl1</span><br><span class="line">mkdir -p /opt/docker_app/mongoDB/cluster/config0-repl2</span><br></pre></td></tr></table></figure></li>
<li><p>根据上面的副本集搭建流程，搭建两个shard副本</p>
</li>
<li><p>后续…..（学完docker高级部分搭建）</p>
</li>
</ol>
<h3 id="安全认证"><a href="#安全认证" class="headerlink" title="安全认证"></a>安全认证</h3><p>默认情况下，MongoDB实例启动运行时是没有启用用户访问权限控制的，也就是说，在实例本机服务<br>器上都可以随意连接到实例进行各种操作。</p>
<p>为了强制开启用户访问控制(用户验证)，则需要在MongoDB实例启动时使用选项–auth 或在指定启动<br>配置文件中添加选项auth=true ；</p>
<p>并且注册角色，在角色定义时可以包含一个或多个已存在的角色，新创建的角色会继承包含的角色所有的权限。在同一个数据库中，新创建角色可以继承其他角色的权限，在admin 数据库中创建的角色可以继承在其它任意<br>数据库中角色的权限。</p>
<p><strong>常用的内置角色：</strong></p>
<table>
<thead>
<tr>
<th>角色</th>
<th>权限描述</th>
</tr>
</thead>
<tbody><tr>
<td>read</td>
<td>可以读取指定数据库中任何数据。</td>
</tr>
<tr>
<td>readWrite</td>
<td>可以读写指定数据库中任何数据，包括创建、重命名、删除集合。</td>
</tr>
<tr>
<td>readAnyDatabase</td>
<td>可以读取所有数据库中任何数据(除了数据库config和local之外)。</td>
</tr>
<tr>
<td>userAdminAnyDatabase</td>
<td>可以在指定数据库创建和修改用户(除了数据库config和local之外)。</td>
</tr>
<tr>
<td>dbAdminAnyDatabase</td>
<td>可以读取任何数据库以及对数据库进行清理、修改、压缩、获取统<br/>计信息、执行检查等操作(除了数据库config和local之外)。</td>
</tr>
<tr>
<td>dbAdmin</td>
<td>可以读取指定数据库以及对数据库进行清理、修改、压缩、获取统<br/>计信息、执行检查等操作。</td>
</tr>
<tr>
<td>userAdmin</td>
<td>可以在指定数据库创建和修改用户。</td>
</tr>
<tr>
<td>clusterAdmin</td>
<td>可以对整个集群或数据库系统进行管理操作。</td>
</tr>
<tr>
<td>backup</td>
<td>备份MongoDB数据最小的权限。</td>
</tr>
<tr>
<td>restore</td>
<td>从备份文件中还原恢复MongoDB数据(除了system.profile集合)的<br/>权限。</td>
</tr>
<tr>
<td>root</td>
<td>超级账号，超级权限</td>
</tr>
</tbody></table>
<p><strong>例子：</strong></p>
<p>创建两个管理员用户，一个是系统的超级管理员myroot ，一个是admin库的管理用户myadmin ；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">切换到admin库</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> use admin</span></span><br><span class="line"><span class="meta">#</span><span class="bash">创建系统超级用户 myroot,设置密码123456，设置角色root</span></span><br><span class="line"><span class="meta">#</span><span class="bash">&gt; db.createUser(&#123;user:<span class="string">&quot;myroot&quot;</span>,<span class="built_in">pwd</span>:<span class="string">&quot;123456&quot;</span>,roles:[ &#123; <span class="string">&quot;role&quot;</span> : <span class="string">&quot;root&quot;</span>, <span class="string">&quot;db&quot;</span> :</span></span><br><span class="line">&quot;admin&quot; &#125; ]&#125;)</span><br><span class="line"><span class="meta">#</span><span class="bash">或</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.createUser(&#123;user:<span class="string">&quot;myroot&quot;</span>,<span class="built_in">pwd</span>:<span class="string">&quot;123456&quot;</span>,roles:[<span class="string">&quot;root&quot;</span>]&#125;)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">创建专门用来管理admin库的账号myadmin，只用来作为用户权限的管理</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.createUser(&#123;user:<span class="string">&quot;myadmin&quot;</span>,<span class="built_in">pwd</span>:<span class="string">&quot;123456&quot;</span>,roles:</span></span><br><span class="line">[&#123;role:&quot;userAdminAnyDatabase&quot;,db:&quot;admin&quot;&#125;]&#125;)</span><br><span class="line"><span class="meta">#</span><span class="bash">查看已经创建了的用户的情况：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.system.users.find()</span></span><br><span class="line"><span class="meta">#</span><span class="bash">删除用户</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.dropUser(<span class="string">&quot;myadmin&quot;</span>)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改密码</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.changeUserPassword(<span class="string">&quot;myroot&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">认证测试</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.auth(<span class="string">&quot;myroot&quot;</span>,<span class="string">&quot;123456&quot;</span>)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MongoDB</tag>
        <tag>noSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中Orderby是怎么工作的</title>
    <url>/2023/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E4%B8%ADOrderby%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
    <content><![CDATA[<h1 id="“orderby”是怎么工作的"><a href="#“orderby”是怎么工作的" class="headerlink" title="“orderby”是怎么工作的"></a>“orderby”是怎么工作的</h1><p>例如：</p>
<p><code>select city,name,age from t where city=&#39;杭州&#39; order by name limit 1000  ;</code></p>
<h2 id="全字段排序："><a href="#全字段排序：" class="headerlink" title="全字段排序："></a>全字段排序：</h2><p>MySQL会给每个线程分配一块内存用于排序，称为<strong>sort_buffer</strong>。</p>
<p>通常情况下，这个语句执行流程如下所示 ：</p>
<ol>
<li>初始化sort_buffer，确定放入name、city、age这三个字段；</li>
<li>从索引city找到第一个满足city=’杭州’条件的主键id，也就是图中的ID_X；</li>
<li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</li>
<li>从索引city取下一个记录的主键id；</li>
<li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</li>
<li>对sort_buffer中的数据按照字段name做快速排序；</li>
<li>按照排序结果取前1000行返回给客户端。</li>
</ol>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230311151255046.png" alt="image-20230311151255046" style="zoom:50%;" />

<blockquote>
<p>图中“按name排序”这个动作，可能在内存中完成，<strong>也可能需要使用外部排序，这取决于排序所需的内存和参数sort_buffer_size</strong>。</p>
<p>sort_buffer_size，就是MySQL为排序开辟的内存（sort_buffer）的大小：</p>
<ul>
<li>如果要排序的数据量小于sort_buffer_size，排序就在内存中完成。</li>
<li>但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</li>
</ul>
</blockquote>
<h2 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序:"></a>rowid排序:</h2><p>我来修改一个参数，让MySQL采用这种算法。</p>
<p><code>SET max_length_for_sort_data = 16;</code>它的意思是，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。</p>
<p>新的算法放入sort_buffer的字段，只有要排序的列（即name字段）和主键id。</p>
<p>但这时，排序的结果就因为少了city和age字段的值，不能直接返回了，整个执行流程就变成如下所示的样子：</p>
<ol>
<li>初始化sort_buffer，确定放入两个字段，即name和id；</li>
<li>从索引city找到第一个满足city=’杭州’条件的主键id，也就是图中的ID_X；</li>
<li>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；</li>
<li>从索引city取下一个记录的主键id；</li>
<li>重复步骤3、4直到不满足city=’杭州’条件为止，也就是图中的ID_Y；</li>
<li>对sort_buffer中的数据按照字段name进行排序；</li>
<li>遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name和age三个字段返回给客户端。</li>
</ol>
<h3 id="两者区别："><a href="#两者区别：" class="headerlink" title="两者区别："></a>两者区别：</h3><ul>
<li><p>如果MySQL实在是担心排序内存太小，会影响排序效率，才会采用rowid排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</p>
</li>
<li><p>如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</p>
</li>
</ul>
<h2 id="利用索引自然排序"><a href="#利用索引自然排序" class="headerlink" title="利用索引自然排序"></a>利用索引自然排序</h2><p>我们可以在这个市民表上创建一个city和name的联合索引，对应的SQL语句是：<code>alter table t add index city_user(city, name);</code></p>
<p>在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足city=’杭州’的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要city的值是杭州，name的值就一定是有序的。</p>
<p>这样整个查询过程的流程就变成了：</p>
<ol>
<li>从索引(city,name)找到第一个满足city=’杭州’条件的主键id；</li>
<li>到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返回；</li>
<li>从索引(city,name)取下一个记录主键id；</li>
<li>重复步骤2、3，直到查到第1000条记录，或者是不满足city=’杭州’条件时循环结束。</li>
</ol>
<blockquote>
<p>这里还可以进一步优化，建立city、name和age的联合索引，就还可以减少回表的次数</p>
</blockquote>
<h2 id="如何正确地显示随机消息"><a href="#如何正确地显示随机消息" class="headerlink" title="如何正确地显示随机消息"></a>如何正确地显示随机消息</h2><h3 id="使用order-by-rand"><a href="#使用order-by-rand" class="headerlink" title="使用order by rand()"></a>使用order by rand()</h3><h4 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h4><p>首先，你会想到用order by rand()来实现这个逻辑。</p>
<p>例如：<code>select word from words order by rand() limit 3;</code></p>
<p><strong>order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法。</strong></p>
<h4 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h4><p>那么，是不是所有的临时表都是内存表呢？</p>
<p>其实不是的。tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。</p>
<p>磁盘临时表使用的引擎默认是InnoDB，是由参数internal_tmp_disk_storage_engine控制的。</p>
<p><strong>MySQL 5.6版本引入的一个新的排序算法，即：优先队列排序算法。</strong>（也就是维护一个堆）</p>
<p>接下来，我们就看看为什么没有使用临时文件的算法，也就是归并排序算法，而是采用了优先队列排序算法。</p>
<p>其实，我们现在的SQL语句，只需要取R值最小的3个rowid。但是，如果使用归并排序算法的话，虽然最终也能得到前3个值，但是这个算法结束后，已经将10000行数据都排好序了。</p>
<h3 id="随机排序方法"><a href="#随机排序方法" class="headerlink" title="随机排序方法"></a>随机排序方法</h3><p><strong>方法1：</strong></p>
<p>思路上是这样的：</p>
<ol>
<li>取得这个表的主键id的最大值M和最小值N;</li>
<li>用随机函数生成一个最大值到最小值之间的数 X = (M-N)*rand() + N;</li>
<li>取不小于X的第一个ID的行。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">max</span>(id),<span class="built_in">min</span>(id) <span class="keyword">into</span> <span class="variable">@M</span>,<span class="variable">@N</span> <span class="keyword">from</span> t ;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@X</span><span class="operator">=</span> <span class="built_in">floor</span>((<span class="variable">@M</span><span class="operator">-</span><span class="variable">@N</span><span class="operator">+</span><span class="number">1</span>)<span class="operator">*</span>rand() <span class="operator">+</span> <span class="variable">@N</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="variable">@X</span> limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这个方法效率很高，因为取max(id)和min(id)都是不需要扫描索引的，而第三步的select也可以用索引快速定位，可以认为就只扫描了3行。但实际上，这个算法本身并不严格满足题目的随机要求，因为ID中间可能有空洞，因此选择不同行的概率不一样，不是真正的随机。</p>
<p><strong>方法2：</strong></p>
<p>思路上是这样的：</p>
<ol>
<li>取得整个表的行数，并记为C。</li>
<li>取得 Y = floor(C * rand())。 floor函数在这里的作用，就是取整数部分。</li>
<li>再用limit Y,1 取得一行。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@C</span> <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@sql</span> <span class="operator">=</span> concat(&quot;select * from t limit &quot;, <span class="variable">@Y</span>, &quot;,1&quot;);</span><br><span class="line"><span class="keyword">prepare</span> stmt <span class="keyword">from</span> <span class="variable">@sql</span>;</span><br><span class="line"><span class="keyword">execute</span> stmt;</span><br><span class="line"><span class="keyword">DEALLOCATE</span> <span class="keyword">prepare</span> stmt;</span><br></pre></td></tr></table></figure>
<p>这个随机算法解决了明显的概率不均匀问题。</p>
<p>但是MySQL处理limit Y,1 的做法就是按顺序一个一个地读出来，丢掉前Y个，然后把下一个记录作为返回结果，因此这一步需要扫描Y+1行。再加上，第一步扫描的C行，总共需要扫描C+Y+1行，执行代价比随机算法1的代价要高。</p>
<blockquote>
<p>如果取三个值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@C</span> <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y1</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y2</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y3</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y1</span>，<span class="number">1</span>； <span class="operator">/</span><span class="operator">/</span>在应用代码里面取Y1、Y2、Y3值，拼出<span class="keyword">SQL</span>后执行</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y2</span>，<span class="number">1</span>；</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y3</span>，<span class="number">1</span>；</span><br></pre></td></tr></table></figure></blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中执行单条语句很慢的场景</title>
    <url>/2023/07/07/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%8D%95%E6%9D%A1%E8%AF%AD%E5%8F%A5%E5%BE%88%E6%85%A2%E7%9A%84%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h1 id="某些执行单条语句很慢的场景"><a href="#某些执行单条语句很慢的场景" class="headerlink" title="某些执行单条语句很慢的场景"></a>某些执行单条语句很慢的场景</h1><h2 id="第一类：查询长时间不返回"><a href="#第一类：查询长时间不返回" class="headerlink" title="第一类：查询长时间不返回"></a>第一类：查询长时间不返回</h2><ol>
<li><p><strong>等MDL锁：</strong></p>
<p>出现<strong>这个状态表示的是，现在有一个线程正在表t上请求或者持有MDL写锁，把select语句堵住了。</strong></p>
</li>
<li><p><strong>等flush：</strong></p>
<p>出现Waiting for table flush状态的可能情况是：有一个flush tables命令被别的语句堵住了，然后它又堵住了我们的select语句。</p>
</li>
<li><p><strong>等行锁：</strong></p>
<p>由于访问id=1这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，我们的select语句就会被堵住。</p>
</li>
</ol>
<h2 id="第二类：查询慢"><a href="#第二类：查询慢" class="headerlink" title="第二类：查询慢"></a>第二类：查询慢</h2><ol>
<li><p><strong>行数多导致的慢查询：</strong></p>
<p><code>mysql&gt; select * from t where c=50000 limit 1;</code>由于字段c上没有索引，这个语句只能走id主键顺序扫描，因此需要扫描5万行。</p>
</li>
<li><p><strong>由于mysql的mvcc导致的慢查询：</strong></p>
<p><code>mysql&gt; select * from t where id=1；</code>虽然扫描行数是1，但执行时间却长达800毫秒。</p>
<p>例如session A先用start transaction with consistent snapshot命令启动了一个事务，之后session B才开始执行update 语句。session B执行完100万次update语句后，session B更新完100万次，生成了100万个回滚日志(undo log)。</p>
<p>带lock in share mode的SQL语句，是当前读，因此会直接读到1000001这个结果，所以速度很快；而select * from t where id=1这个语句，是一致性读，因此需要从1000001开始，依次执行undo log，执行了100万次以后，才将1这个结果返回。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务</title>
    <url>/2023/06/28/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>当数据库上有多个事务同时执行的时候，就可能出现<strong>脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）</strong>的问题，为了解决这些问题，就有了“隔离级别”的概念。</p>
<p>SQL标准的事务隔离级别包括：<strong>读未提交（read uncommitted）</strong>、<strong>读提交（read committed）</strong>、<strong>可重复读（repeatable read）</strong>和<strong>串行化（serializable ）</strong>。</p>
<ul>
<li><strong>读未提交：</strong>一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li><strong>读提交：</strong>一个事务提交之后，它做的变更才会被其他事务看到。（在执行语句之前创建多版本视图）</li>
<li><strong>可重复读：</strong>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。（在开启事务之前创建多版本视图）</li>
<li><strong>串行化：</strong>顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<blockquote>
<p>通过<code>show variables like &#39;transaction_isolation&#39;;</code>查看隔离级别</p>
<p>还可以通过<code>select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</code>查看超过60s的长事务<strong>（长事务不仅会让回滚日志很长，还会阻塞mysql）</strong></p>
</blockquote>
<h2 id="MVCC及一致性读视图"><a href="#MVCC及一致性读视图" class="headerlink" title="MVCC及一致性读视图"></a>MVCC及一致性读视图</h2><p><strong>MVCC（Multi-Version Concurrency Control）</strong>：多版本并发控制；InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。</p>
<p><strong>具体实现：</strong></p>
<ul>
<li><p>InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。而每行数据也都是有多个版本的。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230416144520269.png" alt="image-20230416144520269" style="zoom: 67%;" />

<p>实际上，图中的三个虚线箭头，就是<strong>undo log</strong>；而V1、V2、V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的。比如，需要V2的时候，就是通过V4依次执行U3、U2算出来。</p>
</li>
<li><p>当前事务的<strong>一致性视图（read-view）</strong>：</p>
<p>InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。数组里面事务ID的最小值记为<strong>低水位</strong>，当前系统里面已经创建过的事务ID的最大值加1记为<strong>高水位</strong>。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230416144845691.png" alt="image-20230416144845691"  />

<p>对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：</p>
<ol>
<li><p>如果落在绿色部分：</p>
<p>表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</p>
</li>
<li><p>如果落在红色部分：</p>
<p>表示这个版本是由将来启动的事务生成的，是肯定不可见的；</p>
</li>
<li><p>如果落在黄色部分：</p>
<p>那就包括两种情况：<br><strong>a.</strong> 若 row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；<br><strong>b.</strong> 若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。</p>
</li>
</ol>
<blockquote>
<p>对于更新语句有一个原则：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong>所以更新不按照一致性读。（select语句加锁也是当前读）</p>
<p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的<strong>区别</strong>是：</p>
<ul>
<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li>
<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li>
</ul>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL - 事务</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL优化JOIN语句</title>
    <url>/2023/07/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E4%BC%98%E5%8C%96JOIN%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="Join优化"><a href="#Join优化" class="headerlink" title="Join优化"></a>Join优化</h1><h2 id="被驱动表使用了索引的情况"><a href="#被驱动表使用了索引的情况" class="headerlink" title="被驱动表使用了索引的情况"></a>被驱动表使用了索引的情况</h2><p>例如这个简单的join语句<code>select * from t1 straight_join t2 on (t1.a=t2.a);</code></p>
<p>在这条语句里，被驱动表t2的字段a上有索引，join过程用上了这个索引，因此这个语句的执行流程是这样的：</p>
<ol>
<li>从表t1中读入一行数据 R；</li>
<li>从数据行R中，取出a字段到表t2里去查找；</li>
<li>取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分；</li>
<li>重复执行步骤1到3，直到表t1的末尾循环结束。</li>
</ol>
<p>在这个join语句执行过程中，驱动表是走全表扫描，而被驱动表是走树搜索。</p>
<p>假设被驱动表的行数是M，驱动表的行数是N。每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引。每次搜索一棵树近似复杂度是以2为底的M的对数，记为log2M，<strong>所以整个流程近似复杂度是 N + N<em>2</em>log2M</strong>。</p>
<p>这个算法称为**Index Nested-Loop Join(NLJ)**。</p>
<p><strong>显然，N对扫描行数的影响更大，因此应该让小表来做驱动表。</strong></p>
<blockquote>
<ol>
<li><p><strong>Multi-Range Read优化</strong>（需要设置<code>set optimizer_switch=&quot;mrr_cost_based=off&quot;</code>）</p>
<p>MRR优化的设计思路。此时，语句的执行流程变成了这样：</p>
<ol>
<li>根据索引a，定位到满足条件的记录，将id值放入read_rnd_buffer中;</li>
<li>将read_rnd_buffer中的id进行递增排序；</li>
<li>排序后的id数组，依次到主键id索引中查记录，并作为结果返回。</li>
</ol>
<p>利用<strong>顺序性</strong>的优势</p>
</li>
<li><p><strong>Batched Key Access算法</strong>（需要<code>set optimizer_switch=&#39;mrr=on,mrr_cost_based=off,batched_key_access=on&#39;;</code>）</p>
<p>理解了MRR性能提升的原理，我们就能理解MySQL在5.6版本后开始引入的Batched Key Acess(BKA)算法了。这个BKA算法，其实就是对NLJ算法的优化。</p>
<p>大致逻辑是：为了利用上MRR优化，在从t1表中取a值的时候不再一行一行的去t2表匹配，而是存入<strong>join_buffer</strong>的缓存中再去统一利用MRR匹配取值。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230401150349127.png" alt="image-20230401150349127"></p>
</li>
</ol>
</blockquote>
<h2 id="被驱动表没有索引的情况"><a href="#被驱动表没有索引的情况" class="headerlink" title="被驱动表没有索引的情况"></a>被驱动表没有索引的情况</h2><p>例如<code>select * from t1 straight_join t2 on (t1.a=t2.b);</code></p>
<p>由于表t2的字段b上没有索引，如果再用图2的执行流程时，每次到t2去匹配的时候，就要做一次全表扫描。这个算法是正确的，叫做<strong>“Simple Nested-Loop Join”</strong>，没有索引的情况下会很笨重。</p>
<p><strong>MySQL也没有使用这个Simple Nested-Loop Join算法，而是使用了另一个叫作“Block Nested-Loop Join”的算法，简称BNL。</strong></p>
<p>算法的流程是这样的：</p>
<ol>
<li><p>把表t1的数据读入线程内存join_buffer中，由于我们这个语句中写的是select *，因此是把整个表t1放入了内存；</p>
</li>
<li><p>扫描表t2，把表t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回。</p>
<blockquote>
<p>如果join_buffer放不下，会分段依次放入内存进行判断。所以当没有索引的join语句很慢，就把join_buffer_size改大。</p>
</blockquote>
</li>
</ol>
<p>这个算法与之前的算法的区别在于：<strong>判断是内存操作，速度上会快很多，性能也更好。</strong></p>
<p><strong>BKA优化：</strong></p>
<p>大致思路是：（或者直接在被驱动表加索引）</p>
<ol>
<li>把表t2中满足条件的数据放在临时表tmp_t中；</li>
<li>为了让join使用BKA算法，给临时表tmp_t的字段b加上索引；</li>
<li>让表t1和tmp_t做join操作。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t <span class="keyword">like</span> t1;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> temp_t <span class="keyword">add</span> index(b);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">&lt;=</span><span class="number">2000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b<span class="operator">=</span>temp_t.b);</span><br></pre></td></tr></table></figure>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL - 锁</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL保证高可用</title>
    <url>/2023/07/15/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Mysql的高可用"><a href="#Mysql的高可用" class="headerlink" title="Mysql的高可用"></a>Mysql的高可用</h1><h2 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h2><p>所谓主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值。</p>
<blockquote>
<p>你可以在备库上执行show slave status命令，它的返回结果里面会显示seconds_behind_master，用于表示当前备库延迟了多少秒。</p>
</blockquote>
<h3 id="主备延迟的来源"><a href="#主备延迟的来源" class="headerlink" title="主备延迟的来源:"></a>主备延迟的来源:</h3><ul>
<li><p>有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。</p>
</li>
<li><p>第二种常见的可能了，即备库的压力大：由于主库直接影响业务，大家使用起来会比较克制，反而忽视了备库的压力控制。结果就是，备库上的查询耗费了大量的CPU资源，影响了同步速度，造成主备延迟。</p>
<p>解决方式：</p>
<ul>
<li>一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力。</li>
<li>通过binlog输出到外部系统，比如Hadoop这类系统，让外部系统提供统计类查询的能力。</li>
</ul>
</li>
<li><p>第三种，大事务。如果一个主库上的语句执行10分钟，那这个事务很可能就会导致从库延迟10分钟。</p>
<p>例如：</p>
<ul>
<li>一次性地用delete语句删除太多数据</li>
<li>大表DDL</li>
</ul>
</li>
</ul>
<h2 id="主备切换"><a href="#主备切换" class="headerlink" title="主备切换"></a>主备切换</h2><h3 id="可靠性优先策略："><a href="#可靠性优先策略：" class="headerlink" title="可靠性优先策略："></a>可靠性优先策略：</h3><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230321144902334.png" alt="image-20230321144902334"></p>
<p>在图中的双M结构下，从状态1到状态2切换的详细过程是这样的：</p>
<ol>
<li>判断备库B现在的seconds_behind_master，如果小于某个值（比如5秒）继续下一步，否则持续重试这一步；</li>
<li>把主库A改成只读状态，即把readonly设置为true；</li>
<li>判断备库B的seconds_behind_master的值，直到这个值变成0为止；</li>
<li>把备库B改成可读写状态，也就是把readonly 设置为false；</li>
<li>把业务请求切到备库B。</li>
</ol>
<p>这个切换流程，一般是由专门的HA系统来完成的，我们暂时称之为可靠性优先流程。</p>
<h3 id="可用性优先策略："><a href="#可用性优先策略：" class="headerlink" title="可用性优先策略："></a>可用性优先策略：</h3><p>如果我强行把上面的步骤4、5调整到最开始执行，也就是说不等主备数据同步，直接把连接切到备库B，并且让备库B可以读写，那么系统几乎就没有不可用时间了。</p>
<p>例如：<strong>可用性优先策略，且binlog_format=mixed</strong>时的切换流程和数据结果。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230321145115395.png" alt="image-20230321145115395" style="zoom:67%;" />

<p>现在，我们一起分析下这个切换流程：</p>
<ol>
<li>步骤2中，主库A执行完insert语句，插入了一行数据（4,4），之后开始进行主备切换。</li>
<li>步骤3中，由于主备之间有5秒的延迟，所以备库B还没来得及应用“插入c=4”这个中转日志，就开始接收客户端“插入 c=5”的命令。</li>
<li>步骤4中，备库B插入了一行数据（4,5），并且把这个binlog发给主库A。</li>
<li>步骤5中，备库B执行“插入c=4”这个中转日志，插入了一行数据（5,4）。而直接在备库B执行的“插入c=5”这个语句，传到主库A，就插入了一行新数据（5,5）。</li>
</ol>
<p>最后的结果就是，主库A和备库B上出现了两行不一致的数据。可以看到，这个数据不一致，是由可用性优先流程导致的。</p>
<p>但<strong>设置binlog_format=row</strong>后，因为row格式在记录binlog的时候，会记录新插入的行的所有字段值，所以最后只会有一行不一致。而且，两边的主备同步的应用线程会报错duplicate key error并停止。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230321145257915.png" alt="image-20230321145257915"></p>
<p>从上面的分析中，你可以看到一些结论：</p>
<ol>
<li><strong>使用row格式的binlog时，数据不一致的问题更容易被发现</strong>。而使用mixed或者statement格式的binlog时，数据很可能悄悄地就不一致了。如果你过了很久才发现数据不一致的问题，很可能这时的数据不一致已经不可查，或者连带造成了更多的数据逻辑不一致。</li>
<li>主备切换的可用性优先策略会导致数据不一致。因此，大多数情况下，我都建议你使用可靠性优先策略。毕竟对数据服务来说的话，数据的可靠性一般还是要优于可用性的。</li>
</ol>
<blockquote>
<p>在满足数据可靠性的前提下，MySQL高可用系统的可用性，是依赖于主备延迟的。延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL内部临时表的运用</title>
    <url>/2023/07/23/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<h1 id="内部临时表的运用"><a href="#内部临时表的运用" class="headerlink" title="内部临时表的运用"></a>内部临时表的运用</h1><h2 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h2><p>例如：<code>(select 1000 as f) union (select id from t1 order by id desc limit 2);</code></p>
<p>这个语句的执行流程是这样的：</p>
<ol>
<li>创建一个内存临时表，这个临时表只有一个整型字段f，并且f是主键字段。</li>
<li>执行第一个子查询，得到1000这个值，并存入临时表中。</li>
<li>执行第二个子查询：<ul>
<li>拿到第一行id=1000，试图插入临时表中。但由于1000这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行；</li>
<li>取到第二行id=999，插入临时表成功。</li>
</ul>
</li>
<li>从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是1000和999。</li>
</ol>
<blockquote>
<p>如果把上面这个语句中的union改成union all的话，就没有了“去重”的语义。这样执行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端。因此也就不需要临时表了。</p>
</blockquote>
<h2 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h2><p>例如：<code>select id%10 as m, count(*) as c from t1 group by m;</code></p>
<p>这个语句的执行流程是这样的：</p>
<ol>
<li>创建内存临时表，表里有两个字段m和c，主键是m；</li>
<li>扫描表t1的索引a，依次取出叶子节点上的id值，计算id%10的结果，记为x；<ul>
<li>如果临时表中没有主键为x的行，就插入一个记录(x,1);</li>
<li>如果表中有主键为x的行，就将x这一行的c值加1；</li>
</ul>
</li>
<li>遍历完成后，再根据字段m做排序，得到结果集返回给客户端。(如果不需要排序可以添加<code>order by null</code>)</li>
</ol>
<blockquote>
<p><strong>优化：</strong></p>
<ol>
<li><p>保证分组字段有序</p>
<p>如果在group by扫描过程中可以保证出现的数据是有序的，这样就不需要临时表了。</p>
<p>在MySQL 5.7版本支持了generated column机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列z，然后在z列上创建一个索引</p>
<p><code>alter table t1 add column z int generated always as(id % 100), add index(z);</code></p>
<p>查询：<code>select z, count(*) as c from t1 group by z;</code></p>
</li>
<li><p>直接排序</p>
<p>在group by语句中加入SQL_BIG_RESULT这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。MySQL的优化器一看，磁盘临时表是B+树存储，存储效率不如数组来得高。所以，既然你告诉我数据量很大，那从磁盘空间考虑，还是直接用数组来存吧。</p>
<p><code>select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;</code></p>
<p>执行流程就是这样的：</p>
<ol>
<li>初始化sort_buffer，确定放入一个整型字段，记为m；</li>
<li>扫描表t1的索引a，依次取出里面的id值, 将 id%100的值存入sort_buffer中；</li>
<li>扫描完成后，对sort_buffer的字段m做排序（如果sort_buffer内存不够用，就会利用磁盘临时文件辅助排序）；</li>
<li>排序完成后，就得到了一个有序数组。</li>
<li>根据有序数组，得到数组里面的不同值，以及每个值的出现次数。</li>
</ol>
</li>
</ol>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>由于重启会丢数据，如果一个备库重启，会导致主备同步线程停止；如果主库跟这个备库是双M架构，还可能导致主库的内存表数据被删掉。</p>
<p>因此，在生产上，我不建议你使用普通内存表。（除了上面优化的场景）内部临时表的运用</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL - 锁</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL保证主备一致</title>
    <url>/2023/07/13/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4/</url>
    <content><![CDATA[<h1 id="保证主备一致"><a href="#保证主备一致" class="headerlink" title="保证主备一致"></a>保证主备一致</h1><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230320152804064.png" alt="image-20230320152804064" style="zoom:67%;" />

<p>在状态1中，虽然节点B没有被直接访问，但是我依然建议你把节点B（也就是备库）设置成只读（readonly）模式。这样做，有以下几个考虑：</p>
<ol>
<li>有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；</li>
<li>防止切换逻辑有bug，比如切换过程中出现双写，造成主备不一致；</li>
<li>可以用readonly状态，来判断节点的角色。</li>
</ol>
<h2 id="同步完整流程："><a href="#同步完整流程：" class="headerlink" title="同步完整流程："></a>同步完整流程：</h2><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230320152932581.png" alt="image-20230320152932581" style="zoom: 80%;" />

<p>一个事务日志同步的完整过程是这样的：</p>
<ol>
<li>在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。</li>
<li>在备库B上执行start slave命令，这时候备库会启动两个线程，就是图中的io_thread和sql_thread。其中io_thread负责与主库建立连接。</li>
<li>主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B。</li>
<li>备库B拿到binlog后，写到本地文件，称为中转日志（relay log）。</li>
<li>sql_thread读取中转日志，解析出日志里的命令，并执行。</li>
</ol>
<blockquote>
<p><strong>binlog的格式：</strong></p>
<ul>
<li><strong>statement：</strong>当binlog_format=statement时，binlog里面记录的就是SQL语句的原文。</li>
<li><strong>row：</strong>row格式的binlog里没有了SQL语句的原文，而是替换成了两个event：Table_map（用于说明接下来要操作的表是test库的表t）和Delete_rows（用于定义删除的行为）。</li>
<li><strong>mixed：</strong>mixed格式可以利用statment格式的优点，同时又避免了数据不一致的风险。</li>
</ul>
</blockquote>
<p>上面主要是针对M-S结构，但实际生产上使用比较多的是双M结构，双M结构还有一个循环复制的问题需要解决。</p>
<p>如果节点A同时是节点B的备库，相当于又把节点B新生成的binlog拿过来执行了一次，然后节点A和B间，会不断地循环执行这个更新语句，也就是循环复制了。</p>
<h2 id="双M循环复制解决方案："><a href="#双M循环复制解决方案：" class="headerlink" title="双M循环复制解决方案："></a>双M循环复制解决方案：</h2><ol>
<li>规定两个库的server id必须不同，如果相同，则它们之间不能设定为主备关系；</li>
<li>一个备库接到binlog并在重放的过程中，生成与原binlog的server id相同的新的binlog；</li>
<li>每个库在收到从自己的主库发过来的日志后，先判断server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL - 锁</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL备库并行复制策略</title>
    <url>/2023/07/17/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E5%A4%87%E5%BA%93%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="备库并行复制策略"><a href="#备库并行复制策略" class="headerlink" title="备库并行复制策略"></a>备库并行复制策略</h1><h2 id="按表分发"><a href="#按表分发" class="headerlink" title="按表分发"></a>按表分发</h2><p>按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个worker不会更新同一行。</p>
<p>每个事务在分发的时候，跟所有worker的冲突关系包括以下三种情况：</p>
<ol>
<li>如果跟所有worker都不冲突，coordinator线程就会把这个事务分配给最空闲的woker;</li>
<li>如果跟多于一个worker冲突，coordinator线程就进入等待状态，直到和这个事务存在冲突关系的worker只剩下1个；</li>
<li>如果只跟一个worker冲突，coordinator线程就会把这个事务分配给这个存在冲突关系的worker。</li>
</ol>
<h2 id="按行分发"><a href="#按行分发" class="headerlink" title="按行分发"></a>按行分发</h2><p>要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：如果两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求binlog格式必须是row。</p>
<p>按行复制和按表复制的数据结构差不多，也是为每个worker，分配一个hash表。只是要实现按行分发，这时候的key，就必须是“库名+表名+唯一键的值”。（如果存在唯一索引也需要加上唯一索引）</p>
<p>按行分发的策略有<strong>两个问题</strong>：</p>
<ol>
<li>耗费内存。比如一个语句要删除100万行数据，这时候hash表就要记录100万个项。</li>
<li>耗费CPU。解析binlog，然后计算hash值，对于大事务，这个成本还是很高的。</li>
</ol>
<h2 id="MariaDB的并行复制策略"><a href="#MariaDB的并行复制策略" class="headerlink" title="MariaDB的并行复制策略"></a>MariaDB的并行复制策略</h2><p>MariaDB是这么做的：</p>
<ol>
<li>在一组里面一起提交的事务，有一个相同的commit_id，下一组就是commit_id+1；</li>
<li>commit_id直接写到binlog里面；</li>
<li>传到备库应用的时候，相同commit_id的事务分发到多个worker执行；</li>
<li>这一组全部执行完成后，coordinator再去取下一批。</li>
</ol>
<blockquote>
<p>MySQL 5.6版本的并行复制策略用于的是：<strong>按库并行</strong>。</p>
<p>MySQL 5.6版本的并行复制策略用的是：类似于<strong>MariaDB的策略</strong>。</p>
<p>MySQL 5.7.22的并行复制策略用的是：<strong>按行并行</strong>。</p>
<p>不过，MySQL官方的这个实现还是有很大的优势：</p>
<ol>
<li>writeset是在主库生成后直接写入到binlog里面的，这样在备库执行的时候，不需要解析binlog内容（event里的行数据），节省了很多计算量；</li>
<li>不需要把整个事务的binlog都扫一遍才能决定分发到哪个worker，更省内存；</li>
<li>由于备库的分发策略不依赖于binlog内容，所以binlog是statement格式也是可以的。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL命令大全</title>
    <url>/2021/02/24/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h1 id="MySQL命令大全"><a href="#MySQL命令大全" class="headerlink" title="MySQL命令大全"></a>MySQL命令大全</h1><h2 id="一、简单命令"><a href="#一、简单命令" class="headerlink" title="一、简单命令"></a>一、简单命令</h2><h3 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database my_database;</span><br><span class="line">-- charset 字符集 collation 校对集</span><br></pre></td></tr></table></figure>
<h3 id="2-显示数据库"><a href="#2-显示数据库" class="headerlink" title="2.显示数据库"></a>2.显示数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure>
<h3 id="3-显示当前在哪个数据库"><a href="#3-显示当前在哪个数据库" class="headerlink" title="3.显示当前在哪个数据库"></a>3.显示当前在哪个数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select database();</span><br></pre></td></tr></table></figure>
<h3 id="4-显示部分数据库"><a href="#4-显示部分数据库" class="headerlink" title="4.显示部分数据库"></a>4.显示部分数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases like&#39;my%&#39;;</span><br><span class="line">-- 匹配模式:</span><br><span class="line">--   %为多个未知字符，_为单个未知字符</span><br></pre></td></tr></table></figure>
<h3 id="5-显示数据库创建语句"><a href="#5-显示数据库创建语句" class="headerlink" title="5.显示数据库创建语句"></a>5.显示数据库创建语句</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create database mydatabase;</span><br></pre></td></tr></table></figure>
<h3 id="6-进去数据库"><a href="#6-进去数据库" class="headerlink" title="6.进去数据库"></a>6.进去数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- use 数据库名</span><br><span class="line">-- 出现Database changed表示已经进入指定数据库</span><br><span class="line">use mydatabase;</span><br></pre></td></tr></table></figure>
<h3 id="7-修改数据库"><a href="#7-修改数据库" class="headerlink" title="7.修改数据库"></a>7.修改数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- alter 数据库名 ...</span><br><span class="line">alter mydatabase;</span><br></pre></td></tr></table></figure>
<h3 id="8-修改数据库字符集"><a href="#8-修改数据库字符集" class="headerlink" title="8.修改数据库字符集"></a>8.修改数据库字符集</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter database mydatabase charset utf-8;</span><br></pre></td></tr></table></figure>
<h3 id="9-删除数据库"><a href="#9-删除数据库" class="headerlink" title="9.删除数据库"></a>9.删除数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- (删除前确保数据库中的数据不会被用到)</span><br><span class="line">-- drop database 数据库名</span><br><span class="line">drop database mydatabase;</span><br></pre></td></tr></table></figure>
<h3 id="10-创建数据表"><a href="#10-创建数据表" class="headerlink" title="10.创建数据表"></a>10.创建数据表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- create table 表名(字段名 字段类型[字段属性],....)[表选项];</span><br><span class="line">-- 表选项 Engine: 存储引擎  Charset: 字符集  Collate: 校对集</span><br><span class="line">-- 这里可以先使用use 数据库 ，也可以在表名前加 数据库.</span><br><span class="line">create table class (</span><br><span class="line">	name varchar(10)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="11-创建结果一样的表"><a href="#11-创建结果一样的表" class="headerlink" title="11.创建结果一样的表"></a>11.创建结果一样的表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表名 like 已有表的表名;&#x2F;&#x2F;可以复制其他数据库的表  like XX.XXX</span><br></pre></td></tr></table></figure>
<h3 id="12-显示所有表"><a href="#12-显示所有表" class="headerlink" title="12.显示所有表"></a>12.显示所有表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure>
<h3 id="13-显示部分表"><a href="#13-显示部分表" class="headerlink" title="13.显示部分表"></a>13.显示部分表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show tables like&#39;my%&#39;;</span><br></pre></td></tr></table></figure>
<h3 id="14-查看表结构"><a href="#14-查看表结构" class="headerlink" title="14.查看表结构"></a>14.查看表结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc 表名</span><br><span class="line">show columns from 表名</span><br></pre></td></tr></table></figure>
<h3 id="15-查看表创建语句"><a href="#15-查看表创建语句" class="headerlink" title="15.查看表创建语句"></a>15.查看表创建语句</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create table 表名;</span><br><span class="line">-- ; \g \G是结束符 \G更直观显示</span><br></pre></td></tr></table></figure>
<h3 id="16-修改表名"><a href="#16-修改表名" class="headerlink" title="16.修改表名"></a>16.修改表名</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rename table 表名 to 新表名;</span><br></pre></td></tr></table></figure>
<h3 id="17-修改表选项"><a href="#17-修改表选项" class="headerlink" title="17.修改表选项"></a>17.修改表选项</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 表选项 [&#x3D;]新值</span><br></pre></td></tr></table></figure>
<h3 id="18-增加字段"><a href="#18-增加字段" class="headerlink" title="18.增加字段"></a>18.增加字段</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 add column &#96;字段&#96; 字段属性(int...);&#x2F;*  注意&#96;&#96;必须加*&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="19-修改字段名"><a href="#19-修改字段名" class="headerlink" title="19.修改字段名"></a>19.修改字段名</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 change 旧字段名 新字段名 字段属性;</span><br></pre></td></tr></table></figure>
<h3 id="20-修改字段属性"><a href="#20-修改字段属性" class="headerlink" title="20.修改字段属性"></a>20.修改字段属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 modify 字段名 字段新属性;</span><br></pre></td></tr></table></figure>
<h3 id="21-删除字段"><a href="#21-删除字段" class="headerlink" title="21.删除字段"></a>21.删除字段</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 drop 字段名;</span><br></pre></td></tr></table></figure>
<h3 id="22-删除表"><a href="#22-删除表" class="headerlink" title="22.删除表"></a>22.删除表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop table 表名[1,2....]--可多个</span><br></pre></td></tr></table></figure>
<h3 id="23-插入数据"><a href="#23-插入数据" class="headerlink" title="23.插入数据"></a>23.插入数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名[(字段列表)] values(对应字段列表)</span><br><span class="line">insert into 表名 values(对应字段列表)</span><br></pre></td></tr></table></figure>
<h3 id="24-查询数据"><a href="#24-查询数据" class="headerlink" title="24.查询数据"></a>24.查询数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from 表名</span><br><span class="line">select 字段 from 表名</span><br><span class="line">select 字段 from 表名 where 字段名&#x3D;值</span><br></pre></td></tr></table></figure>
<h3 id="25-删除数据"><a href="#25-删除数据" class="headerlink" title="25.删除数据"></a>25.删除数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from 表名 [where 条件];&#x2F;*如果没有where条件，系统会自动删除表中所有数据*&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="26-修改数据"><a href="#26-修改数据" class="headerlink" title="26.修改数据"></a>26.修改数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表名 set 字段名 &#x3D; 新值 [where 条件] &#x2F;*如果没有where条件，系统会修改那个字段的所有值*&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="27-字符集"><a href="#27-字符集" class="headerlink" title="27.字符集"></a>27.字符集</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set names gbk;</span><br><span class="line">-- 修改字符集</span><br><span class="line">set 系统名 &#x3D; 字符集(gbk)</span><br></pre></td></tr></table></figure>
<h3 id="28-查看系统保存的三种关系处理字符集"><a href="#28-查看系统保存的三种关系处理字符集" class="headerlink" title="28.查看系统保存的三种关系处理字符集"></a>28.查看系统保存的三种关系处理字符集</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;character_set%&#39;;</span><br></pre></td></tr></table></figure>
<h3 id="29-mysql备份"><a href="#29-mysql备份" class="headerlink" title="29.mysql备份"></a>29.mysql备份</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- SQL备份</span><br><span class="line">mysqldump -u -p 数据库[表1 [表二]] &gt; 备份文件地址</span><br><span class="line">-- 如：mysqldump.exe -hlocalhost -P3306 -uroot -proot mydatabase &gt; C:&#x2F;server</span><br><span class="line">-- 数据还原</span><br><span class="line">mysql.exe -u-p 数据库 &lt;文件位置 </span><br><span class="line">source SQL 文件位置</span><br><span class="line">-- 如：mysql -hlocalhost -P3306 -uroot -proot mydatabase &lt; C:&#x2F;server</span><br></pre></td></tr></table></figure>




<h2 id="二、查询语句"><a href="#二、查询语句" class="headerlink" title="二、查询语句"></a>二、查询语句</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">完整语句：</span><br><span class="line">select select选项 字段列表 from 数据表 where 条件 group by 分组 having 条件</span><br><span class="line">order by 排序 limit 限制</span><br><span class="line">--select选项 </span><br><span class="line">all &#x2F;*默认&#x3D; * *&#x2F;</span><br><span class="line">distinct &#x2F;*去重*&#x2F;</span><br><span class="line">--动态数据</span><br><span class="line">select from (select 字段列表 from 表) as 别名;</span><br><span class="line"></span><br><span class="line">--where</span><br><span class="line">where 条件</span><br><span class="line">where 字段 between 数值 and 数值</span><br><span class="line">--逻辑</span><br><span class="line">and</span><br><span class="line">or</span><br><span class="line">in(值,值,..)</span><br><span class="line">is null&#x2F;is not null&#x2F;*判断是否为空*&#x2F;</span><br><span class="line">like &quot;匹配模式&quot;&#x2F;* _单个字符 %多个字符 *&#x2F;</span><br><span class="line"></span><br><span class="line">--group by</span><br><span class="line">group by 字段</span><br><span class="line">group by 字段1 [asc|desc],字段2 [asc|desc]...</span><br><span class="line">group by 字段 with rollup;&#x2F;*对分组进行统计汇总*&#x2F;</span><br><span class="line">count()</span><br><span class="line">avg()</span><br><span class="line">sum()</span><br><span class="line">max()</span><br><span class="line">min()</span><br><span class="line"></span><br><span class="line">--having条件</span><br><span class="line">group by 字段 having 条件&#x2F;*对分组后的数据进行再筛选*&#x2F;</span><br><span class="line">--order by排序</span><br><span class="line">order by 字段[asc|desc]&#x2F;*默认升序|降序 *&#x2F;</span><br><span class="line">order by 字段1 [asc|desc] 字段2 [asc|desc]....&#x2F;*可多字段排序先按第一个*&#x2F;</span><br><span class="line">--limit分页</span><br><span class="line">limit offset,length &#x2F;*offset偏移量 从哪开始,length具体取几条*&#x2F;</span><br><span class="line"></span><br><span class="line">--联合查询</span><br><span class="line">select 语句</span><br><span class="line">UNION [union选项]&#x2F;*all,默认distinct去重*&#x2F;</span><br><span class="line">select 语句;</span><br><span class="line">&#x2F;*联合查询的order by查询时需要将select语句()括起来</span><br><span class="line">还必须使用limit使用较大的值*&#x2F;</span><br><span class="line"></span><br><span class="line">--交叉连接&#x2F;*笛卡尔积无实际意义*&#x2F;</span><br><span class="line">select * from 表1 cross join 表2;</span><br><span class="line">--内连接&#x2F;*通常在对数据精确要求的地方使用*&#x2F;</span><br><span class="line">select * from 表1 [inner] join 表2 on 匹配条件&#x2F;*值1&#x3D;值2*&#x2F;;</span><br><span class="line"></span><br><span class="line">--外连接&#x2F;*主表记录必须保存若从表条件不匹配结果为null*&#x2F;</span><br><span class="line">主表 left join 从表 on 条件&#x2F;*左外连接 左边为主表*&#x2F;常用方式</span><br><span class="line">主表 right join 从表 on 条件&#x2F;*右外连接 右边为主表*&#x2F;</span><br><span class="line">--自然连接</span><br><span class="line">select *from 表1 natural join 表2</span><br><span class="line">--using关键字&#x2F;*用于替代on 效果如自然连接*&#x2F;</span><br><span class="line">表1 join 表2 using(同名字段列表);</span><br><span class="line">--子查询</span><br><span class="line">--where子查询</span><br><span class="line">--标量子查询</span><br><span class="line">select *from 表1 where 条件判断&#x3D;&#x2F;&lt;&gt;(select 字段名 from 表2 where 条件判断);</span><br><span class="line">--列子查询</span><br><span class="line">select 字段 from 表1 where 条件 in (select 字段名 from 表2)</span><br><span class="line">--行子查询</span><br><span class="line">&#x2F;*select * from my_student where (stu_age,stu_height)&#x3D;(select max(stu_age),max(stu_height)from my_student) *&#x2F;</span><br><span class="line">select 字段 from 表1 where 多字段条件&#x3D;(select 字段名 from 表2)</span><br><span class="line">--from子查询</span><br><span class="line">--表子查询</span><br><span class="line">select 字段列表 from (表子查询)as 别名 [where] [group by] [having] [order by] [limit];</span><br><span class="line">--exists子查询&#x2F;*返回0 或1 若返回1执行主查询*&#x2F;</span><br><span class="line">主查询语句 where exists子查询(查询语句);</span><br><span class="line">select  * from classes where cid in (select  cno from student where birthday&gt;&#39;1991-01-01&#39;);&#x2F;*查看生日大于**的学生的班级信息*&#x2F;</span><br></pre></td></tr></table></figure>


<h2 id="三、权限管理"><a href="#三、权限管理" class="headerlink" title="三、权限管理"></a>三、权限管理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--创建用户</span><br><span class="line">create user 用户名 identified by &#39;明文密码&#39;;</span><br><span class="line">用户名：用户名@主机地址</span><br><span class="line">主机地址：&#39;&#x2F;%&#39;</span><br><span class="line">如：create user &#39;user1&#39;@&#39;%&#39; identified by &#39;1234&#39;;</span><br><span class="line">--简化创建</span><br><span class="line">create user user2;</span><br><span class="line">--删除用户</span><br><span class="line">drop user 用户名;</span><br><span class="line">--用户权限管理</span><br><span class="line">1.数据权限 增删查改(select\update\delete\insert)</span><br><span class="line">2.结构权限 结构操作(create\drop)</span><br><span class="line">3.管理权限 权限管理(create user\grant\revoke)</span><br><span class="line">--授予权限</span><br><span class="line">grant 权限列表 on 数据库.[.表名] to 用户名</span><br><span class="line">这里：可以单表数据库.表名 可以某个数据库 数据库.* 也可以整库 *.*</span><br><span class="line">权限列表： 用逗号隔开 all privileges</span><br><span class="line">--删除权限</span><br><span class="line">revoke 权限列表 on 数据库.[.表名] from 用户名</span><br><span class="line">--刷新权限</span><br><span class="line">flush privileges;</span><br><span class="line">--密码丢失找回</span><br><span class="line">1.停止服务 net stop mysql;</span><br><span class="line">2.mysqld --console --skip-grant-tables --shared-memory</span><br><span class="line">3.新开客服端 直接使用mysql进入</span><br><span class="line">4.修改密码 </span><br><span class="line">			update mysql.user set authentication_string&#x3D;&#39;&#39;  where user&#x3D;&#39;root&#39;;&#x2F;*设置无需密码登录*&#x2F;</span><br><span class="line">			ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">5.关闭mysqld</span><br></pre></td></tr></table></figure>


<h2 id="四、字段相关约束"><a href="#四、字段相关约束" class="headerlink" title="四、字段相关约束"></a>四、字段相关约束</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--字段属性 </span><br><span class="line">NULL属性&#x2F;*尽量不要让数据为空 *&#x2F;</span><br><span class="line">设置 NOT NULL</span><br><span class="line">Default默认值&#x2F;*不设置为null *&#x2F;</span><br><span class="line">设置default 值</span><br><span class="line">comment列描述&#x2F;*一种维护时的注释说明查看创建表语句可看*&#x2F;</span><br><span class="line">设置 comment&#39;字段描述&#39;</span><br><span class="line">--主键（1.不能为空 2.数据不能有任何重复）</span><br><span class="line">--分类 业务主键(学生id..) 逻辑主键 一般自增的整型</span><br><span class="line">primary key&#x2F;*在字段后添加*&#x2F;</span><br><span class="line">primary key(字段)</span><br><span class="line">alter table 表名 add primary key(字段)&#x2F;*表后添加*&#x2F;</span><br><span class="line">alter table 表名 drop primary key &#x2F;*删除主键*&#x2F;</span><br><span class="line">--复合主键</span><br><span class="line">primary key(字段1,字段2..)&#x2F;*不常用*&#x2F;</span><br><span class="line">--唯一键</span><br><span class="line">unique key &#x2F;*唯一但可以为空null可以多个*&#x2F;</span><br><span class="line">unique key&#x2F;*在字段后添加*&#x2F;</span><br><span class="line">unique key(字段)</span><br><span class="line">alter table 表名 add unique key(字段)&#x2F;*表后添加*&#x2F;</span><br><span class="line">alter table 表名 drop index 唯一键名 unique key &#x2F;*删除唯一键unique key可省*&#x2F;</span><br><span class="line">--复合主键</span><br><span class="line">unique key(字段1,字段2..)</span><br><span class="line">--自动增长(配合主键使用)</span><br><span class="line">字段之后添加 auto_increment&#x2F;*用于逻辑主键 但只适用于数值*&#x2F;</span><br><span class="line">--修改自增长的值</span><br><span class="line">alter table 表名 auto_increment &#x3D; 值;</span><br><span class="line">--删除增加自增长&#x2F;*重置字段属性即可*&#x2F;</span><br><span class="line">alter table 表名 modify 字段 属性;</span><br><span class="line">--查看自增长属性</span><br><span class="line">show variables like &#39;auto_increment%&#39;;</span><br><span class="line"></span><br><span class="line">--主键冲突更新</span><br><span class="line">insert into 表名 values(值列表)on update 字段&#x3D;新值</span><br><span class="line">--主键冲突替换</span><br><span class="line">replace into 表名 values(值列表)</span><br><span class="line">--蠕虫复制</span><br><span class="line">insert into 表名 select *&#x2F;字段列表 from 表名</span><br><span class="line">--更新数据</span><br><span class="line">update 表名 set 字段名-新值 where 判断条件</span><br><span class="line">update 表名 set 字段名&#x3D;新值 limit 数量</span><br><span class="line">--重置自增长 &#x3D; 删除表中数据;</span><br><span class="line">truncate table 表名;</span><br><span class="line">--重置自增长</span><br><span class="line">ALTER TABLE 表名 AUTO_INCREMENT&#x3D; 1; &#x2F;*保留数据*&#x2F;</span><br><span class="line">&#x2F;*尽量少使用外键*&#x2F;</span><br><span class="line">--增加外键</span><br><span class="line">foreign key(字段) references 主表(字段)</span><br><span class="line">alter table 从表 add constraint &#39;表_ibfk_1&#39; foreign key(字段) references 主表(字段) on 约束模式</span><br><span class="line">约束模式：1.district 严格模式默认 不允许操作 </span><br><span class="line">		  2.cascade:级联模式,一起操作 主表变化,从表跟着变化</span><br><span class="line"></span><br><span class="line">   		  3. set null:置空模式 主表变化,从表对应记录设置为空</span><br><span class="line">	常用约束模式：on update cascade on delete set null;</span><br><span class="line">	--删除外键</span><br><span class="line">	alter table 从表 drop foreign key &#39;constraint名字&#39;;</span><br></pre></td></tr></table></figure>


<h2 id="五、进阶部分"><a href="#五、进阶部分" class="headerlink" title="五、进阶部分"></a>五、进阶部分</h2><h3 id="1-视图"><a href="#1-视图" class="headerlink" title="1.视图"></a>1.视图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--创建视图</span><br><span class="line">create view 视图名字 as select指令;</span><br><span class="line">--查看视图</span><br><span class="line">desc 视图名</span><br><span class="line">--使用视图&#x2F;*可以当表操作*&#x2F;</span><br><span class="line">--修改视图</span><br><span class="line">alter view 视图名字 as 新select指令</span><br><span class="line">--删除视图</span><br><span class="line">drop view 视图名字;</span><br></pre></td></tr></table></figure>
<h3 id="2-手动事务"><a href="#2-手动事务" class="headerlink" title="2.手动事务"></a>2.手动事务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.start transaction &#x2F;&#x2F;此句开始之后,所有语句不会直接写入数据库(保存在事务日志中)</span><br><span class="line">2.事务处理,多条语句构成</span><br><span class="line">3.事务提交：commit&#x2F;rollback</span><br><span class="line">--设置回滚点</span><br><span class="line">set savepoint 回滚点名字;</span><br><span class="line">--回到回滚到</span><br><span class="line">rollback to 回滚点名字;</span><br><span class="line">--事务隔离级别&#x2F;*安全性从低到高  效率从高到低*&#x2F;</span><br><span class="line">read uncommitted</span><br><span class="line">read committed  &#x2F;*只避免脏读*&#x2F;</span><br><span class="line">repeatable read  &#x2F;*只会发生幻读 *&#x2F;</span><br><span class="line">serializable &#x2F;*都可以隔离*&#x2F;</span><br><span class="line">--设置隔离级别</span><br><span class="line">set session transaction isolation level 隔离级别;</span><br><span class="line">--查看隔离级别</span><br><span class="line">select @@transaction_isolation;</span><br></pre></td></tr></table></figure>




<h3 id="3-系统变量"><a href="#3-系统变量" class="headerlink" title="3.系统变量"></a>3.系统变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--查看系统变量</span><br><span class="line">show variables;</span><br><span class="line">set @@变量名;</span><br><span class="line">--修改变量名</span><br><span class="line">--局部修改不影响其他客户端</span><br><span class="line">set 变量名 &#x3D; 新值</span><br><span class="line">--全局修改 需要重新打开客户端才生效</span><br><span class="line">set global 变量名 &#x3D; 值;</span><br><span class="line">--会话变量&#x2F;自定义变量</span><br><span class="line">set @变量 &#x3D; 值;</span><br><span class="line">--通过查询语句为变量赋值</span><br><span class="line">select @name :&#x3D;stu_name,@age :&#x3D; stu_age from my_student limit 1;</span><br><span class="line">select stu_name,stu_age from my_student order by stu_height desc limit 1 into @name,@age;</span><br><span class="line">--查看变量</span><br><span class="line">select @变量名;</span><br><span class="line">--局部变量</span><br><span class="line">--复杂语句中使用(函数&#x2F;存储过程&#x2F;触发器)</span><br><span class="line">declare 变量名 类型 [default 默认值];</span><br></pre></td></tr></table></figure>
<h3 id="4-if-分支"><a href="#4-if-分支" class="headerlink" title="4.if 分支"></a>4.if 分支</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--查询语句中使用</span><br><span class="line">select *,if(stu_age&gt;20,&#39;符合&#39;,&#39;不符合&#39;) as judge from my_student;</span><br><span class="line">--复杂语句中使用(函数&#x2F;存储过程&#x2F;触发器)</span><br><span class="line">if 条件表达式 then </span><br><span class="line">	满足条件执行的语句;</span><br><span class="line">else</span><br><span class="line">	不满足条件执行的语句;</span><br><span class="line">end if;</span><br></pre></td></tr></table></figure>
<h3 id="5-while语句"><a href="#5-while语句" class="headerlink" title="5.while语句"></a>5.while语句</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标识名字:while 条件 do</span><br><span class="line">	[if 条件判断 then </span><br><span class="line">		lterate&#x2F;leave 标识名字&#x2F;&#x2F;循环控制</span><br><span class="line">	end if;</span><br><span class="line">	]</span><br><span class="line">	循环体</span><br><span class="line">end while;</span><br></pre></td></tr></table></figure>
<h3 id="6-内置函数"><a href="#6-内置函数" class="headerlink" title="6.内置函数"></a>6.内置函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--字符串函数</span><br><span class="line">char_length() : 判断字符串的字符数</span><br><span class="line">length() : 判断字符串的字节数</span><br><span class="line">concat() : 连接字符串</span><br><span class="line">instr() : 判断字符在目标字符串中是否存在,若存在返回其位置,不存在返回0</span><br><span class="line">lcase() : 全部小写</span><br><span class="line">left() : 从左侧指定位置开始截取字符串</span><br><span class="line">ltrim() : 消除左边对应的空格</span><br><span class="line">mid() : 从中间指定位置开始截取,若不指定直接到最后</span><br><span class="line">--时间函数</span><br><span class="line">now() : 返回当前时间</span><br><span class="line">curdate() : 返回当前日期</span><br><span class="line">curtime() : 返回当前时间</span><br><span class="line">datediff() : 判断两个日期之间的天数</span><br><span class="line">date_add() : 进行时间的增加&#x2F;减少</span><br><span class="line">--数学函数</span><br><span class="line">abs()</span><br><span class="line">ceiling()</span><br><span class="line">floor()</span><br><span class="line">pow()</span><br><span class="line">found()</span><br><span class="line">--其他函数</span><br><span class="line">Md5() : 对数据进行md5加密</span><br><span class="line">version() : 获得版本</span><br><span class="line">database() : 显示当前数据库</span><br><span class="line">uuid() : 生成一个唯一的标识符</span><br></pre></td></tr></table></figure>


<h3 id="7-自定义函数"><a href="#7-自定义函数" class="headerlink" title="7.自定义函数"></a>7.自定义函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--自定义函数</span><br><span class="line">--修改语句结束符</span><br><span class="line">delimiter $$</span><br><span class="line">create function 函数名(参数名 数据类型,...) return 数据类型</span><br><span class="line">begin</span><br><span class="line">	函数语句</span><br><span class="line">	return 值;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">--查看自定义函数</span><br><span class="line">show function status;</span><br><span class="line"></span><br><span class="line">--查看函数创建语句</span><br><span class="line">show create function 函数名;</span><br><span class="line">--调用函数</span><br><span class="line">select 函数();</span><br><span class="line">--删除函数</span><br><span class="line">drop function 函数名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-存储过程"><a href="#8-存储过程" class="headerlink" title="8.存储过程"></a>8.存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 存储过程</span><br><span class="line">-- 创建过程</span><br><span class="line">如：创建一个求1到100之间的和的过程</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure 过程名([参数列表])</span><br><span class="line">begin </span><br><span class="line">	declare i int default 1;</span><br><span class="line">	set @sum&#x3D;0;</span><br><span class="line">	while i&lt;&#x3D;100 do</span><br><span class="line">		set @sum&#x3D;@sum+i;</span><br><span class="line">		set i &#x3D; i+1;</span><br><span class="line">	end while;</span><br><span class="line">	select@sum;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line">--查看过程</span><br><span class="line">show procedure status;</span><br><span class="line">--查看创建过程的语句</span><br><span class="line">show create procedure 过程名;</span><br><span class="line">--调用过程</span><br><span class="line">call 过程名([参数列表])</span><br><span class="line">--删除过程</span><br><span class="line">drop procedure 过程名;</span><br><span class="line">--过程参数列表</span><br><span class="line">过程类型 变量名 数据类型&#x2F;&#x2F;in int_1 int;</span><br><span class="line">--过程类型</span><br><span class="line">in &#x2F;*提供给过程使用 相当于值传递*&#x2F;</span><br><span class="line">out &#x2F;*给外部使用 相当于引用传递 内部也可以改变外部的值*&#x2F;</span><br><span class="line">inout &#x2F;*给内外部使用 相当于引用传递 内部也可以改变外部的值*&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="9-索引"><a href="#9-索引" class="headerlink" title="9.索引"></a>9.索引</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--创建索引</span><br><span class="line">create [unique]index indexName on 表名(字段)</span><br><span class="line"></span><br><span class="line">--开窗函数</span><br><span class="line">--分组排序</span><br><span class="line">--1 2 3 4</span><br><span class="line">select</span><br><span class="line">    empid,</span><br><span class="line">    ename,</span><br><span class="line">    deptid,</span><br><span class="line">    salary,</span><br><span class="line">    ROW_NUMBER() over (partition by deptid ORDER BY salary desc) as row_number1</span><br><span class="line">from employee;</span><br><span class="line">-- 1 2 2 4</span><br><span class="line">select</span><br><span class="line">    empid,</span><br><span class="line">    ename,</span><br><span class="line">    deptid,</span><br><span class="line">    salary,</span><br><span class="line">    rank() over (partition by deptid ORDER BY salary desc) as row_number1</span><br><span class="line">from employee;</span><br><span class="line">-- 1 2 2 3</span><br><span class="line">select</span><br><span class="line">    empid,</span><br><span class="line">    ename,</span><br><span class="line">    deptid,</span><br><span class="line">    salary,</span><br><span class="line">    dense_rank() over (partition by deptid ORDER BY salary desc) as row_number1</span><br><span class="line">from employee;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL幻读问题</title>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="幻读问题"><a href="#幻读问题" class="headerlink" title="幻读问题"></a>幻读问题</h1><p>这里，我需要对“幻读”做一个说明：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230709094600707.png" alt="image-20230709094600707"></p>
<ol>
<li>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。</li>
<li>上面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读。幻读仅专指“新插入的行”。</li>
</ol>
<p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是**间隙锁(Gap Lock)**。</p>
<p>这样，当你执行 select * from t where d=5 for update的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。</p>
<blockquote>
<p><strong>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。</strong>间隙锁之间都不存在冲突关系。但是，<strong>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的</strong>。所以间隙锁是在可重复读隔离级别下才会生效的</p>
</blockquote>
<h2 id="间隙锁的加锁规则："><a href="#间隙锁的加锁规则：" class="headerlink" title="间隙锁的加锁规则："></a>间隙锁的加锁规则：</h2><ol>
<li><strong>原则1：</strong>加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。</li>
<li><strong>原则2：</strong>查找过程中访问到的对象才会加锁。</li>
<li><strong>优化1：</strong>索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li>
<li><strong>优化2：</strong>索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</li>
<li><strong>一个bug：</strong>唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ol>
<blockquote>
<p><strong>需要注意：</strong></p>
<ol>
<li>lock in share mode只锁覆盖索引，但是如果是for update就不一样了。 执行 for update时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</li>
<li><strong>在删除数据的时候尽量加limit</strong>。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL快速的复制一张表</title>
    <url>/2023/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E5%BF%AB%E9%80%9F%E7%9A%84%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="快速的复制一张表"><a href="#快速的复制一张表" class="headerlink" title="快速的复制一张表"></a>快速的复制一张表</h1><h2 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h2><p>你可以使用下面的命令：</p>
<p><code>mysqldump -h$host -P$port -u$user --add-locks --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where=&quot;a&gt;900&quot; --result-file=/client_tmp/t.sql</code></p>
<p>这条命令中，主要参数含义如下：</p>
<ol>
<li>–single-transaction的作用是，在导出数据的时候不需要对表db1.t加表锁，而是使用START TRANSACTION WITH CONSISTENT SNAPSHOT的方法；</li>
<li>–add-locks设置为0，表示在输出的文件结果里，不增加” LOCK TABLES <code>t</code> WRITE;” ；</li>
<li>–no-create-info的意思是，不需要导出表结构；</li>
<li>–set-gtid-purged=off表示的是，不输出跟GTID相关的信息；</li>
<li>–result-file指定了输出文件的路径，其中client表示生成的文件是在客户端机器上的。</li>
</ol>
<p>再使用这个命令加载：<code>mysql -h127.0.0.1 -P13000  -uroot db2 -e &quot;source /client_tmp/t.sql&quot;</code></p>
<h2 id="导出csv文件"><a href="#导出csv文件" class="headerlink" title="导出csv文件"></a>导出csv文件</h2><p>导出命令：<code>select * from db1.t where a&gt;900 into outfile &#39;/server_tmp/t.csv&#39;;</code></p>
<p>需要注意如下几点：</p>
<ol>
<li>这条语句会将结果保存在服务端。如果你执行命令的客户端和MySQL服务端不在同一个机器上，客户端机器的临时目录下是不会生成t.csv文件的。</li>
<li>into outfile指定了文件的生成位置（/server_tmp/），这个位置必须受参数secure_file_priv的限制。参数secure_file_priv的可选值和作用分别是：<ul>
<li>如果设置为empty，表示不限制文件生成的位置，这是不安全的设置；</li>
<li>如果设置为一个表示路径的字符串，就要求生成的文件只能放在这个指定的目录，或者它的子目录；</li>
<li>如果设置为NULL，就表示禁止在这个MySQL实例上执行select … into outfile 操作。</li>
</ul>
</li>
<li>这条命令不会帮你覆盖文件，因此你需要确保/server_tmp/t.csv这个文件不存在，否则执行语句时就会因为有同名文件的存在而报错。</li>
<li>这条命令生成的文本文件中，原则上一个数据行对应文本文件的一行。但是，如果字段中包含换行符，在生成的文本中也会有换行符。不过类似换行符、制表符这类符号，前面都会跟上“\”这个转义符，这样就可以跟字段之间、数据行之间的分隔符区分开。</li>
</ol>
<p>导入命令：<code>load data infile &#39;/server_tmp/t.csv&#39; into table db2.t;</code></p>
<blockquote>
<p>另外需要注意的是，<strong>select …into outfile方法不会生成表结构文件</strong>, 所以我们导数据时还需要单独的命令得到表结构定义。mysqldump提供了一个–tab参数，可以同时导出表结构定义文件和csv数据文件。这条命令的使用方法如下：<code>mysqldump -h$host -P$port -u$user ---single-transaction  --set-gtid-purged=OFF db1 t --where=&quot;a&gt;900&quot; --tab=$secure_file_priv</code></p>
</blockquote>
<h2 id="物理拷贝方法-不能跨引擎"><a href="#物理拷贝方法-不能跨引擎" class="headerlink" title="物理拷贝方法(不能跨引擎)"></a>物理拷贝方法(不能跨引擎)</h2><p>MySQL 5.6版本引入了<strong>可传输表空间</strong>(transportable tablespace)的方法，可以通过导出+导入表空间的方式，实现物理拷贝表的功能。</p>
<p>假设我们现在的目标是在db1库下，复制一个跟表t相同的表r，具体的执行步骤如下：</p>
<ol>
<li>执行 create table r like t，创建一个相同表结构的空表；</li>
<li>执行alter table r discard tablespace，这时候r.ibd文件会被删除；</li>
<li>执行flush table t for export，这时候db1目录下会生成一个t.cfg文件；</li>
<li>在db1目录下执行cp t.cfg r.cfg; cp t.ibd r.ibd；这两个命令；</li>
<li>执行unlock tables，这时候t.cfg文件会被删除；</li>
<li>执行alter table r import tablespace，将这个r.ibd文件作为表r的新的表空间，由于这个文件的数据内容和t.ibd是相同的，所以表r中就有了和表t相同的数据。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据类型</title>
    <url>/2021/02/24/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="mysql数据类型"><a href="#mysql数据类型" class="headerlink" title="mysql数据类型"></a>mysql数据类型</h1><h2 id="1-整型"><a href="#1-整型" class="headerlink" title="1. 整型"></a>1. 整型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">※Tinyint &#x2F;*迷你整形最大数值0-255 1字节*&#x2F;</span><br><span class="line">Smallint &#x2F;*小整形最大数值0-65535 2字节*&#x2F;</span><br><span class="line">Mediumint &#x2F;*中整形 3字节*&#x2F;</span><br><span class="line">※int &#x2F;*整形 4字节*&#x2F;</span><br><span class="line">bigint&#x2F;*大整形 8字节*&#x2F;</span><br><span class="line"></span><br><span class="line">-- 若不想有负数</span><br><span class="line">类型后加 unsigned</span><br><span class="line"></span><br><span class="line">-- 若想输出时满足最大长度自动填充</span><br><span class="line">类型后加 Zerofill&#x2F;*负数不能用若使用zerofill自动取消负数unsigned*&#x2F;</span><br><span class="line">自定义长度类型后加(数字)&#x2F;*但不能超出类型范围*&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="2-小数和浮点型"><a href="#2-小数和浮点型" class="headerlink" title="2.小数和浮点型"></a>2.小数和浮点型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 小数(浮点型，定点型)</span><br><span class="line">类型(M,D)&#x2F;*m个有效数字，小数占D位*&#x2F;</span><br><span class="line"></span><br><span class="line">-- 浮点型(可以用科学计数法插入 10e5通常用来存储不需要那么精确的数据)</span><br><span class="line">Float &#x2F;*4字节 范围10^38只能保证7位数以内*&#x2F;</span><br><span class="line">Double &#x2F;*8字节 范围10^308只能保证15位数以内*&#x2F;</span><br><span class="line"></span><br><span class="line">-- 定点数(保证精确的小数，小数部分超出长度会四舍五入)</span><br><span class="line">Decimal(M,D)&#x2F;*系统会自动分配空间M最大65 D最大不超过30*&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="3-时间日期类型"><a href="#3-时间日期类型" class="headerlink" title="3.时间日期类型"></a>3.时间日期类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 事件日期类型</span><br><span class="line">Date YYYY-mm-dd&#x2F;*3字节 范围1000-01-01到9999-12-12 初始值为0000-00-00*&#x2F; </span><br><span class="line">Time HH:li:ss &#x2F;*3字节 范围-838:59:59~838:59:59 一般用于表示时间间隔 可以这样插入&quot;数字 000:00:00&quot;等于数字(可为负)*24+后面时间*&#x2F;</span><br><span class="line">Datetime YYYY-mm-dd HH:li:ss &#x2F;*8字节 范围1000-01-01 00:00:00到9999-12-12 23:59:59*&#x2F;</span><br><span class="line">Timestamp YYYY-mm-dd HH:li:ss&#x2F;*从格林威治时间开始*&#x2F;</span><br><span class="line">Year &#x2F;*1字节两位数字插入时 69以下为2000+数字70以上为1900+数字四位插入不动*&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="4-字符串类型"><a href="#4-字符串类型" class="headerlink" title="4.字符串类型"></a>4.字符串类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 字符串型</span><br><span class="line">Char(L) &#x2F;*定长字符，系统一直会分配L大小的空间 L范围0~255*&#x2F;</span><br><span class="line">Varchar(L) &#x2F;*变长字符 系统会根据你输入的值来分配空间(前提未超出你设置的长度) L范围理论0~65535*&#x2F;</span><br><span class="line">Text&#x2F;*当数据长度超过255个字符使用*&#x2F;</span><br><span class="line">Tinytext&#x2F;*一个字节保存 存储数据为2^8+1*&#x2F;</span><br><span class="line"></span><br><span class="line">-- 只使用Text&#x2F;*一个字节保存 存储数据为2^16+2*&#x2F;</span><br><span class="line">Mediumtext&#x2F;*一个字节保存 存储数据为2^24+3*&#x2F;</span><br><span class="line">Longtext&#x2F;*一个字节保存 存储数据为2^32+4*&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="5-其他类型"><a href="#5-其他类型" class="headerlink" title="5.其他类型"></a>5.其他类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Enum和Set都是以数字存储</span><br><span class="line">Enum&#x2F;*确定字段的数据就几个值时使用如性别*&#x2F;</span><br><span class="line">enum(数据值1,.....)&#x2F;*单选*&#x2F;</span><br><span class="line">Set &#x2F;*集合类型 最大只能放64个选项*&#x2F;&#x2F;*多选复选框*&#x2F;</span><br><span class="line">Set(数据值1,.....)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL - 数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的两大日志</title>
    <url>/2023/06/14/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E7%9A%84%E4%B8%A4%E5%A4%A7%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="两大日志"><a href="#两大日志" class="headerlink" title="两大日志"></a>两大日志</h1><h2 id="Redo-log"><a href="#Redo-log" class="headerlink" title="Redo log"></a>Redo log</h2><p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p>
<p>当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p>
<blockquote>
<p>innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。</p>
</blockquote>
<h2 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h2><p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>（归档日志），需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>
<p>与redo log的<strong>区别</strong>：</p>
<ul>
<li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li>
<li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。</li>
<li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ul>
<blockquote>
<p>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。</p>
</blockquote>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>我们来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程：</p>
<ol>
<li><p>执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p>
</li>
<li><p>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</p>
</li>
<li><p>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</p>
</li>
<li><p>执行器生成这个操作的binlog，并把binlog写入磁盘。</p>
</li>
<li><p>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230412142806569.png" alt="image-20230412142806569" style="zoom: 80%;" />

</li>
</ol>
<blockquote>
<p><strong>为什么会有两阶段提交？</strong></p>
<p>如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致，或者主备之间的数据不一致。简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL - 数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL用户权限</title>
    <url>/2023/07/29/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h4 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h4><p><strong>创建用户</strong></p>
<p><code>create user &#39;ua&#39;@&#39;%&#39; identified by &#39;pa&#39;;</code></p>
<p>这条语句的逻辑是创建一个用户’ua’@’%’，密码是pa。(%表示可以从任意ip登录，可以指定ip)</p>
<p>这条命令做了两个动作：</p>
<ol>
<li>磁盘上，往mysql.user表里插入一行，由于没有指定权限，所以这行数据上所有表示权限的字段的值都是N；</li>
<li>内存里，往数组acl_users里插入一个acl_user对象，这个对象的access字段值为0。</li>
</ol>
<p><strong>权限操作</strong></p>
<ul>
<li>赋予权限：<code>grant 权限列表 on 数据库.[.表名] to 用户名  [with grant option];</code>(with grant option表示可以传递给其他用户)</li>
<li>取消权限：<code>revoke 权限列表 on 数据库.[.表名] from 用户名;</code></li>
</ul>
<p><strong>全局权限：</strong></p>
<p>全局权限，作用于整个 MySQL 实例用于管理MySQL服务器的操作，这些权限信息保存在 mysql 库的 user 表里，只能用<code>*.*</code>赋予。</p>
<p>revoke命令与grant命令，做了如下两个动作：</p>
<ol>
<li>磁盘上，将mysql.user表里，用户这一行的所有表示权限的字段的值都修改为”N”或者”Y”；</li>
<li>内存里，从数组acl_users中找到这个用户对应的对象，将access的值修改为0或者1。</li>
</ol>
<p>但是每个连接会有一个线程对象，会将全局权限值拷贝到线程对象中，之后所有关于全局权限的判断，都直接使用线程对象内部保存的权限位。</p>
<p><strong>数据库权限：</strong></p>
<p>对于数据库权限，会在磁盘上生成一个mysql.db表；在内存里，生成数组acl_dbs，这个是一个全局数组，所有线程判断db权限都用这个数组；并不会存在线程对象中。</p>
<p><strong>表权限和列权限：</strong></p>
<p>表权限定义存放在表mysql.tables_priv中，列权限定义存放在表mysql.columns_priv中。这两类权限，组合起来存放在内存的hash结构column_priv_hash中。</p>
<p>跟数据库权限类似，这两个权限每次grant的时候都会修改数据表，也会同步修改内存中的hash结构。因此，对这两类权限的操作，也会<strong>马上影响到已经存在的连接</strong>。</p>
<p><strong>对于flush privileges命令：</strong></p>
<p>flush privileges命令会清空内存中的权限数组，然后从磁盘中对应的表中读取数据重新加载，重新构造一个数组。所以如果内存的权限数据和磁盘数据表相同的话，不需要执行flush privileges。</p>
<blockquote>
<p>权限列表：（所有权限all privileges）</p>
<ol>
<li>数据权限 增删查改(select\update\delete\insert)</li>
<li>结构权限 结构操作(create\drop)</li>
<li>管理权限 权限管理(create user\grant\revoke)</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL短时提供性能的方法</title>
    <url>/2023/07/11/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E7%9F%AD%E6%97%B6%E6%8F%90%E4%BE%9B%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="短时提供性能的方法"><a href="#短时提供性能的方法" class="headerlink" title="短时提供性能的方法"></a>短时提供性能的方法</h1><h2 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h2><p>正常的短连接模式就是连接到数据库后，执行很少的SQL语句就断开，下次需要的时候再重连。如果使用的是短连接，在业务高峰期的时候，就可能出现连接数突然暴涨的情况。</p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><h4 id="第一种方法：先处理掉那些占着连接但是不工作的线程："><a href="#第一种方法：先处理掉那些占着连接但是不工作的线程：" class="headerlink" title="第一种方法：先处理掉那些占着连接但是不工作的线程："></a>第一种方法：先处理掉那些占着连接但是不工作的线程：</h4><p>怎么判断哪些是事务外空闲的呢？</p>
<p>执行<code>show processlist</code></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230317213544900.png" alt="image-20230317213544900"></p>
<p>图中id=4和id=5的两个会话都是Sleep 状态。而要看事务具体状态的话，你可以查information_schema库的innodb_trx表。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230317213632522.png" alt="image-20230317213632522" style="zoom:50%;" />

<p>这个结果里，trx_mysql_thread_id=4，表示id=4的线程还处在事务中。</p>
<p>因此，如果是连接数过多，你可以优先断开事务外空闲太久的连接；如果这样还不够，再考虑断开事务内空闲太久的连接。</p>
<blockquote>
<p>从服务端断开连接使用的是kill connection + id的命令， 一个客户端处于sleep状态时，它的连接被服务端主动断开后，这个客户端并不会马上知道。直到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。</p>
<p>从数据库端主动断开连接可能是有损的，尤其是有的应用端收到这个错误后，不重新连接，而是直接用这个已经不能用的句柄重试查询。这会导致从应用端看上去，“MySQL一直没恢复”。</p>
</blockquote>
<h4 id="减少连接过程的消耗："><a href="#减少连接过程的消耗：" class="headerlink" title="减少连接过程的消耗："></a>减少连接过程的消耗：</h4><p>有的业务代码会在短时间内先大量申请数据库连接做备用，如果现在数据库确认是被连接行为打挂了，那么一种可能的做法，是让数据库跳过权限验证阶段。</p>
<p>跳过权限验证的方法是：重启数据库，并使用–skip-grant-tables参数启动。这样，整个MySQL会跳过所有的权限验证阶段，包括连接过程和语句执行过程在内。</p>
<blockquote>
<p>但是，这种方法风险极高，是我特别不建议使用的方案。尤其你的库外网可访问的话，就更不能这么做了。</p>
<p>在MySQL 8.0版本里，如果你启用–skip-grant-tables参数，MySQL会默认把 –skip-networking参数打开，表示这时候数据库只能被本地的客户端连接。可见，MySQL官方对skip-grant-tables这个参数的安全问题也很重视。</p>
</blockquote>
<h2 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h2><p>在MySQL中，会引发性能问题的慢查询，大体有以下三种可能：</p>
<ol>
<li><p><strong>索引没有设计好；</strong></p>
<p>这种场景一般就是通过紧急创建索引来解决。MySQL 5.6版本以后，创建索引都支持Online DDL了，对于那种高峰期数据库已经被这个语句打挂了的情况，最高效的做法就是直接执行alter table 语句。</p>
<blockquote>
<p>如果是在一主一备的情况下，比较理想的是能够在备库先执行。</p>
<p>大致流程是这样的：</p>
<ol>
<li>在备库B上执行 set sql_log_bin=off，也就是不写binlog，然后执行alter table 语句加上索引；</li>
<li>执行主备切换；</li>
<li>这时候主库是B，备库是A。在A上执行 set sql_log_bin=off，然后执行alter table 语句加上索引。</li>
</ol>
</blockquote>
</li>
<li><p><strong>SQL语句没写好；</strong></p>
<p>这时，我们可以通过改写SQL语句来处理。MySQL 5.7提供了query_rewrite功能，可以把输入的一种语句改写成另外一种模式。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> query_rewrite.rewrite_rules(<span class="keyword">pattern</span>, replacement, pattern_database) <span class="keyword">values</span> (&quot;select * from t where id + 1 = ?&quot;, &quot;select * from t where id = ? - 1&quot;, &quot;db1&quot;);</span><br><span class="line"><span class="keyword">call</span> query_rewrite.flush_rewrite_rules();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>MySQL选错了索引；</strong></p>
<p>这时候，应急方案就是<strong>给这个语句加上force index</strong>或者<strong>使用查询重写功能，给原来的语句加上force index</strong></p>
</li>
</ol>
<h3 id="预防方式："><a href="#预防方式：" class="headerlink" title="预防方式："></a>预防方式：</h3><ol>
<li>上线前，在测试环境，把慢查询日志（slow log）打开，并且把long_query_time设置成0，确保每个语句都会被记录入慢查询日志；</li>
<li>在测试表里插入模拟线上的数据，做一遍回归测试；</li>
<li>观察慢查询日志里每类语句的输出，特别留意Rows_examined字段是否与预期一致</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引(二)</title>
    <url>/2023/06/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E7%B4%A2%E5%BC%95-%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="MySQL索引-二"><a href="#MySQL索引-二" class="headerlink" title="MySQL索引(二)"></a>MySQL索引(二)</h1><h2 id="一般索引和唯一索引"><a href="#一般索引和唯一索引" class="headerlink" title="一般索引和唯一索引"></a>一般索引和唯一索引</h2><p>我们来比较一下在不同过程<strong>一般索引</strong>和<strong>唯一索引</strong>的区别。</p>
<h3 id="查询阶段："><a href="#查询阶段：" class="headerlink" title="查询阶段："></a>查询阶段：</h3><p>例如：<code>select id from T where k=5</code>并且要在k上面加索引。</p>
<p><strong>结构为：</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230416151418723.png" alt="image-20230416151418723" style="zoom: 33%;" />

<ul>
<li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，<strong>直到碰到第一个不满足</strong>k=5条件的记录。</li>
<li>对于唯一索引来说，由于索引定义了唯一性，<strong>查找到第一个满足条件的</strong>记录后，就会停止继续检索。</li>
</ul>
<p>但是因为InnoDB的数据是按数据页为单位来读写的，所以<strong>多读几条数据对性能的影响是微乎其微的</strong>（数据在下一页的情况很少很少）。</p>
<h3 id="更新过程："><a href="#更新过程：" class="headerlink" title="更新过程："></a>更新过程：</h3><p>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，需要先了解一下<strong>change buffer</strong>。</p>
<p><strong>change buffer：</strong></p>
<p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个<strong>数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中</strong>，这样就不需要从磁盘中读入这个数据页了。在下次查询<strong>需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作</strong>。</p>
<blockquote>
<p>但是change buffer不适用于更新完马上会做查询的业务场景。</p>
</blockquote>
<p>普通索引和唯一索引下的change buffer：</p>
<ul>
<li>唯一索引因为要判断数据的唯一性，必须将数据读到内存中，这样没必要使用change buffer了。</li>
<li>普通索引更新会使用change buffer，直接将更新记录在change buffer中之后查询在进行merge操作。</li>
</ul>
<blockquote>
<p>change buffer也会持久化到系统表空间（ibdata1）中，以及redo log中也会记录这个语句</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>普通索引和唯一索引应该怎么选择。其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，我建议你尽量选择普通索引。（<strong>因为如果唯一索引更新的数据没有在内存中就需要进行磁盘IO远比change buffer慢</strong>）</p>
<h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>MySQL是支持前缀索引的，也就是说，你可以定义字符串的一部分作为索引。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</p>
<p>比如，这两个在email字段上创建索引的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> index index1(email);</span><br><span class="line">或</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> index index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>
<p><strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p>
<p>实际上，我们在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</p>
<p><strong>前缀索引对覆盖索引的影响</strong></p>
<p>你先来看看这个SQL语句：<code>select id,email from SUser where email=&#39;zhangssxyz@xxx.com&#39;;</code></p>
<p>如果使用index1（即email整个字符串的索引结构）的话，可以利用覆盖索引，从index1查到结果后直接就返回了，不需要回到ID索引再去查一次。而如果使用index2（即email(6)索引结构）的话，就不得不回到ID索引再去判断email字段的值。</p>
<p>也就是说，使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。</p>
<p><strong>遇到前缀的区分度不够好的情况时，我们要怎么办呢？</strong></p>
<ul>
<li><p><strong>第一种方式是使用倒序存储。</strong></p>
<p>如果你存储身份证号的时候把它倒过来存，每次查询的时候：<code>where id_card = reverse(&#39;input_id_card_string&#39;);</code></p>
</li>
<li><p><strong>第二种方式是使用hash字段。</strong></p>
<p>你可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。然后每次插入新记录的时候，都同时用crc32()这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过crc32()函数得到的结果可能是相同的，所以你的查询语句where部分要判断id_card的值是否精确相同。</p>
</li>
</ul>
<blockquote>
<p>两者区别：</p>
<ol>
<li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字段方法需要增加一个字段。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个hash字段也差不多抵消了。</li>
<li>在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash字段的方式需要额外调用一次crc32()函数。如果只从这两个函数的计算复杂度来看的话，reverse函数额外消耗的CPU资源会更小些。</li>
<li>从查询效率上看，使用hash字段方式的查询性能相对更稳定一些。因为crc32算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li>
</ol>
</blockquote>
<h2 id="选错索引问题"><a href="#选错索引问题" class="headerlink" title="选错索引问题"></a>选错索引问题</h2><p>MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。MySQL采样统计：采样统计的时候，InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。所以MySQL优化器也会优化错误。</p>
<p><strong>解决：</strong></p>
<ul>
<li>使用analyze table t 命令进行修正（可以解决大部分问题）。</li>
<li>直接使用force index强行选择一个索引。</li>
<li>我们可以考虑修改语句，引导MySQL使用我们期望的索引</li>
<li>可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。</li>
</ul>
<h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><h3 id="条件字段函数操作"><a href="#条件字段函数操作" class="headerlink" title="条件字段函数操作"></a>条件字段函数操作</h3><p><strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong>到这里我给你说明了，由于加了month()函数操作，MySQL无法再使用索引快速定位功能，而只能使用全索引扫描。</p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>那么，现在这里就有两个问题：</p>
<ol>
<li>数据类型转换的规则是什么？</li>
<li>为什么有数据类型转换，就需要走全索引扫描？</li>
</ol>
<p>就知道对于优化器来说，这个语句相当于：相当于使用了函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where  CAST(tradid AS signed int) &#x3D; 110717;</span><br></pre></td></tr></table></figure>
<p>所以你就能确认MySQL里的转换规则了：在MySQL中，<strong>字符串和数字做比较的话，是将字符串转换成数字。</strong></p>
<h3 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h3><p>例如字符集utf8mb4是utf8的超集，所以当这两个类型的字符串在做比较的时候，MySQL内部的操作是，先把utf8字符串转成utf8mb4字符集，再做比较。所以也相当于使用了函数。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL - 索引</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引</title>
    <url>/2023/06/23/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引模型"><a href="#索引模型" class="headerlink" title="索引模型"></a>索引模型</h2><ul>
<li><p><strong>哈希表</strong></p>
<p>哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。<strong>但是不可避免的就是哈希冲突，常用的是用拉链法</strong>（每个key节点后面拉一个链表）</p>
<p><strong>缺点：</strong>只适用于等值查询的场景</p>
</li>
<li><p><strong>有序数组</strong></p>
<p>一个按照一定顺序排序的数组，<strong>有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong>。</p>
<p><strong>缺点：</strong>只适用于静态存储引擎，因为插入删除效率很低。</p>
</li>
<li><p><strong>搜索树</strong></p>
<p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。为了维持O(log(N))的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))。但是二叉树的存储量太低了，所以一般使用的都是N叉树；例如B树、B+树。</p>
</li>
</ul>
<h2 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h2><p>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为<strong>索引组织表</strong>。又因为前面我们提到的，InnoDB使用了<strong>B+树索引模型</strong>，所以数据都是存储在B+树中的。</p>
<p><strong>例子：</strong></p>
<ul>
<li><p>创表语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> T (</span><br><span class="line">ID <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">k <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">s <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">index k(k))</span><br><span class="line">engine<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>),(<span class="number">200</span>,<span class="number">2</span>,<span class="string">&#x27;bb&#x27;</span>),(<span class="number">300</span>,<span class="number">3</span>,<span class="string">&#x27;cc&#x27;</span>),(<span class="number">500</span>,<span class="number">5</span>,<span class="string">&#x27;ee&#x27;</span>),(<span class="number">600</span>,<span class="number">6</span>,<span class="string">&#x27;ff&#x27;</span>),(<span class="number">700</span>,<span class="number">7</span>,<span class="string">&#x27;gg&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>索引结构：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230414144202021.png" alt="image-20230414144202021"></p>
</li>
<li><p>查询执行流程：<code>select * from T where k between 3 and 5</code></p>
<ul>
<li>在k索引树上找到k=3的记录，取得 ID = 300；</li>
<li>再到ID索引树查到ID=300对应的R3；</li>
<li>在k索引树取下一个值k=5，取得ID=500；</li>
<li>再回到ID索引树查到ID=500对应的R4；(<strong>回表操作</strong>)</li>
<li>在k索引树取下一个值k=6，不满足条件，循环结束。</li>
</ul>
</li>
</ul>
<h2 id="索引特性"><a href="#索引特性" class="headerlink" title="索引特性"></a>索引特性</h2><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p><strong>覆盖索引主要针对与回表操作的优化</strong>，比如上面的操作如果这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。通常使用<strong>联合索引</strong>来实现。</p>
<blockquote>
<p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段</p>
</blockquote>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>B+树这种索引结构，可以利用索引的<strong>“最左前缀”</strong>，来定位记录。不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p>
<p>正是这种原则，可以对索引的安排有所优化。</p>
<ul>
<li><p>如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</p>
<ul>
<li>例如有了(a,b)联合索引，就可以不需要单独建立a索引</li>
</ul>
</li>
<li><p>空间问题：</p>
<ul>
<li>如果a字段比b字段需要更大的空间，可以建立(a,b)联合索引，再单独建立b索引</li>
</ul>
</li>
</ul>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>由于最左前缀原则，最左前缀可以用于在索引中定位记录。但有多个条件时，这个时候MySQL 5.6 引入的<strong>索引下推优化（index condition pushdown)**， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，</strong>减少回表次数**。</p>
<p><strong>例如：</strong>联合索引（a, b）查询语句是<code>select * from t where a = 1 and b=2;</code></p>
<p>这样根据最左前缀原则，会找到所有满足a=1的索引，<strong>如果在MySQL 5.6之前，会获取主键ID回表进行再次对比。但是有了索引下推，就可以不用回表继续对比，不满足直接筛掉</strong>。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL - 索引</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL自增主键</title>
    <url>/2023/07/25/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE/</url>
    <content><![CDATA[<h1 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h1><h2 id="自增值存在哪？"><a href="#自增值存在哪？" class="headerlink" title="自增值存在哪？"></a>自增值存在哪？</h2><p>不同的引擎对于自增值的保存策略不同：</p>
<ul>
<li>MyISAM引擎的自增值保存在数据文件中。</li>
<li>InnoDB引擎的自增值，其实是保存在了内存里（重启重新去找自增值的最大值max(id)），到了MySQL 8.0版本后，才有了“自增值持久化”的能力（将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启之前的值）。</li>
</ul>
<h2 id="自增值修改机制"><a href="#自增值修改机制" class="headerlink" title="自增值修改机制"></a>自增值修改机制</h2><p>在MySQL里面，如果字段id被定义为AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p>
<ol>
<li>如果插入数据时id字段指定为0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT值填到自增字段；</li>
<li>如果插入数据时id字段指定了具体的值，就直接使用语句里指定的值。</li>
</ol>
<p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值是X，当前的自增值是Y。</p>
<ol>
<li>如果X&lt;Y，那么这个表的自增值不变。</li>
<li>如果X≥Y，就需要把当前自增值修改为新的自增值。</li>
</ol>
<blockquote>
<p>其中，auto_increment_offset 和 auto_increment_increment是两个系统参数，分别用来表示自增的初始值和步长，默认值都是1。</p>
</blockquote>
<h2 id="自增值的修改时机"><a href="#自增值的修改时机" class="headerlink" title="自增值的修改时机"></a>自增值的修改时机</h2><p>例如：表t里面已经有了(1,1,1)这条记录并且c有唯一索引，再执行<code>insert into t values(null, 1, 1); </code></p>
<p>这个语句的执行流程就是：</p>
<ol>
<li>执行器调用InnoDB引擎接口写入一行，传入的这一行的值是(0,1,1);</li>
<li>InnoDB发现用户没有指定自增id的值，获取表t当前的自增值2；</li>
<li>将传入的行的值改成(2,1,1);</li>
<li>将表的自增值改成3；</li>
<li>继续执行插入数据操作，由于已经存在c=1的记录，所以报Duplicate key error，语句返回。</li>
</ol>
<blockquote>
<p><strong>主键id不连续的原因</strong></p>
<ul>
<li>唯一键冲突</li>
<li>事务回滚</li>
<li>批量插入后自增值的浪费</li>
</ul>
<p>InnoDB为了性能放弃自增值回退的功能（因为回退需要判断id是否存在、要不就把自增id的锁范围扩大）</p>
</blockquote>
<h2 id="自增锁的优化"><a href="#自增锁的优化" class="headerlink" title="自增锁的优化"></a>自增锁的优化</h2><p>MySQL 5.1.22版本引入了一个新策略，新增参数innodb_autoinc_lock_mode，默认值是1。</p>
<ol>
<li>这个参数的值被设置为0时，表示采用之前MySQL 5.0版本的策略，即语句执行结束后才释放锁；</li>
<li>这个参数的值被设置为1时：<ul>
<li>普通insert语句，自增锁在申请之后就马上释放；</li>
<li>类似insert … select这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li>
</ul>
</li>
<li>这个参数的值被设置为2时，所有的申请自增主键的动作都是申请后就释放锁。</li>
</ol>
<p><strong>在生产上，尤其是有insert … select这种批量插入数据的场景时，从并发插入数据性能的角度考虑，我建议你这样设置：innodb_autoinc_lock_mode=2 ，并且 binlog_format=row</strong>.这样做，既能提升并发性，又不会出现数据一致性问题。</p>
<p><strong>批量插入数据，包含的语句类型是insert … select、replace … select和load data语句。</strong></p>
<blockquote>
<p>但是，在普通的insert语句里面包含多个value值的情况下，即使innodb_autoinc_lock_mode设置为1，也不会等语句执行完成才释放锁。因为这类语句在申请自增id的时候，是可以精确计算出需要多少个id的，然后一次性申请，申请完成后锁就可以释放了。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL - 数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL语句执行过程及count(*)效率问题</title>
    <url>/2023/07/03/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%8F%8Acount-%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="MySQL语句执行过程及count-效率问题"><a href="#MySQL语句执行过程及count-效率问题" class="headerlink" title="MySQL语句执行过程及count(*)效率问题"></a>MySQL语句执行过程及count(*)效率问题</h1><h2 id="SQL的执行过程"><a href="#SQL的执行过程" class="headerlink" title="SQL的执行过程"></a>SQL的执行过程</h2><p>下面我给出的是MySQL的基本架构示意图，并且清楚的展示了SQL语句的<strong>执行过程：</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230412141059794.png" alt="image-20230412141059794" style="zoom:67%;" />

<ul>
<li><code>连接器：</code>连接器负责跟客户端<strong>建立连接、获取权限、维持和管理连接</strong>。客户端如果太长时间没动静，连接器就会自动将它断开。</li>
<li><code>查询缓存：</code>将之前查询的结构进行缓存，key是查询语句。但是MySQL 8.0版本直接将查询缓存的整块功能删掉了。</li>
<li><code>分析器：</code>对SQL语句先进行<strong>词法分析</strong>再进行<strong>语法分析</strong>。</li>
<li><code>优化器：</code>会对语句进行优化判断。</li>
<li><code>执行器：</code>先校验权限，如果校验通过就会根据表的引擎定义，去使用这个引擎提供的接口，最后将结果组成结果集返回给客户端。</li>
</ul>
<h2 id="count-这么慢"><a href="#count-这么慢" class="headerlink" title="count(*)这么慢"></a>count(*)这么慢</h2><p>你首先要明确的是，在不同的MySQL引擎中，count(*)有不同的<strong>实现方式：</strong></p>
<ul>
<li><strong>MyISAM引擎</strong>把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高；</li>
<li>而<strong>InnoDB引擎</strong>就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li>
</ul>
<blockquote>
<p>由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的</p>
</blockquote>
<p>按照效率排序的话，<code>count(字段)&lt;count(主键id)&lt;count(1)≈count(*)</code>，所以我建议你，尽量使用<code>count(*)</code>。</p>
<p><strong>其他方式：</strong></p>
<ol>
<li><p><strong>用缓存系统保存计数</strong></p>
<p>在并发系统里面，我们是无法精确控制不同线程的执行时刻的，因为存在图中的这种操作序列，所以，我们说即使Redis正常工作，这个计数值还是逻辑上不精确的。</p>
</li>
<li><p><strong>在数据库保存计数</strong></p>
<p>把这个计数直接放到数据库里单独的一张计数表C中，并利用利用“事务”这个特性把问题解决掉。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL误删数据怎么办</title>
    <url>/2023/07/19/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    <content><![CDATA[<h1 id="误删数据怎么办"><a href="#误删数据怎么办" class="headerlink" title="误删数据怎么办"></a>误删数据怎么办</h1><h2 id="误删行"><a href="#误删行" class="headerlink" title="误删行"></a>误删行</h2><p>如果是使用delete语句误删了数据行，可以用Flashback工具通过闪回把数据恢复回来。</p>
<blockquote>
<p>Flashback恢复数据的原理，是修改binlog的内容，拿回原库重放。而能够使用这个方案的前提是，需要确保binlog_format=row 和 binlog_row_image=FULL。</p>
</blockquote>
<p><strong>需要说明的是，我不建议你直接在主库上执行这些操作。</strong></p>
<p>恢复数据比较安全的做法，是恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执行这些操作，然后再将确认过的临时库的数据，恢复回主库。这是因为，一个在执行线上逻辑的主库，数据状态的变更往往是有关联的。可能由于发现数据问题的时间晚了一点儿，就导致已经在之前误操作的基础上，业务代码逻辑又继续修改了其他数据。所以，如果这时候单独恢复这几行数据，而又未经确认的话，就可能会出现对数据的二次破坏。</p>
<h3 id="事前预防"><a href="#事前预防" class="headerlink" title="事前预防"></a>事前预防</h3><ol>
<li>把sql_safe_updates参数设置为on。这样一来，如果我们忘记在delete或者update语句中写where条件，或者where条件里面没有包含索引字段的话，这条语句的执行就会报错。</li>
<li>代码上线前，必须经过SQL审计。</li>
</ol>
<h2 id="误删库-表"><a href="#误删库-表" class="headerlink" title="误删库/表"></a>误删库/表</h2><p>这种情况下，要想恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有定期的全量备份，并且实时备份binlog。</p>
<p>在这两个条件都具备的情况下，假如有人中午12点误删了一个库，恢复数据的流程如下：</p>
<ol>
<li>取最近一次全量备份，假设这个库是一天一备，上次备份是当天0点；</li>
<li>用备份恢复出一个临时库；</li>
<li>从日志备份里面，取出凌晨0点之后的日志；</li>
<li>把这些日志，除了误删除数据的语句外，全部应用到临时库。</li>
</ol>
<blockquote>
<p>说明如下几点：</p>
<ol>
<li>为了加速数据恢复，如果这个临时库上有多个数据库，你可以在使用mysqlbinlog命令时，加上一个–database参数，用来指定误删表所在的库。这样，就避免了在恢复数据时还要应用其他库日志的情况。</li>
<li>在应用日志的时候，需要跳过12点误操作的那个语句的binlog：<ul>
<li>如果原实例没有使用GTID模式，只能在应用到包含12点的binlog文件的时候，先用–stop-position参数执行到误操作之前的日志，然后再用–start-position从误操作之后的日志继续执行；</li>
<li>如果实例使用了GTID模式，就方便多了。假设误操作命令的GTID是gtid1，那么只需要执行set gtid_next=gtid1;begin;commit; 先把这个GTID加到临时实例的GTID集合，之后按顺序执行binlog的时候，就会自动跳过误操作的语句。</li>
</ul>
</li>
</ol>
</blockquote>
<p><strong>一种加速的方法是，</strong>在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库，这样：</p>
<ol>
<li>在start slave之前，先通过执行﻿change replication filter replicate_do_table = (tbl_name) 命令，就可以让临时库只同步误操作的表；</li>
<li>这样做也可以用上并行复制技术，来加速整个数据恢复过程。</li>
</ol>
<p><strong>第二种加速方法是：延迟复制备库</strong></p>
<p>延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TO MASTER_DELAY = N命令，可以指定这个备库持续保持跟主库有N秒的延迟。</p>
<p>比如你把N设置为3600，这就代表了如果主库上有数据被误删了，并且在1小时内发现了这个误操作命令，这个命令就还没有在这个延迟复制的备库执行。这时候到这个备库上执行stop slave，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。</p>
<h3 id="预防方法："><a href="#预防方法：" class="headerlink" title="预防方法："></a>预防方法：</h3><p>第一条建议是，账号分离。这样做的目的是，避免写错命令。比如：</p>
<ul>
<li>我们只给业务开发同学DML权限，而不给truncate/drop权限。而如果业务开发人员有DDL需求的话，也可以通过开发管理系统得到支持。</li>
<li>即使是DBA团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。</li>
</ul>
<p>第二条建议是，制定操作规范。这样做的目的，是避免写错要删除的表名。比如：</p>
<ul>
<li>在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。</li>
<li>改表名的时候，要求给表名加固定的后缀（比如加_to_be_deleted)，然后删除表的动作必须通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表。</li>
</ul>
<h2 id="rm命令误删整个MySQL实例"><a href="#rm命令误删整个MySQL实例" class="headerlink" title="rm命令误删整个MySQL实例"></a>rm命令误删整个MySQL实例</h2><p>其实，对于一个有高可用机制的MySQL集群来说，最不怕的就是rm删除数据了。只要不是恶意地把整个集群删除，而只是删掉了其中某一个节点的数据的话，HA系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作。</p>
<p>这时，你要做的就是在这个节点上把数据恢复回来，再接入整个集群。</p>
<p>当然了，现在不止是DBA有自动化系统，SA（系统管理员）也有自动化系统，所以也许一个批量下线机器的操作，会让你整个MySQL集群的所有节点都全军覆没。应对这种情况，我的建议只能是说尽量把你的备份跨机房，或者最好是跨城市保存。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL锁</title>
    <url>/2023/06/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E9%94%81/</url>
    <content><![CDATA[<h1 id="MySQL中的锁"><a href="#MySQL中的锁" class="headerlink" title="MySQL中的锁"></a>MySQL中的锁</h1><p>根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类。</p>
<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>全局锁是对整个数据库实例加锁。加了这个锁之后整个数据库都处于只读状态。通过<code>Flush tables with read lock</code>开启。</p>
<p>之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
<p>全局锁的典型使用场景是：<strong>做全库逻辑备份。</strong></p>
<p><strong>危害：</strong></p>
<ul>
<li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li>
<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</li>
</ul>
<p><strong>解决方案（但是仅限于使用事务的引擎，如InnoDB引擎）：</strong></p>
<p>所以官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。</p>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>使用的语法是<code>lock tables … read/write</code>可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。</p>
<p>这个表锁有个特点：<strong>除了会限制别的线程读写之外，还会限制本线程也只能进行加了锁的操作</strong>；例如加了read锁之后只能进行读。</p>
<h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>**MDL（metadata lock)**，元数据锁同样分为读锁和写锁。当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。（这个锁是系统默认加上的）</p>
<ul>
<li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li>
</ul>
<p><strong>如何安全地给小表加字段？</strong></p>
<ul>
<li><p>首先我们要解决长事务，事务不提交，就会一直占着MDL锁。在MySQL的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。</p>
</li>
<li><p>给DDL加等待时间：<code>ALTER TABLE tbl_name NOWAIT add column ...</code>或<code>ALTER TABLE tbl_name WAIT N add column ... </code></p>
</li>
</ul>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>MySQL的行锁是在引擎层由各个引擎自己实现的；InnoDB是支持行锁的。</p>
<p><strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p>
<ul>
<li>所要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放</li>
</ul>
<blockquote>
<p>在解决幻读问题时，会引入间<strong>隙锁（Gap Locks）</strong>以及<strong>临键锁（Next-Key Locks）</strong>。</p>
</blockquote>
<h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p><strong>MySQL对于死锁有两种基本策略：</strong></p>
<ul>
<li><p>一种策略是：</p>
<p>直接进入等待，直到超时。这个超时时间可以通过参innodb_lock_wait_timeout来设置。但是这种策略时间很难控制。</p>
</li>
<li><p>另一种策略是：</p>
<p>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。但是会带来额外的负担。</p>
</li>
</ul>
<blockquote>
<p><strong>其余方法：</strong></p>
<ul>
<li>进行并发控制限流</li>
<li>也可以把其中一个记录进行拆分，这样减少了冲突的概率。例如电影院账户总额分为10条记录，有人买票了随机挑一条记录加上。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL - 锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql数据库表的空间回收</title>
    <url>/2023/06/17/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h1 id="数据库表的空间回收"><a href="#数据库表的空间回收" class="headerlink" title="数据库表的空间回收"></a>数据库表的空间回收</h1><h2 id="为什么简单地删除表数据达不到表空间回收的效果？"><a href="#为什么简单地删除表数据达不到表空间回收的效果？" class="headerlink" title="为什么简单地删除表数据达不到表空间回收的效果？"></a>为什么简单地删除表数据达不到表空间回收的效果？</h2><p>首先讲一下<strong>参数innodb_file_per_table</strong>，表数据既可以存在共享表空间里（调为OFF），也可以是单独的文件（调为ON）。</p>
<blockquote>
<p>我建议你不论使用MySQL的哪个版本，都将这个值设置为ON。因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过drop table命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</p>
</blockquote>
<p>InnoDB里的数据都是用<strong>B+树的结构组织的</strong>。如果删除数据，InnoDB引擎只会把这个记录<strong>标记为删除</strong>。可能会复用这个位置。但是，磁盘文件的大小并不会缩小。</p>
<p>现在，你已经知道了InnoDB的数据是按页存储的，那么如果我们删掉了一个数据页上的所有记录，会怎么样？</p>
<p><strong>答案是</strong>：整个数据页就可以被复用了。</p>
<p>通过delete命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。实际上，<strong>不止是删除数据会造成空洞，插入数据也会。</strong>（<strong>随机插入会导致，尽量保证索引递增</strong>）</p>
<p><strong>解决方法：</strong></p>
<p>可以使用alter table A engine=InnoDB命令来重建表。在MySQL 5.5版本之前这个命令就是重新建表移植数据，如果有新的数据就会造成数据丢失。</p>
<p>而在<strong>MySQL 5.6版本开始引入的Online DDL，对这个操作流程做了优化。</strong></p>
<h2 id="Online-DDL重建表的流程："><a href="#Online-DDL重建表的流程：" class="headerlink" title="Online DDL重建表的流程："></a>Online DDL重建表的流程：</h2><ol>
<li>建立一个临时文件，扫描表A主键的所有数据页；</li>
<li>用数据页中表A的记录生成B+树，存储到临时文件中；</li>
<li>生成临时文件的过程中，将所有对A的操作记录在一个日志文件（row log）中，对应的是图中state2的状态；</li>
<li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的数据文件，对应的就是图中state3的状态；</li>
<li>用临时文件替换表A的数据文件。</li>
</ol>
<p>上述流程中，alter语句在启动的时候需要获取<strong>MDL写锁</strong>，但是这个写锁在真正拷贝数据之前就退化成读锁了。因为不会阻塞增删改操作并且为了保护自己，禁止其他线程对这个表同时做DDL。</p>
<p><strong>Online 和 inplace</strong></p>
<p>整个DDL过程都在InnoDB内部完成。对于server层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“inplace”名称的来源。</p>
<p>如果说这两个逻辑之间的关系是什么的话，可以概括为：</p>
<ol>
<li>DDL过程如果是Online的，就一定是inplace的；</li>
<li>反过来未必，也就是说inplace的DDL，有可能不是Online的。截止到MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引(SPATIAL index)就属于这种情况。</li>
</ol>
<blockquote>
<p>optimize table、analyze table和alter table这三种方式重建表的区别：</p>
<ul>
<li>从MySQL 5.6版本开始，alter table t engine = InnoDB（也就是recreate）默认的就是上面图4的流程了；</li>
<li>analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL读锁；</li>
<li>optimize table t 等于recreate+analyze。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL - 数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>RedoLog刷脏页</title>
    <url>/2023/06/19/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/RedoLog%E5%88%B7%E8%84%8F%E9%A1%B5/</url>
    <content><![CDATA[<h4 id="RedoLog刷脏页"><a href="#RedoLog刷脏页" class="headerlink" title="RedoLog刷脏页"></a>RedoLog刷脏页</h4><p>你不难想象，平时执行很快的更新操作，其实就是在写内存和日志，而MySQL偶尔“抖”一下的那个瞬间，可能就是在<strong>刷脏页（flush）</strong>。</p>
<p><strong>什么情况会引发数据库的flush过程呢？</strong></p>
<ol>
<li><p>就是<strong>InnoDB的redo log写满了</strong>。这时候系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。我在第二讲画了一个redo log的示意图，这里我改成环形，便于大家理解。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230307214344823.png" alt="image-20230307214344823" style="zoom:33%;" />

<blockquote>
<p>checkpoint可不是随便往前修改一下位置就可以的。比如图2中，把checkpoint位置从CP推进到CP’，就需要将两个点之间的日志（浅绿色部分），对应的所有脏页都flush到磁盘上。之后，图中从write pos到CP’之间就是可以再写入的redo log的区域。</p>
</blockquote>
</li>
<li><p>就是<strong>系统内存不足</strong>。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。</p>
</li>
<li><p>就是MySQL认为<strong>系统“空闲”的时候</strong>。</p>
</li>
<li><p>就是<strong>MySQL正常关闭的情况</strong>。这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p>
</li>
</ol>
<p><strong>第一种是</strong>redo log写满了，要flush脏页”，这种情况是InnoDB要尽量避免的。因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为0。</p>
<p><strong>第二种是</strong>内存不够用了，要先将脏页写到磁盘”，这种情况其实是常态。但是一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长。</p>
<blockquote>
<p><strong>我们再看一个有趣的策略：</strong><br>一旦一个查询请求需要在执行过程中先flush掉一个脏页时，这个查询就可能要比平时慢了。而MySQL中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。</p>
<p><strong>在InnoDB中，innodb_flush_neighbors 参数就是用来控制这个行为的;而如果使用的是SSD这类IOPS比较高的设备的话，我就建议你把innodb_flush_neighbors的值设置成0。因为这时候IOPS往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷脏页操作，减少SQL语句响应时间。</strong></p>
<p><strong>在MySQL 8.0中，innodb_flush_neighbors参数的默认值已经是0了。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>日志的写入机制</title>
    <url>/2023/06/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E6%97%A5%E5%BF%97%E7%9A%84%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="日志的写入机制"><a href="#日志的写入机制" class="headerlink" title="日志的写入机制"></a>日志的写入机制</h1><h2 id="binlog的写入机制"><a href="#binlog的写入机制" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h2><p>binlog的写入逻辑比较简单：</p>
<ol>
<li>事务执行过程中，先把日志写到binlog cache，</li>
<li>事务提交的时候，再把binlog cache写到binlog文件中。</li>
</ol>
<p>系统给binlog cache分配了一片内存，每个线程一个，参数 <strong>binlog_cache_size</strong>用于控制单个线程内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230319142954431.png" alt="image-20230319142954431"></p>
<blockquote>
<p>write 和fsync的时机，是由参数<strong>sync_binlog</strong>控制的：</p>
<ol>
<li><strong>sync_binlog=0</strong>：表示每次提交事务都只write，不fsync；(一般不建议将这个参数设成0，比较常见的是将其设置为100~1000中的某个数值。)</li>
<li><strong>sync_binlog=1</strong>：表示每次提交事务都会执行fsync；</li>
<li>**sync_binlog=N(N&gt;1)**：表示每次提交事务都write，但累积N个事务后才fsync。(对应的风险是：如果主机发生异常重启，会丢失最近N个事务的binlog日志。)</li>
</ol>
</blockquote>
<h2 id="redo-log的写入机制"><a href="#redo-log的写入机制" class="headerlink" title="redo log的写入机制"></a>redo log的写入机制</h2><p>redo log可能存在的<strong>三种状态</strong>说起：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230319143539792.png" alt="image-20230319143539792"  />

<ol>
<li>存在redo log buffer中，物理上是在MySQL进程内存中，就是图中的红色部分；</li>
<li>写到<strong>磁盘(write)**，但是没有</strong>持久化（fsync)**，物理上是在文件系统的page cache里面，也就是图中的黄色部分；</li>
<li>持久化到磁盘，对应的是hard disk，也就是图中的绿色部分。</li>
</ol>
<blockquote>
<p>日志写到redo log buffer是很快的，wirte到page cache也差不多，但是持久化到磁盘的速度就慢多了。</p>
<p>为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，它有三种可能取值：</p>
<ol>
<li>设置为0：表示每次事务提交时都只是把redo log留在redo log buffer中;</li>
<li>设置为1：表示每次事务提交时都将redo log直接持久化到磁盘；</li>
<li>设置为2：表示每次事务提交时都只是把redo log写到page cache。</li>
</ol>
</blockquote>
<p>InnoDB有一个后台线程，每隔1秒，就会把redo log buffer中的日志，调用write写到文件系统的page cache，然后调用fsync持久化到磁盘。</p>
<p>实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的redo log写入到磁盘中。</p>
<ol>
<li><strong>一种是，redo log buffer占用的空间即将达到 innodb_log_buffer_size一半的时候，后台线程会主动写盘。</strong></li>
<li><strong>另一种是，并行的事务提交的时候，顺带将这个事务的redo log buffer持久化到磁盘。</strong></li>
</ol>
<h2 id="组提交（group-commit）机制："><a href="#组提交（group-commit）机制：" class="headerlink" title="组提交（group commit）机制："></a>组提交（group commit）机制：</h2><p>我需要先和你介绍日志逻辑序列号（log sequence number，LSN）的概念。LSN是单调递增的，用来对应redo log的一个个写入点。每次写入长度为length的redo log， LSN的值就会加上length。</p>
<p>一次组提交里面，<strong>组员越多，节约磁盘IOPS的效果越好</strong>。所以为了让一次fsync带的组员更多，MySQL有一个很有趣的优化：拖时间。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230319151324064.png" alt="image-20230319151324064" style="zoom:67%;" />

<blockquote>
<p>不过通常情况下第3步执行得会很快，所以binlog的write和fsync间的间隔时间短，导致能集合到一起持久化的binlog比较少，因此binlog的组提交的效果通常不如redo log的效果那么好。</p>
<p>如果你想提升binlog组提交的效果，可以通过设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count来实现。</p>
<ol>
<li>binlog_group_commit_sync_delay参数，表示延迟多少微秒后才调用fsync;</li>
<li>binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync。</li>
</ol>
</blockquote>
<p><strong>如果你的MySQL现在出现了性能瓶颈，而且瓶颈在IO上，可以通过哪些方法来提升性能呢？</strong></p>
<p>针对这个问题，可以考虑以下三种方法：</p>
<ol>
<li>设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count参数，减少binlog的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li>
<li>将sync_binlog 设置为大于1的值（比较常见是100~1000）。这样做的风险是，主机掉电时会丢binlog日志。</li>
<li>将innodb_flush_log_at_trx_commit设置为2。这样做的风险是，主机掉电的时候会丢数据。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL - 日志</tag>
      </tags>
  </entry>
  <entry>
    <title>BASE理论</title>
    <url>/2023/10/19/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/BASE%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>BASE理论是与ACID（原子性、一致性、隔离性、持久性）相对立的另一种分布式系统设计原则。BASE是一种更灵活的一致性模型，通常用于分布式系统中，特别是在面对高可用性和分区容错性的要求时。BASE代表以下三个属性：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230919152133467.png" alt="image-20230919152133467" style="zoom: 33%;" />

<h2 id="理论详解"><a href="#理论详解" class="headerlink" title="理论详解"></a>理论详解</h2><ol>
<li><strong>基本可用性（Basic Availability）</strong>：这意味着系统在发生故障或分区时仍然能够提供基本的可用性。基本可用性不一定保证一致性或完全正常的性能，但它确保了系统在某些情况下仍然能够提供服务。</li>
<li><strong>软状态（Soft State）</strong>：在BASE模型中，系统的状态可以在一段时间内是不一致的，但最终会趋向于一致状态。这意味着系统中的数据可以在不同节点上存在短暂的不一致性，但最终会在时间的推移下趋于一致。</li>
<li><strong>最终一致性（Eventual Consistency）</strong>：最终一致性是BASE模型的核心思想，它指的是分布式系统中的数据最终会达到一致状态，但不保证在任何时间点都是强一致的。最终一致性允许系统在一段时间内存在不一致，但最终会在没有新的更新时达到一致状态。</li>
</ol>
<p>BASE理论的核心思想是在某些情况下，为了保证高可用性和容错性，可以<strong>牺牲强一致性</strong>。这在一些互联网应用中是有用的，因为它允许系统在发生故障或网络分区时仍然继续提供服务。然后，系统可以在之后的时间内通过异步或后台进程来实现<strong>最终一致性</strong>。</p>
<blockquote>
<p><strong>BASE理论</strong>可以看作是对<strong>CAP定理</strong>的一种实际应用和实践指导。</p>
</blockquote>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>BASE理论</tag>
      </tags>
  </entry>
  <entry>
    <title>池化技术</title>
    <url>/2023/12/14/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h1><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>数据库的调用方式是先获取数据库的连接，然后依靠这条连接从数据库中查询数据，最后关闭连接释放数据库资源。这种调用方式下，每次执行 SQL 都需要重新建立连接，<strong>频繁地建立数据库连接是很耗费时间的</strong>。</p>
<p>这个时候就需要用到<strong>池化技术</strong>：建立数据库连接池。</p>
<p>数据库连接池有两个最重要的配置：<strong>最小连接数和最大连接数</strong></p>
<ul>
<li>最小连接数：是连接池一直保持的数据库连接</li>
<li>最大连接数：是连接池能申请的最大连接数</li>
</ul>
<h3 id="从连接池中获取连接的相关策略："><a href="#从连接池中获取连接的相关策略：" class="headerlink" title="从连接池中获取连接的相关策略："></a>从连接池中获取连接的相关策略：</h3><ul>
<li>如果当前连接数小于最小连接数，则创建新的连接处理数据库请求，保证池中的最小连接数；</li>
<li>如果当前连接数大于最小连接数小于最大连接数<ul>
<li>如果连接池中有空闲连接则复用空闲连接；</li>
<li>没有则创建新的连接处理请求；</li>
</ul>
</li>
<li>如果当前连接数已经大于等于最大连接数，则按照配置中设定的时间（C3P0 的连接池配置是 checkoutTimeout）等待旧的连接可用<ul>
<li>如果等待超过了这个设定时间则向用户抛出错误。</li>
</ul>
</li>
</ul>
<h3 id="会遇到的问题："><a href="#会遇到的问题：" class="headerlink" title="会遇到的问题："></a>会遇到的问题：</h3><p>连接断开问题：</p>
<ul>
<li>数据库的域名对应的 IP 发生了变更，池子的连接还是使用旧的 IP。</li>
<li>MySQL 有个参数是“wait_timeout”，控制着当数据库连接闲置多长时间后，数据库会主动地关闭这条连接。</li>
</ul>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ul>
<li><p>进行定期检测连接问题：</p>
<p>启动一个线程来定期检测连接池中的连接是否可用，比如使用连接发送“select 1”的命令给数据库看是否会抛出异常，如果抛出异常则将这个连接从连接池中移除，并且尝试关闭。（目前 C3P0 连接池可以采用这种方式来检测连接是否可用，也是比较推荐的）</p>
</li>
<li><p>在使用连接上进行校验，可用再执行SQL（比如 DBCP 连接池的 testOnBorrow 配置项）。</p>
</li>
</ul>
<blockquote>
<p>一般在线上建议最小连接数控制在 10 左右，最大连接数控制在 20～30 左右即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>数据库优化</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>池化技术</tag>
      </tags>
  </entry>
  <entry>
    <title>CAP定理</title>
    <url>/2023/10/22/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/CAP%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h1 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>CAP定理是分布式计算领域的一个重要理论，它描述了在一个分布式系统中，三个关键属性之间的权衡关系。一致性（Consistency）、可用性（Availability）、分区容忍性（Partition Tolerance）。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230909102414658.png" alt="image-20230909102414658" style="zoom:67%;" />

<h2 id="定理详解"><a href="#定理详解" class="headerlink" title="定理详解"></a>定理详解</h2><ol>
<li><strong>一致性（Consistency）</strong>：一致性要求所有参与分布式系统的节点在任何时刻都看到相同的数据副本，即数据的更新必须在所有节点上都是可见的。这意味着在写操作完成后，所有读操作都应该能够立即看到最新的数据。</li>
<li><strong>可用性（Availability）</strong>：可用性要求系统在任何时刻都能够响应客户端的请求，即系统不会因为部分故障而完全失效。高可用性意味着系统能够继续提供服务，即使某些节点或组件出现故障。</li>
<li><strong>分区容忍性（Partition Tolerance）</strong>：分区容忍性是指系统能够在网络分区或通信故障的情况下继续正常运行。网络分区是指分布式系统中的节点之间的通信被断开或延迟，但系统仍然需要继续工作。</li>
</ol>
<p>CAP定理的三种典型组合是：</p>
<ol>
<li><p><strong>CA（一致性和可用性）</strong>：在这种情况下，系统会牺牲分区容忍性，即当发生网络分区时，系统可能会停止工作，以确保数据的一致性和可用性。</p>
<blockquote>
<p>能够保证CA的环境只有在单机环境下保证。</p>
</blockquote>
</li>
<li><p><strong>CP（一致性和分区容忍性）</strong>：在这种情况下，系统会牺牲可用性，即当发生网络分区时，系统可能会停止接受新的请求，以确保数据的一致性和分区容忍性。</p>
</li>
<li><p><strong>AP（可用性和分区容忍性）</strong>：在这种情况下，系统会牺牲一致性，即当发生网络分区时，系统仍然会响应请求，但可能会提供不一致的数据。</p>
<blockquote>
<p>在分布式集群环境下，分区容忍性是必须要保证的即多副本来保证；正是因为这个多副本的缘故引发了副本数据一致性问题，又区分出了CP和AP，如果要保证一致性就得牺牲可用性（大部分都是AP，因为CP强一致性会阻塞请求）。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>CAP定理</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据异构同步方案</title>
    <url>/2023/10/23/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/MySQL%E6%95%B0%E6%8D%AE%E5%BC%82%E6%9E%84%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="MySQL数据异构同步"><a href="#MySQL数据异构同步" class="headerlink" title="MySQL数据异构同步"></a>MySQL数据异构同步</h1><h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p>MySQL数据异构同步是将数据从一个MySQL数据库复制到另一个不同结构数据库（如Elasticsearch等），但这两个数据库可能具有不同的架构、结构或配置的过程。</p>
<p>总之，MySQL数据异构同步是一项复杂的任务，涉及多个概念和技术，旨在确保数据在不同的MySQL数据库之间正确、高效和安全地复制和同步。</p>
<h2 id="传统做法"><a href="#传统做法" class="headerlink" title="传统做法"></a>传统做法</h2><p>直接在对MySQL数据更新的时候就调用其他团队的接口进行同步：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230913101815476.png" alt="image-20230913101815476"></p>
<p>缺点：</p>
<ul>
<li>团队之间强耦合</li>
<li>团队开发成本高，还需要了解其他团队的接口规范</li>
</ul>
<h2 id="推荐做法"><a href="#推荐做法" class="headerlink" title="推荐做法"></a>推荐做法</h2><p>使用 Canal（阿里巴巴开源的数据库变更数据捕获组件）可以实现 MySQL 数据异构同步。</p>
<p>Canal能够监控 MySQL 数据库的变更，捕获INSERT、UPDATE、DELETE等操作，并将这些变更数据传递给目标数据库或其他系统。</p>
<p><strong>实现流程：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230913102150047.png" alt="image-20230913102150047"></p>
<ol>
<li>使用Canal对MySQL数据变更进行监听</li>
<li>将变更数据发送到消息队列中</li>
<li>对应的异构数据库订阅消息队列</li>
<li>一旦有消息就根据变更数据执行相应逻辑</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li>增强数据同步和处理的效率</li>
<li>大大对团队之间工作进行解耦</li>
<li>增强了架构的可伸缩性和灵活性</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>异构同步</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式一致性算法</title>
    <url>/2023/11/04/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="分布式一致性算法"><a href="#分布式一致性算法" class="headerlink" title="分布式一致性算法"></a>分布式一致性算法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>分布式一致性算法是一组用于确保分布式系统中数据一致性的算法。这些算法旨在解决多个节点之间的数据同步和一致性问题，以确保在分布式环境中的各个节点上的数据副本保持一致。</p>
<p>一些常见的分布式一致性算法包括：</p>
<ol>
<li><strong>Paxos算法</strong>：Paxos算法是一种经典的分布式一致性算法，用于确保在网络中多个节点之间达成一致性协议。</li>
<li><strong>Raft算法</strong>：Raft算法是另一种用于分布式一致性的算法，它的设计更加容易理解和实现，适用于构建可靠的分布式系统。</li>
<li><strong>ZAB 算法：</strong>ZAB（ZooKeeper Atomic Broadcast）选举算法是为 ZooKeeper 实现分布式协调功能而设计的。</li>
<li><strong>Gossip算法：</strong>Gossip算法，是一种分布式计算中常用的算法，它用于在一个分布式系统中传播信息或数据，以实现数据的一致性和同步。</li>
</ol>
<h2 id="算法简单介绍"><a href="#算法简单介绍" class="headerlink" title="算法简单介绍"></a>算法简单介绍</h2><h3 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h3><p>Paxos算法是一种分布式一致性算法，用于在分布式系统中达成一致的共识。它是由Leslie Lamport于1990年提出的，被认为是分布式系统领域的经典算法之一。Paxos算法的主要目标是允许多个节点在面对故障和网络延迟的情况下，达成共识，确保数据的一致性；Paxos算法的核心思想是<strong>通过多轮的消息传递和投票来达成共识</strong>。</p>
<p><strong>关键概念：</strong></p>
<ol>
<li><strong>提议者（Proposers）</strong>：提议者是试图向系统提交一个值的节点。每个提议者会生成一个提案（Proposal），其中包含一个提案号（Proposal Number）和一个值。提案号是唯一  标识提案的，通常包括一个提议者的标识符和一个递增的序号。</li>
<li><strong>学习者（Learners）</strong>：学习者是节点，它们等待系统中的大多数节点接受相同的提案，以达成共识。一旦学习者确定了共识值，它们就会学到这个值，即<strong>状态转移过程</strong>。</li>
<li><strong>接受者（Acceptors）</strong>：接受者是节点，它们用来接受提议并投票是否接受提案。每个接受者可以接受一个提案，并在接受提案后通知其他节点。接受者可以有不同的投票策略，但通常<strong>选择接受具有最高提案号的提案。</strong></li>
</ol>
<p><strong>基本流程：</strong></p>
<ul>
<li>准备阶段：<ol>
<li>提议者选择一个唯一的提案号，并向接受者发送一个准备请求（Prepare Request）包含该提案号。</li>
<li>每个接受者比较提案号，如果接受者之前已经回应过更高提案号的准备请求，则拒绝请求。否则，接受者返回一个承诺不再接受低于该提案号的提案，并返回之前已经接受的提案（如果有的话）。</li>
<li>提议者收到多数接受者的承诺后，进入下一阶段。</li>
</ol>
</li>
<li>提议阶段：<ol>
<li>提议者向多数接受者发送一个提案请求（Accept Request），包含提案号和值。</li>
<li>每个接受者检查提案号是否是它之前承诺的最高提案号，如果是，则接受提案，并将提案号和值广播给其他节点。</li>
<li>学习者在收到<strong>多数节点（一半以上）</strong>的接受消息后，确定了共识值。</li>
</ol>
</li>
</ul>
<p><strong>优点：</strong></p>
<ol>
<li><strong>一致性保证</strong>：Paxos算法能够确保在分布式系统中的所有节点之间达成一致性，即使在面临网络故障和节点故障的情况下也能够保持一致。</li>
<li><strong>容错性</strong>：Paxos是一种具有强容错性的算法，可以处理节点故障、消息丢失等异常情况，保证系统的可用性和一致性。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><strong>复杂性</strong>：Paxos算法的实现和理解相对复杂，它包括多个阶段和消息交互，需要谨慎设计和调试，容易出现错误。</li>
<li><strong>性能开销</strong>：Paxos算法在某些情况下（因为消息交互次数多）可能会引入较大的性能开销，特别是在网络通信和消息传递方面，可能导致延迟增加。</li>
</ol>
<h3 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h3><p>Raft算法是一种用于分布式一致性的算法，类似于Paxos，但它旨在更易于理解和实现。Raft算法由Diego Ongaro和John Ousterhout于2013年提出，并已成为分布式系统中常用的共识算法之一，尤其在分布式数据库和分布式存储系统中得到广泛应用。</p>
<p>Raft算法的设计目标是提供更直观的分布式一致性解决方案，通过将问题分解为可管理的部分，使得算法更容易理解和实现。</p>
<p><strong>关键概念：</strong></p>
<ol>
<li>领导者（Leader）：领导者是Raft算法中的核心节点，主要负责日志复制、心跳检测等工作。</li>
<li>跟随者（Follower）：跟随者是Raft算法中的被动节点，只响应来自领导者和候选者的消息。</li>
<li>候选者（Candidate）：候选者是Raft算法中的中间状态，用于领导者选举过程。</li>
</ol>
<p><strong>步骤：</strong></p>
<ol>
<li><p><strong>领导者选举</strong>：</p>
<ul>
<li>在一个Raft集群中，只有领导者可以接受客户端的请求并将其复制到日志中。</li>
<li>领导者选举使用<strong>随机化的定时器</strong>和<strong>心跳机制</strong>来实现。候选者节点发起选举，并需要获得多数节点的支持才能成为领导者。</li>
</ul>
<blockquote>
<p>超时机制（随机）：因为随机可以规避多领导者竞选</p>
<ul>
<li>Follower等待心跳超时</li>
<li>等待选举投票超时</li>
</ul>
<p>投票规则：</p>
<ul>
<li>term大的成员拒绝投票给term小的RequestVote消息。</li>
<li>最后一条日志项编号大的拒绝投票给最后一条日志项编号小的成员。</li>
<li>每个成员，一届term任期内只投出一张选票，先来先获得投票。</li>
</ul>
</blockquote>
</li>
<li><p><strong>日志复制</strong>：日志项是连续的</p>
<ul>
<li>领导者负责将客户端的操作添加到日志中，并将日志复制到其他节点。这确保了所有节点都具有相同的操作序列。</li>
<li>跟随者节点在接收到领导者的日志条目后，将其附加到本地日志。</li>
</ul>
</li>
<li><p><strong>安全性</strong>：</p>
<ul>
<li>Raft算法使用严格的一致性模型，确保只有领导者可以接受客户端的请求，这样避免了分布式系统中的多个领导者问题。</li>
<li>安全性还包括数据持久性，即数据在节点故障时不会丢失。Raft要求领导者在接收请求后必须等待<strong>大多数节点</strong>的确认后才能提交日志条目。</li>
</ul>
</li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li>简单性：Raft的设计目标之一是提供更容易理解和实现的共识算法。相对于Paxos等复杂的算法，Raft的概念更直观，因此更容易实现和维护。</li>
<li>安全性：Raft算法在保证分布式系统的安全性方面表现出色。它确保当大多数节点正常运行时，系统能够达成共识，从而防止数据丢失或损坏。</li>
<li>选举机制：Raft使用选举机制来选举领导者，确保系统中的节点能够动态适应节点故障和网络分区等情况。这有助于系统的可用性和容错性。</li>
<li>日志复制：Raft通过日志复制来确保系统的一致性。这种方式更直观，易于理解，并且能够有效地处理数据复制和恢复。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>性能开销：Raft算法的性能开销相对较高，尤其是在大规模分布式系统中。这主要是因为它需要维护额外的状态和进行领导者选举。</li>
<li>限制：Raft算法对网络分区（节点之间的通信中断）的处理方式相对保守。虽然这有助于确保一致性，但在某些情况下可能导致系统不可用。</li>
</ol>
<blockquote>
<p>相对于Paxos，Raft更易于理解和实现，因此在实际应用中更受欢迎。它提供了一种直观的方式来处理分布式一致性问题，有助于开发人员更容易地构建可靠的分布式系统。</p>
</blockquote>
<h3 id="ZAB-算法"><a href="#ZAB-算法" class="headerlink" title="ZAB 算法"></a>ZAB 算法</h3><p>ZAB（ZooKeeper Atomic Broadcast）选举算法是为 ZooKeeper 实现分布式协调功能而设计的。相较于 Raft 算法的投票机制，ZAB 算法增加了通过节点 ID 和数据 ID 作为参考进行选主，节点 ID 和数据 ID 越大，表示数据越新，优先成为主。</p>
<p><strong>关键概念：</strong></p>
<ol>
<li>领导者（Leader）：Zookeeper集群的核心角色，在集群启动或崩溃恢复中通过Follower参与选举产生，<strong>为客户端提供读写服务，并对事务请求进行处理</strong>。</li>
<li>跟随者（Follower）：Zookeeper集群的核心角色，在集群启动或崩溃恢复中参加选举，没有被选上就是这个角色，<strong>为客户端提供读取服务</strong>，也就是处理非事务请求，Follower不能处理事务请求，对于收到的事务请求会转发给Leader。</li>
<li>观察者（Observer）：观察者角色，<strong>不参加选举，为客户端提供读取服务，处理非事务请求</strong>，对于收到的事务请求会转发给Leader。使用Observer的目的是为了扩展系统，提高读取性能。</li>
<li>成员状态：<ul>
<li>LOOKING: 竞选状态，没有Leader。</li>
<li>FOLLOWING: 随从状态，同步Leader 状态，参与Leader选举的投票过程。</li>
<li>OBSERVING: 观察状态，同步Leader 状态，不参与Leader选举的投票过程。</li>
<li>LEADING: 领导者状态，存在Leader。</li>
</ul>
</li>
</ol>
<p><strong>步骤：</strong></p>
<ul>
<li>选举阶段： 在选举阶段，ZAB算法用于选举一个领导者节点，这个领导者节点将负责处理所有写操作和数据复制。在分布式系统中，只有一个领导者能够进行写操作，以确保一致性。选举过程包括节点的争夺和选举出领导者，通常采用基于投票的机制，其中大多数节点投票给同一个节点成为领导者。</li>
<li>成员发现： 成员发现阶段是指ZAB算法用于检测集群中的新节点或失效节点，并确保所有节点都知道当前的集群成员。这一阶段确保节点的<strong>动态加入和离开不会破坏共识算法的正常运行</strong>。</li>
<li>数据同步： 一旦选出领导者，领导者负责接受客户端的写请求，并将这些写请求转化为一个序列的提案（proposal）。然后，领导者将这些提案发送给集群中的其他节点以进行复制。数据同步阶段确保集群中的所有节点都有相同的数据状态，以维护一致性。</li>
<li>数据广播： 在数据广播阶段，领导者将接受到的提案广播给集群中的其他节点，这些节点将按照相同的顺序应用这些提案，从而确保各节点的数据状态保持一致。一旦多数节点成功应用了提案，数据就被视为已经提交，并且可以告知客户端，从而完成一次写操作</li>
</ul>
<p><strong>优点：</strong>ZAB协议优点是在保证数据一致性的同时，具有高可用性和可扩展性。</p>
<p><strong>缺点：</strong></p>
<ol>
<li>内存占用多：ZAB协议缺点是需要占用大量的内存和存储空间来记录节点状态。</li>
<li>选主开销：在选主过程中，需要进行领导者选举，这会引入额外的开销和延迟。</li>
<li>单一领导者：ZAB算法采用了单一领导者模式，这意味着所有的写操作都必须经过领导者，可能会成为性能瓶颈。</li>
</ol>
<h3 id="Gossip算法（复制算法）"><a href="#Gossip算法（复制算法）" class="headerlink" title="Gossip算法（复制算法）"></a>Gossip算法（复制算法）</h3><p>Gossip算法，又称八卦算法，是一种用于分布式系统中的信息传播和数据同步的算法。它的工作方式类似于人们之间传播八卦或谣言的方式，通过节点之间<strong>相互交流信息</strong>来实现分布式系统的协调和数据一致性。</p>
<p><strong>节点状态：</strong></p>
<ul>
<li><strong>Susceptible (S)</strong>: “Susceptible” 节点是指在 Gossip 协议中<strong>可能会传播消息即未传播</strong>的节点。这些节点处于接收消息的状态，它们会接受来自其他节点的信息并可能将其传播给其他节点。当一个节点接收到消息时，它可以变为 “Infective” 状态。</li>
<li><strong>Infective (I)</strong>: “Infective” 节点是<strong>已经接收了消息</strong>并可以传播消息的节点。这些节点会将他们接收到的消息传播给其他节点，以便在系统中传播信息和状态。当一个节点变为 “Infective” 状态后，它可以传播消息给其他节点，并继续保持 “Infective” 状态，以确保消息能够传播到系统中的其他节点。</li>
<li><strong>Recovered (R)</strong>: “Recovered” 节点是指<strong>已经接收并传播了消息的节点，但它们不再继续传播相同的消息</strong>。这些节点可以被认为是已经处理了消息并不再活跃地传播它们。在某些 Gossip 协议中，节点可能会从 “Infective” 状态转变为 “Recovered” 状态，以限制消息的传播范围。</li>
</ul>
<p><strong>复制方式：</strong></p>
<ul>
<li><p>直接邮寄：就是指你的节点收到更新数据的时侯直接把这个数据发送给其它的节点。</p>
</li>
<li><p>反熵：每个节点周期性地随机选择其他节点（<strong>一般是采用闭环结构</strong>），然后通过互相交换自己的所有数据来消除两者之间的差异，直到整个网络中节点数据一致。</p>
</li>
<li><p>谣言传播：</p>
<p>各节点周期性的，向随机的一组节点广播更新数据。</p>
<p>其他节点收到更新的数据后，继卖周期性的，向随机的一组节点广播更新数据，直到所有节点都处理了新数据。</p>
<p>为了使谣言传播能够停止（避免广播风暴) ，gossip增加removed状态，当节点收到的谣言并且该谣言处于removed (之前已经处理过的谣言）时，该节点将不继续传播该谣言。</p>
</li>
</ul>
<p><strong>特点：</strong></p>
<ol>
<li>去中心化，集群中各个节点都是对等的。</li>
<li>无法保证在某个时刻所有节点状态一致。</li>
<li>比较适合小数据量的同步。失败检测、路由同步、Pub/Sub、动态负载均衡。</li>
</ol>
<h3 id="Distro协议"><a href="#Distro协议" class="headerlink" title="Distro协议"></a>Distro协议</h3><p>Distro算法是集Gossip以及 Eureka协议的优点并加以优化而出来的，对于原生的Gossip，由于随机选取发送消息的节点，也就不可避免的存在消息重复发送给同一节点的情况，增加了网络的传输的压力，也给消息节点带来额外的处理负载，而Distro算法引入了权威Server的概念，每个节点负责一部分数据以及将自己的数据同步给其他节点，有效的降低了消息冗余的问题。</p>
<p><strong>步骤：</strong></p>
<ul>
<li>Nacos 启动时首先从其他远程节点同步全部数据。</li>
<li>Nacos 每个节点是平等的都可以处理写入请求，同时把新数据同步到其他节点。</li>
<li>每个节点只负责部分数据，定时发送自己负责数据的校验值到其他节点来保持数据一致性。</li>
<li>当该节点接收到属于该节点负责的服务时，直接写入。</li>
<li>当该节点接收到不属于该节点负责的服务时，将在集群内部路由，转发给对应的节点，从而完成写入。</li>
<li>读取操作则不需要路由，因为集群中的各个节点会同步服务状态，每个节点都会有一份最新的服务数据。</li>
<li>而当节点发生宕机后，原本该节点负责的一部分服务的写入任务会转移到其他节点，从而保证 Nacos 集群整体的可用性。</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>分布式一致性算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态通知方案</title>
    <url>/2023/10/29/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E6%80%81%E9%80%9A%E7%9F%A5%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="动态通知方案"><a href="#动态通知方案" class="headerlink" title="动态通知方案"></a>动态通知方案</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>“动态通知” 是指在实时或运行时通知或提醒系统的方式。这种通知可以是基于事件、数据变化、用户行为或其他触发条件的。动态通知在计算机科学和信息技术领域中非常常见，用于各种应用，包括通信、监控、安全、用户界面等。</p>
<p>动态通知可以采用不同的方式和机制，主要包括：</p>
<ul>
<li><strong>Push通知</strong>：这是一种实时通知方式，其中数据或信息被主动推送到接收方。常见的例子包括移动应用中的推送通知、实时聊天消息等。</li>
<li><strong>Pull通知</strong>：在这种方式下，接收方定期轮询或请求来获取更新或信息。这通常涉及定期检查服务器或资源的状态以获取新数据。</li>
</ul>
<h2 id="Push通知"><a href="#Push通知" class="headerlink" title="Push通知"></a>Push通知</h2><p>Push方式通常是基于<strong>观察者模式</strong>（Observer Pattern）实现的。在这种方式下，有一个被观察者（通常称为主题）和多个观察者。当主题的状态发生变化时，它会主动通知所有观察者，将更新推送给它们。</p>
<p>例如：微博动态推送</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20231012104629970.png" alt="image-20231012104629970" style="zoom:67%;" />

<ul>
<li>优点：<ul>
<li>有很好的实时性</li>
</ul>
</li>
<li>缺点：<ul>
<li>需要在服务器存数据，无法保证无状态</li>
<li>粉丝量太多会引发<strong>写扩散</strong>的问题（大量动态队列持久化造成磁盘高IO）</li>
</ul>
</li>
</ul>
<p><strong>写扩散问题解决：</strong></p>
<ul>
<li>设置上限，例如微信好友5000个</li>
<li>限流策略，X分钟内完成消息发布</li>
<li>优化存储策略，采用NoSQL或大数据方案</li>
</ul>
<h2 id="Pull通知"><a href="#Pull通知" class="headerlink" title="Pull通知"></a>Pull通知</h2><p>Pull方式通常是通过<strong>轮询</strong>或请求的方式实现的。在这种方式下，观察者定期轮询被观察者的状态或在需要时主动请求更新。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20231012104921357.png" alt="image-20231012104921357"></p>
<ul>
<li>优点：<ul>
<li>能做到无状态服务器</li>
</ul>
</li>
<li>缺点：<ul>
<li>实时性较差</li>
<li>大量请求会导致<strong>读扩散</strong>问题，搞垮服务器</li>
</ul>
</li>
</ul>
<p><strong>读扩散问题解决：</strong></p>
<ul>
<li>MQ削峰填谷，超长队列直接拒绝</li>
<li>增加轮询间隔，减少请求次数</li>
<li>服务端增加缓存，优化查询效率</li>
<li>增加验证码，分散时间，减少机器人刷票</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>动态通知</tag>
      </tags>
  </entry>
  <entry>
    <title>多级缓存架构</title>
    <url>/2023/11/01/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="多级缓存架构"><a href="#多级缓存架构" class="headerlink" title="多级缓存架构"></a>多级缓存架构</h1><h2 id="分布式多久缓存架构"><a href="#分布式多久缓存架构" class="headerlink" title="分布式多久缓存架构"></a>分布式多久缓存架构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>分布式缓存架构是一种用于提高应用程序性能和可伸缩性的计算机架构，它利用分布式计算资源和存储资源来管理和存储数据的缓存。这种架构的主要目标是减轻数据库或其他后端存储系统的负载，从而<strong>加快数据访问速度并提高系统的可伸缩性</strong>。</p>
<p><strong>架构图：</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230906104845098.png" alt="image-20230906104845098" style="zoom:67%;" />

<p>一共分为四层：客户端层、应用层、服务层、数据层；</p>
<h3 id="各层缓存"><a href="#各层缓存" class="headerlink" title="各层缓存"></a>各层缓存</h3><h4 id="客户端层："><a href="#客户端层：" class="headerlink" title="客户端层："></a>客户端层：</h4><p>客户端层的缓存通常是<strong>通过浏览器进行管理</strong>，它使用响应头中的一些字段来控制缓存行为，将静态文件缓存在客户端本地。</p>
<p>这些字段包括：</p>
<ul>
<li><code>Cache-Control</code>： 这个响应头字段包含了各种指令，以告诉浏览器如何处理响应的缓存。<ul>
<li><code>max-age</code>：指定了资源在被认为过期之前可以被缓存的秒数。例如，<code>max-age=3600</code>表示资源可以在浏览器缓存中存储一个小时。</li>
<li><code>no-cache</code>：表示缓存必须重新验证资源的有效性，但仍然可以缓存。</li>
<li><code>no-store</code>：表示不允许缓存该资源。</li>
<li><code>public</code>：表示该响应可以被任何缓存存储，包括中间代理服务器。</li>
<li><code>private</code>：表示响应只能被单个用户的浏览器缓存，而不能被共享缓存。</li>
</ul>
</li>
<li><code>Expires：</code> 这个响应头字段包含了一个日期/时间值，表示资源的过期时间。</li>
<li><code>ETag</code>和<code>Last-Modified</code>： 这两个字段用于实现条件请求。</li>
<li><code>If-None-Match</code>和<code>If-Modified-Since</code>：这两个请求头字段用于条件请求，浏览器在发现缓存过期或需要重新验证资源时，会使用它们来告诉服务器缓存的版本信息。</li>
</ul>
<h4 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h4><p>应用层的缓存通常是通过使用<strong>CDN（内容分发网络）</strong>来实现的。CDN是一组分布在全球不同位置的服务器群集，它们存储了大量的静态和动态内容（例如网页、图像、视频等），并在接收到用户请求时，根据用户的位置和其他因素，从最近的服务器提供内容。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230906110043011.png" alt="image-20230906110043011" style="zoom:50%;" />

<p><strong>解决问题：</strong></p>
<ul>
<li>带宽集中占用的问题</li>
<li>数据分发问题</li>
</ul>
<blockquote>
<p>如果并不存在远距离的数据分发问题，可以使用Nginx的缓存管理（当然可以两者都使用）：有静态资源缓存和压缩功能（在本地目录下缓存）。</p>
<p><strong>特点：</strong></p>
<ul>
<li>可以用于更精细地控制缓存内容（根据URL、HTTP头等条件来配置）</li>
</ul>
<p><strong>同时使用的理由：</strong></p>
<ul>
<li><strong>更精细的控制</strong>: Nginx允许您更精细地控制哪些内容需要缓存，缓存的时间以及其他缓存策略。</li>
<li><strong>应对CDN故障</strong>: 虽然CDN通常可靠，但仍然有可能出现故障或问题。</li>
<li><strong>自定义需求</strong>: 某些网站可能有特殊的缓存需求，不适用于CDN默认配置。</li>
</ul>
</blockquote>
<h4 id="服务层："><a href="#服务层：" class="headerlink" title="服务层："></a>服务层：</h4><p>服务层的缓存在分布式应用中非常重要，可以显著提高性能和减轻数据库负载。进程外缓存和进程内缓存是两种常见的缓存策略，它们有不同的特点和用途：</p>
<ol>
<li><strong>进程外缓存（Out-of-Process Cache）</strong>：<ul>
<li><strong>例子：</strong> Redis、Memcached等。</li>
<li><strong>特点：</strong><ul>
<li>进程外缓存是独立于应用程序进程的，通常运行在单独的缓存服务器上。</li>
<li>它可以在多个应用程序实例之间共享缓存数据，因为多个应用程序可以连接到同一个缓存服务器。</li>
<li>进程外缓存通常具有高性能和低延迟，因为它们专门用于缓存，不受应用程序本身的负载影响。</li>
<li>支持持久化，数据可以在重启后仍然可用。</li>
</ul>
</li>
<li><strong>用途：</strong><ul>
<li>存储频繁访问的数据，减轻数据库负载。</li>
<li>缓存计算密集型操作的结果，提高响应速度。</li>
<li>实现分布式锁、消息队列等功能。</li>
</ul>
</li>
</ul>
</li>
<li><strong>进程内缓存（In-Process Cache）</strong>：<ul>
<li><strong>例子：</strong> 本地内存缓存、应用程序内部数据结构等。</li>
<li><strong>特点：</strong><ul>
<li>进程内缓存存储在应用程序的内存中，是应用程序的一部分。</li>
<li>它对于单个应用程序实例有效，不共享于多个应用程序实例之间。</li>
<li>进程内缓存通常具有极低的延迟，因为数据可以直接从内存中读取。</li>
<li>数据存储在应用程序的进程内，因此没有网络开销。</li>
</ul>
</li>
<li><strong>用途：</strong><ul>
<li>存储短期内需要频繁访问的数据，避免多次查询数据库。</li>
<li>缓存应用程序内部状态和计算结果，以提高处理效率。</li>
<li>在单个应用程序实例内实现临时性的数据共享。</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>这里需要引入消息队列来解决缓存一致性问题：</p>
<ul>
<li>当数据库中数据进行更新时需要将变更消息推送给本地缓存和redis缓存，进行双写更新。</li>
</ul>
<p>当数据有以下特点是使用服务层缓存最好：</p>
<ul>
<li>缓存的数据是稳定的。</li>
<li>瞬时可能会产生极高并发的场景。</li>
<li>一定程度上允许数据不一致。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>多级缓存架构</tag>
      </tags>
  </entry>
  <entry>
    <title>接口幂等性</title>
    <url>/2023/11/08/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/</url>
    <content><![CDATA[<h1 id="接口幂等性"><a href="#接口幂等性" class="headerlink" title="接口幂等性"></a>接口幂等性</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>接口幂等性（Idempotence）是计算机科学和网络通信领域的一个重要概念，用于描述某个操作可以重复执行多次而不会产生不同的结果。幂等性是设计和开发网络服务和API时的重要原则之一，特别是在处理与数据修改相关的操作时，以确保系统的可靠性和一致性。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>设计幂等性的API对于分布式系统的可靠性和容错性至关重要。它允许客户端在网络通信中重试操作，而无需担心产生不一致的结果。在API设计中，可以通过以下方式来确保幂等性：</p>
<ol>
<li><p><strong>幂等性检查：</strong>在处理请求之前，服务器可以检查请求的幂等性，以确保不会产生意外的结果。</p>
<ul>
<li>缺点：<ul>
<li>前置判断地方太多，容易遗留</li>
<li>干扰正常业务编写</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>构建幂等表：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230919102511895.png" alt="image-20230919102511895"></p>
<ul>
<li><p>关键点：</p>
<ul>
<li>请求的请求头中必须带有唯一请求id</li>
<li>判断是否在Redis中存在，不存在则存入Redis（格式为：系统-Id:请求状态:过期时间）</li>
<li>数据服务完成请求需要修改Redis中该请求的状态（利用AOP进行后置通知更新）</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>前台应用需要进行改造</li>
<li>架构复杂度增加</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>接口幂等性</tag>
      </tags>
  </entry>
  <entry>
    <title>数据迁移</title>
    <url>/2023/11/12/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h1 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h1><h2 id="迁移数据方案"><a href="#迁移数据方案" class="headerlink" title="迁移数据方案"></a>迁移数据方案</h2><p>迁移过程也需要满足以下几个目标：</p>
<ul>
<li>迁移应该是在线的迁移，也就是在迁移的同时还会有数据的写入；</li>
<li>数据应该保证完整性，也就是说在迁移之后需要保证新的库和旧的库的数据是一致的；</li>
<li>迁移的过程需要做到可以回滚，这样一旦迁移的过程中出现问题，可以立刻回滚到源库不会对系统的可用性造成影响。</li>
</ul>
<h3 id="“双写”方案"><a href="#“双写”方案" class="headerlink" title="“双写”方案"></a>“双写”方案</h3><p>第一种方案我称之为双写，其实说起来也很简单，它可以分为以下几个步骤：</p>
<ol>
<li><p>将新的库配置为源库的从库用来同步数据；如果需要将数据同步到多库多表，那么可以使用一些第三方工具获取 Binlog 的增量日志（比如开源工具 Canal），在获取增量日志之后就可以按照分库分表的逻辑写入到新的库表中了。</p>
</li>
<li><p>同时我们需要改造业务代码，在数据写入的时候不仅要写入旧库也要写入新库。当然，基于性能的考虑，我们可以异步地写入新库，只要保证旧库写入成功即可。<strong>但是我们需要注意的是，</strong>需要将写入新库失败的数据记录在单独的日志中，这样方便后续对这些数据补写，保证新库和旧库的数据一致性。</p>
</li>
<li><p>然后我们就可以开始校验数据了。由于数据库中数据量很大，做全量的数据校验不太现实。你可以抽取部分数据，具体数据量依据总体数据量而定，只要保证这些数据是一致的就可以。</p>
</li>
<li><p>如果一切顺利，我们就可以将读流量切换到新库了。由于担心一次切换全量读流量可能会对系统产生未知的影响，所以这里<strong>最好采用灰度的方式来切换，</strong>比如开始切换 10% 的流量，如果没有问题再切换到 50% 的流量，最后再切换到 100%。</p>
</li>
<li><p>由于有双写的存在，所以在切换的过程中出现任何的问题都可以将读写流量随时切换到旧库去，保障系统的性能。</p>
</li>
<li><p>在观察了几天发现数据的迁移没有问题之后，就可以将数据库的双写改造成只写新库，数据的迁移也就完成了。</p>
</li>
</ol>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230506144851263.png" alt="image-20230506144851263" style="zoom:67%;" />

<p>这种方案是一种比较通用的方案，无论是迁移 MySQL 中的数据还是迁移 Redis 中的数据，甚至迁移消息队列都可以使用这种方式，<strong>你在实际的工作中可以直接拿来使用。</strong></p>
<p><strong>优点：</strong>迁移的过程可以随时回滚，将迁移的风险降到了最低；</p>
<p><strong>劣势：</strong>时间周期比较长，应用有改造的成本。</p>
<blockquote>
<p>如果是将数据从自建机房迁移到云上，你也可以使用这个方案：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230506145823458.png" alt="image-20230506145823458"></p>
</blockquote>
<h3 id="级联同步方案"><a href="#级联同步方案" class="headerlink" title="级联同步方案"></a>级联同步方案</h3><p>这种方案也比较简单，比较适合数据从自建机房向云上迁移的场景；具体的步骤如下：</p>
<ol>
<li>先将新库配置为旧库的从库，用作数据同步；</li>
<li>再将自建机房中的一个备库配置为新库的从库，用作数据的备份；</li>
<li>等到三个库的写入一致后，将数据库的读流量切换到新库；</li>
<li>然后暂停应用的写入，将业务的写入流量切换到新库（由于这里需要暂停应用的写入，所以需要安排在业务的低峰期）。</li>
</ol>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230506151106899.png" alt="image-20230506151106899" style="zoom:67%;" />

<p><strong>这种方案的回滚方案也比较简单，</strong>可以先将读流量切换到备库再暂停应用的写入，将写流量切换到备库，这样所有的流量都切换到了备库，也就是又回到了自建机房的环境，就可以认为已经回滚了。</p>
<p><strong>优点：</strong>简单易实施，在业务上基本没有改造的成本；</p>
<p><strong>缺点：</strong>在切写的时候需要短暂的停止写入，对于业务来说是有损的。</p>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>数据迁移细节</title>
    <url>/2023/12/01/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<h1 id="数据迁移细节"><a href="#数据迁移细节" class="headerlink" title="数据迁移细节"></a>数据迁移细节</h1><p>数据迁移运用场景：</p>
<ul>
<li>重构项目但数据不能丢失，需要重新设计表结构</li>
<li>单库拆分分库分表</li>
</ul>
<h2 id="数据备份工具"><a href="#数据备份工具" class="headerlink" title="数据备份工具"></a>数据备份工具</h2><ul>
<li>mysqldump：一个用于备份和恢复 MySQL 数据库的命令行工具。它允许用户导出 MySQL 数据库的结构、数据以及表之间的关系，以便在数据库发生问题时进行恢复。它是一个逻辑备份工具，导出的内容是一条条 SQL。</li>
<li>XtraBackup：它使用了 InnoDB 存储引擎的数据备份技术，支持增量备份和恢复，并且支持多主机备份和恢复。它是一个物理备份工具，相当于直接复制 InnoDB 的底层存储文件。</li>
</ul>
<blockquote>
<p>innodb_autoinc_lock_mode 是 InnoDB 引擎里面控制自增主键生成策略的参数，它有三个取值。</p>
<ul>
<li><p>0：使用表自增锁，但是锁在 INSERT 语句结束之后就释放了。</p>
</li>
<li><p>1：使用表自增锁，如果是普通的 INSERT INTO VALUE 或者 INSERT INTO VALUES 语句，申请了主键就释放锁，而不是整个 INSERT 语句执行完毕才释放。如果是 INSERT SELECT 等语句，因为无法确定究竟要插入多少行，所以都是整个 INSERT 语句执行完毕才释放。</p>
</li>
<li><p>2：使用表自增锁，所有的语句都是申请了主键就立刻释放。</p>
</li>
</ul>
</blockquote>
<h2 id="一个高效、稳定的数据迁移方案"><a href="#一个高效、稳定的数据迁移方案" class="headerlink" title="一个高效、稳定的数据迁移方案"></a>一个高效、稳定的数据迁移方案</h2><p><strong>基本步骤：</strong></p>
<ol>
<li><p>创建目标表</p>
</li>
<li><p>用源表的数据初始化目标表。</p>
<ul>
<li>使用源表的历史备份，基本上数据库都会有备份机制，那么你自然可以利用这些备份来初始化目标表的数据。</li>
<li>源表导出数据，大部分情况下，使用 mysqldump 是不会出问题的，无非就是导出导入慢一些，而这也恰好是你刷亮点的地方。</li>
</ul>
<blockquote>
<p>亮点：加快mysqldump导入和导出速度</p>
<ul>
<li>加快导出速度能做的事情并不多，主要就是开启 extended-insert 选项，将多行合并为一个 INSERT 语句。</li>
<li>加快导入速度就可以做比较多的事情。<ol>
<li>关闭唯一性检查和外键检查，源表已经保证了这两项，所以目标表并不需要检查。</li>
<li>关闭 binlog，毕竟导入数据用不着 binlog。</li>
<li>调整 redo log 的刷盘时机，把 innodb_flush_log_at_trx_commit 设置为 0（只刷在buffer中）。</li>
</ol>
</li>
</ul>
</blockquote>
</li>
<li><p>执行一次校验，并且修复数据，此时用源表数据修复目标表数据。</p>
<p>所有的表都需要有 update_time 这个字段，那么你在校验和修复的时候就可以采用增量的方案。因为只有 update_time 晚于你导出数据的那个时间点，才说明这一行的数据已经发生了变更。在修复的时候就<strong>直接用源表的数据覆盖掉目标表的数据</strong>。</p>
</li>
<li><p>业务代码开启双写，此时读源表，并且先写源表，数据以源表为准。</p>
<p>支持双写大体上有两个方向：侵入式和非侵入式两种：</p>
<ul>
<li><p>侵入式：<strong>侵入式方案就是直接修改业务代码</strong>。要求业务代码在写了源表之后再写目标表。但是侵入式方案是不太可行的，或者说代价很高。因为这意味着所有的业务都要检查一遍，然后修改。</p>
</li>
<li><p>非侵入式：<strong>非侵入式一般和你使用的数据库中间件有关</strong>，比如说 ORM 框架。这一类框架一般会提供两种方式来帮你解决类似的问题。</p>
<ol>
<li>AOP（Aspect Oriented Program 面向切面编程）方案：不同框架有不同叫法，比如说可能叫做 interceptor、middleware、hook、handler、filter。这个方案的关键就是捕捉到发起的增删改调用，篡改为双写模式。</li>
<li>数据库操作抽象：可能叫做 Session、Connection、Connection Pool、Executor 等，就是将对源表的操作修改为双写模式。</li>
</ol>
<blockquote>
<p>不管你采用哪个方案，你都要确保一个东西，就是双写可以在运行期随时切换状态，单写源表、先写源表、先写目标表、单写目标表都可以。</p>
<ul>
<li>大多数时候都是利用一个标记位，然后你可以通过配置中心或者接口直接修改它的值。</li>
</ul>
<p>正常面试官都可能会问到，如果在双写过程中，写入源表成功了，但是写入目标表失败了，该怎么办？</p>
<ul>
<li>在设计方案的时候，我考虑过在写入目标表失败的时候，发一个消息到消息队列，然后尝试修复数据。但是这个其实很难做到，因为我不知道该修复哪些数据。比如说一个 UPDATE 语句在目标表上执行失败，我没办法根据 UPDATE 语句推断出源表上哪些行被影响到了，除非可以拿到源库执行的sql。</li>
</ul>
<p>主键问题：</p>
<ul>
<li>在双写的时候比较难以处理的问题是自增主键问题。为了保持源表和目标表的数据完全一致，需要在源表插入的时候拿到自增主键的值，然后用这个值作为目标表插入的主键。</li>
<li>在处理批量插入的时候要更加小心一些。正常来说，批量插入如果用的是 VALUES 语法，那么生成的主键是连续的，就可以从返回的最后一个主键推测出前面其他行的主键。即便 innodb_autoinc_lock_mode 取值是 2 也能保证这一点。但是如果用的是多个 INSERT INTO VALUE 语句，或者 INSERT SELECT 语句，这些语句生成的主键就可能不连续。在双写之前，就要先改造这一类的业务。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>开启增量校验和数据修复，保持一段时间。</p>
<p>增量校验基本上就是一边保持双写，一边校验最新修改的数据，如果不一致，就要进行修复。</p>
<p>有两个方案：</p>
<ul>
<li><p>利用更新时间戳，比如说 update_time 这种列，利用更新时间戳的思路很简单，就是定时查询每一张表，然后根据更新时间戳来判断某一行数据有没有发生变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="comment">// 执行查询</span></span><br><span class="line">  <span class="comment">// SELECT * FROM xx WHERE update_time &gt;= last_time</span></span><br><span class="line">  rows := findUpdatedRows()</span><br><span class="line">  <span class="keyword">for</span> row in rows &#123;</span><br><span class="line">    <span class="comment">// 找到目标行，要用主键来找，用唯一索引也可以，看你支持到什么程度</span></span><br><span class="line">    tgtRow = findTgt(row.id)</span><br><span class="line">    <span class="keyword">if</span> row != tgtRow &#123;</span><br><span class="line">      <span class="comment">// 修复数据</span></span><br><span class="line">      fix()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用这一批数据里面最大的更新时间戳作为下一次的起始时间戳</span></span><br><span class="line">  last_time = maxUpdateTime(row)</span><br><span class="line">  <span class="comment">// 睡眠一下</span></span><br><span class="line">  sleep(1s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意点：</p>
<ul>
<li><p>注意源表需要软删除。</p>
</li>
<li><p>校验和修复的时候都要小心主从同步的问题，如果校验和修复都使用从库的话，那么就会出现校验出错，或者修复出错的情况。按照道理来说，强制走主库就可以解决问题，但是这样对主库的压力是比较大的。</p>
</li>
<li><p>所以我采用的是双重校验方案。第一次校验的时候读从库，如果发现数据不一致，再读主库，用主库的数据再校验一次。修复的时候就只能以主库数据为准。这种方案的基本前提是，主从延迟和数据不一致的情况是小概率的，所以最终会走到主库也是小概率的。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>利用 binlog：基于行的 binlog 模式</p>
<p>在校验和修复的数据时候，我采用的是监听 binlog 的方案。binlog 只用于触发校验和修复这个动作，当我收到 binlog 之后，我会用 binlog 中的主键，去查询源表和目标表，再比较两者的数据。如果不一致，就用源表的数据去修复目标表。</p>
<blockquote>
<p>它虽然能够进一步减轻数据库查询的压力，但是实在过于复杂，得不偿失。所以不管是实践，还是面试，我都建议你不要使用这个方案。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>切换双写顺序，此时读目标表，并且先写目标表，数据以目标表为准。</p>
<p>引入这一步，是为了能够在切换到以目标表为准之前，有一个过渡阶段。也就是说，通过先写目标表，再写源表这种方式，万一发现数据迁移出现了问题，还可以回滚为先写源表，再写目标表，确保业务没有问题。</p>
</li>
<li><p>继续保持增量校验和数据修复。</p>
<p>在切换了双写顺序之后，保持增量校验和修复是顺理成章的，方案和步骤 5 一样。不过步骤 5 的校验和修复都是以源表为准，那么在这一步，就是以目标表为准。</p>
</li>
<li><p>切换为目标表单写，读写都只操作目标表。</p>
</li>
</ol>
<h2 id="总结要点："><a href="#总结要点：" class="headerlink" title="总结要点："></a>总结要点：</h2><ul>
<li>不管什么先后顺序问题、什么并发问题，在修复的时候你永远用主表的最新数据去修复，绝对不会出问题。</li>
<li>如果源表或者目标表本身也是分库分表的，那么无非就是查询、修复数据的时候使用对应的分库分表规则而已。</li>
<li>整个方案在第八步之前，都是可以回滚的。但是一旦切换到第八步，就不可能回滚了。</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>架构分层</title>
    <url>/2023/11/23/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82/</url>
    <content><![CDATA[<h1 id="架构分层"><a href="#架构分层" class="headerlink" title="架构分层"></a>架构分层</h1><p>软件架构分层在软件工程中是一种常见的设计方式，它是将整体系统拆分成 N 个层次，每个层次有独立的职责，多个层次协同提供完整的功能。</p>
<h2 id="常见分层架构"><a href="#常见分层架构" class="headerlink" title="常见分层架构"></a>常见分层架构</h2><p><strong>MVC（Model-View-Controller）架构</strong></p>
<ul>
<li>它将整体的系统分成了 Model（模型），View（视图）和 Controller（控制器）三个层次，也就是将用户视图和业务处理隔离开，并且通过控制器连接起来，很好地实现了表现和逻辑的解耦，是一种标准的软件分层架构。</li>
</ul>
<p><strong>另外一种常见的分层方式是将整体架构分为表现层、逻辑层和数据访问层：</strong></p>
<ul>
<li>表现层，顾名思义嘛，就是展示数据结果和接受用户指令的，是最靠近用户的一层；</li>
<li>逻辑层里面有复杂业务的具体实现；</li>
<li>数据访问层则是主要处理和存储之间的交互。</li>
</ul>
<p><strong>计网中的 TCP/IP四层模型：</strong></p>
<ul>
<li>分为链路层、网络层、传输层和应用层</li>
<li>每一层各司其职又互相帮助，网络层负责端到端的寻址和建立连接，传输层负责端到端的数据传输等，同时相邻两层还会有数据的交互。这样可以隔离关注点，让不同的层专注做不同的事情。</li>
</ul>
<h2 id="分层的优缺点"><a href="#分层的优缺点" class="headerlink" title="分层的优缺点"></a>分层的优缺点</h2><p><strong>优点：</strong></p>
<ul>
<li>首先分层的设计简化了系统设计，让人各司其职只关注某一层的事情。</li>
<li>再次就是提高了系统的复用性，可以将某一层单独抽出使用。</li>
<li>能够更容易的进行横向扩展，比如可以将某一层单独部署扩展。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>增加了代码的复杂度。</li>
<li>如果我们把每个层次独立部署，层次间通过网络来交互，那么多层的架构在性能上会有损耗。</li>
</ul>
<h2 id="分层案例"><a href="#分层案例" class="headerlink" title="分层案例"></a>分层案例</h2><p>分层架构需要考虑层次之间一定是相邻层互相依赖，数据的流转也只能在相邻的两层之间流转。</p>
<p>参照阿里系统分层的规约：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230412163055014.png" alt="image-20230412163055014" style="zoom:67%;" />

<ul>
<li>终端显示层：各端模板渲染并执行显示的层。当前主要是 Velocity 渲染，JS 渲染， JSP 渲染，移动端展示等。</li>
<li>开放接口层：将 Service 层方法封装成开放接口，同时进行网关安全控制和流量控制等。</li>
<li>Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</li>
<li>Service 层：业务逻辑层。</li>
<li>Manager 层：通用业务处理层。这一层主要有两个作用：<ul>
<li>其一，你可以将原先 Service 层的一些通用能力下沉到这一层，比如与缓存和存储交互策略，中间件的接入；</li>
<li>其二，你也可以在这一层封装对第三方接口的调用，比如调用支付服务，调用审核服务等。</li>
</ul>
</li>
<li>DAO 层：数据访问层，与底层 MySQL、Oracle、HBase 等进行数据交互。</li>
<li>外部接口或第三方平台：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>架构分层</tag>
      </tags>
  </entry>
  <entry>
    <title>经典限流算法</title>
    <url>/2023/11/16/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E7%BB%8F%E5%85%B8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="经典限流算法"><a href="#经典限流算法" class="headerlink" title="经典限流算法"></a>经典限流算法</h1><h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p><strong>限流算法</strong>是一种用于控制流量或请求访问频率的技术，广泛应用于各种场景，以确保系统的稳定性和可用性。</p>
<p>现代互联网很多业务场景，比如秒杀、下单、查询商品详情。这些只是一些限流算法应用的示例，实际上，几乎任何需要控制流量或请求速率的应用都可以从限流算法中受益。选择适当的限流算法取决于具体的需求和系统架构。常见的限流算法包括令牌桶算法、漏桶算法、计数器算法等。</p>
<h2 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h2><h3 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h3><p>计数器算法是一种基于计数器的限流方法。它通过维护一个计数器来<strong>记录请求的数量</strong>，并与预设的阈值进行比较。</p>
<ul>
<li>当计数器超过阈值时，就会触发限流操作。可以根据需要选择计数器的精度（例如每秒、每分钟等）以及阈值的设置。</li>
</ul>
<p><strong>缺点：</strong></p>
<p>临界问题：例如在临界两把突发的高峰，无法进行限制。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230718155501005.png" alt="image-20230718155501005"></p>
<h3 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h3><p>滑动窗口，又称rolling window。滑动窗口算法维护一个固定大小的时间窗口，通常使用队列或数组来记录请求的时间戳。</p>
<ul>
<li>请求进入窗口时，旧的时间戳会被移出，从而保持窗口内的请求数量在限制范围内。</li>
<li>滑动窗口解决了计数器算法的临界值问题。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230913151109884.png" alt="image-20230913151109884"></p>
<p><strong>缺点：</strong></p>
<ul>
<li>不适用于长时间限流：滑动窗口算法通常用于实时或较短时间的限流，例如每秒或每分钟的请求限制。</li>
<li>不考虑请求的权重或优先级：滑动窗口算法通常将所有请求视为相等，无法根据请求的权重或优先级进行不同的处理。</li>
<li>对于突发流量的适应性有限：滑动窗口算法主要用于平滑流量，但对于突发流量的适应性有限。</li>
</ul>
<h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>漏桶算法也是一种基于容器的限流算法，它维护一个固定容量的桶，其中请求按照固定速率流入。</p>
<ul>
<li>如果桶已满，新的请求将被拒绝或排队等待。</li>
<li>请求从桶中以固定速率流出，确保流量控制在规定速率内。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230718155431819.png" alt="image-20230718155431819"></p>
<p><strong>缺点：</strong></p>
<ul>
<li>不适用于突发流量：漏桶算法的主要目的是通过固定速率来平滑流量，因此不适合处理突发流量。</li>
<li>不提供灵活性：漏桶算法的速率是固定的，这意味着它无法根据系统负载或其他因素进行动态调整。</li>
<li>无法应对不同优先级的请求：漏桶算法将所有请求平等对待，无法区分不同请求的优先级。</li>
<li>可能浪费带宽：如果流量的速率明显低于漏桶的容量，它会强制要求每个请求等待一个固定的时间而浪费带宽。</li>
</ul>
<h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>令牌桶算法是一种基于令牌的限流算法，它维护一个固定容量的令牌桶，其中每个令牌表示一个请求的许可。</p>
<ul>
<li>令牌以固定速率被添加到令牌桶中。当请求到达时，必须从令牌桶中获取令牌才能执行请求。</li>
<li>如果令牌桶为空，请求将被拒绝或排队等待令牌可用。</li>
</ul>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230913151510820.png" alt="image-20230913151510820" style="zoom: 50%;" />

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230804104831834.png" alt="image-20230804104831834"></p>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>经典限流算法</tag>
      </tags>
  </entry>
  <entry>
    <title>项目发布</title>
    <url>/2023/10/16/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<h1 id="项目发布问题"><a href="#项目发布问题" class="headerlink" title="项目发布问题"></a>项目发布问题</h1><p>项目发布是将项目的最终版本或特定功能部署到生产环境或可用于用户的过程。这个过程通常需要精心计划和执行，以确保项目的稳定性、性能和可用性。皆是在尽可能减少服务停机时间控制新版本带来的质量风险。</p>
<p>一般项目发布有以下几种方式：</p>
<p><strong>全量发布：</strong></p>
<ol>
<li><strong>蓝绿发布（Blue-Green Deployment）：</strong><ul>
<li><strong>概述：</strong> 蓝绿发布是一种部署策略，它在<strong>两个完全独立的生产环境</strong>中交替部署应用程序版本。一个环境是当前运行的版本（蓝色环境），另一个环境是新版本（绿色环境）。</li>
<li>部署流程：<ol>
<li>初始阶段，蓝色环境运行当前稳定的版本，而绿色环境准备好新版本。</li>
<li>在准备就绪后，可以将流量从蓝色环境切换到绿色环境，使新版本上线。</li>
<li>如果出现问题，可以轻松切换回蓝色环境，恢复旧版本。</li>
<li>这个过程可以反复进行，确保平滑的升级和回滚。</li>
</ol>
</li>
</ul>
</li>
<li><strong>红黑发布（Red-Black Deployment）：</strong><ul>
<li><strong>概述：</strong> 红黑发布是一种部署策略，它在<strong>同一生产环境</strong>中交替部署两个不同版本的应用程序。一个版本是当前生产版本（红色），另一个是新版本（黑色）。</li>
<li>部署流程：<ol>
<li>初始阶段，红色版本是当前运行的生产版本。</li>
<li>黑色版本在准备就绪后，与红色版本并行部署。</li>
<li>测试新版本是否稳定，如果有问题，可以迅速切换回红色版本。</li>
<li>当确定新版本没有问题时，可以将流量逐渐切换到黑色版本，从而完成升级。</li>
</ol>
</li>
</ul>
</li>
</ol>
<p><strong>增量发布：</strong></p>
<ol>
<li><strong>灰度发布（Canary Release）：</strong><ul>
<li><strong>概述：</strong> 灰度发布是一种逐步引入新版本或功能的策略，以限制潜在风险。在灰度发布中，新版本或功能仅在一小部分用户或服务器上进行部署，然后逐渐扩大范围。</li>
<li>部署流程：<ol>
<li>初始阶段，只有一小部分用户或服务器接收到新版本或功能的更新。</li>
<li>监控新版本的性能和稳定性，如果没有问题，逐渐扩大范围，使更多用户或服务器接收到更新。</li>
<li>如果出现问题，可以迅速回滚到之前的版本，最小化影响。</li>
</ol>
</li>
</ul>
</li>
<li><strong>滚动发布（Rolling Release）：</strong><ul>
<li><strong>概述：</strong> 滚动发布模型中，新功能、修补程序和更新以连续和逐渐的方式发布，而不是按计划的版本号。</li>
<li>部署流程：<ol>
<li>开发团队在持续基础上进行新功能的开发，修复错误或进行改进。</li>
<li>使用持续集成工具来自动集成和测试新代码，以及确保不会引入重大错误或冲突。</li>
<li>一旦新的变更通过测试，它们可以立即部署到生产环境中，一台一台的慢慢部署，如果发布过程出现了问题，回滚很麻烦，要逐台找到机器并且回滚。</li>
</ol>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>旧版本无法协同作业的问题：</p>
<ul>
<li>放弃灰度，采用红黑方式全量发布</li>
<li>可以考虑独立部署数据源进行迁移（只适用于小数据量）</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发系统设计目标</title>
    <url>/2023/11/27/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87/</url>
    <content><![CDATA[<h1 id="系统设计目标"><a href="#系统设计目标" class="headerlink" title="系统设计目标"></a>系统设计目标</h1><p>高并发系统设计的三大目标：<strong>高性能、高可用、可扩展</strong>。</p>
<ul>
<li>高性能：保证系统能够承载高并发的前提。</li>
<li>高可用：防止系统隔三差五宕机维护停机。</li>
<li>可扩展：保证能够在短时间内迅速完成扩容，更加平稳地承担峰值流量。</li>
</ul>
<h2 id="提升系统性能"><a href="#提升系统性能" class="headerlink" title="提升系统性能"></a>提升系统性能</h2><h3 id="性能优化原则"><a href="#性能优化原则" class="headerlink" title="性能优化原则"></a>性能优化原则</h3><ol>
<li><p><strong>性能优化一定不能盲目，一定是问题导向的。</strong></p>
<p>脱离了问题，盲目地提早优化会增加系统的复杂度，浪费开发人员的时间，也因为某些优化可能会对业务上有些折中的考虑，所以也会损伤业务。</p>
</li>
<li><p><strong>性能优化也遵循“八二原则”。</strong></p>
<p>在优化过程中一定要抓住主要矛盾，优先优化主要的性能瓶颈点。</p>
</li>
<li><p><strong>性能优化也要有数据支撑。</strong></p>
<p>一定要把性能监控系统做好，在优化过程中，时刻关注优化效果。</p>
</li>
<li><p><strong>性能优化的过程是持续的。</strong></p>
<p>高并发的系统通常是业务逻辑相对复杂的系统，在优化过程中需要循序渐进，不断寻找性能瓶颈并优化。</p>
</li>
</ol>
<h3 id="性能的度量指标"><a href="#性能的度量指标" class="headerlink" title="性能的度量指标"></a>性能的度量指标</h3><p>性能的度量指标主要用于明确性能问题、评估优化效果。</p>
<p>度量性能的指标是<strong>系统接口的响应时间</strong>，但是单次的响应时间是没有意义的，需要知道一段时间的性能情况是什么样的，主要的统计特征值有：</p>
<ul>
<li><p>平均值</p>
<p>平均值是把这段时间所有请求的响应时间数据相加，再除以总请求数。但是不能真实反应出系统性能。</p>
</li>
<li><p>最大值</p>
<p>就是这段时间内所有请求响应时间最长的值，但过于极端。</p>
</li>
<li><p>分位值</p>
<p>分位值有很多种，比如 90 分位、95 分位、75 分位。分位值排除了偶发极慢请求对于数据的影响，能够很好地</p>
<p>反应这段时间的性能情况，分位值越大，对于慢请求的影响就越敏感。（在实际工作中也应用最多，能真实反</p>
<p>应性能）</p>
</li>
</ul>
<blockquote>
<p>对于系统的响应时间：</p>
<ul>
<li>200ms：用户是感觉不到延迟的，就像是瞬时发生的一样。</li>
<li>1s：用户可以感受到一些延迟，但却是可以接受的</li>
<li>1s之后：会有明显等待的感觉，等待时间越长，用户的使用体验就越差。</li>
</ul>
</blockquote>
<h3 id="优化基本思路"><a href="#优化基本思路" class="headerlink" title="优化基本思路"></a>优化基本思路</h3><ol>
<li><p><strong>提高系统的处理核心数</strong></p>
<p>提高系统的处理核心数就是增加系统的并行处理能力，这个思路是优化性能最简单的途径。</p>
<p>但并不是核心数越多越好。<strong>随着并发进程数的增加，并行的任务对于系统资源的争抢也会愈发严重。</strong>在某一</p>
<p>个临界点上继续增加并发进程数，反而会造成系统性能的下降，这就是性能测试中的拐点模型。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230417171408562.png" alt="image-20230417171408562"></p>
</li>
<li><p><strong>减少单次任务响应时间</strong></p>
<p>想要减少任务的响应时间，首先要看你的系统是 CPU 密集型还是 IO 密集型的。</p>
<ul>
<li><p>CPU密集型：</p>
<p>CPU 密集型系统中，需要处理大量的 CPU 运算，那么选用更高效的算法或者减少运算次数就是这类系</p>
<p>统重要的优化手段。</p>
</li>
<li><p>IO密集型：</p>
<p>IO 密集型系统指的是系统的大部分操作是在等待 IO 完成，这里 IO 指的是磁盘 IO 和网络 IO。这类系统</p>
<p>的性能瓶颈可能出在系统内部，也可能是依赖的其他系统。这种情况就只有针对性的进行处理。</p>
</li>
</ul>
</li>
</ol>
<h2 id="提高系统可用性"><a href="#提高系统可用性" class="headerlink" title="提高系统可用性"></a>提高系统可用性</h2><p><strong>高可用性（High Availability，HA）</strong>它指的是系统具备较高的无故障运行的能力。对于一个高并发大流量的系统是至关重要的，系统出现故障比系统性能低更损伤用户的使用体验。</p>
<h3 id="可用性的度量"><a href="#可用性的度量" class="headerlink" title="可用性的度量"></a>可用性的度量</h3><p>可用性的度量主要是<strong>MTBF</strong> 和<strong>MTTR。</strong></p>
<p><strong>MTBF</strong></p>
<p>是平均故障间隔的意思，代表两次故障的间隔时间，也就是系统正常运转的平均时间。这个时间越长，系统稳定性越高。</p>
<p><strong>MTTR</strong></p>
<p>表示故障的平均恢复时间，也可以理解为平均故障时间。这个值越小，故障对于用户的影响越小。</p>
<p><strong>评估标准：</strong></p>
<p>我们可以用下面的公式表示它们之间的关系：<code>Availability = MTBF / (MTBF + MTTR)</code></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230418164414151.png" alt="image-20230418164414151" style="zoom:67%;" />

<ul>
<li>一个九和两个九的可用性是很容易达到的，三个九就降到8个小时需要基本保证的。</li>
<li>四个九之后可能需要建立完善的运维值班体系、故障处理流程和业务变更流程。</li>
<li>五个九之后，故障就不能靠人力恢复了。</li>
</ul>
<blockquote>
<p>一般来说，核心业务系统的可用性，需要达到四个九，非核心系统的可用性最多容忍到三个九</p>
</blockquote>
<h3 id="高可用设计的思路"><a href="#高可用设计的思路" class="headerlink" title="高可用设计的思路"></a>高可用设计的思路</h3><p>一个成熟系统的可用性需要从<strong>系统设计</strong>和<strong>系统运维</strong>两方面来做保障。</p>
<ol>
<li><p>系统设计</p>
<p>在做系统设计的时候，要把发生故障作为一个重要的考虑点，预先考虑如何自动化地发现故障，发生故障之后要如何解决。还需要掌握一些具体的优化方法，比如 <strong>failover（故障转移）、超时控制以及降级和限流。</strong></p>
<ul>
<li><p>故障转移：</p>
<p>一般来说，发生 failover 的节点可能有两种情况：</p>
<ol>
<li><p>是在完全对等的节点之间做 failover。</p>
<p>在这种情况下，如果访问某一个节点失败，那么简单地随机访问另一个节点就好了。</p>
</li>
<li><p>是在不对等的节点之间，即系统中存在主节点也存在备节点。</p>
<p>需要在代码中控制如何检测主备机器是否故障（使用最广泛的故障检测机制是“心跳”），以及如何做主备切换（选主的结果需要在多个备份节点上达成一致，所以会使用某一种分布式一致性算法，比方说 Paxos，Raft。）。</p>
</li>
</ol>
</li>
<li><p>超时控制：</p>
<p>复杂的高并发系统通常会有很多的系统模块组成，同时也会依赖很多的组件和服务，<strong>它们之间的调用最怕的就是延迟而非失败</strong>（因为调用方就会阻塞在这次调用上，它已经占用的资源得不到释放。当存在大量这种阻塞请求时，调用方就会因为用尽资源而挂掉）。</p>
<p>超时时间：<strong>我建议你通过收集系统之间的调用日志，统计比如说 99% 的响应时间是怎样的，然后依据这个时间来指定超时时间。</strong></p>
</li>
<li><p>降级：</p>
<p><strong>降级是为了保证核心服务的稳定而牺牲非核心服务的做法。</strong>所以当并发较高的情况下，它就有可能成为瓶颈，就会对非核心服务进行降级，关闭其服务，保证主体的流程更加稳定。</p>
</li>
<li><p>限流：</p>
<p>它通过对并发的<strong>请求进行限速</strong>来保护系统，对QPS进行限制。</p>
</li>
</ul>
</li>
<li><p>系统运维</p>
<p>在系统运维的层面可以从<strong>灰度发布、故障演练</strong>两个方面来考虑如何提升系统的可用性。</p>
<ul>
<li><p>灰度发布：</p>
<p>灰度发布指的是系统的变更<strong>不是一次性地推到线上的</strong>，而是按照一定比例逐步推进的。</p>
<p><strong>例如：</strong>我们先在 10% 的机器上进行变更，同时观察 Dashboard 上的系统性能指标以及错误日志。如果运行了一段时间之后系统指标比较平稳并且没有出现大量的错误日志，那么再推动全量变更。</p>
</li>
<li><p>故障演练：</p>
<p>故障演练指的是<strong>对系统进行一些破坏性的手段，观察在出现局部故障时，整体的系统表现是怎样的</strong>，从而发现系统中存在的，潜在的可用性问题。</p>
<blockquote>
<p>当然，故障演练是以你的系统可以抵御一些异常情况为前提的。如果你的系统还没有做到这一点，那么我建议你另外搭建一套和线上部署结构一模一样的线下系统，然后在这套系统上做故障演练，从而避免对生产系统造成影响。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="提高系统可扩展性"><a href="#提高系统可扩展性" class="headerlink" title="提高系统可扩展性"></a>提高系统可扩展性</h2><p>高可扩展性是一个设计的指标，它表示可以通过增加机器的方式来线性提高系统的处理能力，从而承担更高的流量和并发。</p>
<h3 id="提高扩展性的困难点"><a href="#提高扩展性的困难点" class="headerlink" title="提高扩展性的困难点"></a>提高扩展性的困难点</h3><p>集群系统中，<strong>不同的系统分层上可能存在一些“瓶颈点”</strong>，这些瓶颈点制约着系统的横向扩展能力。</p>
<p>例如：</p>
<ul>
<li>系统的流量是每秒 1000 次请求，对数据库的请求量也是每秒 1000 次。如果流量增加 10 倍；系统可以通过扩容正常服务，数据库却成了瓶颈。</li>
<li>单机网络带宽是 50Mbps，那么如果扩容到 30 台机器，前端负载均衡的带宽就超过了千兆带宽的限制，也会成为瓶颈点</li>
</ul>
<p>所以<strong>无状态的服务和组件更易于扩展</strong>，而像 MySQL 这种存储服务是有状态的，就比较难以扩展。我们要知道系统并发到了某一个量级之后，哪一个因素会成为我们的瓶颈点，从而针对性地进行扩展（例如<strong>数据库、缓存、依赖的第三方、负载均衡、交换机带宽等等</strong>都是系统扩展时需要考虑的因素）。</p>
<h3 id="高扩展性设计思路"><a href="#高扩展性设计思路" class="headerlink" title="高扩展性设计思路"></a>高扩展性设计思路</h3><p><strong>拆分</strong>是提升系统扩展性最重要的一个思路，它会把庞杂的系统拆分成独立的，有单一职责的模块。</p>
<p><strong>案例：</strong></p>
<p>假如你要设计一个社区，有5大模块：用户、关系、内容、评论、搜索。</p>
<p>并且采用三层部署架构：</p>
<ul>
<li>负载均衡负责请求的分发；</li>
<li>应用服务器负责业务逻辑的处理；</li>
<li>数据库负责数据的存储落地。</li>
</ul>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230419164017552.png" alt="image-20230419164017552" style="zoom:67%;" />

<p><strong>数据库层面的拆分：</strong></p>
<p>假如存储目前的瓶颈点是容量，那么我们只需要针对关系模块的数据做拆分就好了：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230419164256243.png" alt="image-20230419164256243"></p>
<p>这样拆分了，各个库就不会相互干扰；并且如果某个模块仍然超过单机限制，就需要对单模块进行<strong>二次拆分</strong>并且根据情况进行<strong>预分配</strong>避免频繁扩容（这次拆分就要<strong>按照数据特征做水平拆分，按照某算法将数据分到各个库中</strong>）。</p>
<blockquote>
<p><strong>当数据库按照业务和数据维度拆分之后，我们尽量不要使用事务</strong>。因为这个协调的成本会随着资源的扩展不断升高，最终达到无法承受的程度。</p>
</blockquote>
<p><strong>应用层面的拆分：</strong></p>
<p>一般从三个维度考虑拆分：</p>
<ul>
<li><p>业务维度：</p>
<p>就把同一类的业务拆分为一个单独的业务池，按照业务的维度拆分成用户池、内容池、关系池、评论池、点赞池和搜索池。</p>
<p>这样当某个业务遇到了瓶颈只需要<strong>扩展该业务池子以及确定上下游依赖方</strong>就可以了。</p>
</li>
<li><p>重要性维度：</p>
<p>根据业务接口的重要程度拆分，把业务分为<strong>核心池</strong>和<strong>非核心池</strong>。</p>
<p>当整体流量上升时优先扩容核心池，降级部分非核心池的接口，从而保证整体系统的稳定性。</p>
</li>
<li><p>请求来源维度：</p>
<p>还可以根据接入<strong>客户端类型的不同做业务池</strong>的拆分。例如小程序和网页端的拆分。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>设计目标</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发系统通用设计方法</title>
    <url>/2023/11/20/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="高并发系统通用设计方法"><a href="#高并发系统通用设计方法" class="headerlink" title="高并发系统通用设计方法"></a>高并发系统通用设计方法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在应对高并发大流量时主要有三种方法：</p>
<ul>
<li><strong>Scale-out（横向扩展）：</strong>分而治之是一种常见的高并发系统设计方法，采用分布式部署的方式把流量分流开，让每个服务器都承担一部分并发和流量。</li>
<li><strong>缓存：</strong>使用缓存来提高系统的性能，就好比用“拓宽河道”的方式抵抗高并发大流量的冲击。</li>
<li><strong>异步：</strong>在某些场景下，未处理完成之前我们可以让请求先返回，在数据准备好之后再通知请求方，这样可以在单位时间内处理更多的请求。</li>
</ul>
<h2 id="Scale-out（横向扩展）"><a href="#Scale-out（横向扩展）" class="headerlink" title="Scale-out（横向扩展）"></a>Scale-out（横向扩展）</h2><p>这个方案的思想来源于CPU的发展，从单CPU到多核CPU；由于单CPU的工艺无法再有所突破，则将多个 CPU 核心压在一个芯片上，从而大大提升 CPU 的并行处理能力。其中单CPU的性能突破叫做<strong>Scale-up（纵向扩展）</strong>，多核心的思想叫做<strong>Scale-out（横向扩展）</strong>。</p>
<ul>
<li><p>Scale-up（纵向扩展）：</p>
<p>通过不断提高单体性能的思想，比如升级单台服务器硬件。这种方案简单方便。</p>
</li>
<li><p>Scale-out（横向扩展）：</p>
<p>通过将多个低性能的机器组成一个分布式集群来共同抵御高并发流量的冲击。但是引入了多节点管理的问题。</p>
</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存的思想遍布系统设计的每个角落，不管是操作系统、浏览器、数据库等都能看到缓存的影子。使用缓存的主要作用是提升系统的访问性能，在高并发的场景下就可以支撑更多用户的同时访问。</p>
<p><strong>能提升性能的原因在于：</strong>缓存大多都是基于内存级别，远比磁盘IO要快几个数量级，这样能让系统处理更快，提高系统吞吐量。</p>
<h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p><strong>异步</strong>也是一种常见的高并发设计方法。异步调用，调用方不需要等待方法逻辑执行完成就可以返回执行其他的逻辑，在被调用方法执行完毕后再通过回调、事件通知等方式将结果反馈给调用方。</p>
<p>正是因为异步的特性，异步主要用于解决某些响应时间较长，会造成阻塞的方法；防止系统性能严重下降甚至发生雪崩。</p>
<p><strong>异步的方式：</strong>后端处理时会把请求丢到消息队列中，同时快速响应用户，告诉用户我们正在排队处理，然后释放出资源来处理更多的请求。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230410161556656.png" alt="image-20230410161556656"></p>
<blockquote>
<p><strong>一般系统的演进过程应该遵循下面的思路：</strong></p>
<ul>
<li>最简单的系统设计满足业务需求和流量现状，选择最熟悉的技术体系。</li>
<li>随着流量的增加和业务的变化修正架构中存在问题的点，如单点问题、横向扩展问题、性能无法满足需求的组件。在这个过程中，选择社区成熟的、团队熟悉的组件帮助我们解决问题，在社区没有合适解决方案的前提下才会自己造轮子。</li>
<li>当对架构的小修小补无法满足需求时，考虑重构、重写等大的调整方式以解决现有的问题。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>通用设计方法</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理(一)</title>
    <url>/2023/04/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="内存管理（一）"><a href="#内存管理（一）" class="headerlink" title="内存管理（一）"></a>内存管理（一）</h1><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>操作系统需要提供一个易用（easy to use）的物理内存抽象。这个抽象叫作<strong>地址空间（address space）</strong>，是运行的程序看到的系统中的内存。</p>
<p>一个进程的地址空间包含运行的程序的所有内存状态。比如：程序的代码（code，指令）必须在内存中，因此它们在地址空间里。</p>
<p>在程序运行时，地址空间有两个区域可能增长（或者收缩）。它们就是堆（在顶部）和栈（在底部）。堆在代码（1KB）之下开始并向下增长（当用户通过malloc()请求更多内存时），栈从16KB 开始并向上增长（当用户进行程序调用时）。</p>
<p><strong>虚拟化内存</strong></p>
<p>虚拟内存系统负责为程序提供一个巨大的、稀疏的、私有的地址空间的假象，其中保存了程序的所有指令和数据。操作系统在专门硬件的帮助下，<strong>通过每一个虚拟内存的索引，将其转换为物理地址，物理内存根据获得的物理地址但获取所需的信息。</strong></p>
<p>当我们描述地址空间时，所描述的是操作系统提供给运行程序的抽象（abstract）。程序不在物理地址0～16KB 的内存中，而是加载在任意的物理地址。</p>
<p>当操作系统这样做时，我们说操作系统在<strong>虚拟化内存（virtualizing memory）</strong>，因为运行的程序认为它被加载到特定地址的内存中，并且具有非常大的地址空间（例如32 位或64 位）。</p>
<h2 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h2><p>在实现虚拟内存时，我们将追求类似的战略，在实现高效和控制的同时，提供期望的虚拟化。高效决定了我们要利用硬件的支持，这在开始的时候非常初级（如使用一些寄存器），但会变得相当复杂（比如我们会讲到的TLB、页表等）。控制意味着操作系统要确保应用程序只能访问它自己的内存空间。</p>
<p><strong>如何实现高效的内存虚拟化？如何提供应用程序所需的灵活性？如何保持控制应用程序可访问的内存位置，从而确保应用程序的内存访问受到合理的限制？如何高效地实现这一切？</strong></p>
<p>我们利用了一种通用技术，有时被称为<strong>基于硬件的地址转换（hardware-based addresstranslation）</strong>，简称为地址转换（address translation）。它可以看成是受限直接执行这种一般方法的补充。利用地址转换，硬件对每次内存访问进行处理（即指令获取、数据读取或写入），将指令中的<strong>虚拟（virtual）地址转换为数据实际存储的物理（physical）地址</strong>。因此，在每次内存引用时，硬件都会进行地址转换，将应用程序的内存引用重定位到内存中实际的位置。</p>
<ol>
<li><p><strong>动态（基于硬件）重定位</strong></p>
<p>将虚拟地址转换为物理地址，这正是所谓的<strong>地址转换（address translation）技术</strong>。也就是说，硬件<strong>取得进程认为它要访问的地址，将它转换成数据实际位于的物理地址</strong>。由于这种重定位是在运行时发生的，而且我们甚至可以在进程开始运行后改变其地址空间，这种技术一般被称为动态重定位。</p>
<p>具体来说，每个CPU 需要两个硬件寄存器：<strong>基址（base）寄存器</strong>和<strong>界限（bound）寄存器</strong>，有时称为<strong>限制（limit）寄存器</strong>。这组基址和界限寄存器，让我们能够将地址空间放在物理内存的任何位置，同时又能确保进程只能访问自己的地址空间。</p>
<p>该进程产生的所有内存引用，都会被处理器通过以下方式转换为物理地址：<br><code>physical address = virtual address + base</code></p>
<blockquote>
<p>这种基址寄存器配合界限寄存器的硬件结构是芯片中的（每个CPU 一对）。有时我们将CPU 的这个负责地址转换的部分统称为内存管理单元（Memory Management Unit，MMU）。</p>
</blockquote>
</li>
<li><p><strong>硬件上的支持</strong></p>
<p>操作系统在<strong>特权模式</strong>（privileged mode，或<strong>内核模式</strong>，kernel mode），可以访问整个机器资源。应用程序在<strong>用户模式（user mode）</strong>运行，只能做有限的操作。</p>
<p>硬件应该提供一些特殊的指令，用于修改基址寄存器和界限寄存器，允许操作系统在切换进程时改变它们。这些指令是<strong>特权（privileged）指令</strong>，只有在内核模式下，才能修改这些寄存器。</p>
<p>最后，在用户程序尝试非法访问内存（越界访问）时，CPU必须能够产生异常（exception）。在这种情况下，CPU 应该阻止用户程序的执行，并安排操作系统的“越界”异常处理程序（exception handler）去处理。操作系统的处理程序会做出正确的响应，比如在这种情况下终止进程。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230323092748131.png" alt="image-20230323092748131"></p>
</li>
<li><p><strong>操作系统的支持</strong></p>
<p><strong>第一，</strong>在进程创建时，操作系统必须采取行动，为进程的地址空间找到内存空间。当新进程创建时，操<br>作系统检索这个数据结构（常被称为空闲列表，free list），为新地址空间找到位置，并将其标记为已用。</p>
<p><strong>第二，</strong>在进程终止时（正常退出，或因行为不端被强制终止），操作系统也必须做一些工作，回收它的所有内存，给其他进程或者操作系统使用。在进程终止时，操作系统会将这些内存放回到空闲列表，并根据需要清除相关的数据结构。</p>
<p><strong>第三，</strong>在上下文切换时，操作系统也必须执行一些额外的操作。每个CPU 毕竟只有一个基址寄存器和一个界限寄存器，但对于每个运行的程序，它们的值都不同，因为每个程序被加载到内存中不同的物理地址。</p>
<p><strong>第四，</strong>操作系统必须提供异常处理程序（exception handler），或要一些调用的函数，像上面提到的那样。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230323092949390.png" alt="image-20230323092949390"></p>
</li>
</ol>
<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>如果我们将整个地址空间放入物理内存，那么栈和堆之间的空间并没有被进程使用，却依然占用了实际的物理内存。因此，简单的通过基址寄存器和界限寄存器实现的虚拟内存很浪费。另外，如果剩余物理内存无法提供连续区域来放置完整的地址空间，进程便无法运行。</p>
<p>为了解决这个问题，<strong>分段（segmentation）</strong>的概念应运而生。在MMU 中引入不止一个基址和界限寄存器对，而是给地址空间内的每个逻辑段（segment）一对。</p>
<p>分段的机制使得操作系统能够将<strong>不同的段放到不同的物理内存区域</strong>，从而避免了虚拟地址空间中的未使用部分占用物理内存。<br><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230324092723779.png" alt="image-20230324092723779" style="zoom:80%;" /></p>
<p><strong>共享问题</strong></p>
<p>为了支持共享，需要一些额外的硬件支持，这就是保护位（protection bit）。基本为每个段增加了几个位，标识程序是否能够读写该段，或执行其中的代码。通过将代码段标记为只读，同样的代码可以被多个进程共享，而不用担心破坏隔离。虽然每个进程都认为自己独占这块内存，但操作系统秘密地共享了内存，进程不能修改这些内存，所以假象得以保持。</p>
<p><strong>细粒度与粗粒度的分段</strong></p>
<p>到目前为止，我们的例子大多针对只有很少的几个段的系统（即代码、栈、堆）。我们可以认为这种分段是粗粒度的（coarse-grained），因为它将地址空间分成较大的、粗粒度的块。但是，一些早期系统（如Multics[CV65, DD68]）更灵活，允许将地址空间划分为大量较小的段，这被称为细粒度（fine-grained）分段。</p>
<p>支持许多段需要进一步的硬件支持，并在内存中保存某种段表（segment table）。这种段表通常支持创建非常多的段，因此系统使用段的方式，可以比之前讨论的方式更灵活。</p>
<p><strong>出现的问题</strong></p>
<ol>
<li><p>第一个是老问题：操作系统在上下文切换时应该做什么？</p>
<p><strong>解答：</strong>各个段寄存器中的内容必须保存和恢复。显然，每个进程都有自己独立的虚拟地址空间，操作系统必须在进程运行前，确保这些寄存器被正确地赋值。</p>
</li>
<li><p>第二个问题是，物理内存很快充满了许多空闲空间的小洞，因而很难分配给新的段，或扩大已有的段。这种问题被称为外部碎片。</p>
<p><strong>解决方案：</strong>一种更简单的做法是利用<strong>空闲列表管理算法</strong>，试图保留大的内存块用于分配。 </p>
</li>
</ol>
<h2 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h2><p>如果要管理的空闲空间由大小不同的单元构成，管理就变得困难（而且有趣）。这种情况出现在用户级的内存分配库（如malloc()和free()），或者操作系统用分段（segmentation）的方式实现虚拟内存。在这两种情况下，出现了外部碎片（external fragmentation）的问题：</p>
<ul>
<li>空闲空间被分割成不同大小的小块，成为碎片，后续的请求可能失败，因为没有一块足够大的连续空闲空间，即使这时总的空闲空间超出了请求的大小。</li>
</ul>
<h3 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h3><p><strong>分割与合并</strong></p>
<ul>
<li><p>如果请求的空间大小小于某块空闲块。这种情况下，分配程序会执行所谓的<strong>分割（splitting）动作</strong>：它找到一块可以满足请求的空闲空间，将其分割，第一块返回给用户，第二块留在空闲列表中。</p>
</li>
<li><p>在归还一块空闲内存时，仔细查看要归还的内存块的地址以及邻它的空闲空间块。如果新归还的空间与一个原有空闲块相邻（或两个，就像这个例子），就将它们<strong>合并</strong>为一个较大的空闲块。</p>
</li>
</ul>
<p><strong>追踪已分配空间的大小</strong></p>
<p>你可能注意到，free(void *ptr)接口没有块大小的参数。对于给定的指针，内存分配库可以很快确定要释放空间的大小，从而将它放回空闲列表。要完成这个任务，大多数分配程序都会在头块（header）中保存一点额外的信息，它在内存中，通常就在返回的内存块之前。</p>
<p>获得头块的指针后，库可以很容易地确定幻数是否符合预期的值，作为正常性检查，并简单计算要释放的空间大小（即头块的大小加区域长度）</p>
<p><strong>让堆增长</strong></p>
<p>操作系统在执行sbrk 系统调用时，会找到空闲的物理内存页，将它们映射到请求进程的地址空间中去，并返回新的堆的末尾地址。</p>
<h3 id="基本策略"><a href="#基本策略" class="headerlink" title="基本策略"></a>基本策略</h3><p><strong>最优匹配</strong></p>
<p>最优匹配（best fit）策略非常简单：首先遍历整个空闲列表，找到和请求大小一样或更大的空闲块，然后返回这组候选者中最小的一块。这就是所谓的最优匹配（也可以称为最小匹配）。只需要遍历一次空闲列表，就足以找到正确的块并返回。</p>
<p><strong>最差匹配</strong></p>
<p>最差匹配（worst fit）方法与最优匹配相反，它尝试找最大的空闲块，分割并满足用户需求后，将剩余的块（很大）加入空闲列表。最差匹配尝试在空闲列表中保留较大的块，而不是向最优匹配那样可能剩下很多难以利用的小块。</p>
<p><strong>首次匹配</strong></p>
<p>首次匹配（first fit）策略就是找到第一个足够大的块，将请求的空间返回给用户。同样，剩余的空闲空间留给后续请求。</p>
<p><strong>下次匹配</strong></p>
<p>不同于首次匹配每次都从列表的开始查找，下次匹配（next fit）算法多维护一个指针，指向上一次查找结束的位置。</p>
<blockquote>
<p>其他方式：</p>
<p><strong>分离空闲列表</strong></p>
<p>一直以来有一种很有趣的方式叫作分离空闲列表（segregated list）。基本想法很简单：如果某个应用程序经常申请一种（或几种）大小的内存空间，那就用一个独立的列表，只管理这样大小的对象。其他大小的请求都一给更通用的内存分配程序。</p>
<p><strong>伙伴系统</strong></p>
<p>因为合并对分配程序很关键，所以人们设计了一些方法，让合并变得简单，一个好例子就是二分伙伴分配程序（binary buddy allocator）。</p>
<p>在这种系统中，空闲空间首先从概念上被看成大小为2N 的大空间。当有一个内存分配请求时，空闲空间被递归地一分为二，直到刚好可以满足请求的大小（再一分为二就无法满足）。这时，请求的块被返回给用户。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理(三)</title>
    <url>/2023/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E4%B8%89/</url>
    <content><![CDATA[<h1 id="内存管理-三"><a href="#内存管理-三" class="headerlink" title="内存管理(三)"></a>内存管理(三)</h1><h2 id="超越物理内存：机制"><a href="#超越物理内存：机制" class="headerlink" title="超越物理内存：机制"></a>超越物理内存：机制</h2><p>操作系统如何利用大而慢的设备，透明地<strong>提供巨大虚拟地址空间的假象</strong>？</p>
<p>不仅是一个进程，增加交换空间让操作系统为多个并发运行的进程都提供巨大地址空间的假象。</p>
<h3 id="交换空间"><a href="#交换空间" class="headerlink" title="交换空间"></a>交换空间</h3><p>我们要做的第一件事情就是，在硬盘上开辟一部分空间用于物理页的移入和移出。在操作系统中，一般这样的空间称为<strong>交换空间（swap space）</strong>，因为我们将内存中的页交换到其中，并在需要的时候又交换回去。</p>
<p>交换空间的大小是非常重要的，它决定了系统在某一时刻能够使用的最大内存页数。</p>
<h3 id="存在位"><a href="#存在位" class="headerlink" title="存在位"></a>存在位</h3><p>硬件（或操作系统，在软件管理TLB 时）<strong>判断是否在内存中的方法</strong>，是通过页表项中的一条新信息，即存在位（present bit）。如果存在位设置为1，则表示该页存在于物理内存中，并且所有内容都如上所述进行。如果存在位设置为零，则页不在内存中，而在硬盘上。访问不在物理内存中的页，这种行为通常被称为页错误（page fault）。</p>
<p>当TLB 未命中发生的时候有3 种重要情景：</p>
<ol>
<li>第一种情况，该页存在（present）且有效（valid）（第18～21 行）。在这种情况下，TLB 未命中处理程序可以简单地从PTE 中获取PFN，然后重试指令（这次TLB 会命中），并因此继续前面描述的流程。</li>
<li>第二种情况（第22～23 行），页错误处理程序需要运行。虽然这是进程可以访问的合法页（毕竟是有的），但它并不在物理内存中。</li>
<li>第三种情况，访问的是一个无效页，可能由于程序中的错误（第13～14 行）。在这种情况下，PTE 中的其他位都不重要了。硬件捕获这个非法访问，操作系统陷阱处理程序运行，可能会杀死非法进程。</li>
</ol>
<blockquote>
<p>在上面描述的过程中，你可能会注意到，我们假设有足够的空闲内存来从存储交换空间换入（page in）的页。当然，情况可能并非如此。内存可能已满（或接近满了）。因此，操作系统可能希望<strong>先交换出（page out）一个或多个页，以便为操作系统即将交换入的新页留出空间</strong>。选择哪些页被交换出或被替换（replace）的过程，被称为<strong>页交换策略（page-replacementpolicy）</strong>。</p>
</blockquote>
<h3 id="交换何时真正发生"><a href="#交换何时真正发生" class="headerlink" title="交换何时真正发生"></a>交换何时真正发生</h3><p>为了保证有少量的空闲内存，大多数操作系统会设置<strong>高水位线（High Watermark，HW）和低水位线（Low Watermark，LW）</strong>，来帮助决定何时从内存中清除页。原理是这样：当操作系统发现有少于LW 个页可用时，后台负责释放内存的线程会开始运行，直到有HW 个可用的物理页。这个后台线程有时称为交换守护进程（swap daemon）或页守护进程（pagedaemon），它然后会很开心地进入休眠状态，因为它毕竟为操作系统释放了一些内存。</p>
<h2 id="内存页替换策略"><a href="#内存页替换策略" class="headerlink" title="内存页替换策略"></a>内存页替换策略</h2><h3 id="最优替换策略"><a href="#最优替换策略" class="headerlink" title="最优替换策略"></a>最优替换策略</h3><p>Belady展示了一个简单的方法（但遗憾的是，很难实现！），即<strong>替换内存中在最远将来才会被访问到的页</strong>，可以达到缓存未命中率最低。</p>
<blockquote>
<p>遗憾的是，正如我们之前在开发调度策略时所看到的那样，未来的访问是无法知道的，你无法为通用操作系统实现最优策略①。因此，在开发一个真正的、可实现的策略时，我们将聚焦于寻找其他决定把哪个页面踢出的方法。因此，最优策略只能作为比较，知道我们的策略有多接近“完美”。</p>
</blockquote>
<h3 id="简单策略：FIFO"><a href="#简单策略：FIFO" class="headerlink" title="简单策略：FIFO"></a>简单策略：FIFO</h3><p>页在进入系统时，简单地放入一个队列。当发生替换时，<strong>队列尾部的页（“先入”页）被踢出</strong>。FIFO 有一个很大的优势：实现相当简单。</p>
<blockquote>
<p>对比FIFO 和最优策略，FIFO 明显不如最优策略，FIFO 命中率只有36.4%（不包括强制性未命中为57.1%）。先进先出（FIFO）根本无法确定页的重要性：即使页0 已被多次访问，FIFO 仍然会将其踢出，因为它是第一个进入内存的。</p>
</blockquote>
<h3 id="另一简单策略：随机"><a href="#另一简单策略：随机" class="headerlink" title="另一简单策略：随机"></a>另一简单策略：随机</h3><p>另一个类似的替换策略是<strong>随机</strong>，在内存满的时候它随机选择一个页进行替换。随机具有类似于FIFO 的属性。实现我来很简单，但是它在挑选替换哪个页时不够智能。</p>
<h3 id="利用历史数据：LRU"><a href="#利用历史数据：LRU" class="headerlink" title="利用历史数据：LRU"></a>利用历史数据：LRU</h3><p>正如在调度策略所做的那样，为了提高后续的命中率，我们再次通过历史的访问情况作为参考。例如，如果某个程序在过去访问过某个页，则很有可能在不久的将来会再次访问该页。</p>
<p>页替换策略可以使用的一个历史信息是频率（frequency）。<strong>如果一个页被访问了很多次，也许它不应该被替换，因为它显然更有价值</strong>。页更常用的属性是访问的近期性（recency），越近被访问过的页，也许再次访问的可能性也就越大。</p>
<p>系统的每个页有一个使用位，然后这些使用位存储在某个地方（例如，它们可能在每个进程的页表中，或者只在某个数组中）。每当页被引用（即读或写）时，硬件将使用位设置为1。但是，硬件不会清除该位（即将其设置为0），这由操作系统负责。</p>
<p><strong>实现方法：</strong></p>
<p>操作系统如何利用使用位来实现近似LRU？可以有很多方法，有一个简单的方法称作<strong>时钟算法（clock algorithm）</strong>。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230430100109881.png" alt="image-20230430100109881"></p>
<p>Clock算法逻辑如下：</p>
<ol>
<li>每个缓存槽都有一个对应的状态，每当这个缓存槽中的数据被访问后，将状态至为 1，否则为0 （图中用绿色表示状态为1，红色表示状态为0）</li>
<li>使用一个指针A指向下一个将要被淘汰的位置</li>
<li>每次需要淘汰缓存中，从A指针开始，顺时针遍历，找到第一个状态为0的槽，将其淘汰</li>
<li>而B指针会定时顺时针遍历，把所有的缓存槽的状态为都重置为0</li>
</ol>
<blockquote>
<p>时钟算法的一个小修改（最初也由Corbato提出），是对内存中的页是否被修改的额外考虑。这样做的原因是：如果页已被修改（modified）并因此变脏（dirty），则踢出它就必须将它写回磁盘，这很昂贵。如果它没有被修改（因此是干净的，clean），踢出就没成本。物理帧可以简单地重用于其他目的而无须额外的I/O。因此，<strong>一些虚拟机系统更倾向于踢出干净页，而不是脏页。</strong></p>
</blockquote>
<p>当内存就是被超额请求时，操作系统应该做什么，这组正在运行的进程的内存需求是否超出了可用物理内存？</p>
<p>在这种情况下，系统将不断地进行换页，这种情况有时被称为<strong>抖动（thrashing）</strong></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理(二)</title>
    <url>/2023/04/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="内存管理-二"><a href="#内存管理-二" class="headerlink" title="内存管理(二)"></a>内存管理(二)</h1><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>第一种是将空间分割成不同长度的分片，就像虚拟内存管理中的分段。遗憾的是，这个解决方法存在固有的问题。具体来说，将空间切成不同长度的分片以后，空间本身会碎片化（fragmented），随着时间推移，分配内存会变得比较困难。</p>
<p>因此，值得考虑第二种方法：将空间分割成固定长度的分片。在虚拟内存中，我们称这种思想为<strong>分页</strong>。</p>
<p>分页不是将一个进程的地址空间分割成几个不同长度的逻辑段（即代码、堆、段），而是分割成固定大小的单<br>元，每个单元称为一页。相应地，我们把物理内存看成是定长槽块的阵列，叫作页帧（pageframe）。每个这样的页帧包含一个虚拟内存页。</p>
<h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a><strong>组成部分</strong></h3><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230328095945964.png" alt="image-20230328095945964"></p>
<p>为了记录地址空间的每个虚拟页放在物理内存中的位置，操作系统通常为每个进程保存一个数据结构，<strong>称为页表（page table）。页表的主要作用是为地址空间的每个虚拟页面保存地址转换（address translation）</strong>，从而让我们知道每个页在物理内存中的位置。为了转换（translate）该过程生成的虚拟地址，我们必须首先将它分成两个组件：<strong>虚拟页面号（virtual page number，VPN）和页内的偏移量（offset）</strong>。</p>
<p><strong>有效位（valid bit）</strong>通常用于指示特定地址转换是否有效。</p>
<p>我们还可能有<strong>保护位（protection bit）</strong>，表明页是否可以读取、写入或执行。同样，以这些位不允许的方式访问页，会陷入操作系统。还有其他一些重要的部分，但现在我们不会过多讨论。</p>
<p><strong>存在位（present bit）</strong>表示该页是在物理存储器还是在磁盘上（即它已被换出，swapped out）。</p>
<p><strong>参考位（reference bit，也被称为访问位，accessed bit）</strong>有时用于追踪页是否被访问，也用于确定哪些页很受欢迎，因此应该保留在内存中。这</p>
<h2 id="快速地址转换（TLB）"><a href="#快速地址转换（TLB）" class="headerlink" title="快速地址转换（TLB）"></a>快速地址转换（TLB）</h2><p>因为这些映射信息一般存储在物理内存中，所以在转换虚拟地址时，分页逻辑上需要一次额外的内存访问。每次指令获取、显式加载或保存，都要额外读一次内存以得到转换信息，这慢得无法接受。</p>
<p>我们要增加所谓的地址转换旁路缓冲存储器（translation-lookaside buffer），它就是频繁发生的虚拟到物理地址转换的硬件缓存（cache）。因此，更好的名称应该是地址转换缓存（address-translation cache）。</p>
<p>对每次内存访问，硬件先检查TLB，看看其中是否有期望的转换映射，如果有，就完成转换（很快），不用访问页表（其中有全部的转换映射）。</p>
<h3 id="大体流程："><a href="#大体流程：" class="headerlink" title="大体流程："></a><strong>大体流程：</strong></h3><ol>
<li><p>从虚拟地址中提取页号（VPN）</p>
</li>
<li><p>然后检查TLB 是否有该VPN 的转换映射。</p>
<ul>
<li><p>如果有，我们有了TLB 命中（TLB hit），这意味着TLB 有该页的转换映射。成功！接下来我们就可以从相关的TLB 项中取出页帧号（PFN），与原来虚拟地址中的偏移量组合形成期望的物理地址（PA），并访问内存，假定保护检查没有失败。</p>
</li>
<li><p>如果CPU 没有在TLB 中找到转换映射（TLB 未命中），我们有一些工作要做。在硬件访问页表来寻找转换映射，并用该转换映射更新TLB，假设该虚拟地址有效，而且我们有相关的访问权限。当TLB 更新成功后，系统会重新尝试该指令，这时TLB 中有了这个转换映射，内存引用得到很快处理。</p>
</li>
</ul>
</li>
</ol>
<h3 id="TLB的组成："><a href="#TLB的组成：" class="headerlink" title="TLB的组成："></a><strong>TLB的组成：</strong></h3><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230329092645174.png" alt="image-20230329092645174"></p>
<ul>
<li>VPN：虚拟帧号</li>
<li>PEN：物理帧号</li>
<li>TLB 通常有一个有效（valid）位：用来标识该项是不是有效地转换映射。</li>
<li>一个地址空间标识符（Address Space Identifier，ASID）：用于进程切换使用。</li>
<li>通常还有一些保护（protection）位：用来标识该页是否有访问权限。例如，代码页被标识为可读和可执行，而堆的页被标识为可读和可写。</li>
<li>脏位（dirty）：表示该页是否被写入新数据。</li>
<li>全局位（Global，G）：用来指示这个页是不是所有进程全局共享的。</li>
<li>一致性位（Coherence，C）：决定硬件如何缓存该页。</li>
</ul>
<h3 id="替换策略："><a href="#替换策略：" class="headerlink" title="替换策略："></a><strong>替换策略：</strong></h3><ul>
<li>一种常见的策略是替换最近最少使用（least-recently-used，LRU）的项。LRU尝试利用内存引用流中的局部性，假定最近没有用过的项，可能是好的换出候选项。</li>
<li>另一种典型策略就是随机（random）策略，即随机选择一项换出去。</li>
</ul>
<h2 id="较小的表"><a href="#较小的表" class="headerlink" title="较小的表"></a>较小的表</h2><p>我们现在来解决分页引入的第二个问题：页表太大，因此消耗的内存太多。段增加了几个位，标识程序是否能够读写该段，或执行其中的代码。</p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a><strong>解决方案：</strong></h3><ol>
<li><strong>更大的页：</strong>减小页表大小：使用更大的页。这种方法的主要问题在于，大内存页会导致每页内的浪费，这被称为内部碎片（internalfragmentation）问题（因为浪费在分配单元内部）。</li>
<li><strong>混合方法：</strong>分页和分段：解决上述问题的办法是使用分页和分段混合使用，这样就解决了内部碎片的问题了。但是这种杂合导致外部碎片再次出现。</li>
<li><strong>多级页表：</strong>能够离散的分布在内存中，解决了混合方法的外部碎片问题。</li>
<li><strong>反向页表：</strong>一般被视为使用正常的系统内存的TLB的片外扩展。与真正的页表不同，它不需要容纳所有的映射。其中的项代表系统的每个物理页，而不是有许多页表（系统的每个进程一个）。页表项告诉我们哪个进程正在使用此页，以及该进程的哪个虚拟页映射到此物理页。（个人理解为：只存了当前正在运行的所有进程所使用的页地址）</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁</title>
    <url>/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="死锁的条件"><a href="#死锁的条件" class="headerlink" title="死锁的条件"></a>死锁的条件</h2><p>死锁的产生需要如下4 个条件：</p>
<ul>
<li><strong>互斥：</strong>线程对于需要的资源进行互斥的访问（例如一个线程抢到锁）。</li>
<li><strong>持有并等待：</strong>线程持有了资源（例如已将持有的锁），同时又在等待其他资源（例<br>如，需要获得的锁）。</li>
<li><strong>非抢占：</strong>线程获得的资源（例如锁），不能被抢占。</li>
<li><strong>循环等待：</strong>线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这<br>个资源又是下一个线程要申请的。</li>
</ul>
<p>如果这4 个条件的任何一个没有满足，死锁就不会产生。</p>
<h3 id="破坏互斥："><a href="#破坏互斥：" class="headerlink" title="破坏互斥："></a>破坏互斥：</h3><p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如: SPOOLing技术。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。类似于在两者之间加了一个中间层输出进程来进行接收 进程请求。</p>
<h3 id="破坏持有并等待："><a href="#破坏持有并等待：" class="headerlink" title="破坏持有并等待："></a>破坏持有并等待：</h3><p>可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p>
<h3 id="破坏非抢占："><a href="#破坏非抢占：" class="headerlink" title="破坏非抢占："></a>破坏非抢占：</h3><p>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p>
<p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如:剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)</p>
<h3 id="破坏循环等待："><a href="#破坏循环等待：" class="headerlink" title="破坏循环等待："></a>破坏循环等待：</h3><p>可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。</p>
<h2 id="相关算法："><a href="#相关算法：" class="headerlink" title="相关算法："></a>相关算法：</h2><ol>
<li><p>哲学家进餐问题：</p>
<p>筷子是<strong>临界资源</strong>，一段时间只允许一位哲学家使用。为了表示互斥，用一个<strong>信号量</strong>表示一只筷子，五个信号量构成信号量数组。</p>
<p>核心思想解决方法：</p>
<ul>
<li>利用原子思想完成。即只有拿起两支筷子的哲学家才可以进餐，否则，一支筷子也不拿。</li>
<li>奇数号哲学家先拿他左边的筷子，偶数号哲学家先拿他右边的筷子。这样破坏了同方向环路，一个哲学家拿到一只筷子后，就阻止了他邻座的一个哲学家吃饭。</li>
<li>至多允许四位哲学家进餐，将最后一个哲学家停止申请资源，断开环路。</li>
<li>哲学家申请资源总是按照资源序号先大后小的顺序，这样0，3号哲学家先右后左，但是4号哲学家先左后右，改变方向，破坏了环路。</li>
</ul>
</li>
<li><p>银行家算法：</p>
<p>核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p>
</li>
</ol>
<h2 id="死锁检测："><a href="#死锁检测：" class="headerlink" title="死锁检测："></a><strong>死锁检测：</strong></h2><p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程…</p>
<p><strong>则可以画出系统资源图，依次除去顺利执行的线程，如果最终不能消除所有边，则会发生死锁。</strong></p>
<h2 id="解除死锁："><a href="#解除死锁：" class="headerlink" title="解除死锁："></a>解除死锁：</h2><ol>
<li><strong>资源剥夺法：</strong>挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li><strong>撤销进程法（或称终止进程法）：</strong>强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li>
<li><strong>进程回退法：</strong>让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>进程管理(一)</title>
    <url>/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="进程管理（一）"><a href="#进程管理（一）" class="headerlink" title="进程管理（一）"></a>进程管理（一）</h1><h2 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h2><p>进程的非正式定义非常简单：进程就是运行中的程序。程序本身是没有生命周期的，它只是存在磁盘上面的一些指令（也可能是一些静态数据）。是操作系统让这些字节运行起来，让程序发挥作用。</p>
<p><strong>进程状态：</strong></p>
<p>简而言之，进程可以处于以下3 种状态之一：</p>
<ol>
<li>运行（running）：在运行状态下，进程正在处理器上运行。这意味着它正在执行<br>指令。</li>
<li>就绪（ready）：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统<br>选择不在此时运行。</li>
<li>阻塞（blocked）：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件<br>时才会准备运行。一个常见的例子是，当进程向磁盘发起I/O 请求时，它会被阻塞，<br>因此其他进程可以使用处理器。</li>
</ol>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230316220801940.png" alt="image-20230316220801940" style="zoom:50%;" />

<h2 id="虚拟化CPU"><a href="#虚拟化CPU" class="headerlink" title="虚拟化CPU"></a>虚拟化CPU</h2><p><strong>虽然只有少量的物理CPU 可用，但是操作系统如何提供几乎有无数个CPU 可用的假象？</strong></p>
<p>操作系统通过虚拟化（virtualizing）CPU 来提供这种假象。通过让一个进程只运行一个时间片，然后切换到其他进程，操作系统提供了存在多个虚拟CPU 的假象。这就是<strong>时分共享（time sharing）CPU 技术</strong>，允许用户如愿运行多个并发进程。潜在的开销就是性能损失，因为如果CPU 必须共享，每个进程的运行就会慢一点。</p>
<p>要实现CPU 的虚拟化，要实现得好，操作系统就需要一些低级机制以及一些高级智能。我们将低级机制称为机制（mechanism）。机制是一些低级方法或协议，实现了所需的功能。例如，我们稍后将学习如何<strong>实现上下文切换（context switch）</strong>，它让操作系统能够停止运行一个程序，并开始在给定的CPU 上运行另一个程序。所有现代操作系统都采用了这种分时机制。</p>
<blockquote>
<p><strong>时分共享（time sharing）</strong>是操作系统共享资源所使用的最基本的技术之一。通过允许资源由一个实体使用一小段时间，然后由另一个实体使用一小段时间，如此下去，所谓的资源（例如，CPU 或网络链接）可以被许多人共享。时分共享的自然对应技术是空分共享，资源在空间上被划分给希望使用它的人。例如，磁盘空间自然是一个空分共享资源，因为一旦将块分配给文件，在用户删除文件之前，不可能将它分配给其他文件。</p>
</blockquote>
<h2 id="受限直接执行"><a href="#受限直接执行" class="headerlink" title="受限直接执行"></a>受限直接执行</h2><p>在构建这样的虚拟化机制时存在一些挑战：</p>
<ol>
<li><strong>第一个是性能：</strong>如何在不增加系统开销的情况下实现虚拟化？</li>
<li><strong>第二个是控制权：</strong>如何有效地运行进程，同时保留对CPU 的控制？控制权对于操作系统尤为重要，因为操作系统负责资源管理。如果没有控制权，一个进程可以简单地无限制运行并接管机器，或访问没有权限的信息。</li>
</ol>
<p>因此，在保持控制权的同时获得高性能，这是构建操作系统的主要挑战之一。</p>
<p><strong>解决方案：</strong></p>
<p>为了使程序尽可能快地运行，操作系统开发人员想出了一种技术——我们称之为受限的直接执行（limited direct execution）。这个概念的“直接执行”部分很简单：只需直接在CPU上运行程序即可。</p>
<p>因此，当OS 希望启动程序运行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码（从磁盘）加载到内存中，找到入口点（main()函数或类似的），跳转到那里，并开始运行用户的代码。</p>
<blockquote>
<p>但是，这种方法在我们的虚拟化CPU 时产生了一些问题。</p>
<ul>
<li>第一个问题很简单：如果我们只运行一个程序，操作系统怎么能确保程序不做任何我们不希望它做的事，同时仍然高效地运行它？</li>
<li>第二个问题：当我们运行一个进程时，操作系统如何让它停下来并切换到另一个进程，从而实现虚拟化CPU 所需的时分共享？</li>
</ul>
</blockquote>
<p><strong>问题1：受限制的操作：</strong></p>
<p>硬件通过提供不同的执行模式来协助操作系统。在用户模式（user mode）下，应用程序不能完全访问硬件资源。在内核模式（kernel mode）下，操作系统可以访问机器的全部资源。还提供了陷入（trap）内核和从陷阱返回（return-from-trap）到用户模式程序的特别说明，以及一些指令，让操作系统告诉硬件陷阱表（trap table）在内存中的位置。</p>
<p><strong>问题2：在进程之间切换：</strong></p>
<p>如果操作系统没有在CPU 上运行，那么操作系统显然没有办法采取行动。因此，我们遇到了关键问题：<strong>如何重获CPU 的控制权</strong></p>
<p><strong>协作方式：等待系统调用</strong></p>
<p>在协作调度系统中，OS 通过等待系统调用，或某种非法操作发生，从而重新获得CPU 的控制权。</p>
<p><strong>非协作方式：操作系统进行控制</strong></p>
<p>事实证明，没有硬件的额外帮助，如果进程拒绝进行系统调用（也不出错），从而将控制权交还给操作系统，那么操作系统无法做任何事情。事实上，在协作方式中，当进程陷入无限循环时，唯一的办法就是使用古老的解决方案来解决计算机系统中的所有问题——重新启动计算机。</p>
<p>解决方案：<strong>时钟中断</strong></p>
<p>时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时，操作系统重新获得CPU 的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。</p>
<p><strong>保存和恢复上下文</strong></p>
<p>上下文切换在概念上很简单：操作系统要做的就是为当前正在执行的进程保存一些寄存器的值（例如，到它的内核栈），并为即将执行的进程恢复一些寄存器的值（从它的内核栈）。这样一来，操作系统就可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程，而是继续执行另一个进程。</p>
<blockquote>
<p>为了保存当前正在运行的进程的上下文，操作系统会执行一些底层汇编代码，来保存<strong>通用寄存器、程序计数器</strong>，以及当前正在运行的<strong>进程的内核栈指针</strong>，然后恢复寄存器、程序计数器，并切换内核栈，供即将运行的进程使用。通过切换栈，内核在进入切换代码调用时，是一个进程（被中断的进程）的上下文，在返回时，是另一进程（即将执行的进程）的上下文。当操作系统最终执行从陷阱返回指令时，即将执行的进程变成了当前运行的进程。至此上下文切换完成。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>进程管理(二)</title>
    <url>/2023/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="进程管理（二）"><a href="#进程管理（二）" class="headerlink" title="进程管理（二）"></a>进程管理（二）</h3><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>我们还不知道操作系统调度程序采用的上层策略（policy）。接下来会介绍一系列的调度策略（sheduling policy）。</p>
<p><strong>调度指标</strong></p>
<p>相关指标：周转时间（turnaround time）、响应时间（response time）。</p>
<p>T 周转时间= T 完成时间−T 到达时间</p>
<p>T 响应时间= T 首次运行−T 到达时间</p>
<h4 id="基础调度算法"><a href="#基础调度算法" class="headerlink" title="基础调度算法"></a>基础调度算法</h4><p><strong>先进先出（FIFO）</strong></p>
<p>我们可以实现的最基本的算法，被称为先进先出（First In First Out 或FIFO）调度，有时候也称为先到先服务（First Come First Served 或FCFS）。</p>
<p>优点：</p>
<ul>
<li>它很简单，而且易于实现。</li>
</ul>
<p>缺点：</p>
<ul>
<li>存在护航效应：一些耗时较少的潜在资源消费者被排在重量级的资源消费者之后，会等很长时间。</li>
</ul>
<p><strong>最短任务优先（SJF）</strong></p>
<p>策略：先运行最短的任务，然后是次短的任务，如此下去。</p>
<p>优点：</p>
<ul>
<li>改善了平均周转时间和平均带权周转时间，缩短作业的等待时间。</li>
<li>提高系统的吞吐量。</li>
</ul>
<p>缺点：</p>
<ul>
<li>存在护航效应：一些耗时较多的潜在资源消费者被排在轻量级的资源消费者之后，会等很长时间。</li>
<li>未能依据作业的紧迫程度来划分执行的优先级。</li>
</ul>
<p><strong>最短完成时间优先（STCF）</strong></p>
<p>向SJF 添加抢占，称为最短完成时间优先（Shortest Time-to-Completion First，STCF）或抢占式最短作业优先（Preemptive Shortest JobFirst ，PSJF）调度程序。</p>
<p>策略：每当新工作进入系统时，它就会确定剩余工作和新工作中，谁的剩余时间最少，然后调度该工作。</p>
<p>优点：</p>
<ul>
<li>“最短的”平均等待时间、平均周转时间</li>
<li>同样提高系统的吞吐量。</li>
</ul>
<p>缺点：</p>
<ul>
<li>同样存在护航效应：一些耗时较多的潜在资源消费者被排在轻量级的资源消费者之后，会等很长时间。</li>
<li>同样未能依据作业的紧迫程度来划分执行的优先级。</li>
</ul>
<p><strong>时间片轮转</strong></p>
<p>策略：RR 在一个时间片（time slice，有时称为调度量子，schedulingquantum）内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束。它反复执行，直到所有任务完成。</p>
<p>优点：</p>
<ul>
<li>对于所有任务都是公平的。</li>
</ul>
<p>缺点：</p>
<ul>
<li>缺点由于高频率的进程切换,因此会有一定的开销.</li>
<li>同样未能依据作业的紧迫程度来划分执行的优先级。</li>
</ul>
<blockquote>
<p>时间片设得太短会导致过多的进程切换，降低了CPU效率；而设得太长又可能引起对短的交互请求的响应变差。</p>
</blockquote>
<h4 id="高级调度算法"><a href="#高级调度算法" class="headerlink" title="高级调度算法"></a>高级调度算法</h4><p><strong>多级反馈队列</strong></p>
<p>MLFQ 中有许多独立的队列（queue），每个队列有不同的优先级（priority level）。任何时刻，一个工作只能存在于一个队列中。MLFQ 总是优先执行较高优先级的工作（即在较高级队列中的工作）。每个队列中可能会有多个工作，因此具有同样的优先级。在这种情况下，我们就对这些工作采用轮转调度。</p>
<p><strong>其中详细规则：</strong></p>
<ul>
<li> 规则1：如果A 的优先级 &gt; B 的优先级，运行A（不运行B）。</li>
<li> 规则2：如果A 的优先级 = B 的优先级，轮转运行A 和B。</li>
<li> 规则3：工作进入系统时，放在最高优先级（最上层队列）。</li>
<li> 规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。</li>
<li> 规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列。MLFQ 有趣的原因是：它不需要对工作的运行方式有先验知识，而是通过观察工</li>
</ul>
<p><strong>比例份额</strong></p>
<p>比例份额算法基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定比例的CPU 时间，而不是优化周转时间和响应时间。</p>
<p>彩票调度最精彩的地方在于利用了随机性（randomness）。当你需要做出决定时，采用随机的方式常常是既可靠又简单的选择。</p>
<h4 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h4><p>由于计算机的架构师们当时难以让单核CPU 更快，同时又不增加太多功耗，所以这种多核CPU 很快就变得流行。</p>
<p><strong>多处理器架构</strong></p>
<p>为了理解多处理器调度带来的新问题，必须先知道它与单CPU 之间的基本区别。区别的核心在于对硬件缓存（cache）的使用，以及多处理器之间共享数据的方式。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230321092128233.png" alt="image-20230321092128233"></p>
<p><strong>缓存一致性问题：</strong></p>
<p>基本解决方案：</p>
<p>通过监控内存访问，硬件可以保证获得正确的数据，并保证共享内存的唯一性。在基于总线的系统中，一种方式是使用总线窥探（bussnooping）。每个缓存都通过监听链接所有缓存和内存的总线，来发现内存访问。如果CPU 发现对它放在缓存中的数据的更新，会作废（invalidate）本地副本（从缓存中移除），或更新（update）它（修改为新值）。</p>
<p><strong>同步问题：</strong></p>
<p>跨CPU 访问（尤其是写入）共享数据或数据结构时，需要使用互斥原语（比如锁），才能保证正确性（其他方法，如使用无锁（lock-free）数据结构，很复杂，偶尔才使用。</p>
<p>具体来说，随着CPU数量的增加，访问同步共享的数据结构会变得很慢。</p>
<p><strong>调度方式：</strong></p>
<ol>
<li><p>单队列调度</p>
<p>单队列多处理器调度（Single Queue Multiprocessor Scheduling，SQMS）：将所有需要调度的工作放入一个单独的队列中。但是为了保证在多CPU 上正常运行，调度程序的开发者需要在代码中通过加锁（locking）来保证原子性。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230321094004237.png" alt="image-20230321094004237"></p>
</li>
<li><p>多队列调度</p>
<p>正是由于单队列调度程序的这些问题，有些系统使用了多队列的方案，比如每个CPU一个队列。这样一来，每个CPU 调度之间相互独立，就避免了单队列的方式中由于数据共享及同步带来的问题。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230321094031010.png" alt="image-20230321094031010"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/2021/03/11/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于只是因重复而导致使用无法令人接受的大量内存的大量物件。主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。（例如各种池技术就是使用的享元模式）</p>
<h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><h3 id="2-1代码"><a href="#2-1代码" class="headerlink" title="2.1代码"></a>2.1代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 设计模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FlyweightFactory factory = <span class="keyword">new</span> FlyweightFactory();</span><br><span class="line">        Flyweight f01 = factory.getFlyweight(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Flyweight f02 = factory.getFlyweight(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Flyweight f03 = factory.getFlyweight(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Flyweight f11 = factory.getFlyweight(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        Flyweight f12 = factory.getFlyweight(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        f01.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第1次调用a。&quot;</span>));</span><br><span class="line">        f02.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第2次调用a。&quot;</span>));</span><br><span class="line">        f11.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第1次调用b。&quot;</span>));</span><br><span class="line">        f12.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第2次调用b。&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非享元外部信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsharedConcreteFlyweight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line">    UnsharedConcreteFlyweight(String info) &#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象享元对象</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight state)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体享元对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    ConcreteFlyweight(String key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体享元&quot;</span> + key + <span class="string">&quot;被创建！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight outState)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;具体享元&quot;</span> + key + <span class="string">&quot;被调用，&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;非享元信息是:&quot;</span> + outState.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//享元工厂角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Flyweight&gt; flyweights = <span class="keyword">new</span> HashMap&lt;String, Flyweight&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Flyweight flyweight = (Flyweight) flyweights.get(key);</span><br><span class="line">        <span class="keyword">if</span> (flyweight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体享元&quot;</span> + key + <span class="string">&quot;已经存在，被成功获取！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flyweight = <span class="keyword">new</span> ConcreteFlyweight(key);</span><br><span class="line">            flyweights.put(key, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-优点"><a href="#3-优点" class="headerlink" title="3.优点"></a>3.优点</h2><ul>
<li>相同对象只要保存一份，这降低了系统中对象的数量，大大减少对象的创建，降低系统的内存，使效率提高。</li>
</ul>
<h2 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4.缺点"></a>4.缺点</h2><ul>
<li>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。</li>
<li>读取享元模式的外部状态会使得运行时间稍微变长。</li>
</ul>
<h2 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5.使用场景"></a>5.使用场景</h2><ul>
<li>当系统中多处需要同一组信息时，可以把这些信息封装到一个对象中，然后对该对象进行缓存，这样，一个对象就可以提供给多出需要使用的地方，避免大量同一对象的多次创建，降低大量内存空间的消耗。</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>享元模式</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2021/03/09/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>
<h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><h3 id="2-1代码"><a href="#2-1代码" class="headerlink" title="2.1代码"></a>2.1代码</h3><ol>
<li><p>静态代理：静态代理中，我们对目标对象的每个方法的增强都是手动完成的，十分不灵活；从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 设计模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPattern01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IphoneProxy iphoneProxy = <span class="keyword">new</span> IphoneProxy(<span class="keyword">new</span> IphoneFactoryImpl());</span><br><span class="line">        iphoneProxy.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务类接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IphoneFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IphoneFactoryImpl</span> <span class="keyword">implements</span> <span class="title">IphoneFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;厂家直销&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IphoneProxy</span> <span class="keyword">implements</span> <span class="title">IphoneFactory</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IphoneFactoryImpl impl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IphoneProxy</span><span class="params">(IphoneFactoryImpl impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.impl=impl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我来代理&quot;</span>);</span><br><span class="line">        impl.create();</span><br><span class="line">        System.out.println(<span class="string">&quot;有优惠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>动态代理：相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类；从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</p>
</li>
</ol>
<ul>
<li><p>使用JDK动态代理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPattern02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 动态代理：</span></span><br><span class="line"><span class="comment">         *  特点：字节码随用随创建，随用随加载</span></span><br><span class="line"><span class="comment">         *  作用：不修改源码的基础上对方法增强</span></span><br><span class="line"><span class="comment">         *  分类：</span></span><br><span class="line"><span class="comment">         *      基于接口的动态代理</span></span><br><span class="line"><span class="comment">         *      基于子类的动态代理</span></span><br><span class="line"><span class="comment">         *  基于接口的动态代理：</span></span><br><span class="line"><span class="comment">         *      涉及的类：Proxy</span></span><br><span class="line"><span class="comment">         *      提供者：JDK官方</span></span><br><span class="line"><span class="comment">         *  如何创建代理对象：</span></span><br><span class="line"><span class="comment">         *      使用Proxy类中的newProxyInstance方法</span></span><br><span class="line"><span class="comment">         *  创建代理对象的要求：</span></span><br><span class="line"><span class="comment">         *      被代理类最少实现一个接口，如果没有则不能使用</span></span><br><span class="line"><span class="comment">         *  newProxyInstance方法的参数：</span></span><br><span class="line"><span class="comment">         *      ClassLoader：类加载器</span></span><br><span class="line"><span class="comment">         *          它是用于加载代理对象字节码的。和被代理对象使用相同的类加载器。固定写法。</span></span><br><span class="line"><span class="comment">         *      Class[]：字节码数组</span></span><br><span class="line"><span class="comment">         *          它是用于让代理对象和被代理对象有相同方法。固定写法。</span></span><br><span class="line"><span class="comment">         *      InvocationHandler：用于提供增强的代码</span></span><br><span class="line"><span class="comment">         *          它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。</span></span><br><span class="line"><span class="comment">         *          此接口的实现类都是谁用谁写。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),</span><br><span class="line">                producer.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 作用：执行被代理对象的任何接口方法都会经过该方法</span></span><br><span class="line"><span class="comment">                     * 方法参数的含义</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> proxy   代理对象的引用</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> method  当前执行的方法</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> args    当前执行方法所需的参数</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span>        和被代理对象方法有相同的返回值</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="comment">//提供增强的代码</span></span><br><span class="line">                        Object returnValue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//1.获取方法执行的参数</span></span><br><span class="line">                        Float money = (Float)args[<span class="number">0</span>];</span><br><span class="line">                        <span class="comment">//2.判断当前方法是不是销售</span></span><br><span class="line">                        <span class="keyword">if</span>(<span class="string">&quot;saleProduct&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">                            returnValue = method.invoke(producer, money*<span class="number">0.8f</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        proxyProducer.saleProduct(<span class="number">10000f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对生产厂家要求的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销售</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 售后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterService</span><span class="params">(<span class="keyword">float</span> money)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">IProducer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销售</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销售产品，并拿到钱：&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 售后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterService</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提供售后服务，并拿到钱：&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>必须实现接口的原因：</strong>JDK动态代理会在程序运行期间，去动态生产一个代理类，叫$Proxy0 ,那么这个动态生成的代理类会去继承一个 java.lang.reflect.Proxy 这样一个类，同时还会去实现被代理类的接口，在java里面不支持多种继承的，而每个动态代理都继承一个Proxy，所以就导致的JDK里面的动态代理只能代理接口，而不能代理实现类。</p>
</blockquote>
</li>
<li><p>CGLIB代理：CGLIB 是一个基于ASM的字节码生成库，它允许我们在<strong>运行时对字节码进行修改和动态生成</strong>。CGLIB 通过<strong>继承方式</strong>实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPattern03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 动态代理：</span></span><br><span class="line"><span class="comment">         *  特点：字节码随用随创建，随用随加载</span></span><br><span class="line"><span class="comment">         *  作用：不修改源码的基础上对方法增强</span></span><br><span class="line"><span class="comment">         *  分类：</span></span><br><span class="line"><span class="comment">         *      基于接口的动态代理</span></span><br><span class="line"><span class="comment">         *      基于子类的动态代理</span></span><br><span class="line"><span class="comment">         *  基于子类的动态代理：</span></span><br><span class="line"><span class="comment">         *      涉及的类：Enhancer</span></span><br><span class="line"><span class="comment">         *      提供者：第三方cglib库</span></span><br><span class="line"><span class="comment">         *  如何创建代理对象：</span></span><br><span class="line"><span class="comment">         *      使用Enhancer类中的create方法</span></span><br><span class="line"><span class="comment">         *  创建代理对象的要求：</span></span><br><span class="line"><span class="comment">         *      被代理类不能是最终类</span></span><br><span class="line"><span class="comment">         *  create方法的参数：</span></span><br><span class="line"><span class="comment">         *      Class：字节码</span></span><br><span class="line"><span class="comment">         *          它是用于指定被代理对象的字节码。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      Callback：用于提供增强的代码</span></span><br><span class="line"><span class="comment">         *          它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。</span></span><br><span class="line"><span class="comment">         *          此接口的实现类都是谁用谁写。</span></span><br><span class="line"><span class="comment">         *          我们一般写的都是该接口的子接口实现类：MethodInterceptor</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Producer cglibProducer = (Producer)Enhancer.create(producer.getClass(), <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行对象的任何方法都会经过该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">             *    以上三个参数和基于接口的动态代理中invoke方法的参数是一样的</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> methodProxy ：当前执行方法的代理对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">//提供增强的代码</span></span><br><span class="line">                Object returnValue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//1.获取方法执行的参数</span></span><br><span class="line">                Float money = (Float)args[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">//2.判断当前方法是不是销售</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;saleProduct&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">                    returnValue = method.invoke(producer, money*<span class="number">0.8f</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        cglibProducer.saleProduct(<span class="number">12000f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销售</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销售产品，并拿到钱：&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 售后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterService</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提供售后服务，并拿到钱：&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CGLIB代理相比JDK动态代理：</p>
<ol>
<li>性能更高：CGLIB代理通常比JDK代理更快，因为它直接操作字节码，<strong>而不是反射调用</strong>。这在需要频繁调用代理方法的情况下可以提供显著的性能优势。</li>
<li>支持无接口的代理：CGLIB可以代理没有实现接口的类，而JDK代理要求目标对象必须实现接口。</li>
<li>更强大的代理功能：CGLIB代理可以代理普通类，包括final类和不能被继承的类，而JDK代理不能代理这些类。这意味着您可以使用CGLIB代理更广泛地代理各种对象。</li>
<li>CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="3-优点"><a href="#3-优点" class="headerlink" title="3.优点"></a>3.优点</h2><ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性</li>
</ul>
<h2 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4.缺点"></a>4.缺点</h2><ul>
<li>代理模式会造成系统设计中类的数量增加</li>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度；</li>
</ul>
<h2 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5.使用场景"></a>5.使用场景</h2><ul>
<li>当无法或不想直接引用某个对象或访问某个对象存在困难时，可以通过代理对象来间接访问。使用代理模式主要有两个目的：一是保护目标对象，二是增强目标对象。</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2021/03/03/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>单例模式，属于创建类型的一种常用的设计模式。通过单例模式的方法创建的类在当前进程中只有一个实例，保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><h3 id="2-1常用实现方式"><a href="#2-1常用实现方式" class="headerlink" title="2.1常用实现方式"></a>2.1常用实现方式</h3><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Instace</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Instace.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    一般情况下，建议使用饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用静态内部类方式。如果涉及到反序列化创建对象时，可以尝试使用枚举方式。如果有其他特殊的需求，可以考虑使用双检锁方式。</p>
<h2 id="3-优点"><a href="#3-优点" class="headerlink" title="3.优点"></a>3.优点</h2><ul>
<li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>避免对资源的多重占用（比如写文件操作）。</li>
</ul>
<h2 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4.缺点"></a>4.缺点</h2><p>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<h2 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5.使用场景"></a>5.使用场景</h2><ul>
<li><p>要求生产唯一序列号。</p>
</li>
<li><p>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</p>
</li>
<li><p>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/2021/03/12/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。</p>
<h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><h3 id="2-1代码"><a href="#2-1代码" class="headerlink" title="2.1代码"></a>2.1代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 设计模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadePattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">        facade.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外观类 集成了多个子系统类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SubSystem01 obj1 = <span class="keyword">new</span> SubSystem01();</span><br><span class="line">    <span class="keyword">private</span> SubSystem02 obj2 = <span class="keyword">new</span> SubSystem02();</span><br><span class="line">    <span class="keyword">private</span> SubSystem03 obj3 = <span class="keyword">new</span> SubSystem03();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统01的method1()被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统02的method2()被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统03的method3()被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-优点"><a href="#3-优点" class="headerlink" title="3.优点"></a>3.优点</h2><ul>
<li>实现了子系统与客户端之间的松耦合关系，提高灵活性，提高了安全性。</li>
<li>客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。</li>
</ul>
<h2 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4.缺点"></a>4.缺点</h2><ul>
<li>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</li>
</ul>
<h2 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5.使用场景"></a>5.使用场景</h2><ul>
<li>设计初期阶段，应该有意识的将不同层分离，层与层之间建立外观模式。</li>
<li>开发阶段，子系统越来越复杂，增加外观模式提供一个简单的调用接口。</li>
<li>维护一个大型遗留系统的时候，可能这个系统已经非常难以维护和扩展，但又包含非常重要的功能，为其开发一个外观类，以便新系统与其交互。</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>外观模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/2021/03/01/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>工厂方法模式（FACTORY METHOD）是一种常用的类<strong>创建型</strong>设计模式，意义是定义一个创建产品对象的工厂接口，将实际创建工作<strong>推迟到子类当中</strong>。“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p>
<h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><h3 id="2-1类图"><a href="#2-1类图" class="headerlink" title="2.1类图"></a>2.1类图</h3><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/161457850443.png" alt="161457850443"></p>
<h3 id="2-2代码"><a href="#2-2代码" class="headerlink" title="2.2代码"></a>2.2代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 设计模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethodPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Water water = <span class="keyword">new</span> DrinksFactory().createWater();</span><br><span class="line">        Water water1 = <span class="keyword">new</span> SodaWaterFactory().createWater();</span><br><span class="line">        water.show();</span><br><span class="line">        water1.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象产品:提供产品接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">Water</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drinks</span> <span class="keyword">implements</span> <span class="title">Water</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;我是饮料&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SodaWater</span> <span class="keyword">implements</span> <span class="title">Water</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是苏打水&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象工厂：提供生成产品接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Water <span class="title">createWater</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体的子工厂A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DrinksFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Water <span class="title">createWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;饮料生产中.......&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Drinks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体的子工厂B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SodaWaterFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Water <span class="title">createWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;苏打水生产中.......&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SodaWater();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-优点"><a href="#3-优点" class="headerlink" title="3.优点"></a>3.优点</h2><ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</li>
<li>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。</li>
<li>典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</li>
</ul>
<h2 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4.缺点"></a>4.缺点</h2><ul>
<li>类的个数容易过多，增加复杂度</li>
<li>增加了系统的抽象性和理解难度</li>
<li>抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。</li>
</ul>
<h2 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5.使用场景"></a>5.使用场景</h2><ul>
<li><p>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</p>
</li>
<li><p>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。</p>
</li>
<li><p>客户不关心创建产品的细节，只关心产品的品牌</p>
</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂方法</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/2021/03/02/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>抽象工厂模式（Abstract Factory Pattern）隶属于设计模式中的<strong>创建型</strong>模式，用于产品族的构建。抽象工厂模式可以向客户端提供一个<strong>接口</strong>，使客户端在<strong>不必指定产品的具体情况下，创建多个产品族中的产品对象。</strong>可以看做是简单工厂的改进(或进一步抽象)。</p>
<h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><h3 id="2-1类图"><a href="#2-1类图" class="headerlink" title="2.1类图"></a>2.1类图</h3><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/161468748894.png" alt="161468748894"></p>
<h3 id="2-2代码"><a href="#2-2代码" class="headerlink" title="2.2代码"></a>2.2代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 设计模式;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wht</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CdFactory cdFactory = <span class="keyword">new</span> CdFactory();</span><br><span class="line">        ScFactory scFactory = <span class="keyword">new</span> ScFactory();</span><br><span class="line">        Pizza sausage = cdFactory.getPizza(<span class="string">&quot;Sausage&quot;</span>);</span><br><span class="line">        Pizza cheese = scFactory.getPizza(<span class="string">&quot;Cheese&quot;</span>);</span><br><span class="line">        System.out.println(sausage);</span><br><span class="line">        System.out.println(cheese);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象产品接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 准备材料</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 烹饪pizza</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 成都香肠披萨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CdSausagePizza</span> <span class="keyword">implements</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备香肠&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;准备面粉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始加工香肠pizza&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 成都奶酪披萨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CdCheesePizza</span> <span class="keyword">implements</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备奶酪&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;准备面粉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始加工奶酪pizza&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 四川香肠披萨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScSausagePizza</span> <span class="keyword">implements</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备香肠&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;准备面粉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始加工香肠pizza&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 四川奶酪披萨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScCheesePizza</span> <span class="keyword">implements</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备奶酪&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;准备面粉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始加工奶酪pizza&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbsFactory</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得披萨</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Pizza <span class="title">getPizza</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体工厂类1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CdFactory</span> <span class="keyword">implements</span> <span class="title">AbsFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">getPizza</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(name.equals(<span class="string">&quot;Sausage&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> CdSausagePizza();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(name.equals(<span class="string">&quot;Cheese&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> CdCheesePizza();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体工厂类2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScFactory</span> <span class="keyword">implements</span> <span class="title">AbsFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">getPizza</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(name.equals(<span class="string">&quot;Sausage&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> ScSausagePizza();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(name.equals(<span class="string">&quot;Cheese&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> ScCheesePizza();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="3-优点"><a href="#3-优点" class="headerlink" title="3.优点"></a>3.优点</h2><ul>
<li>分离了具体的类。客户通过抽象接口操纵实例，产品的类名也在具体工厂的实现中被分离，它们不出现在客户代码中。</li>
<li>易于交换产品系列。一个具体工厂类只在初始化时出现一次，这使得改变一个应用的具体工厂变得很容易，只需改变具体的工厂即可使用不同的产品配置。</li>
<li>有利于产品的一致性。当一个系列的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要，而抽象工厂很容易实现这一点。</li>
</ul>
<h2 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4.缺点"></a>4.缺点</h2><ul>
<li>难以支持新种类的产品。因为抽象工厂接口确定了可以被创建的产品集合，所以难以扩展抽象工厂以生产新种类的产品。</li>
</ul>
<h2 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5.使用场景"></a>5.使用场景</h2><ul>
<li>当需要创建的对象是一系列相互关联或相互依赖的产品族时。</li>
<li>系统中有多个产品族，但每次只使用其中的某一族产品。</li>
<li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>抽象工厂</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2021/03/14/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>桥接模式是将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(interface)模式。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><h3 id="2-1代码"><a href="#2-1代码" class="headerlink" title="2.1代码"></a>2.1代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 设计模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgePattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Implementor imple = <span class="keyword">new</span> ConcreteImplementorA();</span><br><span class="line">        Abstraction abs = <span class="keyword">new</span> RefinedAbstraction(imple);</span><br><span class="line">        abs.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体实现化(Concrete Implementor)角色被访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象化角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Implementor imple;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Abstraction</span><span class="params">(Implementor imple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.imple = imple;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展抽象化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor imple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(imple);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扩展抽象化(Refined Abstraction)角色被访问&quot;</span>);</span><br><span class="line">        imple.OperationImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-优点"><a href="#3-优点" class="headerlink" title="3.优点"></a>3.优点</h2><ul>
<li>抽象与实现分离，扩展能力强</li>
<li>符合开闭原则</li>
<li>符合合成复用原则</li>
<li>其实现细节对客户透明</li>
</ul>
<h2 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4.缺点"></a>4.缺点</h2><ul>
<li>由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。</li>
</ul>
<h2 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5.使用场景"></a>5.使用场景</h2><ul>
<li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li>
<li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li>
<li>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>桥接模式</tag>
      </tags>
  </entry>
  <entry>
    <title>模板方法模式</title>
    <url>/2021/03/06/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>在模板模式（Template Pattern）中，定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</p>
<h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><h3 id="2-1代码"><a href="#2-1代码" class="headerlink" title="2.1代码"></a>2.1代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 设计模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethodPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractClass abstractClass = <span class="keyword">new</span> ConcreteClass();</span><br><span class="line">        abstractClass.TemplateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象模板类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span></span>&#123;</span><br><span class="line">    <span class="comment">//模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TemplateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SpecificMethod();</span><br><span class="line">        abstractMethod1();</span><br><span class="line">        abstractMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//具体方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象类中的具体方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象方法1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//抽象方法2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法1的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法2的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-优点"><a href="#3-优点" class="headerlink" title="3.优点"></a>3.优点</h2><ul>
<li>利用模板方法将相同处理逻辑的代码放到抽象父类中，可以提高代码的复用性。</li>
<li>将不同的代码不同的子类中，通过对子类的扩展增加新的行为，提高代码的扩展性。</li>
<li>把不变的行为写在父类上，去除子类的重复代码，提供了一个很好的代码复用平台，符合开闭原则。</li>
</ul>
<h2 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4.缺点"></a>4.缺点</h2><ul>
<li>类数目的增加，每一个抽象类都需要一个子类来实现，这样导致类的个数增加。</li>
<li>类数量的增加，间接地增加了系统实现的复杂度。</li>
<li>继承关系自身缺点，如果父类添加新的抽象方法，所有子类都要改一遍。</li>
</ul>
<h2 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5.使用场景"></a>5.使用场景</h2><ul>
<li> 有多个子类共有的方法，且逻辑相同。</li>
<li> 重要的、复杂的方法，可以考虑作为模板方法。</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>模板方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2021/03/13/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p>
<h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><h3 id="2-1代码"><a href="#2-1代码" class="headerlink" title="2.1代码"></a>2.1代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 设计模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context c = <span class="keyword">new</span> Context();</span><br><span class="line">        c.setStrategy(<span class="keyword">new</span> ConcreteStrategyA());</span><br><span class="line">        c.strategyMethod();</span><br><span class="line">        c.setStrategy(<span class="keyword">new</span> ConcreteStrategyB());</span><br><span class="line">        c.strategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象策略类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span></span>;    <span class="comment">//策略方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类A..</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略A的策略方法被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类B...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略B的策略方法被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Strategy <span class="title">getStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy.strategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-优点"><a href="#3-优点" class="headerlink" title="3.优点"></a>3.优点</h2><ul>
<li>多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句，如 if…else 语句、switch…case 语句。</li>
<li>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。</li>
<li>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。</li>
<li>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。</li>
<li>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</li>
</ul>
<h2 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4.缺点"></a>4.缺点</h2><ul>
<li>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。</li>
<li>策略模式造成很多的策略类，增加维护难度。</li>
</ul>
<h2 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5.使用场景"></a>5.使用场景</h2><ul>
<li> 多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。</li>
<li> 需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。</li>
<li> 对客户隐藏具体策略(算法)的实现细节，彼此完全独立。</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>简单工厂模式</title>
    <url>/2021/02/27/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，简而言之就是提供一个<strong>工厂</strong>接收不同的<strong>参数</strong>来提供不同的<strong>对象</strong>。</p>
<h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><h3 id="2-1类图"><a href="#2-1类图" class="headerlink" title="2.1类图"></a>2.1类图</h3><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/161441395090.png" alt="161441395090"></p>
<h3 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 设计模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactoryPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shoes nike = SimpleFactory.getShoes(<span class="string">&quot;Nike&quot;</span>);</span><br><span class="line">        nike.createShoes();</span><br><span class="line">        Shoes adidas = SimpleFactory.getShoes(<span class="string">&quot;Adidas&quot;</span>);</span><br><span class="line">        adidas.createShoes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象的产品类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shoes</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">createShoes</span><span class="params">()</span></span>;<span class="comment">//具体如何造鞋的业务逻辑，留给具体子类实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的实现类1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NikeShoes</span> <span class="keyword">extends</span> <span class="title">Shoes</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createShoes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//具体逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我是nike厂家&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;先这样...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;再这样...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的实现类2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdidasShoes</span> <span class="keyword">extends</span> <span class="title">Shoes</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createShoes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//具体逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我是Adidas厂家&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;先这样...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;再这样...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shoes <span class="title">getShoes</span><span class="params">(String arg)</span></span>&#123;</span><br><span class="line">        Shoes shoes = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(arg.equals(<span class="string">&quot;Nike&quot;</span>))&#123;</span><br><span class="line">            shoes = <span class="keyword">new</span> NikeShoes();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arg.equals(<span class="string">&quot;Adidas&quot;</span>))&#123;</span><br><span class="line">            shoes = <span class="keyword">new</span> AdidasShoes();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shoes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-优点"><a href="#3-优点" class="headerlink" title="3.优点"></a>3.优点</h2><p>比较容易理解，操作简单,外界只需要提供指定参数就可以，无需究竟如何创建及如何组织的。明确了各自的职责和权利，有利于整个软件体系结构优化。</p>
<h2 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4.缺点"></a>4.缺点</h2><p>违背了设计模式的ocp(对扩展开放,对修改关闭)原则.</p>
<h2 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5.使用场景"></a>5.使用场景</h2><ul>
<li><p>工厂类负责创建的对象比较少；</p>
</li>
<li><p>并会大量的创建某种或某批对象时</p>
</li>
<li><p>客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>简单工厂</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2021/03/04/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>观察者模式（有时又被称为模型（Model）-视图（View）模式、源-收听者(Listener)模式或从属者模式),在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。</p>
<h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><h3 id="2-1类图"><a href="#2-1类图" class="headerlink" title="2.1类图"></a>2.1类图</h3><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20210301184421521.png" alt="image-20210301184421521"></p>
<h3 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 设计模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ring ring = <span class="keyword">new</span> OverClassRing();</span><br><span class="line">        Student student1 = <span class="keyword">new</span> MiddleSchoolStudent();</span><br><span class="line">        Student student2 = <span class="keyword">new</span> collegeStudent();</span><br><span class="line">        ring.add(student1);</span><br><span class="line">        ring.add(student2);</span><br><span class="line">        ring.notice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象目标:铃声</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Ring</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">        students.add(student);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">        students.remove(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体目标:下课铃声</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverClassRing</span> <span class="keyword">extends</span> <span class="title">Ring</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">            student.response();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象观察者：学生</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1:大学生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">collegeStudent</span> <span class="keyword">implements</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;高数课下课了，我们会寝室学习吧(玩耍)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者2:中学生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiddleSchoolStudent</span> <span class="keyword">implements</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;语文课下课了，我们开始预习下节数学课吧&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-优点"><a href="#3-优点" class="headerlink" title="3.优点"></a>3.优点</h2><p>观察者模式解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。</p>
<h2 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4.缺点"></a>4.缺点</h2><p>在应用观察者模式时需要考虑一下开发小路问题，程序中包括一个被观察者和多个被观察者，开发和调试比较复杂，而且Java中的消息的通知默认是顺序执行的，一个观察者的卡顿会影响整体的执行效率。在这种情况下，一般考虑采用异步的方式。</p>
<h2 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5.使用场景"></a>5.使用场景</h2><ul>
<li><p>当一个抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</p>
</li>
<li><p>当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象需要被改变。</p>
</li>
<li><p>当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，不希望这些对象是紧密耦合的。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式总结</title>
    <url>/2023/04/17/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230306212145386.png" alt="image-20230306212145386"></p>
<h3 id="模式分类"><a href="#模式分类" class="headerlink" title="模式分类"></a>模式分类</h3><ul>
<li><p>创建型： 在创建对象的同时隐藏创建逻辑，不使⽤ new 直接实例化对象，程序在判断需要创建哪些对象时更灵活。包括⼯⼚/抽象⼯⼚/单例/建造者/原型模式。</p>
</li>
<li><p>结构型： 通过类和接⼝间的继承和引⽤实现创建复杂结构的对象。包括适配器/桥接模式/过滤器/组合/装饰器/外观/享元/代理模式。</p>
</li>
<li><p>⾏为型： 通过类之间不同通信⽅式实现不同⾏为。包括责任链/命名/解释器/迭代器/中介者/备忘录/观察者/状态/策略/模板/访问者模式。</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230306212410826.png" alt="image-20230306212410826"></p>
<blockquote>
<p><strong>创建型：</strong></p>
<ul>
<li><p>单例模式</p>
<ul>
<li>注意双重检查锁里面的volatile（提供可⻅性、禁⽌指令重排序）</li>
</ul>
</li>
<li><p>各种工厂模式（简单工厂、工厂方法、抽象工厂）</p>
<ul>
<li><p>简单工厂模式：根据参数不同，创建不同的类（类属于同一大类即同一接口或者父类）</p>
<ul>
<li>例子：java中的DateFormat</li>
</ul>
</li>
<li><p>工厂方法模式：与简单工厂相比，具体商品交给子工厂去完成，将产品实例化操作延迟到工厂子类去做。好处在于需要新增商品就新增子工厂即可。</p>
<ul>
<li>例子：Collection中的Iterator迭代器对象的生产过程</li>
</ul>
</li>
<li><p>抽象工厂模式：对工厂方法模式再优化，不像工厂方法只能生产一大类的产品，可以生产其他大类的产品。在父亲工厂中新增产品体系即可。（缺点违反开闭原则）</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230309152331523.png" alt="image-20230309152331523" style="zoom: 50%;" />
</li>
</ul>
</li>
<li><p>建造者模式：以详细的步骤创建复杂对象。将构造的方法不应该放在类的构造函数里面，应该抽取出来放在专门的建造者里面，（如果过于复杂可以添加主管类，并由主管类来管理调用哪些方法。）</p>
</li>
<li><p>原型模式：解决复制对象的问题，对对象进行克隆。</p>
<ul>
<li>浅克隆用java再带的clonable接口的clone方法</li>
<li>深克隆，在clone方法里面new一个新对象</li>
</ul>
</li>
</ul>
<p><strong>结构型：</strong></p>
<ul>
<li>适配器：类似于充电器，使两个不兼容的东西兼容到一起，提供接口转换，与装饰者不一样的是并不是对原有接口进行修改加强。</li>
<li>桥接模式：将继承关系转换为关联关系，从而降低类与类的耦合，减少了代码的编码量</li>
<li>装饰者：动态地给一个对象添加一些额外的功能。就增加功能来说，装饰模式比生成子类更为灵活。</li>
<li>代理模式：代理模式的本质是⼀个中间件，主要目的是解耦合服务提供者和使用者。使用者通过代理间接的访问服务提供者，便于后者的封装和控制。主要有静态代理，JDK继承式的动态代理，CGLIB基于接口动态代理</li>
<li>外观模式：对现有的系统添加一个新街口，来隐藏系统的复杂性即对负责方法进行封装。</li>
<li>享元模式：典型的比如流行的池化技术，运用共享技术有效地支持大量细粒度的对象。享元模式把共享对象分为内部状态与外部状态。内部状态为主要共享内容，外部状态即各不相同的不共享属性。</li>
</ul>
<p><strong>行为型：</strong></p>
<ul>
<li>责任链：形成一个类似于链表的事务处理链。请求者不知道由谁来处理。但是请求性能会低一点。</li>
<li>观察者：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。</li>
<li>策略模式：定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)；例子如ThreadPoolExecutor，需要传入具体的策略类。</li>
<li>模板方法：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</li>
</ul>
</blockquote>
<h3 id="设计模式在实际中的运用"><a href="#设计模式在实际中的运用" class="headerlink" title="设计模式在实际中的运用"></a>设计模式在实际中的运用</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><ul>
<li>单例模式：使用单例模式来实现全局唯一的对象，例如日志记录器、数据库连接池等。</li>
<li>工厂模式：像java.util.Calendar等中的getInstance()方法。</li>
<li>观察者模式：进行对某些事件进行监听例如：java.util.EventListener等各种Listener。</li>
<li>策略模式：java.util.Comparator能根据不同的要求来定制排序。</li>
<li>模板方法模式：java.util.Collections中的sort()让子类可以重写方法的⼀部分，而不是整个重写。</li>
<li>责任链模式：javax.servlet.Filter中的doFilter()方法，会有一个过滤器链依次处理。</li>
<li>原型模式：java.lang.Objec中的clone()方法使得类的实例能够生成自身的拷贝。</li>
<li>建造者模式：java.lang.StringBuilder定义了⼀个新的类来构建另⼀个类的实例，以简化复杂对象的创建。</li>
<li>代理模式：java.lang.reflect.Proxy中的代理类。</li>
<li>装饰者模式：java.io.BufferedInputStream(InputStream)进行包装动态的给⼀个对象附加额外的功能。</li>
<li>适配器模式：java.io.InputStreamReader(InputStream)转换流用来把⼀个接口转化成另⼀个接口。</li>
<li>桥接模式：JDBC连接驱动。</li>
</ul>
<h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><ul>
<li>工厂设计模式：Spring 使用工厂模式通过BeanFactory 、ApplicationContext 创建 bean 对象。</li>
<li>代理设计模式：Spring AOP 功能的实现。</li>
<li>单例设计模式：Spring 中的 Bean 默认都是单例的。</li>
<li>模板方法模式：Spring 中 jdbcTemplate 、hibernateTemplate 等以<br>Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li>观察者模式：Spring 事件驱动模型就是观察者模式很经典的⼀个应用。</li>
<li>适配器模式：Spring MVC 中DispatcherServlet也是用到了适配器模式适配Controller 。</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2021/03/05/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>适配器模式（有时候也称包装样式或者包装）将一个类的接口适配成用户所期待的。一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。</p>
<h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><h3 id="2-1代码"><a href="#2-1代码" class="headerlink" title="2.1代码"></a>2.1代码</h3><ol>
<li>类适配器模式的代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 设计模式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAdapterPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Target target = <span class="keyword">new</span> ClassAdapter();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在适配中.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassAdapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>对象适配器模式的代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapterPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line">        Target target = <span class="keyword">new</span> ObjectAdapter(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在适配中.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectAdapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-优点"><a href="#3-优点" class="headerlink" title="3.优点"></a>3.优点</h2><ul>
<li>将目标类和适配者类解耦</li>
<li>增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性</li>
<li>灵活性和扩展性都非常好，符合开闭原则</li>
</ul>
<h2 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4.缺点"></a>4.缺点</h2><ul>
<li>类适配器，对于Java不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为接口，不能为类，其使用有一定的局限性，不能将一个适配者类和他的子类同时适配到目标接口。所以多用对象适配器。</li>
</ul>
<h2 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5.使用场景"></a>5.使用场景</h2><ul>
<li>接口中规定了所有要实现的方法</li>
<li>但一个要实现此接口的具体类，只用到了其中的几个方法，而其它的方法都是没有用的。</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>IP协议</title>
    <url>/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h1><p>IP指网际互连协议，Internet Protocol的缩写，是TCP/IP体系中的网络层协议。根据<strong>端到端</strong>的设计原则，IP只为主机提供一种无连接、不可靠的、尽力而为的数据包传输服务。</p>
<p>IP主要包含三方面内容：</p>
<ul>
<li>数据报格式</li>
<li>分组处理的约定</li>
<li>地址约定</li>
</ul>
<h2 id="IP-数据报格式："><a href="#IP-数据报格式：" class="headerlink" title="IP 数据报格式："></a><strong>IP 数据报格式：</strong></h2><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230422103007635.png" alt="image-20230422103007635" style="zoom:50%;" />

<h2 id="IP-分片和重组："><a href="#IP-分片和重组：" class="headerlink" title="IP 分片和重组："></a><strong>IP 分片和重组：</strong></h2><p>由于不同的网络链路有不同的MTU (最大传输单元)，所以很多时候没办法直接将整个IP分组向下传输，大的IP数据报就需要在网络上被分片形成独立的分组（目标主机会启动定时器，如果规定时间之外任一一个分片没到就只能全部丢弃），并在最终的目标主机根据ID以及偏移量进行重组。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230422104747694.png" alt="image-20230422104747694" style="zoom:50%;" />

<p>一个数据报被分割成若干个小的数据报：</p>
<ul>
<li>相同的ID</li>
<li>不同的偏移量</li>
<li>最后一个分片fragflag标记为0</li>
</ul>
<p><strong>例子：</strong></p>
<ul>
<li><p><strong>胖分组：</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230422105049251.png" alt="image-20230422105049251" style="zoom:50%;" />
</li>
<li><p><strong>分片分组：</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230422105121256.png" alt="image-20230422105121256" style="zoom:50%;" />

</li>
</ul>
<h2 id="IP编址："><a href="#IP编址：" class="headerlink" title="IP编址："></a><strong>IP编址：</strong></h2><p>32位标示，对主机或者路由器的接口编址；路由器通常拥有多个接口，主机也有可能有多个接口，IP地址和每一个接口关联。</p>
<p>IP地址是由<strong>网络地址</strong>与<strong>主机地址</strong>两部分所组成。</p>
<ul>
<li><strong>网络地址：</strong>网络地址可用来识别设备所在的网络，网络地址位于IP地址的前段。</li>
<li><strong>主机地址：</strong>主机地址位于IP地址的后段，可用来识别网络上设备。同一网络上的设备都会有相同的网络地址，而各设备之间则是以主机地址来区别。</li>
</ul>
<blockquote>
<p>什么是子网：</p>
<ul>
<li>一个子网内的节点（主机或者路由器）它们的IP地址的高位部分相同，这些节点构成的网络的一部分叫做子网</li>
<li>无需路由器介入，子网内各主机可以在物理上相互直接到达</li>
</ul>
</blockquote>
<p><strong>地址分类：</strong></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>最大网络数</th>
<th>IP地址范围</th>
<th>单个网段最大主机数</th>
<th>私有IP地址范围</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>126(2^7-2)</td>
<td>1.0.0.1-127.255.255.254</td>
<td>16777214</td>
<td>10.0.0.0-10.255.255.255</td>
</tr>
<tr>
<td>B</td>
<td>16384(2^14)</td>
<td>128.0.0.1-191.255.255.254</td>
<td>65534</td>
<td>172.16.0.0-172.31.255.255</td>
</tr>
<tr>
<td>C</td>
<td>2097152(2^21)</td>
<td>192.0.0.1-223.255.255.254</td>
<td>254</td>
<td>192.168.0.0-192.168.255.255</td>
</tr>
</tbody></table>
<p>非常用地址：</p>
<ul>
<li>D类地址：前四位是1110，用于多播(multicast)，即一对多通信；</li>
<li>E类地址：前四位是1111，保留为以后使用。</li>
</ul>
<blockquote>
<p><strong>特殊IP地址：</strong></p>
<ul>
<li><p>127.0.0.1：回送地址</p>
</li>
<li><p>255.255.255.255：广播地址，用于服务寻找IP</p>
</li>
<li><p>127.0.0.1：本机地址，用于回路检测</p>
</li>
<li><p>0.0.0.0：任一IP，表示不清楚的主机和目的网络</p>
</li>
</ul>
</blockquote>
<p><strong>无类域间路由：</strong></p>
<p>CIDR: Classless InterDomain Routing，子网部分可以在任意的位置（通过子网掩码来区分），地址格式: a.b.c.d/x, 其中x 是地址中子网号的长度。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230422155629811.png" alt="image-20230422155629811"></p>
<blockquote>
<p><strong>子网掩码：</strong><br>用来区分子网部分和主机部分：</p>
<ul>
<li>1: bit位置表示子网部分</li>
<li>0:bit位置表示主机部分</li>
</ul>
<p>原始的A、B、C类网络的子网掩码分别是：</p>
<ul>
<li>A：255.0.0.0 ：11111111 00000000 0000000 00000000</li>
<li>B：255.255.0.0：11111111 11111111 0000000 00000000</li>
<li>C：255.255.255.0：11111111 11111111 11111111 00000000</li>
</ul>
</blockquote>
<h2 id="转发表和转发算法"><a href="#转发表和转发算法" class="headerlink" title="转发表和转发算法"></a>转发表和转发算法</h2><p><strong>转发表：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230422155912978.png" alt="image-20230422155912978"></p>
<p>首先获得IP数据报的目标地址，再根据Mask子网掩码获得网络地址，然后拿网络地址与转发表进行比对：</p>
<ul>
<li>如果找到了，就按照表项的对应接口转发该报文</li>
<li>没有找到，则使用默认表项转发数据报</li>
</ul>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>由于32-bit地址空间将会被很快用完，所以IPv6由此诞生。并且拥有固定的40 字节头部，在数据报传输过程中，不允许分片，而是让主机自己进行处理，减轻了路由器的压力。</p>
<p><strong>数据报格式：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230424145123656.png" alt="image-20230424145123656"></p>
<ul>
<li>Priority：标示流中数据报的优先级</li>
<li>Flow Label：标示数据报在一个“flow”</li>
<li>Next header：标示上层协议</li>
</ul>
<blockquote>
<p>和IPv4的其它变化：</p>
<ul>
<li>Checksum：被移除掉，降低在每一段中的处理速度</li>
<li>Options：允许，但是在头部之外, 被“Next Header” 字段标示</li>
<li>ICMPv6：ICMP的新版本</li>
</ul>
<p>平滑升级：由于主机太多了，只能平滑的升级，IPv6只能通过隧道（即将IPv6的报文封装成IPv4的报文进行通信）在IPv4的环境下进行相互通信。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>传输层(一)</title>
    <url>/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="传输层-一"><a href="#传输层-一" class="headerlink" title="传输层(一)"></a>传输层(一)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>传输层是整个网络体系结构中的关键层次之一，主要负责向两个主机中<strong>进程</strong>之间的<strong>通信</strong>提供服务。传输层在终端用户之间提供透明的数据传输，向上层提供可靠的数据传输服务。传输层在给定的链路上通过流量控制、分段/重组和差错控制来保证数据传输的可靠性。<strong>主要的传输协议有TCP和UDP。</strong></p>
<p><strong>服务过程：</strong></p>
<ul>
<li>发送方：将应用层的报文分成<strong>报文段</strong>，然后传递给网络层</li>
<li>接收方：将报文段重组成报文，然后传递给应用层</li>
</ul>
<p><strong>服务类型：</strong></p>
<ul>
<li>可靠的、保序的传输： TCP<ul>
<li>多路复用、解复用</li>
<li>拥塞控制</li>
<li>流量控制</li>
<li>建立连接</li>
</ul>
</li>
<li>不可靠、不保序的传输：UDP<ul>
<li>多路复用、解复用</li>
<li>没有为尽力而为的IP服务添加更<br>多的其它额外服务</li>
</ul>
</li>
</ul>
<blockquote>
<p>都不提供的服务：</p>
<ul>
<li>延时保证</li>
<li>带宽保证</li>
</ul>
</blockquote>
<h2 id="多路复用和解复用"><a href="#多路复用和解复用" class="headerlink" title="多路复用和解复用"></a>多路复用和解复用</h2><ul>
<li><p><strong>在发送方主机多路复用：</strong></p>
<p>从多个套接字接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部加以<br>封装(该头部信息用于以后的解复用)</p>
</li>
<li><p><strong>在接收方主机多路解复用：</strong></p>
<p>根据报文段的头部信息中的IP地址和端口号将接收到的报文段发给正确的套接字(和对应的应用进程)</p>
</li>
</ul>
<p><strong>面向连接的解复用（TCP）：</strong></p>
<p>由于UDP的Socket需要关联自身的IP和端口以及目标的IP和端口，每个连接会有单独的socket进行复用</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230413101857645.png" alt="image-20230413101857645"></p>
<p><strong>无连接的解复用（UDP）：</strong></p>
<p>由于UDP的Socket只关联自身的IP和端口，所以不管谁发送的都可以复用同一个Socket。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230413101556588.png" alt="image-20230413101556588"></p>
<h2 id="无连接传输：UDP"><a href="#无连接传输：UDP" class="headerlink" title="无连接传输：UDP"></a>无连接传输：UDP</h2><ul>
<li>UDP提供一种“尽力而为”的服务，报文可能丢失、乱序。</li>
<li>UDP属于无连接的服务：<ul>
<li>UDP发送端和接收端之间没有握手</li>
<li>每个UDP报文段都被独立地处理</li>
</ul>
</li>
</ul>
<p><strong>数据报格式：</strong></p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230413115853860.png" alt="image-20230413115853860" style="zoom:67%;" />

<p><strong>优势：</strong></p>
<ul>
<li>不建立连接（会增加延时）</li>
<li>简单：在发送端和接收端没有连接状态</li>
<li>报文段的头部很小(开销小)</li>
<li>无拥塞控制和流量控制：</li>
<li>UDP可以尽可能快的发送报文段</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>可靠数据传输协议rdt</title>
    <url>/2023/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AErdt/</url>
    <content><![CDATA[<h4 id="可靠数据传输协议（rdt）"><a href="#可靠数据传输协议（rdt）" class="headerlink" title="可靠数据传输协议（rdt）"></a>可靠数据传输协议（rdt）</h4><p>rdt在应用层、传输层和数据链路层都很重要，信道的不可靠特点决定了可靠数据传输协议（ rdt ）的复杂性。</p>
<p><strong>Rdt1.0： 在可靠信道上的可靠数据传输</strong></p>
<p>本层只需要直接将数据进行上下传输：</p>
<ul>
<li>发送方将数据发送到下层信道</li>
<li>接收方从下层信道接收数据</li>
</ul>
<p><strong>Rdt2.0：具有比特差错的信道</strong></p>
<p>本层需要采用差错控制编码进行差错检测。</p>
<ul>
<li>发送方差错控制编码、缓存（以备检错重传 ）</li>
<li>接收方使用编码检错</li>
<li>接收方的反馈：控制报文（ACK，NAK）：接收方–&gt;发送方</li>
<li>发送方收到反馈相应的动作<ul>
<li>出错重传</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>改进一：</strong>为了防止ACK/NAK的信息丢失出错，引入了序号的新机制：</p>
<ul>
<li><p>发送方：</p>
<ul>
<li>必须检测ACK/NAK是否出错</li>
<li>在分组中加入序列号，因为 一次只发送一个未经确认的分组，两个序列号（0，1）就足够了</li>
</ul>
</li>
<li><p>接收方：</p>
<ul>
<li>必须检测接收到的分组是否是重复的</li>
</ul>
</li>
</ul>
<p><strong>改进二：</strong>为了节省空间带宽，省去了NAK，只适用ACK；上一个ACK表示NAK。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230414104218193.png" alt="image-20230414104218193"></p>
</blockquote>
<p><strong>Rdt3.0：具有比特差错和分组丢失的信道</strong></p>
<p>首先基于Rdt2.0上解决了比特差错的问题，但是有可能分组会丢失，如果分组丢失，这样不但接收方等待发送方的数据，而且发送方等待接收方的ACK确认，造成了死锁。</p>
<p><strong>解决方案：</strong>引入超时重传机制：如果到时没有收到ACK-&gt;重传（同样用序号保证数据不重复）</p>
<p>自此Rdt3.0依靠各种机制已经能够提供可靠的数据传输，但是由于需要等待确定导致性能不太理想。</p>
<p><strong>性能优化：</strong></p>
<p>利用流水线协议（两种通用的流水线协议：<strong>回退N步(GBN)**和</strong>选择重传(SR)**），提高链路的利用率。</p>
<p>允许发送方在未得到对方确认的情况下一次发送多个分组</p>
<ul>
<li>必须增加序号的范围:用多个bit表示分组的序号</li>
<li>在发送方/接收方要有缓冲区</li>
</ul>
<p><strong>具体实现：</strong></p>
<ul>
<li><p>回退N步：</p>
<ul>
<li>发送端最多在流水线中有N个未确认的分组</li>
<li>发送端拥有对最老的未确认分组的定时器</li>
<li>接收端只是发送累计型确认（按顺序依次接收，发送累计确认）</li>
</ul>
</li>
<li><p>选择重传：</p>
<ul>
<li><p>如果下一个可用于该分组的序号可在发送窗口中，则发送，并且每个分组有自己的定时器（只有收到该序号的ACK才会清除）。</p>
</li>
<li><p>接收端发送相应的ACK(n)；该分组及以前缓存的序号连续的分组交付给上层，然后将窗口移到下一个仍未被接收的分组。</p>
</li>
</ul>
</li>
<li><p>总结：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230415152219406.png" alt="image-20230415152219406"></p>
</li>
</ul>
<blockquote>
<p><strong>滑动窗口(slide window)协议：</strong></p>
<p>一种缓冲区的具体协议，分为发送方缓冲区和接收方缓冲区（窗口即是缓冲区内容的一个范围，根据某种条件滑动），根据大小不同可以把传输协议分为：</p>
<ul>
<li>停止等待协议：发送方缓存区（SW）为1，接收方缓存区（RW）为1</li>
<li>回退N步协议：发送方缓存区（SW）&gt; 1，接收方缓存区（RW）为1</li>
<li>选择重传协议：发送方缓存区（SW）&gt; 1，接收方缓存区（RW）&gt; 1</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>套接字编程</title>
    <url>/2023/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h1><h2 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h2><ol>
<li>服务器首先运行，等待连接建立（服务器进程必须先处于运行状态）<ul>
<li>创建欢迎socket</li>
<li>和本地端口捆绑</li>
<li>在欢迎socket上阻塞式等待接收用户的连接</li>
</ul>
</li>
<li>客户端主动和服务器建立连接<ul>
<li>创建客户端本地套接字（隐式捆绑到本地port）</li>
<li>指定服务器进程的IP地址和端口号，与服务器进程连接</li>
</ul>
</li>
<li>当与客户端连接请求到来时<ul>
<li>服务器接受来自用户端的请求，解除阻塞式等待，返回一个新的socket（与欢迎socket不一样），与客户端通信</li>
<li>允许服务器与多个客户端通信，使用源IP和源端口来区分不同的客户端</li>
</ul>
</li>
<li>连接API调用有效时，客户端P与服务器建立了TCP连接</li>
</ol>
<h2 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h2><p>UDP：在客户端和服务器之间没有连接</p>
<p>传输层提供端到端的进程之间的网络传输服务。</p>
<ul>
<li>没有握手</li>
<li>发送端在每一个报文中明确地指定目标的IP地址和端口号（因为socket只绑定了本地的IP和端口）</li>
<li>服务器必须从收到的分组中提取出发送端的IP地址和端口号</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层协议</title>
    <url>/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP：超文本传输协议，并且HTTP是无状态的（不需要维护客户端状态 ），使用TCP建立连接，客户发起一个与服务器的TCP连接(建立套接字) ，端口号为80；HTTP/1.1 默认使用持久连接以及流水线请求方式。</p>
<p>客户/服务器模式：</p>
<ul>
<li>客户：请求、接收和显示Web对象的浏览器</li>
<li>服务器：对请求进行响应，发送对象的Web服务器</li>
</ul>
<p><strong>请求报文：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230406105418268.png" alt="image-20230406105418268"></p>
<p><strong>请求方式：</strong></p>
<ul>
<li>GET：发送一个请求来取得服务器上的某一资源。</li>
<li>POST：向 <code>url</code> 指定的资源提交数据或附加新的数据。</li>
<li>HEAD：只请求页面的首部。</li>
<li>PUT：数据发送到服务器以创建或更新资源，侧重于创建数据，对应insert操作。</li>
<li>DELETE：删除服务器上的某资源。</li>
</ul>
<p><strong>响应报文：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230406105525998.png" alt="image-20230406105525998"></p>
<p><strong>响应状态码：</strong></p>
<ul>
<li>1XX：表示【临时响应】并需要请求者继续执行操作的状态代码</li>
<li>2XX：代表请求已成功被服务器接收、理解、并接受。<ul>
<li><code>200(成功)</code>服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。</li>
<li><code>201(已创建)</code>请求成功并且服务器创建了新的资源。</li>
<li><code>202(已接受)</code>服务器已接受请求，但尚未处理。</li>
<li><code>203(非授权信息)</code>服务器已成功处理了请求，但返回的信息可能来自另一来源。</li>
<li><code>204(无内容)</code>服务器成功处理了请求，但没有返回任何内容。</li>
<li><code>205(重置内容)</code>服务器成功处理了请求，但没有返回任何内容。</li>
<li><code>206(部分内容)</code>服务器成功处理了部分 GET 请求。</li>
</ul>
</li>
<li>3XX：表示要完成请求，需要进一步操作如：重定向<ul>
<li><code>300(多种选择)</code>针对请求，服务器可执行多种操作。服务器可根据请求者(user agent)选择一项操作，或提供操作列表供请求者选择。</li>
<li><code>301(永久移动)</code>请求的网页已永久移动到新位置。服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。</li>
<li><code>302(临时移动)</code>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li>
<li><code>303(查看其他位置)</code>请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</li>
<li><code>304(未修改)</code>自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</li>
<li><code>305(使用代理)</code>请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。</li>
<li><code>307(临时重定向)</code>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li>
</ul>
</li>
<li>4XX：请求出错<ul>
<li><code>400(错误请求)</code>表示客户端请求的语法错误，服务器无法理解，例如 url 含有非法字符、json 格式有问题。</li>
<li><code>401(未授权)</code>请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。</li>
<li><code>402</code>表示保留，将来使用。</li>
<li><code>403(禁止)</code>表示服务器理解请求客户端的请求，但是拒绝请求。</li>
<li><code>404(未找到)</code>服务器无法根据客户端的请求找到资源(网页)。</li>
<li><code>405(方法禁用)</code>禁用请求中指定的方法。</li>
<li><code>406(不接受)</code>无法使用请求的内容特性响应请求的网页。</li>
<li><code>407(需要代理授权)</code>此状态代码与 401(未授权)类似，但指定请求者应当授权使用代理。</li>
<li><code>408(请求超时)</code>服务器等候请求时发生超时。</li>
<li><code>409(冲突)</code>服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。</li>
<li><code>410(已删除)</code>如果请求的资源已永久删除，服务器就会返回此响应。</li>
</ul>
</li>
<li>5XX：服务器本身的错误<ul>
<li><code>500(服务器内部错误)</code>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。</li>
<li><code>501(尚未实施)</code>服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</li>
<li><code>502(错误网关)</code>服务器作为网关或代理，从上游服务器收到无效响应。</li>
<li><code>503(服务不可用)</code>服务器目前无法使用(由于超载或停机维护)。通常，这只是暂时状态。</li>
<li><code>504(网关超时)</code>服务器作为网关或代理，但是没有及时从上游服务器收到请求。</li>
<li><code>505(HTTP 版本不受支持)</code>服务器不支持请求中所用的 HTTP 版本。</li>
</ul>
</li>
</ul>
<p><strong>Cookies</strong></p>
<p>大多数主要的门户网站使用cookies，HTTP cookies就是服务器端发送给浏览器端的一小部分数据，浏览器接收到这个数据之后，可以存起来自己用，也可以在后续发送到server端进行一些数据的校验。</p>
<ul>
<li>交互流程：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230407094449748.png" alt="image-20230407094449748"></p>
<p><strong>web缓存</strong></p>
<p>浏览器将所有的HTTP请求发给缓存，通常缓存是由ISP安装(大学、公司、居民区ISP)</p>
<ul>
<li>在缓存中的对象：缓存直接返回对象</li>
<li>如对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端</li>
</ul>
<p><strong>目的：</strong></p>
<ul>
<li>降低客户端的请求响应时间</li>
<li>可以大大减少一个机构内部网络与Internent接入链路上的流量</li>
<li>互联网大量采用了缓存：可以使较弱的ICP也能够有效提供内容</li>
</ul>
<h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p>FTP：文件传输协议，向远程主机上传输文件或从远程主机接收文件。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230331095433251.png" alt="image-20230331095433251"></p>
<ul>
<li>ftp服务器：端口号为21</li>
<li>ftp客户端：发起传输的一方</li>
</ul>
<p><strong>相关状态码：</strong></p>
<ul>
<li>331 Username OK, password required</li>
<li>125 data connection already open;transfer starting</li>
<li>425 Can’t open data connection</li>
<li>452 Error writingfile</li>
</ul>
<blockquote>
<p>客户端与服务器建立了两条连接，一个是控制连接，另一个是数据连接。</p>
</blockquote>
<h2 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h2><p>SMTP是一种提供可靠且有效的<strong>电子邮件传输</strong>的协议。SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230331103143857.png" alt="image-20230331103143857" style="zoom:67%;" />

<p>3个主要组成部分：</p>
<ul>
<li>用户代理：又名“邮件阅读器”，用于撰写、编辑和阅读邮件例如Outlook等</li>
<li>邮件服务器：邮箱中管理和维护发送给用户的邮件</li>
<li>简单邮件传输协议：SMTP使用持久连接，使用TCP在客户端和服务器之间传送报文，端口号为25。</li>
</ul>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>域名系统（Domain Name System，缩写：DNS）是互联网的一项服务。它作为将<strong>域名相互映射</strong>的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53。</p>
<p><strong>需要解决的问题：</strong></p>
<ol>
<li><p>如何命名设备</p>
<p>用有意义的字符串：好记，便于人类用使用，解决一个平面命名的重名问题：<strong>层次化命名</strong></p>
</li>
<li><p>如何完成名字到IP地址的转换</p>
<p>分布式的数据库维护和响应名字查询，维护域名-IP地址(其它)的映射关系。</p>
</li>
<li><p>如何维护</p>
<ul>
<li>在上级域的名字服务器中增加两条记录，指向这个新增<br>的子域的域名和域名服务器的地址</li>
<li>在新增子域的名字服务器上运行名字服务器，负责本域<br>的名字解析： 名字-&gt;IP地址</li>
</ul>
</li>
</ol>
<p><strong>解析过程：</strong></p>
<p>以 <a href="http://www.baidu.com/">www.baidu.com</a> 这个域名为例</p>
<ul>
<li><p>一开始，域名解析请求先会检查本机的 hosts 文件，查看是否有该域名对应的 IP；</p>
</li>
<li><p>如果没有的话，就请求 Local DNS 是否有域名解析结果的缓存，如果有就返回标识是从非权威 DNS 返回的结果；</p>
</li>
<li><p>如果没有就开始 DNS 的迭代查询。先请求根 DNS，根 DNS 返回顶级 DNS（.com）的地址；再请求.com 顶级 DNS 得到 baidu.com 的域名服务器地址；再从 baidu.com 的域名服务器中查询到 <a href="http://www.baidu.com/">www.baidu.com</a> 对应的 IP 地址，返回这个 IP 地址的同时标记这个结果是来自于权威 DNS 的结果，同时写入 Local DNS 的解析<strong>结果缓存</strong>，这样下一次的解析同一个域名就不需要做 DNS 的迭代查询了。</p>
</li>
</ul>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p><strong>前言</strong></p>
<p>随着互联网的发展，视频流量占据着互联网大部分的带宽。</p>
<p>挑战：服务器如何通过网络向上百万用户同时流化视频内容(上百万视频内容)？</p>
<p>单个超级服务器无法提供服务：</p>
<ul>
<li>服务器到客户端路径上跳数较多，瓶颈链路的带宽小导致停顿</li>
<li>“二八规律”决定了网络同时充斥着同一个视频的多个拷贝，效率低（付费高、带宽浪费、效果差)</li>
<li>单点故障点，性能瓶颈</li>
<li>周边网络的拥塞</li>
</ul>
<p>解决方案：通过<strong>CDN</strong>，全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验</p>
<p><strong>概述</strong></p>
<p>CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输得更快、更稳定。</p>
<p>通过在网络各处放置<strong>节点服务器</strong>所构成的在现有的互联网基础之上的一层智能<strong>虚拟网络</strong>，CDN系统能够实时地根据<strong>网络流量</strong>和各节点的连接、负载状况以及到用户的距离和<strong>响应时间</strong>等综合信息将用户的请求重新导向离用户最近的<strong>服务节点</strong>上。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230409100855048.png" alt="image-20230409100855048"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层基础</title>
    <url>/2023/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="应用层基础"><a href="#应用层基础" class="headerlink" title="应用层基础"></a>应用层基础</h1><p>应用层也称为应用实体，它由若干个特定应用服务元素和一个或多个公用应用服务元素组成。</p>
<p>网络应用的实例：互联网流行的应用层协议</p>
<ul>
<li>HTTP</li>
<li>FTP</li>
<li>SMTP / POP3 /IMAP</li>
<li>DNS</li>
</ul>
<p>编程：网络应用程序</p>
<ul>
<li>Socket API</li>
</ul>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><h3 id="客户-服务器（C-S）体系结构"><a href="#客户-服务器（C-S）体系结构" class="headerlink" title="客户-服务器（C/S）体系结构"></a>客户-服务器（C/S）体系结构</h3><p><strong>服务器:</strong></p>
<ul>
<li>一直运行</li>
<li>固定的IP地址和周知的端口号（约定）</li>
<li>扩展性差</li>
</ul>
<p><strong>客户端:</strong></p>
<ul>
<li><p>主动与服务器通信</p>
</li>
<li><p>与互联网有间歇性的连接</p>
</li>
<li><p>可能是动态IP 地址</p>
</li>
<li><p>不直接与其它客户端通信</p>
</li>
</ul>
<h3 id="对等体（P2P）体系结构"><a href="#对等体（P2P）体系结构" class="headerlink" title="对等体（P2P）体系结构"></a>对等体（P2P）体系结构</h3><p><strong>特点：</strong></p>
<ul>
<li><p>（几乎）没有一直运行的服务器</p>
</li>
<li><p>任意端系统之间可以进行通信，并且每一个节点既是客户端又是服<br>务器</p>
</li>
<li><p>参与的主机间歇性连接且可以改变IP 地址</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>难以管理</li>
</ul>
<blockquote>
<p>也有C/S和P2P体系结构的混合体：</p>
<ul>
<li>Napster</li>
</ul>
</blockquote>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ol>
<li>数据丢失率<ul>
<li>有些应用则要求100%的可靠数据传输（如文件）</li>
<li>有些应用（如音频）能容忍一定比例以下的数据丢失</li>
</ul>
</li>
<li>吞吐<ul>
<li>一些应用（如多媒体）必须需要最小限度的吞吐，从而使得应用能够有效运转</li>
<li>一些应用能充分利用可供使用的吞吐(弹性应用)</li>
</ul>
</li>
<li>延迟<ul>
<li>一些应用出于有效性考虑，对数据传输有严格的时间限制</li>
</ul>
</li>
<li>安全性<ul>
<li>机密性</li>
<li>完整性</li>
<li>可认证性</li>
</ul>
</li>
</ol>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p><strong>进程标示和寻址问题</strong></p>
<p>进程为了接收报文，必须有一个标识即：SAP（发送也需要标示）</p>
<ul>
<li>主机：唯一的32位IP地址<ul>
<li>仅仅有IP地址不能够唯一标示一个进程；在一台端系统上有很多应用进程在运行</li>
</ul>
</li>
<li>所采用的传输层协议：TCP or UDP</li>
<li>端口号（Port Numbers）</li>
</ul>
<p><strong>传输层-应用层提供服务所传递的信息</strong></p>
<ul>
<li>层间接口必须要携带的信息<ul>
<li> 要传输的报文（对于本层来说：SDU）</li>
<li> 谁传的：对方的应用进程的标示：IP+TCP(UDP) 端口</li>
<li> 传给谁：对方的应用进程的标示：对方的IP+TCP(UDP)端口号</li>
</ul>
</li>
<li>传输层实体（tcp或者udp实体）根据这些信息进行TCP报文段（UDP数据报）的封装<ul>
<li>源端口号，目标端口号，数据等</li>
<li>将IP地址往下交IP实体，用于封装IP数据报：源IP,目标IP</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果Socket API 每次传输报文，都携带如此多的信息，太繁琐易错，不便于管理</p>
<ul>
<li>用个代号标示通信的双方或者单方：Socket</li>
<li>就像OS打开文件返回的句柄一样</li>
</ul>
</blockquote>
<p><strong>如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用</strong></p>
<ol>
<li>定义应用层协议：报文格式，解释，时序等</li>
<li>编制程序，通过API调用网络基础设施提供通信服务传报文，解析报文，实现应用时序等</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络和因特网</title>
    <url>/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/</url>
    <content><![CDATA[<h1 id="计算机网络和因特网"><a href="#计算机网络和因特网" class="headerlink" title="计算机网络和因特网"></a>计算机网络和因特网</h1><h2 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h2><p><strong>Internet</strong>，中文正式译名为因特网，又叫做<strong>国际互联网</strong>。它是由那些使用公用语言互相通信的计算机连接而成的全球网络。一旦你连接到它的任何一个节点上，就意味着您的计算机已经连入Internet网上了。Internet目前的用户已经遍及全球，有超过几亿人在使用Internet，并且它的用户数还在以等比级数上升。 </p>
<p><strong>从服务的角度来看：</strong></p>
<p>Internet就是<strong>使用通信设施进行通信的分布式应用</strong>，其中<strong>通信基础设施为apps提供编程接口（通信服务），为app应用提供无连接不可靠服务和面向连接的可靠服务。</strong></p>
<h3 id="具体构成"><a href="#具体构成" class="headerlink" title="具体构成"></a>具体构成</h3><ul>
<li><strong>节点：</strong><ul>
<li>主机及其上运行的应用程序</li>
<li>路由器、交换机等网络交换设备</li>
</ul>
</li>
<li><strong>边：</strong>通信链路<ul>
<li>接入网链路：主机连接到互联网的链路</li>
<li>主干链路：路由器间的链路</li>
</ul>
</li>
<li><strong>协议：</strong>对等层实体在通信交换过程中应该遵守的规则协议。协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及在报文传输和/或接收或其他事件方面所采取的动作</li>
</ul>
<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><h3 id="边缘系统："><a href="#边缘系统：" class="headerlink" title="边缘系统："></a>边缘系统：</h3><p>如果要用现有的技术术语描述的话，边缘网络包括汇聚层网络和接入层网络的一部分或全部， 是接入用户的最后一段网络。由主机和应用程序（客户端和服务器）组成。</p>
<h3 id="服务模式："><a href="#服务模式：" class="headerlink" title="服务模式："></a>服务模式：</h3><ul>
<li><p>客户/服务器模式：（一种主从模式）服务器主，客户端从；客户端请求的所有资源都来自于服务器。</p>
</li>
<li><p>对等模式：（P2P模式）每个结点既是客户端又是服务器。在分布式文件分发系统中大行其道，例如迅雷。</p>
</li>
</ul>
<h3 id="通信方式："><a href="#通信方式：" class="headerlink" title="通信方式："></a>通信方式：</h3><ul>
<li>面向连接的服务：利用传输层TCP协议可靠地、按顺序地传送数据；并具有流量控制、拥塞控制的功能。</li>
<li>面向无连接的服务：利用传输层UDP协议不可靠数据传输数据，并无流量控制、拥塞控制。例如流媒体、远程会议、DNS。</li>
</ul>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络核心就是由路由器组成的网状网络。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230320093336029.png" alt="image-20230320093336029" style="zoom: 80%;" />

<h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230320152413416.png" alt="image-20230320152413416"></p>
<ul>
<li><strong>电路交换：</strong>为每个呼叫预留一条专有电路：如电话网<ul>
<li>频分复用：频分复用FDM就是将用于传输信道的总带宽划分成若干个子频带（或称子信道），每一个子信道传输1路信号。</li>
<li>时分复用：时分复用TDM是采用同一物理连接的不同时段来传输不同的信号，也能达到多路传输的目的。</li>
</ul>
</li>
<li><strong>分组交换：</strong>（存储转发，提高共享性 ）<ul>
<li>特性：<ul>
<li>将要传送的数据分成一个个单位：分组</li>
<li>将分组从一个路由器传到相邻路由器（hop） ，一段段最终从源端传至目标端</li>
<li>每段采用链路的最大传输能力（带宽）</li>
</ul>
</li>
<li>排队延迟：如果到达速率&gt;链路的输出速率，分组会排队等待传输，如果路由器缓存使用完，分组会被丢弃。</li>
<li>关键功能：<ul>
<li>路由：利用路由算法决定分组采用的源到目标的路径</li>
<li>转发：将分组从路由器的输入链路转移到输出链路</li>
</ul>
</li>
<li>实现方式：<ul>
<li>数据报网络</li>
<li>虚电路网络</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="接入网和物理媒体"><a href="#接入网和物理媒体" class="headerlink" title="接入网和物理媒体"></a>接入网和物理媒体</h2><h3 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h3><ul>
<li><p>住宅接入网络</p>
<p><strong>线缆网络：</strong></p>
<p>线缆和光纤网络将个家庭用户接入到ISP 路由器。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230321100348659.png" alt="image-20230321100348659"></p>
<p><strong>modem方式接入：</strong></p>
<p>将上网数据利用调制器调制加载音频信号上，在电话线上传输，在局端将其中的数据解调出来；反之亦然。有效的利用了原来有的电话线资源，节约了成本。但是带宽很小被淘汰了。</p>
<p><strong>digital subscriber line (DSL)</strong></p>
<p>采用现存的到交换局DSLAM的电话线</p>
<ul>
<li>DSL线路上的数据被传到互联网</li>
<li>DSL线路上的语音被传到电话网</li>
</ul>
</li>
<li><p>单位接入网络（学校、公<br>司）</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230321100745539.png" alt="image-20230321100745539" style="zoom:80%;" />
</li>
<li><p>无线接入网络</p>
<ul>
<li>无线LANs：建筑物内部</li>
<li>广域无线接入：由电信运营商提供</li>
</ul>
</li>
</ul>
<h3 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h3><ul>
<li><strong>同轴电缆：</strong>两根同轴的铜导线。</li>
<li><strong>光纤：</strong>光脉冲，每个脉冲表示一个bit，在玻璃纤维中传输，低误码率安全。</li>
<li><strong>无线链路：</strong>开放空间传输电磁波，携带要传输的数据。</li>
</ul>
<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p><strong>网络结构：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230322100303019.png" alt="image-20230322100303019"></p>
<ul>
<li>POP：高层ISP面向客户网络的接入点，涉及费用结算<ul>
<li>如一个低层ISP接入多个高层ISP，多宿( multi home)</li>
</ul>
</li>
<li>IXP：多个对等ISP互联互通之处，对等接入通常不涉及费用结算</li>
<li>ICP：自己部署专用网络，同时和各级ISP连接。</li>
</ul>
<h2 id="分组延时和丢失"><a href="#分组延时和丢失" class="headerlink" title="分组延时和丢失"></a>分组延时和丢失</h2><h3 id="分组延时"><a href="#分组延时" class="headerlink" title="分组延时"></a>分组延时</h3><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230323094301991.png" alt="image-20230323094301991"></p>
<ol>
<li>nodal processing：节点处理延时</li>
<li>queueing：排队延时</li>
<li>transmission：传输延时</li>
<li>propagation：传播延时</li>
</ol>
<h3 id="分组丢失"><a href="#分组丢失" class="headerlink" title="分组丢失"></a>分组丢失</h3><ul>
<li>链路的队列缓冲区容量有限</li>
<li>当分组到达一个满的队列时，该分组将会丢失</li>
<li>丢失的分组可能会被前一个节点或源端系统重传，或根本不重传</li>
</ul>
<h2 id="协议层次及服务模型"><a href="#协议层次及服务模型" class="headerlink" title="协议层次及服务模型"></a>协议层次及服务模型</h2><p>网络是一个复杂的系统！网络功能繁杂：数字信号的物理信号承载、点到点、路由、rdt、进程区分、应用等</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230328103957955.png" alt="image-20230328103957955"></p>
<p><strong>层次化方式</strong>实现复杂网络功能：</p>
<ul>
<li>将网络复杂的功能分层功能明确的<strong>层次</strong>，每一层实现了其中一个或一组功能，功能中有其上层可以使用的<strong>功能：服务</strong></li>
<li>本层协议实体相互交互执行本层的<strong>协议动作</strong>，目的是实现本层功能，通过接口为上层提供更好的服务</li>
<li>在实现本层协议的时候，直接利用了下层所<strong>提供的服务</strong></li>
<li>本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用的）+更下层所提供的服务</li>
</ul>
<blockquote>
<p><strong>服务( Service)：</strong>低层实体向上层实体提供它们之间的通信的能力</p>
<ul>
<li><p>服务用户(service user)</p>
</li>
<li><p>服务提供者(service provider )</p>
</li>
</ul>
<p><strong>原语(primitive)：</strong>上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过<br>服务访问原语来进行交互的—形式<br><strong>服务访问点SAP (Services Access Point) ：</strong>上层使用下层提供的服务通过层间的接口</p>
</blockquote>
<h3 id="服务类型："><a href="#服务类型：" class="headerlink" title="服务类型："></a>服务类型：</h3><ol>
<li><p><strong>面向连接的服务( Connection-oriented Service)</strong></p>
<ul>
<li>连接(Connection)：两个通信实体为进行通信而建立的一种结合</li>
<li>面向连接的服务通信的过程：建立连接，通信，拆除连接</li>
<li>面向连接的服务的例子：网络层的连接被成为虚电路<ul>
<li>适用范围：对于大的数据块要传输; 不适合小的零星报文</li>
<li>特点：保序</li>
<li>服务类型：<ul>
<li>可靠的信息流传送页面(可靠的获得,通过接收方的确认)</li>
<li>可靠的字节流远程登录</li>
<li>不可靠的连接数字化声音</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>无连接的服务(Connectionless Service)</strong></p>
<ul>
<li>无连接服务：两个对等层实体在通信前不需要建立一个连接，不预留资源；不需要通信双方都是<br>活跃；(例：寄信)</li>
<li>特点：不可靠、可能重复、可能失序</li>
<li>IP分组，数据包；</li>
<li>适用范围：适合传送零星数据；</li>
<li>服务类型：<ul>
<li>不可靠的数据报电子方式的函件</li>
<li>有确认的数据报挂号信</li>
<li>请求回答信息查询</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>路由器的组成</title>
    <url>/2023/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90/</url>
    <content><![CDATA[<h1 id="路由器的组成"><a href="#路由器的组成" class="headerlink" title="路由器的组成"></a>路由器的组成</h1><p><strong>通用路由器体系架构：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230421100136022.png" alt="image-20230421100136022"></p>
<ul>
<li>路由：运行路由选择算法／协议(RIP, OSPF, BGP)生成路由表</li>
<li>转发：从输入到输出链路交换数据报-根据路由表进行分组的转发</li>
</ul>
<h2 id="输入端："><a href="#输入端：" class="headerlink" title="输入端："></a>输入端：</h2><ol>
<li>接收物理层的Bit级数据</li>
<li>链路层协议动作、解封装</li>
<li>会进入队列（匹配瞬间的输入速率和输出速率的不一致性，但有可能遇到队头阻塞导致丢失），队头根据数据报头部的信息如：目的地址，在输入端口内存中的<strong>转发表</strong>中查找合适的输出端口</li>
</ol>
<h2 id="中间交换过程："><a href="#中间交换过程：" class="headerlink" title="中间交换过程："></a>中间交换过程：</h2><p>将分组从输入缓冲区传输到合适的输出端口，有三种典型的交换机构：</p>
<ul>
<li><p><strong>通过内存交换</strong></p>
<p>在CPU直接控制下的交换，采用传统的计算机</p>
<p>​    <img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230421102850313.png" alt="image-20230421102850313" style="zoom:67%;" /></p>
<ul>
<li>转发速率被内存的带宽限制(数据报通过BUS两遍)</li>
<li>一次只能转发一个分组</li>
</ul>
</li>
<li><p><strong>通过总线交换</strong></p>
<p>数据报通过共享总线，从输入端口转发到输出端口</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230421102914223.png" alt="image-20230421102914223" style="zoom:67%;" />

<ul>
<li>交换速度受限于总线带宽</li>
<li>1次处理一个分组</li>
</ul>
</li>
<li><p><strong>通过互联网络(crossbar等)的交换</strong></p>
<p>Banyan（榕树）网络，crossbar(纵横)和其它的互联网络被开发，将多个处理器连接成多处理器</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230421103013081.png" alt="image-20230421103013081" style="zoom:67%;" />

<ul>
<li>同时并发转发多个分组，克服总线带宽限制</li>
</ul>
</li>
</ul>
<h2 id="输出端："><a href="#输出端：" class="headerlink" title="输出端："></a>输出端：</h2><ol>
<li>接收输出端口转发过来的分组；（当数据报从交换机构的到达速度比传输速率快就需要输出端口缓存，但是数据报（分组）由于拥塞可能会被丢弃）</li>
<li>根据调度规则将不同分组交由下一层处理，并不一定完全按照先后顺序。</li>
</ol>
<blockquote>
<p><strong>调度规则：</strong></p>
<ul>
<li>FIFO (first in first out) scheduling：按照分组到来的次序发送<ul>
<li>丢弃策略: <ul>
<li>tail drop: 丢弃刚到达的分组</li>
<li>priority: 根据优先权丢失/移除分组</li>
<li>random: 随机地丢弃/移除</li>
</ul>
</li>
</ul>
</li>
<li>优先权调度：发送最高优先权的分组</li>
<li>Round Robin (RR) scheduling：循环扫描不同类型的队列, 发送完一类的一个分组，再发送下一个类的一个分组，循环所有类</li>
<li>Weighted Fair Queuing (WFQ)：一般化的Round Robin，给一类型的分组加上权重，让每个类在每一个循环中获得不同权重的服务量</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>路由选择</title>
    <url>/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h1 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h1><h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><p>路由选择算法(routing algorithm)：网络层软件的一部分，完成路由功能，为转发提供路线。</p>
<p><strong>路由的原则：</strong></p>
<ul>
<li>正确性(correctness)：算法必须是正确的和完整的。</li>
<li>简单性(simplicity)：算法在计算机上应简单。</li>
<li>健壮性(robustness)：算法应能适应通信量和网络拓扑的变化。</li>
<li>稳定性(stability)：产生的路由不应该摇摆。</li>
<li>公平性(fairness)：对每一个站点都公平。</li>
<li>最优性(optimality)：某一个指标的最优，时间上，费用上，等指标，或综合指标。</li>
</ul>
<h3 id="链路状态路由选择-link-state-routing"><a href="#链路状态路由选择-link-state-routing" class="headerlink" title="链路状态路由选择(link state routing)"></a>链路状态路由选择(link state routing)</h3><p>LS路由的基本工作过程：</p>
<ol>
<li>发现相邻节点,获知对方网络地址</li>
<li>测量到相邻节点的代价(延迟,开销)</li>
<li>组装一个LS分组，描述它到相邻节点的代价情况</li>
<li>将分组通过扩散的方法发到所有其它路由器</li>
<li>通过Dijkstra算法找出最短路径（这才是路由算法）</li>
</ol>
<h3 id="距离矢量路由选择-distance-vector-routing"><a href="#距离矢量路由选择-distance-vector-routing" class="headerlink" title="距离矢量路由选择(distance vector routing)"></a>距离矢量路由选择(distance vector routing)</h3><p>距离矢量路由选择的基本思想：</p>
<ul>
<li><p>各路由器维护一张路由表</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230427100345726.png" alt="image-20230427100345726"></p>
</li>
<li><p>各路由器与相邻路由器交换路由表</p>
</li>
<li><p>根据获得的路由信息,更新路由表</p>
</li>
</ul>
<h3 id="算法对比"><a href="#算法对比" class="headerlink" title="算法对比"></a>算法对比</h3><ul>
<li>消息复杂度：DV更好<ul>
<li>LS：局部的路由信息；全局传播。</li>
<li>DV：只和邻居交换信息，全局的路由信息，局部传播。</li>
</ul>
</li>
<li>收敛时间：LS更好<ul>
<li>LS：O(n2) 算法。</li>
<li>DV：收敛较慢，可能存在路由环路。</li>
</ul>
</li>
<li>健壮性：LS更好<ul>
<li>LS：错误信息影响较小，局部，路由较健壮</li>
<li>DV：DV 节点可能通告对全网所有节点的不正确路径代价。</li>
</ul>
</li>
</ul>
<h2 id="子网自治系统内部的路由选择"><a href="#子网自治系统内部的路由选择" class="headerlink" title="子网自治系统内部的路由选择"></a>子网自治系统内部的路由选择</h2><h3 id="RIP："><a href="#RIP：" class="headerlink" title="RIP："></a>RIP：</h3><p>基于距离矢量算法的一种路由实现</p>
<p>步骤：</p>
<ul>
<li>每条链路cost=1，计算出邻居的跳数</li>
<li>DV每隔30秒和邻居交换DV，通告（每个通告包括：最多25个目标子网）</li>
<li>最后计算出路由</li>
</ul>
<h3 id="OSPF："><a href="#OSPF：" class="headerlink" title="OSPF："></a>OSPF：</h3><p>基于链路状态算法的一种路由实现</p>
<p>步骤：</p>
<ul>
<li>LS 分组在网络中（一个AS内部）分发</li>
<li>全局网络拓扑、代价在每一个节点中都保持</li>
<li>路由计算采用Dijkstra算法</li>
</ul>
<h2 id="ISP之间的路由选择"><a href="#ISP之间的路由选择" class="headerlink" title="ISP之间的路由选择"></a>ISP之间的路由选择</h2><h3 id="BGP："><a href="#BGP：" class="headerlink" title="BGP："></a>BGP：</h3><p>自治区域间路由协议“事实上的”标准</p>
<p>平面路由的问题：</p>
<ul>
<li>规模巨大的网络中，路由信息的存储、传输和计算代价巨大</li>
<li>管理问题：<ul>
<li>不同的网络所有者希望按照自己的方式管理网络</li>
<li>希望对外隐藏自己网络的细节</li>
</ul>
</li>
</ul>
<p>BGP将互联网分成一个个AS(路由器区域)，解决了平面路由的问题。</p>
<p>BGP 提供给每个AS以以下方法：</p>
<ul>
<li>eBGP: 从相邻的ASes那里获得子网可达信息</li>
<li>iBGP: 将获得的子网可达信息传遍到AS内部的所有路由器</li>
<li>根据子网可达信息和策略来决定到达子网的“好”路径</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>链路层和局域网</title>
    <url>/2023/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
    <content><![CDATA[<h1 id="链路层和局域网"><a href="#链路层和局域网" class="headerlink" title="链路层和局域网"></a>链路层和局域网</h1><p>数据链路层提供相邻两个点的网络传输服务。物理层负责将数字信号转换为01的物理信号，并通过物理媒介（网线，光缆，电缆）传给相邻的网卡。</p>
<h3 id="相关术语："><a href="#相关术语：" class="headerlink" title="相关术语："></a>相关术语：</h3><ul>
<li>主机和路由器是节点（网桥和交换机也是）：<code>nodes</code></li>
<li>沿着通信路径,连接个相邻节点通信信道的是链路：<code>links</code><ul>
<li>有线链路</li>
<li>无线链路</li>
<li>局域网，共享性链路</li>
</ul>
</li>
<li>第二层协议数据单元帧：<code>frame</code></li>
</ul>
<h3 id="相关服务："><a href="#相关服务：" class="headerlink" title="相关服务："></a>相关服务：</h3><ul>
<li><strong>封装成桢</strong>，链路接入<ul>
<li>将数据报封装在帧中，加上帧头、帧尾部</li>
<li>如果采用的是共享性介质，信道接入获得信道访问权</li>
<li>在帧头部使用“MAC”（物理）地址来标示源和目的</li>
</ul>
</li>
<li>在（一个网络内）相邻两个节点完成<strong>可靠数据传递</strong><ul>
<li>流量控制</li>
<li>错误检测</li>
<li>差错纠正</li>
</ul>
</li>
</ul>
<h2 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h2><p>差错检测（error detection），是指在发送的码序列（码字）中加入适当的<strong>冗余度</strong>以使得接收端能够发现传输中是否发生差错的技术。</p>
<ul>
<li>EDC = 差错检测和纠正位（冗余位）</li>
<li>D = 数据由差错检测保护，可以包含头部字段</li>
</ul>
<p>校验方式：</p>
<ul>
<li>奇偶校验：根据校验和，检测单个bit级错误，检测和纠正单个bit错误</li>
<li>CRC（循环冗余校验）：通过某种数学运算实现有效信息与校验位之间的循环校验</li>
</ul>
<h2 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h2><p>多路访问协议（介质访问控制协议：MAC），分布式算法-决定节点如何使用共享信道，防止多个站点同时传送时的冲突问题。</p>
<h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><ul>
<li><strong>信道划分</strong><ul>
<li>把信道划分成小片（时间、频率、编码），分配片给每个节点专用<ul>
<li>TDMA：时分多路访问</li>
<li>FDMA：频分多路访问</li>
<li>CDMA：码分多路访问</li>
</ul>
</li>
</ul>
</li>
<li><strong>随机访问</strong><ul>
<li>信道不划分，允许冲突，并冲突后恢复<ul>
<li>CSMA：载波侦听多路访问，在传输前先侦听信道，如果有冲突则推迟传送</li>
<li>CSMA/CD：在传输前先侦听信道，如果有冲突则推迟传送；并在传输中也对冲突进行检测，如果冲突则传输终止，减少对信道的浪费。</li>
</ul>
</li>
</ul>
</li>
<li><strong>依次轮流</strong><ul>
<li>节点依次轮流，但是有很多数据传输的节点可以获得较长的信道使用权<ul>
<li>轮流(Taking Turns)MAC协议：<ul>
<li>论询：主节点邀请从节点依次传送<ul>
<li>缺点：<ul>
<li>轮询开销：轮询本身消耗信道带宽</li>
<li>等待时间：每个节点需等到主节点轮询后开始传输</li>
<li>单点故障：主节点失效时造成整个系统无法工作</li>
</ul>
</li>
</ul>
</li>
<li>令牌传递：控制令牌( token)循环从一个节点到下一个节点传递<ul>
<li>缺点：<ul>
<li>令牌开销：本身消耗带宽</li>
<li>延迟：只有等到抓住令牌，才可传输</li>
<li>单点故障(token)：令牌丢失系统级故障，整个系统无法传输</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="MAC-地址和ARP"><a href="#MAC-地址和ARP" class="headerlink" title="MAC 地址和ARP"></a>MAC 地址和ARP</h3><p>48bit MAC地址固化在适配器的ROM，用于使帧从一个网卡传递到与其物理连接的另一个网卡(在同一个物理网络中)。只是<strong>用于区分一个子网内部的不同的节点</strong>，可以完成一个物理网络内部的节点到节点的数据交付。</p>
<p><strong>ARP协议</strong></p>
<p>地址解析协议，即ARP（Address Resolution Protocol），是<strong>根据IP地址获取物理MAC地址</strong>的一个TCP/IP协议。</p>
<p>在LAN上的每个IP节点都有一个ARP表，ARP表包括一些LAN节点IP/MAC地址的映射。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230504105223173.png" alt="image-20230504105223173" style="zoom:50%;" />

<h2 id="以太帧结构"><a href="#以太帧结构" class="headerlink" title="以太帧结构"></a>以太帧结构</h2><p>发送方适配器在<strong>以太网帧</strong>中封装IP数据报，或其他网络层协议数据单元。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230504111434969.png" alt="image-20230504111434969"></p>
<ul>
<li>地址：6字节源MAC地址，目标MAC地址</li>
<li>类型：指出高层协议</li>
<li>CRC：在接收方校验</li>
</ul>
<blockquote>
<p>以太网：无连接、不可靠的服务</p>
<ul>
<li>无连接：帧传输前，发送方和接收方之间没有握手</li>
<li>不可靠：接收方适配器不发送ACKs或NAKs给发送方</li>
<li>以太网的MAC协议：采用<strong>二进制退避的CSMA/CD</strong>介质访问控制形式</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>面向连接的传输：TCP</title>
    <url>/2023/05/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%A0%E8%BE%93%EF%BC%9ATCP/</url>
    <content><![CDATA[<h1 id="面向连接的传输：TCP"><a href="#面向连接的传输：TCP" class="headerlink" title="面向连接的传输：TCP"></a>面向连接的传输：TCP</h1><p>传输控制协议（TCP，Transmission Control Protocol）是一种点对点、可靠的、按顺序的字节流（但是没有报文边界）、全双工、有流量控制拥塞控制、面向连接的传输协议。为了在不可靠的互联网络上提供可靠的点到点字节流而专门设计的一个传输协议。 </p>
<h2 id="报文段结构"><a href="#报文段结构" class="headerlink" title="报文段结构"></a><strong>报文段结构</strong></h2><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230416104355148.png" alt="image-20230416104355148" style="zoom:80%;" />

<ul>
<li>序号：报文段首字节的在字节流的编号。</li>
<li>确认号：期望从另一方收到的下一个字节的序号，累积确认。</li>
</ul>
<h2 id="可靠数据传递"><a href="#可靠数据传递" class="headerlink" title="可靠数据传递"></a><strong>可靠数据传递</strong></h2><p>TCP在IP不可靠服务的基础上建立了Rdt；结合了上面两种滑动窗口协议。</p>
<ul>
<li>累积确认（像GBN，但是区别在于ACK的序号是期望收到的报文序号）</li>
<li>单个重传定时器（像GBN）</li>
<li>超时重传（只重发那个最早的未确认段：SR）</li>
<li>重复确认重传（收到了3次冗余确认，进行快速重传）</li>
</ul>
<h2 id="发送方事件"><a href="#发送方事件" class="headerlink" title="发送方事件"></a><strong>发送方事件</strong></h2><ol>
<li>从应用层接收数据：<ul>
<li>用nextseq创建报文段，发送报文启动定时器</li>
</ul>
</li>
<li>超时重传：<ul>
<li>重传后沿最老的报文段</li>
<li>重启定时器</li>
</ul>
</li>
<li>收到确认：<ul>
<li>更新已被确认的报文序号</li>
<li>如果当前还有未被确认的报文段，重新启动定时器</li>
</ul>
</li>
</ol>
<h2 id="接收方事件"><a href="#接收方事件" class="headerlink" title="接收方事件"></a><strong>接收方事件</strong></h2><ol>
<li>延迟的ACK。对另一个按序报文段的到达最多等待500ms。<ul>
<li>如果下一个报文段在这个时间间隔内没有到达，则发送一个ACK。</li>
<li>如果到达就发送累积ACK指明下一个期待的字节序号。</li>
</ul>
</li>
</ol>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><strong>流量控制</strong></h2><p>接收方控制发送方，不让发送方发送的太多、太快以至于让接收方的缓冲区溢出。</p>
<p>实现：</p>
<ul>
<li>接收方在其向发送方的TCP段头部的rwnd字段“通告”其空闲buffer大小</li>
<li>发送方限制未确认字节的个数≤接收方发送过来的rwnd值，保证接收方不会被淹没</li>
</ul>
<blockquote>
<p><strong>会与后面的拥塞控制进行联合控制，缓存区空闲大小和拥塞窗口之间取最小值</strong></p>
</blockquote>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a><strong>连接管理</strong></h2><p>在正式交换数据之前，发送方和接收方握手建立通信关系。在通信结束后要进行连接关闭。</p>
<ul>
<li><p><strong>建立连接（三次握手）：</strong></p>
<p><strong>连接建立的本质：</strong></p>
<ul>
<li>知道要和对方通信</li>
<li>准备好相关资源</li>
<li>控制变量要做置位（特别是连接的初始序号、初始的buffer大小，以免老的数据报对新的有影响）</li>
</ul>
<p><strong>不能两次握手的原因：</strong></p>
<ul>
<li><p>会因为确定连接的延迟到达，重发连接请求造成的半连接问题，浪费了服务器资源</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230417141459470.png" alt="image-20230417141459470" style="zoom:67%;" />
</li>
<li><p>同样因为连接确认的延迟，连接请求重发，并且数据也跟着延迟重发，导致不仅虚假连接发送到服务器上就连重复数据也被一起发送过去了。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230417141812517.png" alt="image-20230417141812517" style="zoom:67%;" />

</li>
</ul>
<p><strong>正确三次握手：</strong></p>
<p>中间讲对连接<strong>请求的确认和我的初始序号合并成一个报文</strong>发送给客户端。并且第三次握手有可能会包含正式数据。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230417142627779.png"></p>
<ul>
<li>第三次握手解决了半连接的问题</li>
<li>变化的初始序号解决了数据延迟重传的问题</li>
</ul>
</li>
<li><p><strong>关闭连接（四次挥手）：</strong></p>
<p>客户端，服务器分别关闭它自己这一侧的连接发送FIN bit = 1的TCP段。并且一旦接收到FIN，用ACK回应。</p>
<p><strong>本质就是对两个方向的连接进行单独拆除</strong>。并且为了避免最后一次确认的丢失问题（因为总是依赖最后一次的确认），客户端在第四次挥手之后还需要进入时间等待状态，结束后才正式关闭连接。</p>
<p><strong>保活定时器：</strong>TCP服务器进程每收到一次TCP客户进程的数据，就重新设置并启动保活计时器。若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器进程就向TCP客户进程发送一个探测报文段，以后则每隔75秒钟发送一次，若10次都未响应，则服务器直接关闭该连接。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230417142944890.png" alt="image-20230417142944890"></p>
</li>
</ul>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a><strong>拥塞控制</strong></h2><p>拥塞的表现：“太多的数据需要网络传输，超过了网络的处理能力”</p>
<ul>
<li>分组丢失(路由器缓冲区溢出)</li>
<li>分组经历比较长的延迟(在路由器的队列中排队)</li>
</ul>
<p>两种常用的拥塞控制方法：</p>
<ul>
<li><p>端到端拥塞控制（TCP采用的方法）</p>
</li>
<li><p>端系统根据延迟和丢失事件推断是否有拥塞。</p>
<p><strong>拥塞检测：</strong></p>
<ul>
<li>某个段超时了（丢失事件）：拥塞</li>
</ul>
</li>
<li><p>有关某个段的3次重复ACK：轻微拥塞</p>
<p><strong>速率控制：</strong></p>
<ol>
<li>维持一个拥塞窗口的值：CongWin</li>
</ol>
</li>
</ul>
<ol start="2">
<li>发送端限制已发送但是未确认的数据量（的上限）:<code>LastByteSent-LastByteAcked &lt;= CongWin</code></li>
<li>粗略地控制发送方的往网络中注入的速率：<code>rate ≈CongWin/RTT </code></li>
</ol>
<p>  <strong>控制策略：</strong></p>
<p>  主要有三个阶段<strong>慢启动、拥塞避免、轻微拥塞阶段</strong>：</p>
<p>  <strong>慢启动：</strong>从1个开始收到ACK就加倍增长，拥塞后将CongWin降为1，将CongWin/2作为阈值，进入慢启动阶段（倍增直到CongWin/2），到了CongWin/2之后就进入<strong>拥塞避免阶段开始线性增长</strong>。</p>
<p>  如果收到三个重复ACK进入轻微拥塞状态，<strong>将CongWin减半并线性增长</strong></p>
  <img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230419135521190.png" alt="image-20230419135521190" style="zoom:67%;" />

<ul>
<li><p>网络辅助的拥塞控制（网络负担比较重）</p>
<p>路由器提供给端系统以反馈信息</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode_多数元素</title>
    <url>/2021/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<h2 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h2><ul>
<li>方法1：可以开map记录然后遍历map统计得出答案 </li>
<li>方法2：先排序再遍历数组边遍历边统计</li>
<li>官方方法：排序返回n/2 下标的值</li>
<li>官方方法2：摩尔投票法</li>
</ul>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                temp++;</span><br><span class="line">                <span class="keyword">if</span>(temp&gt;(len/<span class="number">2</span>))&#123;</span><br><span class="line">                    ans=nums[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="官方方法："><a href="#官方方法：" class="headerlink" title="官方方法："></a>官方方法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">moreThanHalfNum_Solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val, cnt = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (auto x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cnt) val = x, cnt ++ ;     <span class="comment">//目标值与其他值刚好配对抵消时，重置计数</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == val) cnt ++ ;</span><br><span class="line">                <span class="keyword">else</span> cnt -- ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> val;                         <span class="comment">//最后剩下的一定是多于半数的目标值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之两数之和</title>
    <url>/2021/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>你可以按任意顺序返回答案。</p>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>可以看出这题基本思路就是遍历nums的每一个元素num，然后寻找该数组中是否存在target-num的值。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> len = nums.length;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> num = nums[i];</span><br><span class="line">                <span class="keyword">int</span> temp = target - num;</span><br><span class="line">                <span class="keyword">int</span> index = getIndex(nums,temp);</span><br><span class="line">                <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index==i)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans[<span class="number">0</span>]=i;</span><br><span class="line">                    ans[<span class="number">1</span>]=index;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num==nums[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之买卖股票的最佳时机</title>
    <url>/2021/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>方法1：动态规划： 创建一个dp数组记录状态 dp 0 为该天持有股票手上的现金数额 ，dp 1 为该天不持有股票手上的现金数额，注意起始状态 dp 0为 -当天的股价，dp 1 为 0；</p>
<p>官方方法：遍历数组一边遍历一边记录 最低股价，然后当当前股价高于最低股价就先判断是否大于最大利润，若大于更新最大利润，最后返回。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><p>方法1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],-prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minprice) &#123;</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit) &#123;</span><br><span class="line">                maxprofit = prices[i] - minprice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之二叉树的中序遍历</title>
    <url>/2021/04/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p>
<p><strong>示例：</strong></p>
<pre><code>输入：root = [1,null,2,3]
输出：[1,3,2]
</code></pre>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>​    递归遍历，先左再添加再右</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        midOrder(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">midOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        midOrder(root.left);</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">        midOrder(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之二叉树的最大深度</title>
    <url>/2021/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例：</strong></p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>返回它的最大深度 3 。</p>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>遍历二叉树，先遍历左支再遍历右支，然后比较得出最大深度</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lTemp = maxDepth(root.left)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rTemp = maxDepth(root.right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(lTemp,rTemp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之二叉树的直径</title>
    <url>/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<h1 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p><strong>示例：</strong></p>
<p>给定二叉树</p>
<pre><code>          1
         / \
        2   3
       / \     
      4   5  
</code></pre>
<p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>使用递归分别遍历左右子树，计算出最大深度，再相加更新ans并返回。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        getMax(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = getMax(node.left);</span><br><span class="line">        <span class="keyword">int</span> right = getMax(node.right);</span><br><span class="line">        ans = Math.max(left+right,ans);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之全排列</title>
    <url>/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<p><strong>示例：</strong></p>
<pre><code>输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
</code></pre>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>使用dfs进行全排列，注意一定要回溯的时候移除之前的数！</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(nums,temp);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums,List&lt;Integer&gt; temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.size()==nums.length)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!temp.contains(num))&#123;</span><br><span class="line">                temp.add(num);</span><br><span class="line">                dfs(nums,temp);</span><br><span class="line">                temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之删除字符串中的所有相邻重复项</title>
    <url>/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;abbaca&quot;</span><br><span class="line">输出：&quot;ca&quot;</span><br><span class="line">解释：</span><br><span class="line">例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</span><br></pre></td></tr></table></figure>


<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>这题和有效括号类似，可以利用栈先进后出的特性来存储每个字符并判断得出最后结果</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> len = S.length();</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> S;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">…            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Character character : stack) &#123;</span><br><span class="line">            sb.append(character);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之删除有序数组中的重复项</title>
    <url>/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例：</strong></p>
<pre><code>输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。
</code></pre>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0,0,1,1,1,1,2,3,3]</span><br><span class="line">输出：7, nums &#x3D; [0,0,1,1,2,3,3]</span><br><span class="line">解释：函数应返回新长度 length &#x3D; 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>​    使用双指针，一根指针指单个不同的数，一个指针如果相同就移动。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span> ,j = <span class="number">0</span>,count=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(j+i&lt;nums.length) &#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[i+j]==nums[i]) &#123;</span><br><span class="line">				<span class="keyword">if</span>(j&lt;<span class="number">2</span>) &#123;</span><br><span class="line">					temp[count] = nums[i];</span><br><span class="line">					count++;</span><br><span class="line">				&#125;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				i=i+j;</span><br><span class="line">				j=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; count; k++) &#123;</span><br><span class="line">			nums[k]=temp[k];</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之只出现一次的数字</title>
    <url>/2021/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><ul>
<li>我个人第一时间想到的是先排序再遍历看哪个是单出来的 (时间复杂度太高了) </li>
<li>还有一种是使用hashmap计数然后判断 </li>
<li>官方给出的解法 使用异或 (数组中各数异或 最后只会得到不相同的一个)</li>
</ul>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><ul>
<li>解法1：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;</span><br><span class="line">            ans = nums[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len-<span class="number">1</span>; i+=<span class="number">2</span>) &#123;</span><br><span class="line">…        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>解法二(略)</p>
</li>
<li><p>解法三</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            ans = ans ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之合并两个有序数组</title>
    <url>/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p>
<p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素</p>
<p><strong>示例：</strong></p>
<pre><code>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
</code></pre>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><ol>
<li>直接合并排序</li>
<li>使用的双指针方法，但是时间复杂度有点高了</li>
<li>双指针优化</li>
</ol>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[m+n];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>,index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m&amp;&amp;j&lt;n)&#123;</span><br><span class="line">            <span class="comment">//找那边更小，找到指针也需要移动</span></span><br><span class="line">            <span class="keyword">if</span>(nums1[i]&lt;nums2[j])&#123;</span><br><span class="line">                temp[index++] = nums1[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[index++] = nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m)&#123;</span><br><span class="line">            temp[index++] = nums1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n)&#123;</span><br><span class="line">            temp[index++] = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; temp.length; k++) &#123;</span><br><span class="line">            nums1[k] = temp[k];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(nums1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[m+n];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>,index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m||j&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">                temp[index++] = nums2[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">                temp[index++] = nums1[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                temp[index++] = nums1[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index++] = nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n+m; k++) &#123;</span><br><span class="line">            nums1[k] = temp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之合并两个有序链表</title>
    <url>/2021/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例 1：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/merge_ex1.jpg" alt="img"></p>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>使用递归算法，一直判断把问题交给下个子问题，直到链表到最后递归结束。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之合并二叉树</title>
    <url>/2021/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例 1:</p>
<p>输入:<br>    Tree 1                     Tree 2<br>          1                         2<br>         / \                       / \<br>        3   2                  1   3<br>       /                           \   \<br>      5                             4   7<br>输出:<br>合并后的树:<br>         3<br>        / <br>       4   5<br>      / \   \<br>     5   4   7</p>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>使用深度遍历即可,可以new一个根节点也可以直接使用t1返回.显然直接使用t1效率更高和内存消耗更低</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line">        t1.val = t1.val + t2.val;</span><br><span class="line">        t1.left = mergeTrees(t1.left,t2.left);</span><br><span class="line">        t1.right = mergeTrees(t1.right,t2.right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之回文链表</title>
    <url>/2021/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>请判断一个链表是否为回文链表。</p>
<p><strong>示例：</strong></p>
<pre><code>输入: 1-&gt;2
输出: false
</code></pre>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>使用递归，递归的归刚好反向的，就回溯的过程中从前往后对比。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ListNode temp=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       temp = head;</span><br><span class="line">       <span class="keyword">return</span> check(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> flag = check(head.next)&amp;&amp;(head.val==temp.val);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">        <span class="keyword">return</span> flag; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之子集</title>
    <url>/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h1 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><ul>
<li>使用回溯法，进行子集枚举。(排列组合子集都可以用到)</li>
</ul>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.add(nums[cur]);</span><br><span class="line">        dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">        temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之对称二叉树</title>
    <url>/2021/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p><strong>示例：</strong></p>
<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre>
<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>

<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>使用递归，先将完整的二叉树分成两个小的左右单独的树进行递归对比，如果左右子树都为空说明对称返回true，若一边为空一边不为空则返回false说明不对称，若节点的值不相同也返回false，最重要的是<strong>注意：因为要求镜像对称所以左子树的左节点要和右子树的右节点进行对比，左子树的右节点要和右子树的左节点进行对比！</strong></p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode left,TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>&amp;&amp;right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>||right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left.val!=right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(left.left,right.right)&amp;&amp;check(left.right,right.left);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之找到所有数组中消失的数字</title>
    <url>/2021/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="找到所有数组中消失的数字"><a href="#找到所有数组中消失的数字" class="headerlink" title="找到所有数组中消失的数字"></a>找到所有数组中消失的数字</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个范围在 1 ≤ a[i] ≤ <em>n</em> ( <em>n</em> = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>找到所有在 [1, <em>n</em>] 范围之间没有出现在数组中的数字。</p>
<p>您能在不使用额外空间且时间复杂度为*O(n)*的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>这题要求找出1到n数租缺少了哪一个，就开一个大小为n的数组，然后遍历nums把每个元素以坐标存在新开的数组中，最后统计看那个坐标的元素为0则就少哪个数。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            count[num]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                ans.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之括号的生成</title>
    <url>/2021/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E6%8B%AC%E5%8F%B7%E7%9A%84%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h1 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<p><strong>示例：</strong></p>
<pre><code>输入：n = 3
输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]
</code></pre>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>使用dfs，注意需要判断左右括号是否小于0了，否则就会递归到死！</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        getKH(ans, <span class="string">&quot;&quot;</span>, n, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getKH</span><span class="params">(List&lt;String&gt; ans,String str,<span class="keyword">int</span> lCount,<span class="keyword">int</span> rCount)</span></span>&#123;</span><br><span class="line">      	<span class="comment">//出口说明左右括号都选完了</span></span><br><span class="line">        <span class="keyword">if</span>(lCount==<span class="number">0</span>&amp;&amp;rCount==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当剩下的左括号比右括号多时肯定不合法可以直接回溯了</span></span><br><span class="line">        <span class="keyword">if</span>(lCount&gt;rCount)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//选左括号</span></span><br><span class="line">        <span class="keyword">if</span>(lCount&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            getKH(ans, str+<span class="string">&quot;(&quot;</span>, lCount-<span class="number">1</span>, rCount);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//选右括号</span></span><br><span class="line">        <span class="keyword">if</span>(rCount&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            getKH(ans, str+<span class="string">&quot;)&quot;</span>, lCount, rCount-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之最大子序和</title>
    <url>/2021/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<h1 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><ul>
<li>使用动态规划,我们边遍历数组边算出当前的最大和，然后再比较之前的最大和得出最终的最大和</li>
</ul>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//dp记录当前最大和</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>]+nums[i],nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;ans)&#123;</span><br><span class="line">                ans = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之最小栈</title>
    <url>/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<h1 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p>
<p><strong>示例 ：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;min-stack</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><ul>
<li>使用辅助栈的方法，把每次插入最小的放入辅助栈，需要最小的就peek辅助栈栈顶，需要pop就看是否是辅助栈栈顶元素，若是辅助栈也要一并pop出来</li>
</ul>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; min_stack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        min_stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(min_stack.isEmpty() || x &lt;= min_stack.peek())</span><br><span class="line">            min_stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(temp==min_stack.peek())&#123;</span><br><span class="line">            min_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之有效的括号</title>
    <url>/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>这题括号的匹配刚好契合数据结构栈先进后出的特性。。所以就当输入为左括号时就入栈，当为右括号时就弹出栈顶元素进行匹配，匹配成功则继续，失败则直接返回false，这里有两个需要注意的地方就是当字符串长度为1时就肯定没效直接返回false，还有当循环结束了栈里面还有字符那说明也没用相应的匹配也返回false;</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">                <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">                    stack.push(ch);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ch==<span class="string">&#x27;(&#x27;</span>||ch==<span class="string">&#x27;[&#x27;</span>||ch==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                        stack.push(ch);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">char</span> temp = stack.pop();</span><br><span class="line">                        <span class="keyword">if</span>(temp!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">char</span> temp = stack.pop();</span><br><span class="line">                        <span class="keyword">if</span>(temp!=<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">char</span> temp = stack.pop();</span><br><span class="line">                        <span class="keyword">if</span>(temp!=<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stack.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之根据身高重建队列</title>
    <url>/2021/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p>
<p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p>
<p><strong>示例：</strong></p>
<pre><code>输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
</code></pre>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]</span><br><span class="line">输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</span><br></pre></td></tr></table></figure>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>​    先根据身高逆序排序，再按照ki顺序排序，这样排序个子高的就不需要动了比它矮的直接插在它前面即可，直接根据它的ki直接插入到集合中。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">        Arrays.sort(people, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[<span class="number">0</span>]!=b[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.compare(b[<span class="number">0</span>],a[<span class="number">0</span>]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.compare(a[<span class="number">1</span>],b[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] person : people) &#123;</span><br><span class="line">            ans.add(person[<span class="number">1</span>],person);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[ans.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之比特位计数</title>
    <url>/2021/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a>比特位计数</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<p><strong>示例：</strong></p>
<pre><code>输入: 2
输出: [0,1,1]
</code></pre>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>这里偷个懒直接用java类库</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            arr[i] = Integer.bitCount(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之汉明距离</title>
    <url>/2021/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>两个整数之间的<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p>
<p><strong>注意：</strong><br>0 ≤ <code>x</code>, <code>y</code> &lt; 231.</p>
<p><strong>示例</strong>:</p>
<p><strong>输入</strong>: x = 1, y = 4</p>
<p><strong>输出</strong>: 2</p>
<p><strong>解释</strong>:<br>1   (0 0 0 1)<br>4   (0 1 0 0)<br>          ↑     ↑</p>
<p>上面的箭头指出了对应二进制位不同的位置。</p>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><ul>
<li>先x异或y将相同二进制位变为0，不相同的二进制位变为1</li>
<li>再用Integer内置bitCount函数计算有多少个1</li>
</ul>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Integer.bitCount(x^y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之爬楼梯</title>
    <url>/2021/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h1 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>经典的动态规划题目</p>
<p>我们用 f(x)<em>f</em>(<em>x</em>) 表示爬到第 x<em>x</em> 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出式子：<em>f</em>(<em>x</em>)=<em>f</em>(<em>x</em>−1)+<em>f</em>(<em>x</em>−2)</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> pre1=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre2=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ans=pre1+pre2;</span><br><span class="line">            pre1=pre2;</span><br><span class="line">            pre2=ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之环形链表</title>
    <url>/2021/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<p><strong>示例：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20210330210515093.png" alt="image-20210330210515093"></p>
<pre><code>输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
</code></pre>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>使用快慢双指针，先判断是否为空链表和只有一个节点若是直接返回false，再用快指针去追慢指针，如果有环一定会相遇，反之不会</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fir = head;</span><br><span class="line">        ListNode sec = head.next;</span><br><span class="line">        <span class="keyword">while</span>(fir!=sec)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sec==<span class="keyword">null</span>||sec.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fir = fir.next;</span><br><span class="line">            sec = sec.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之相交链表</title>
    <url>/2021/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>如下面的两个链表<strong>：</strong></p>
<p><strong>示例：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Iooooot/photos@master/blogAboutPic/image-20210326133334338.png" alt="image-20210326133334338"></p>
<pre><code>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
</code></pre>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>使用双指针，分别以一样的速度走一样长度的路径(A链+B链)，看是否会相遇在一个点若没有相交就只会都指向最后的null节点。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode pA = headA, pB = headB;</span><br><span class="line">    <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">        pA = pA == <span class="keyword">null</span> ? headB : pA.next;</span><br><span class="line">        pB = pB == <span class="keyword">null</span> ? headA : pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之移动零</title>
    <url>/2021/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<h1 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>先遍历数组，再遍历的过程中，若该数为0则用count记录次数，若不为0，则将该数放在 i - count 位上并该位变为0，直到遍历完成。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = nums.length,count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>||count==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                nums[i-count]=nums[i];</span><br><span class="line">                nums[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之翻转二叉树</title>
    <url>/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>翻转一棵二叉树。</p>
<p><strong>示例：</strong></p>
<p>输入：</p>
<pre><code>       4
     /   \
  2     7
 / \   / \
1   3 6   9
</code></pre>
<p>输出：<br>            4<br>      /   <br>      7     2<br>     / \   / <br>    9   6 3   1</p>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>使用深度遍历即可,左右子字点互换即可。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        root.left=invertTree(root.left);</span><br><span class="line">        root.right=invertTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之翻转链表</title>
    <url>/2021/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E4%B9%8B%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>反转一个单链表。</p>
<p><strong>示例：</strong></p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h2><p>这题的目的就是把两节点之间的指向反转</p>
<p>所以可以用双指针一个pre 一个cur ，让cur.next指向pre，再把双指针依次往后挪最后返回即可。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="comment">//这个temp用于指向下一个不然后面cur.next=pre之后就找不到了</span></span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2021/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li><p>首先必须是有序数组</p>
</li>
<li><p>先定义一个中心指针</p>
</li>
<li><p>循环看查找的数是否和中心点相等</p>
</li>
<li><p>若比中心点小肯定在它左边就继续对比左边，反之对比右边</p>
</li>
<li><p>如果左边界大于右边界了就退出循环</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 算法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 二分查找 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">14</span>, <span class="number">53</span>, <span class="number">214</span>, <span class="number">542</span>, <span class="number">748</span>&#125;;</span><br><span class="line">        System.out.println(binaryFind(arr, <span class="number">111</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binaryFind</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; num) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>基本算法模板</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// 区间[l,r]被划分为[l,mid]和[mid + 1,r]时使用:</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	  	<span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">	     	<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="comment">//取中间值</span></span><br><span class="line">	      <span class="keyword">if</span>(check(mid)) r = mid;<span class="comment">//如果处于右半边满足条件则答案在mid的左边包括mid也有可能</span></span><br><span class="line">	      <span class="keyword">else</span> l = mid + <span class="number">1</span>; <span class="comment">//不满足条件答案在mid的右边不包括mid</span></span><br><span class="line">	    &#125;</span><br><span class="line">	  	<span class="keyword">return</span> l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 区间[l,r]被划分为[l,mid-1]和[mid,r]时使用:</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	  	<span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">	     	<span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>; <span class="comment">//取中间值 但是由于取得l=mid防止下标越界需要+1处理</span></span><br><span class="line">	      <span class="keyword">if</span>(check(mid)) l = mid;<span class="comment">//左半边满足条件答案在mid的右边并且包括mid</span></span><br><span class="line">	      <span class="keyword">else</span> r = mid - <span class="number">1</span>;<span class="comment">//处于右半边不满足条件答案在mid的左边不包括mid</span></span><br><span class="line">	    &#125;</span><br><span class="line">	  	<span class="keyword">return</span> l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//浮点数二分</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="keyword">double</span> l,<span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">	  <span class="keyword">while</span>(r - l &gt; <span class="number">1e-6</span>)&#123; <span class="comment">//这里需比答案要求高出两位才能保证精度正确</span></span><br><span class="line">	  	<span class="keyword">double</span> mid = (l + r)/<span class="number">2</span>; <span class="comment">//取中点</span></span><br><span class="line">	    <span class="keyword">if</span>(check(mid)) r = mid; <span class="comment">//左右两边都有可能是答案,因为浮点数只能确定范围不能精确到某个位置</span></span><br><span class="line">	    <span class="keyword">else</span> l = mid; </span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">return</span> l;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/162002842044.png" alt="image-20210324151736927"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 算法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 冒泡排序 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">9</span>,-<span class="number">1</span>,<span class="number">10</span>,<span class="number">20</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i]&gt;arr[j])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                    flag =<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和</title>
    <url>/2022/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><h3 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h3><p>一维前缀和：该位之前所有数之和，需要拿一个数组来存，前缀和的目的就是为了方便之后需要求数组中某一段的和不再需要重新遍历，只需要利用前缀和进行操作。</p>
<p>如：输入一个长度为 n 的整数序列。接下来再输入 m 个询问，每个询问输入一对 l,r。对于每个询问，输出原序列中从第 l个数到第 r个数的和。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="keyword">int</span> a[N],s[N]; <span class="comment">//将比较大的数组定义为全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,l,r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]); <span class="comment">//录入数组</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) s[i] = s[i<span class="number">-1</span>] + a[i]; <span class="comment">//求前缀和</span></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[r] - s[l - <span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//利用前缀和求l到r的和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><h3 id="简单分析-1"><a href="#简单分析-1" class="headerlink" title="简单分析"></a>简单分析</h3><p>二维前缀和：同样是指该点向上之前矩阵中所有数之和；需要二维数组来存，依然是为了方便求二维矩阵数组中某个子矩阵的和。</p>
<p>如：输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2表示一个子矩阵的左上角坐标和右下角坐标。对于每个询问输出子矩阵中所有数的和。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"><span class="keyword">int</span> a[N][N],s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,q,x1,y1,x2,y2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; <span class="comment">//注意要从1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]); <span class="comment">//录入数组</span></span><br><span class="line">            s[i][j] = s[i<span class="number">-1</span>][j] + s[i][j<span class="number">-1</span>] - s[i<span class="number">-1</span>][j<span class="number">-1</span>] + a[i][j]; <span class="comment">//根据公式计算前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2); <span class="comment">//录入坐标</span></span><br><span class="line">        <span class="keyword">int</span> ans = s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]; <span class="comment">//根据公式计算两坐标之间子矩阵和</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希排序</title>
    <url>/2021/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>先将数组分为length/2组，然后依次/2分组</li>
<li>每组进行插入排序</li>
<li>最后再进行总的插入排序</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/162002842082.png" alt="162002842082"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 算法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 希尔排序 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        shellSort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="comment">//循环进行分组，i表示分组数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len/<span class="number">2</span>; i &gt;<span class="number">0</span> ; i/=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//开始插入排序</span></span><br><span class="line">          	<span class="comment">//因为分了组所以只遍历len-i次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">              	<span class="comment">//从k位开始遍历比较</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j-i; k &gt;=<span class="number">0</span> ; k-=i) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[k]&gt;arr[k+i])&#123;</span><br><span class="line">                        <span class="keyword">int</span> temp = arr[k];</span><br><span class="line">                        arr[k] = arr[k+i];</span><br><span class="line">                        arr[k+i] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 算法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 希尔排序 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        shellSort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="comment">//循环进行分组，i表示分组数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len/<span class="number">2</span>; i &gt;<span class="number">0</span> ; i/=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//开始插入排序</span></span><br><span class="line">          	<span class="comment">//因为分了组所以只遍历len-i次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">              <span class="keyword">int</span> index = j;</span><br><span class="line">              <span class="keyword">int</span> temp = arr[index];</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> k = j-i; k &gt;=<span class="number">0</span> ; k-=i) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(temp&lt;arr[k])&#123;</span><br><span class="line">                        arr[index]=arr[k];</span><br><span class="line">                      	index = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              arr[index] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基数排序</title>
    <url>/2021/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>基数排序(Radix Sort)是<strong>桶排序</strong>的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。<br>具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/162002841955.png" alt="image-20210406150910890"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 算法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 基数排序 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">53</span>,<span class="number">3</span>,<span class="number">542</span>,<span class="number">748</span>,<span class="number">1114</span>,<span class="number">214</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        radixSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//设置二维数组作为桶</span></span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        <span class="comment">//设置每个桶的指针</span></span><br><span class="line">        <span class="keyword">int</span>[] bucketIndex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;max)&#123;</span><br><span class="line">                max = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = (max+<span class="string">&quot;&quot;</span>).length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">//算出这个数在哪个桶</span></span><br><span class="line">                <span class="keyword">int</span> numIndex = (arr[j]/((<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i)))%<span class="number">10</span>;</span><br><span class="line">                <span class="comment">//将这个数放入桶中</span></span><br><span class="line">                bucket[numIndex][bucketIndex[numIndex]]=arr[j];</span><br><span class="line">                bucketIndex[numIndex]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketIndex.length; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(bucketIndex[k]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;bucketIndex[k] ; l++) &#123;</span><br><span class="line">                        arr[index++] = bucket[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                bucketIndex[k] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>差值查找</title>
    <url>/2021/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B7%AE%E5%80%BC%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>相当于对二分查找的一种优化，让mid指针更加精确</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/162002842031.png" alt="image-20210409173339371"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 算法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 插值查找 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">           arr[i] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = insertValueSearch(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>, <span class="number">99999</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertValueSearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;arr[left]||num&gt;arr[right])&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l =left;</span><br><span class="line">        <span class="keyword">int</span> r = right;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r-l)*(num-arr[l])/(arr[r]-arr[l]);</span><br><span class="line">        <span class="keyword">while</span> (l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid]==num)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid]&gt;num)&#123;</span><br><span class="line">                r = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = l + (r-l)*(num-arr[l])/(arr[r]-arr[l]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>差分</title>
    <url>/2022/01/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>差分和前缀和是密不可分的，如有一个数组a，就会对应有一个差分数组b。差分数组b的特性是：</p>
<p>a[i]=b1+b2+b3+…+bi,即为将数组a看做b的前缀和数组,a与b互为逆运算.</p>
<h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><h3 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h3><p>一维差分就是由一维数组组成的差分，主要运用差分数组的特性将求原数组a(b的前缀和数组)的某子区间进行加减操作从O(n)转化为O(1).</p>
<p>如：输入一个长度为 n 的整数序列。接下来输入 m 个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r]之间的每个数加上 c。请你输出进行完所有操作后的序列。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    b[l] += num; <span class="comment">//将第l个加上num因为a为b的前缀和所以l之后所有a[i]都会加上num</span></span><br><span class="line">    b[r+<span class="number">1</span>] -= num; <span class="comment">//由于只需要加到r所以需要将r+1处的b减去num用来抵消上面加的num</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]); <span class="comment">//录入原数组</span></span><br><span class="line">        insert(i,i,a[i]); <span class="comment">//求差分数组 就等于初始化原数组为0将每一位都加上a[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);</span><br><span class="line">        insert(l,r,c); <span class="comment">//根据询问执行插入得到新的差分数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = a[i<span class="number">-1</span>] + b[i];  <span class="comment">//重新逆运算求回原数组(即为求b数组的前缀和)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><h3 id="简单分析-1"><a href="#简单分析-1" class="headerlink" title="简单分析"></a>简单分析</h3><p>二维差分与一维类似只不过由线段变为矩阵，差分数组b变为一个矩阵，作用依然是运用差分数组的特性将求原数组a(b的前缀和数组)的某子区间进行加减操作从O(n)转化为O(1).</p>
<p>如：输入一个 n 行 m 列的整数矩阵，再输入 q个操作，每个操作包含五个整数 x1,y1,x2,y2,c其中 (x1,y1)(x1,y1) 和 (x2,y2)(x2,y2) 表示一个子矩阵的左上角坐标和右下角坐标。每个操作都要将选中的子矩阵中的每个元素的值加上 c。请你将进行完所有操作后的矩阵输出。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>差分公式分析</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://s3.bmp.ovh/imgs/2022/01/7eb06571f25a9c17.png" alt="image-20220124132208934"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"><span class="keyword">int</span> a[N][N],b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    b[x1][y1] += c; <span class="comment">//先将起始坐标的差分数组+c等同于对于a数组(b的前缀和数组)x1,y1之后的整个矩阵都加上了c</span></span><br><span class="line">    <span class="comment">//由于只需要加到x2，y2坐标 就需要把x2，y2之后多余的矩阵减去c与刚才加的c抵消</span></span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c; <span class="comment">//但是会减去两次一个重复的矩阵需要加回来一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]); <span class="comment">//录入原矩阵</span></span><br><span class="line">            <span class="comment">//同样假设一开始a数组都为0则差分数组b也都为0，这样求a数组的差分数组就等同于从一开始的0插入a[i][j]依次得到新的差分数组</span></span><br><span class="line">            <span class="comment">//当原数组录入完则差分数组也计算完</span></span><br><span class="line">            insert(i,j,i,j,a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123; <span class="comment">//q次询问</span></span><br><span class="line">        <span class="keyword">int</span> x1,y1,x2,y2,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c); <span class="comment">//录入两坐标和,需加的值c</span></span><br><span class="line">        insert(x1,y1,x2,y2,c); <span class="comment">//直接调用插入函数 更新差分数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据差分数组 逆运算求回所对应新的原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            a[i][j] =a[i - <span class="number">1</span>][j] + a[i][j - <span class="number">1</span>] - a[i - <span class="number">1</span>][j - <span class="number">1</span>] + b[i][j]; <span class="comment">//二维前缀和公式</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i][j]); <span class="comment">//边求边打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2021/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/162002841968.png" alt="162002841968"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/162002841965.png" alt="162002841965"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 算法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 归并排序 </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        sort(nums, <span class="number">0</span>,nums.length-<span class="number">1</span>, temp);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//对左半边进行归并排序</span></span><br><span class="line">            sort(arr, left, mid,temp);</span><br><span class="line">            <span class="comment">//对右半边进行归并排序</span></span><br><span class="line">            sort(arr, mid+<span class="number">1</span>, right,temp);</span><br><span class="line">            <span class="comment">//开始分治中的治操作，在归的途中进行合并</span></span><br><span class="line">            merge(arr,left,mid,right,temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//左分支的指针</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="comment">//右分支的指针</span></span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//temp数组的指针</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//在左右两分支找最小的数放在temp数组中</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=right)&#123;</span><br><span class="line">            <span class="comment">//找那边更小，找到指针也需要移动</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;arr[j])&#123;</span><br><span class="line">                temp[index++] = arr[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[index++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找完将剩余元素之间放入temp中</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            temp[index++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;</span><br><span class="line">            temp[index++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后将temp复制回原数组</span></span><br><span class="line">        index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            arr[left++]=temp[index++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2021/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>1．先从数列中取出一个数作为基准数。</p>
<p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p>
<p>3．再对左右区间重复第二步，直到各区间只有一个数。  </p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/162002841931.png" alt="162002841931"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul>
<li>双向划分(最基础版)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 算法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 快速排序 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">9</span>,<span class="number">78</span>,<span class="number">0</span>,<span class="number">23</span>,-<span class="number">567</span>,<span class="number">70</span>&#125;;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = left;<span class="comment">//左下标</span></span><br><span class="line">            <span class="keyword">int</span> r = right;<span class="comment">//右下标</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[l];<span class="comment">//基准数</span></span><br><span class="line">            <span class="comment">//循环进行分组</span></span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="comment">//从右边找比它小的数</span></span><br><span class="line">                <span class="keyword">while</span>(r&gt;l&amp;&amp;arr[r]&gt;=temp)&#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果找到则将它放在左边</span></span><br><span class="line">                <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">                    arr[l]=arr[r];</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从左边找比它大的数</span></span><br><span class="line">                <span class="keyword">while</span>(l&lt;r&amp;&amp;arr[l]&lt;=temp)&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果找到则将它放在右边</span></span><br><span class="line">                <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">                    arr[r]=arr[l];</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里l==r</span></span><br><span class="line">            <span class="comment">//注意需要将temp填回中间</span></span><br><span class="line">            arr[l]=temp;</span><br><span class="line">            <span class="comment">//分别对中间两边再进行分组排序</span></span><br><span class="line">            <span class="comment">//左边</span></span><br><span class="line">            quickSort(arr,left,l-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//右边</span></span><br><span class="line">            quickSort(arr, l+<span class="number">1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>双向划分升级版</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>; <span class="comment">//数组只有一个或零个元素肯定有序直接返回</span></span><br><span class="line">  	<span class="comment">//并用i，j记录左右划分起点，但是由于使用的dowhile肯定会先++所以需要再往外取1</span></span><br><span class="line">  	<span class="keyword">int</span> x = arr[left + right &gt;&gt; <span class="number">1</span>],i = left - <span class="number">1</span>,j = right + <span class="number">1</span>; <span class="comment">//取中点为基准</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123; </span><br><span class="line">      <span class="keyword">do</span> i++;<span class="keyword">while</span>(arr[i] &lt; x); <span class="comment">//从左向右找找大于等于x的数</span></span><br><span class="line">      <span class="keyword">do</span> j--;<span class="keyword">while</span>(arr[i] &gt; x);	<span class="comment">//从右向左找找小于等于x的数</span></span><br><span class="line">      <span class="keyword">if</span>(i &lt; j)&#123;								<span class="comment">//如果i，j没有相遇则交换使左边小于等于x，右边大于等于x</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	quickSort(arr,left,j); 			<span class="comment">//递归遍历左边</span></span><br><span class="line">  	quickSort(arr,j+<span class="number">1</span>,right);		<span class="comment">//递归遍历右边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>单向划分</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>; <span class="comment">//数组只有一个或零个元素肯定有序直接返回</span></span><br><span class="line">  	<span class="keyword">int</span> x = arr[<span class="number">1</span>],i = left; <span class="comment">//取最左边为基准 i作为分隔点,左边全为小于x的数据包括i右边大于等于x</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = left + <span class="number">1</span>;j &lt;= r;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &lt; x)&#123; <span class="comment">//用j来从左向右找小于x的值与++i交换 因为i所在的元素已经小于x</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[++i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[left]; <span class="comment">//最后将基准与i即为基准的最终位置交换</span></span><br><span class="line">    arr[left] = arr[i];</span><br><span class="line">    arr[i] = temp;</span><br><span class="line">    </span><br><span class="line">  	quickSort(arr,left,i-<span class="number">1</span>); 			<span class="comment">//递归遍历左边</span></span><br><span class="line">  	quickSort(arr,i+<span class="number">1</span>,right);		<span class="comment">//递归遍历右边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2021/05/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>遍历 len-1 次</li>
<li>每次将第i个插入数组，并判断与当前最前面的数的大小。</li>
</ul>
<p>​    <img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/162002842034.png" alt="image-20210326131234044"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 算法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 插入排序 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">101</span>,<span class="number">34</span>,<span class="number">119</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="keyword">int</span> num = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span> ; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(num&lt;arr[j])&#123;</span><br><span class="line">                    arr[index] = arr[j];</span><br><span class="line">                    index = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[index] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2021/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>遍历 len-1 次</li>
<li>每次选择出最小的值放在前面</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/162002842041.png" alt="image-20210325162602291">    </p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 算法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 选择排序 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">101</span>,<span class="number">34</span>,<span class="number">119</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> min，minIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">            minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;min)&#123;</span><br><span class="line">                    min = arr[j];</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">if</span>(minIndex!=i)&#123;</span><br><span class="line">             arr[minIndex]=arr[i];</span><br><span class="line">             arr[i]=min;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度大整数计算</title>
    <url>/2022/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%A4%A7%E6%95%B4%E6%95%B0%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="高精度大整数计算"><a href="#高精度大整数计算" class="headerlink" title="高精度大整数计算"></a>高精度大整数计算</h1><h2 id="两个高精度大整数相加"><a href="#两个高精度大整数相加" class="headerlink" title="两个高精度大整数相加"></a>两个高精度大整数相加</h2><h3 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h3><p>​    由于两个都是大整数，需要用数组或容器来存。具体运算就跟手算一样，各位相加留下10的余数多于10的进位，从个位开始一直重复到最高位即可，最后需要注意进位是否还多出一位来。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230422092806798.png" alt="image-20230422092806798"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c++代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c;  <span class="comment">//用于存和</span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.size() || i &lt; B.size();i++)&#123; <span class="comment">//遍历从个位开始到最高位</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.size()) t += A[i]; <span class="comment">//如果数A还有数则与进位加在一起</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.size()) t += B[i];	<span class="comment">//如果数B还有数则与进位加在一起</span></span><br><span class="line">        c.push_back(t % <span class="number">10</span>); <span class="comment">//10的余数为该位结果</span></span><br><span class="line">        t /= <span class="number">10</span>; <span class="comment">//进位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) c.push_back(t); <span class="comment">//检查是否还有进位</span></span><br><span class="line">    <span class="keyword">return</span> c; <span class="comment">//返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a,b; <span class="comment">//用字符串先接受输入 如123 注意1是最高位 3是最低位</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A; <span class="comment">//装操作数的容器</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.size() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">//从个位开始装</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = b.size() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)B.push_back(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c = add(A,B); <span class="comment">//调用函数计算结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c.size() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c[i]); <span class="comment">// 还是还原正常的高位到低位输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两个高精度大整数相减"><a href="#两个高精度大整数相减" class="headerlink" title="两个高精度大整数相减"></a>两个高精度大整数相减</h2><h3 id="简单分析-1"><a href="#简单分析-1" class="headerlink" title="简单分析"></a>简单分析</h3><p>​    同样由于两个都是大整数，需要用数组或容器来存。具体运算就跟手算一样，首先保证A要大于等于B，然后设t为借位，还是从低位到高位每次将A的各位 - B的各位 - 借位t，将其对10求余则为两数差该位的答案，再由其正负确定是否向高位借位。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230422092741697.png" alt="image-20230422092741697"></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c++代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//比较两数大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(A.size()!= B.size())&#123; <span class="comment">//如果长度不同则谁长谁大</span></span><br><span class="line">        <span class="keyword">return</span> A.size()&gt; B.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = A.size() - <span class="number">1</span>;i &gt;= <span class="number">0</span> ;i--)&#123;<span class="comment">//注意是从高位开始比较</span></span><br><span class="line">                <span class="keyword">if</span>(A[i] != B[i])&#123;  <span class="comment">//依次比较每一位  不相等则该位谁大就谁大</span></span><br><span class="line">                    <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//完全相等直接返回1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c; <span class="comment">//结果容器</span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">//借位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.size();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = A[i] - t; <span class="comment">//先将借位减去</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.size()) temp -= B[i]; <span class="comment">//如果B数还有数就减去</span></span><br><span class="line">        c.push_back((temp + <span class="number">10</span>) % <span class="number">10</span>); <span class="comment">//结果对10求余为该位答案</span></span><br><span class="line">        <span class="keyword">if</span>(temp &gt;= <span class="number">0</span>)t = <span class="number">0</span>; <span class="comment">//判断借位</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.size() != <span class="number">1</span> &amp;&amp; c.back()==<span class="number">0</span>)c.pop_back(); <span class="comment">//去除前缀0 如10-10=00只需要输出一个0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A,B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.size() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//从个位开始装</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = b.size() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)B.push_back(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C = cmp(A,B) ? sub(A,B) : sub(B,A); <span class="comment">//保证A&gt;=B</span></span><br><span class="line">    <span class="keyword">if</span>(!cmp(A,B))<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;-&quot;</span>; <span class="comment">//如果A&lt;B需要将结果加负号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.size() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)<span class="built_in">cout</span>&lt;&lt;C[i]; <span class="comment">// 还是还原正常的高位到低位输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度大整数乘小整数"><a href="#高精度大整数乘小整数" class="headerlink" title="高精度大整数乘小整数"></a>高精度大整数乘小整数</h2><h3 id="简单分析-2"><a href="#简单分析-2" class="headerlink" title="简单分析"></a>简单分析</h3><p>​    只有一个大整数所以只需要一个容器来存另一个用整数即可，与手算有点点区别，还是从低位到高位依次用大整数的每一位乘以小数b得到一个小整数，将其对10求余就是该位的答案并将多余的进位运算,同样注意前缀0问题;</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230422092649078.png" alt="image-20230422092649078"></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c++代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c; <span class="comment">//存结果</span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.size() || t;i++)&#123; <span class="comment">//从低位开始如果遍历完A但是依然还有进位继续循环</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.size()) t += A[i] * b; <span class="comment">//得到每位的总结果</span></span><br><span class="line">        c.push_back(t%<span class="number">10</span>); <span class="comment">//对10求余得到当前位的结果</span></span><br><span class="line">        t /= <span class="number">10</span>; <span class="comment">//其余进位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.size() != <span class="number">1</span> &amp;&amp; c.back() == <span class="number">0</span>)c.pop_back(); <span class="comment">//去除前缀0 如12*0=00只要一个0  			return c;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b; </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.size() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">//依然倒置让个位在前</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C = mul(A,b);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.size() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)<span class="built_in">cout</span>&lt;&lt;C[i]; <span class="comment">// 还是还原正常的高位到低位输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="高精度大整数除以小整数"><a href="#高精度大整数除以小整数" class="headerlink" title="高精度大整数除以小整数"></a>高精度大整数除以小整数</h2><h3 id="简单分析-3"><a href="#简单分析-3" class="headerlink" title="简单分析"></a>简单分析</h3><p>​    只有一个大整数所以只需要一个容器来存另一个用整数即可，与手算有区别，从高位开始算，将每一位加上上一位的余数*10除以b，继续将余数留给下一位，直到大数的每一位计算完，需要注意答案是从高位到低位排列的，要去除前缀0需要先逆置;</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20230422092709367.png" alt="image-20230422092709367"></p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c++代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>; <span class="comment">//上一位的余数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = A.size() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123; <span class="comment">//除法需要从高位开始除</span></span><br><span class="line">        <span class="keyword">int</span> temp = t*<span class="number">10</span> + A[i];  <span class="comment">//上一位余数因为高一位需要*10加上该位</span></span><br><span class="line">        c.push_back(temp / b); <span class="comment">//得到该位的答案</span></span><br><span class="line">        t = temp % b; <span class="comment">//将该位余数记录</span></span><br><span class="line">    &#125;</span><br><span class="line">    r = t; <span class="comment">//最终余数</span></span><br><span class="line">    reverse(c.begin(),c.end()); <span class="comment">//由于从高位开始算的高位在前面所以需要逆置去除前缀零</span></span><br><span class="line">    <span class="keyword">while</span>(c.size() != <span class="number">1</span> &amp;&amp; c.back() == <span class="number">0</span>)c.pop_back();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.size() - <span class="number">1</span>;i &gt;=<span class="number">0</span>;i--)A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//依然倒置让个位在前</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C = div(A,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.size() - <span class="number">1</span>;i &gt;=<span class="number">0</span>;i--)<span class="built_in">cout</span>&lt;&lt;C[i]; <span class="comment">// 还是还原正常的高位到低位输出</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;r;<span class="comment">//输出余数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ集群</title>
    <url>/2023/02/12/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h1 id="RabbitMQ集群"><a href="#RabbitMQ集群" class="headerlink" title="RabbitMQ集群"></a>RabbitMQ集群</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般一台RabbitMQ 服务器，无法满足目前真实应用的要求；特别是在RabbitMQ 服务器遇到内存崩溃、机器掉电或者主板故障等情况，如果不使用集群消息队列功能就会完全失效，并且不能支持很高的吞吐量，所以搭建集群是很有必要的。</p>
<h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><p>大致结构：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220903215739041.png" alt="image-20220903215739041" style="zoom:50%;" />

<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>准备三台服务器（可以克隆，可以利用docker创建三个容器）</p>
</li>
<li><p>配置各个服务器的host文件：<code>vim /etc/hosts</code></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220903220243851.png" alt="image-20220903220243851"></p>
</li>
<li><p>要确保各个节点的 cookie 文件使用的是同一个值，在node1上进行远程复制：</p>
<p><code>scp /var/lib/rabbitmq/.erlang.cookie root@node2:/var/lib/rabbitmq/.erlang.cookie</code></p>
<p><code>scp /var/lib/rabbitmq/.erlang.cookie root@node3:/var/lib/rabbitmq/.erlang.cookie</code></p>
</li>
<li><p>重新启动 RabbitMQ 服务,顺带启动 Erlang 虚拟机和 RbbitMQ 应用服务(在三台节点上分别执行以下命令)：<code>rabbitmq-server -detached</code></p>
</li>
<li><p>分别让node2和node3加入到以node1为主的集群中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl stop_app (rabbitmqctl stop 会将Erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务) </span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node1 rabbitmqctl start_app(只启动应用服务)</span><br></pre></td></tr></table></figure></li>
<li><p>查看集群状态：<code>rabbitmqctl cluster_status</code></p>
</li>
<li><p>需要重新设置用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建账号</span><br><span class="line">rabbitmqctl add_user admin 123</span><br><span class="line"># 设置用户角色</span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"># 设置用户权限</span><br><span class="line">rabbitmqctl set_permissions -p &quot;&#x2F;&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解除集群(只需要在node2和node3中执行)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset </span><br><span class="line">rabbitmqctl start_app </span><br><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure>

<p>在node1上执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl forget_cluster_node rabbit@node2</span><br><span class="line">rabbitmqctl forget_cluster_node rabbit@node3</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h2></li>
</ol>
<p>如果 RabbitMQ 集群中只有一个 Broker 节点，那么该节点的失效将导致整体服务的临时性不可用，并且也可能会导致消息的丢失。</p>
<p>引入镜像队列(Mirror Queue)的机制，可以将队列镜像到集群中的其他 Broker 节点之上，如果集群中的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性。</p>
<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><ol>
<li><p>随便给一个节点添加policy（在ui界面里的admin这一栏右侧的policies中）：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220904130344264.png" alt="image-20220904130344264"></p>
</li>
<li><p>在 node1 上创建一个队列发送一条消息，队列存在镜像队列</p>
</li>
<li><p>停掉 node1 之后发现 node2 成为镜像队列，并且就算整个集群只剩下一台机器了 依然能消费队列里面的消息说明队列里面的消息被镜像队列传递到相应机器里面了。</p>
</li>
</ol>
<h2 id="实现负载均衡"><a href="#实现负载均衡" class="headerlink" title="实现负载均衡"></a>实现负载均衡</h2><p>…..后续学习</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/2021/04/14/%E6%95%B0%E6%8D%AE%E5%BA%93/ORM%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/MyBatis/MyBatis/</url>
    <content><![CDATA[<h1 id="Mybatis笔记"><a href="#Mybatis笔记" class="headerlink" title="Mybatis笔记"></a>Mybatis笔记</h1><h2 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h2><p>​        MyBatis 是一款优秀的<strong>持久层框架</strong>，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以<strong>使用简单的 XML 或注解来配置和映射原生信息</strong>，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</p>
<ul>
<li><strong>优点：</strong></li>
<li>Mybatis将重要的步骤抽取出来可以人工定制，其他步骤自动化<ul>
<li>重要步骤写在配置文件中（方便维护）</li>
<li>完全解决数据库优化问题</li>
<li>Mybatis底层就是对原生JDBC的一个简单封装</li>
<li>即将java编码与sql抽取出来，还不会失去自动化功能的半自动持久层框架</li>
</ul>
</li>
</ul>
<h2 id="Mybatis的使用"><a href="#Mybatis的使用" class="headerlink" title="Mybatis的使用"></a>Mybatis的使用</h2><h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--LOG4J日志包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="创建mybatis全局配置文件"><a href="#创建mybatis全局配置文件" class="headerlink" title="创建mybatis全局配置文件"></a>创建mybatis全局配置文件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    resource 是指在类路径下 url 指网络路径或者磁盘路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;mybatisTest\Test1\conf\dbconfig.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    settings设置项属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTypeForNull&quot;</span> <span class="attr">value</span>=<span class="string">&quot;NULL&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 懒加载 只有当属性被用到时才会在ass分步查询中加载       --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    别名处理器 可以给我java类型起别名 默认类名小写--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        1.单个起别名--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;typeAlias type=&quot;mybatisTest.Test1.Employee&quot; alias=&quot;emp&quot;/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        2.批量起别名</span></span><br><span class="line"><span class="comment">            package:为某个包下的所有类批量起别名</span></span><br><span class="line"><span class="comment">            name:指定包名默认全部为类名小写</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;mybatisTest.Test1&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        3.使用注解起别名 在类上加@Alias(&quot;emp&quot;)</span></span><br><span class="line"><span class="comment">            优先级最高</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    环境们，可以配置多个环境 修改default切换环境</span></span><br><span class="line"><span class="comment">        id 唯一标识</span></span><br><span class="line"><span class="comment">        必须有</span></span><br><span class="line"><span class="comment">        transactionManager 事务管理器</span></span><br><span class="line"><span class="comment">            type：事务管理器类型</span></span><br><span class="line"><span class="comment">        dataSource ：数据源</span></span><br><span class="line"><span class="comment">            type：类型</span></span><br><span class="line"><span class="comment">            自定义数据源：实现DataSourceFactory接口type为全类名</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    databaseIdProvider实现多数据库厂商--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">&quot;DB_VENDOR&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        为不同的数据库厂商起别名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;MySQL&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Oracle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;oracle&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    将我们写好的sql映射文件一定要注册到全局配置文件(mybatis-config.xml)中--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    将我们写好的sql映射文件到全局配置中</span></span><br><span class="line"><span class="comment">        resource 是指在类路径下</span></span><br><span class="line"><span class="comment">        url 指网络路径或者磁盘路径</span></span><br><span class="line"><span class="comment">        class:注册接口</span></span><br><span class="line"><span class="comment">               1.有sql映射文件，必须与接口同名并同一目录</span></span><br><span class="line"><span class="comment">               2.没有sql映射文件，sql映射文件利用注解写在接口上</span></span><br><span class="line"><span class="comment">               推荐</span></span><br><span class="line"><span class="comment">                   比较重要的dao接口用sql映射反之用注解</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mybatisTest\Test1\conf\EmployeeMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mybatisTest\Test1\EmployeeMapperPlus.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mybatisTest\Test1\conf\DepartmentMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;mybatisTest.Test1.EmployeeMapperAnnotation&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mybatisTest\Test1\conf\EmployeeMapperDynamicSQL.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        批量注册  包下所有注册 但没有注解的必须与接口同名并同一目录--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;package name=&quot;&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>数据库配置文件</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:///mybatis?useUnicode=true&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=123456</span><br></pre></td></tr></table></figure></li>
<li><p>log4J配置文件</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span><br><span class="line">log4j.rootLogger=DEBUG,console,file</span><br><span class="line"></span><br><span class="line">#控制台输出的相关设置</span><br><span class="line">log4j.appender.console = org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.Target = System.out</span><br><span class="line">log4j.appender.console.Threshold=DEBUG</span><br><span class="line">log4j.appender.console.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern=[%c]-%m%n</span><br><span class="line"></span><br><span class="line">#文件输出的相关设置</span><br><span class="line">log4j.appender.file = org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.file.File=./log/日志.log</span><br><span class="line">log4j.appender.file.MaxFileSize=10mb</span><br><span class="line">log4j.appender.file.Threshold=DEBUG</span><br><span class="line">log4j.appender.file.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span><br><span class="line"></span><br><span class="line">#日志输出级别</span><br><span class="line">log4j.logger.org.mybatis=DEBUG</span><br><span class="line">log4j.logger.java.sql=DEBUG</span><br><span class="line">log4j.logger.java.sql.Statement=DEBUG</span><br><span class="line">log4j.logger.java.sql.ResultSet=DEBUG</span><br><span class="line">log4j.logger.java.sql.PreparedStatement=DEBUG</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="sql映射配置文件的简单配置"><a href="#sql映射配置文件的简单配置" class="headerlink" title="sql映射配置文件的简单配置"></a>sql映射配置文件的简单配置</h4>  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace相当于告诉Mybatis这个配置文件实现哪个接口的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.wht.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--select:用于定义查询操作</span></span><br><span class="line"><span class="comment">			id：方法名，某个方法的实现</span></span><br><span class="line"><span class="comment">			resultType：指方法运行后的返回值类型</span></span><br><span class="line"><span class="comment">			#&#123;属性名&#125;：代表取出传递过来的参数值</span></span><br><span class="line"><span class="comment">			parameterType：传过来的参数类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wht.pojo.User&quot;</span>&gt;</span></span><br><span class="line">         select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wht.pojo.User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSessionFactory <span class="title">getSqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String resource = <span class="string">&quot;mybatisTest\\Test1\\conf\\mybatis-config.xml&quot;</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">        <span class="comment">//获取sqlSession实例，能直接执行已经映射的sql语句</span></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">            List&lt;User&gt; userList = mapper.getUserList();</span><br><span class="line">            userList.forEach(System.out::println);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Sql映射文件"><a href="#Sql映射文件" class="headerlink" title="Sql映射文件"></a>Sql映射文件</h4><h5 id="所有标签"><a href="#所有标签" class="headerlink" title="所有标签"></a>所有标签</h5><ul>
<li><p>​    cache：和缓存有关</p>
<ul>
<li>属性：<ul>
<li>eviction:缓存回收策略<pre><code>  • LRU –最近最少使用：移除最长时间不被使用的对象
  • FIFO – 先进先出：按对象进入缓存顺序来移除它们
  • SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象
  • WEAK – 弱引用：更积极地移除基于垃圾回收器状态和弱引用规则的对象
  **默认使用 LRU**
</code></pre>
</li>
<li>flushInterval：缓存刷新间隔<pre><code>  缓存多长时间清空一次，默认不清空，设置一个毫秒
</code></pre>
</li>
<li>readOnly 是否只读<pre><code>  true：只读 不会修改数据，并会加快获取速度，直接把数据引用交给用户所以不安全。
  false：非只读，mybatis序列化和反序列化的技术克隆一份新的数据给你，安全但速度稍慢。
</code></pre>
</li>
<li>size：缓存存放多少元素，一般设为1024</li>
<li>type：指定自定义缓存的全类名实现cache接口即可：如redis等 </li>
</ul>
</li>
</ul>
</li>
<li><p>​    cache-ref:和缓存有关</p>
<ul>
<li> <cache-ref namespace=""/> 不同namespace直接可以相互引用缓存</li>
</ul>
</li>
<li><p>​    parameterMap:参数map</p>
</li>
<li><p>​    resultMap：结果映射，自定义结果集的封装规则</p>
</li>
<li><p>​    sql：抽取可重用sql</p>
</li>
<li><p>​    delete、update、insert、select：增删改查</p>
<ul>
<li><p>主要属性：</p>
<ul>
<li><p>id：用于和dao方法进行绑定</p>
</li>
<li><p>paramType：参数类型，默认不用写</p>
</li>
<li><p>resultType：返回值类型，</p>
<ul>
<li>若为list类型写list中的元素类型，</li>
</ul>
</li>
</ul>
</li>
<li><p>map则就为map(查询单条数据，则key为字段名，value为对应值；)</p>
</li>
<li><p>填map中元素的类型(查询多条数据,需要在dao方法上加上@MapKey(“key”)，则key为你设置的值，value为javaBean对象)</p>
</li>
</ul>
</li>
<li><p>flushCache：只要该语句被调用，就会清空缓存，默认为true(对应插入删除更新语句)</p>
</li>
<li><p>databaseId：指定属于哪个数据库</p>
</li>
<li><p>useGeneratedKeys：使用自增主键(仅对insert和update有用)</p>
<ul>
<li><p>keyProperty：获取了自增主键并封装给javaBean哪个属性(仅对insert和update有用)</p>
<ul>
<li><p>若数据库不支持自增主键则</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">order</span>=<span class="string">&#x27;BEFORE&#x27;</span> <span class="attr">resultType</span>=<span class="string">&#x27;integer&#x27;</span> <span class="attr">keyProperty</span>=<span class="string">&#x27;id&#x27;</span>&gt;</span></span><br><span class="line">			select max(id)+1 from t_employee</span><br><span class="line"><span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>参数问题：</p>
<ul>
<li>单个参数<ul>
<li>基本类型：<ul>
<li>取值：#{随便写}</li>
</ul>
</li>
</ul>
</li>
<li>多个参数<ul>
<li>取值： <ul>
<li>#{param1}，#{param2}..#{paramN}</li>
</ul>
</li>
<li>原因：只要传入多个参数：mybatis会自动封装在map中，key就是参数的索引，或者可以使用@Param(“XXX”)指定key</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>传入map</p>
<pre><code>  - 取值：#&#123;key&#125;
</code></pre>
</li>
<li><p>传入javaBean</p>
<pre><code>  - 取值：#&#123;pojo的属性名&#125;
</code></pre>
<ul>
<li><p>取值方式对比</p>
<ul>
<li>#{}：是参数预编译的方式，参数的位置都是用？替代，都是预编译设置进去的，安全不会有sql注入；</li>
<li>${}：不是参数预编译，直接拼串上去的；</li>
<li><strong>一般都是用#{}，但在不支持参数预编译的地方就使用${}</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>resultMap自定义参数</p>
<ul>
<li>type：指定哪个javaBean自定义封装规则 </li>
</ul>
</li>
<li><p>id：唯一标识，查询语句使用 resultMap属性引用时填写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;MyDifEmp&quot;</span> <span class="attr">type</span>=<span class="string">&quot;mybatisTest.Test1.Employee&quot;</span>&gt;</span></span><br><span class="line"> 			<span class="comment">&lt;!--主键列对应规则   --&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	 				<span class="comment">&lt;!--普通列对应规则   --&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">       		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.depName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>association属性：</p>
</li>
<li><p>进行指定联合javaBean对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;MyDifEmp2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;mybatisTest.Test1.Employee&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        association可以指定联合javaBean对象</span></span><br><span class="line"><span class="comment">    javaType:property类型</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;mybatisTest.Test1.Department&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;depName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>collection属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;myDeptPlus&quot;</span> <span class="attr">type</span>=<span class="string">&quot;department&quot;</span>&gt;</span></span><br><span class="line">  		        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  		        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;depName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">  		<span class="comment">&lt;!--    collection用来定义集合关联集合类型的属性</span></span><br><span class="line"><span class="comment">  		        ofType 指定集合里面元素的类型</span></span><br><span class="line"><span class="comment">  		     --&gt;</span></span><br><span class="line">  		        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">  		            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  		            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">  		            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">  		            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">  		        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>定义集合关联集合类型的属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;myDeptPlusStep&quot;</span> <span class="attr">type</span>=<span class="string">&quot;department&quot;</span>&gt;</span></span><br><span class="line">  	        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  	        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;depName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!--      分步查询</span></span><br><span class="line"><span class="comment">  	            select 使用哪个xml文件中的select语句</span></span><br><span class="line"><span class="comment">  	            column 需要使用的参数</span></span><br><span class="line"><span class="comment">  	 --&gt;</span></span><br><span class="line">  	        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">select</span>=<span class="string">&quot;mybatisTest.Test1.EmployeeMapperPlus.getEmpsByDeptId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">  	        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>分步查询（但一般直接使用sql连接查询，因为发多个sql影响性能）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    使用association进行分步查询--&gt;</span></span><br><span class="line">  	    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;MyEmpByStep&quot;</span> <span class="attr">type</span>=<span class="string">&quot;mybatisTest.Test1.Employee&quot;</span>&gt;</span></span><br><span class="line">  	        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  	        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">  	        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">  	        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!--        </span></span><br><span class="line"><span class="comment">  				定义关联对象</span></span><br><span class="line"><span class="comment">  	            分步查询</span></span><br><span class="line"><span class="comment">  	            select 使用哪个xml文件中的select语句</span></span><br><span class="line"><span class="comment">  	            column 需要使用的参数</span></span><br><span class="line"><span class="comment">  	--&gt;</span></span><br><span class="line">  	        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">select</span>=<span class="string">&quot;mybatisTest.Test1.DepartmentMapper.getDeptById&quot;</span> <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span>&gt;</span></span><br><span class="line">  	  <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h3><ul>
<li><p>where标签：</p>
<ul>
<li>就等同于sql中的where,但它会自动去除开头and 或者 or</li>
</ul>
</li>
<li><p>if标签：用于做判断</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByConditionIf&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">        select * from tb1_employee</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--             </span></span><br><span class="line"><span class="comment">                 test 中取参数进行判断 </span></span><br><span class="line"><span class="comment">								&amp;amp; 转义 &amp;</span></span><br><span class="line"><span class="comment">								&amp;quot;&amp;quot; 转义 &quot;&quot;</span></span><br><span class="line"><span class="comment">								&amp;lt; 转义 &lt;</span></span><br><span class="line"><span class="comment">								trim()删除首尾空白</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=null&quot;</span>&gt;</span></span><br><span class="line">                id=#&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;lastName!=null and !lastName.equals(<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>)&quot;</span>&gt;</span></span><br><span class="line">                and last_name like #&#123;lastName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email!=null <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> email.trim()!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">                and email=#&#123;email&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender==<span class="symbol">&amp;quot;</span>男<span class="symbol">&amp;quot;</span> or gender==<span class="symbol">&amp;quot;</span>女<span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">                and gender=#&#123;gender&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>trim标签：用于截取字符串</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByConditionTrim&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">        select * from tb1_employee</span><br><span class="line">--</span><br><span class="line">--         prefix=&quot;&quot; 前缀，给整个拼完的字符串加个前缀</span><br><span class="line">--         prefixOverrides=&quot;&quot; 前缀覆盖：去掉整个字符串前面多余的字符</span><br><span class="line">--         suffix=&quot;&quot; 后缀 给整个拼完的字符串加个后缀</span><br><span class="line">--         suffixOverrides=&quot;&quot; 后缀覆盖：去掉整个字符串后面多余的字符</span><br><span class="line">        <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=null&quot;</span>&gt;</span></span><br><span class="line">                id=#&#123;id&#125; and</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;lastName!=null <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> lastName!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">                last_name like #&#123;lastName&#125; and</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email!=null <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> email.trim()!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">                email=#&#123;email&#125; and</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender==<span class="symbol">&amp;quot;</span>男<span class="symbol">&amp;quot;</span> or gender==<span class="symbol">&amp;quot;</span>女<span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">                gender=#&#123;gender&#125; and</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>foreach标签：用于遍历</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByConditionForeach&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">        select * from tb1_employee</span><br><span class="line">        -- collection 指定要遍历的集合 list类型的参数会特殊处理封装在map中,map的key就叫list除非你使用@Param设置了key</span><br><span class="line">        -- item: 将当前遍历出的元素赋值给该变量</span><br><span class="line">        -- #两个大括号可以取出变量值</span><br><span class="line">        -- separator 每个元素与每个元素之间的分隔符</span><br><span class="line">        --  open :以什么开始</span><br><span class="line">        --  close:以什么结束</span><br><span class="line">        --  index 索引：遍历list时是索引 遍历map时表示map的key，item就是map的值</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item_id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;where id in (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">            #&#123;item_id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>choose标签：用于分支选择</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByConditionChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">        select * from tb1_employee</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;id!=null&quot;</span>&gt;</span></span><br><span class="line">                    id=#&#123;id&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;lastName!=null <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> lastName!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">                    last_name like #&#123;lastName&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;email!=null <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> email.trim()!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">                    email=#&#123;email&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;gender==<span class="symbol">&amp;quot;</span>男<span class="symbol">&amp;quot;</span> or gender==<span class="symbol">&amp;quot;</span>女<span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">                    gender=#&#123;gender&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">           			<span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                  	1=1</span><br><span class="line">              	<span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>set标签：相当于sql中update中的set，可以动态更新</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        update tb1_employee</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;lastName!=null <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> lastName!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">                last_name = #&#123;lastName&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email!=null <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> email.trim()!=<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">                email=#&#123;email&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender==<span class="symbol">&amp;quot;</span>男<span class="symbol">&amp;quot;</span> or gender==<span class="symbol">&amp;quot;</span>女<span class="symbol">&amp;quot;</span>&quot;</span>&gt;</span></span><br><span class="line">                gender=#&#123;gender&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>bind标签：用于绑定表达式</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;_lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27;+lastName+&#x27;%&#x27;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>include标签：用于引用sql</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    批量保存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addEmps&quot;</span>&gt;</span></span><br><span class="line">      insert into tb1_employee(<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;insertColumn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>)</span><br><span class="line">      values</span><br><span class="line">      <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">        (#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">      <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    sql将一些常用sql存起来</span></span><br><span class="line"><span class="comment">        一般将常要进行查询的列名，或要插入的列名抽取出来</span></span><br><span class="line"><span class="comment">  当需要使用是 用include标签引用</span></span><br><span class="line"><span class="comment">        include还可以自定义property，sql还可以用#&#123;&#125;引用</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;insertColumn&quot;</span>&gt;</span></span><br><span class="line">        last_name,email,gender,d_id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>OGNL表达式(对象图导航语言) 动态sql test中的语句</p>
<ul>
<li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Iooooot/photos@master/blogAboutPic/image-20210404195729637.png" alt="image-20210404195729637">    </p>
</li>
<li>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 两个内置参数 --&gt;</span><br><span class="line">&lt;!--    不只是方法传递过来的参数可以被用来判断，取值--&gt;</span><br><span class="line">&lt;!--    mybatis默认还有两个内置参数--&gt;</span><br><span class="line">&lt;!--    _parameter：代表整个参数--&gt;</span><br><span class="line">&lt;!--        单个参数：_parameter就是这个参数--&gt;</span><br><span class="line">&lt;!--        多个参数：参数会被封装为一个map：_parameter代表这个map--&gt;</span><br><span class="line">&lt;!--    _databaseId：如果配置了databaseIdProvider标签就代表当前数据库</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>  缓存机制：</p>
<pre><code>   每个会话进入会先查询找二级缓存再来看一级缓存，若都没有就去数据库查询
</code></pre>
<p>  ​    <img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/039C67216D7ECCD71EEA320AE49322E3.png" alt="img"></p>
<p>  <strong>一级缓存：</strong></p>
<p>  ​    一级缓存(默认存在)：(本地缓存) sqlSession级别的缓存,不同的sqlSession缓存不共享,一级缓存是一致开启的.</p>
<p>  ​        原理：查询之后会讲数据放入map中<br>  ​            与数据库同一次会话期间查询到的数据会放在本地缓存中。<br>  ​            以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库；<br>  ​       一级缓存失效情况<br>  ​           1.sqlSession不同<br>  ​           2.sqlSession相同，条件不同<br>  ​           3.sqlSession相同，两次查询之间执行了增删改操作(可能修改了当前数据)<br>  ​           4.手动使用 clearCache()清空缓存</p>
<p>  <strong>二级缓存：</strong>(全局缓存)：基于namespace级别的缓存，一个xml文件的namespace对应一个二级缓存</p>
<pre><code>         工作机制：
                1.一个会话，查询一条数据，会被放入一级缓存
                 2.如果会话关闭，一级缓存中的数据会被保存到二级缓存中；
                 3.不同namespace查出的数据会放在自己对应的缓存map中
         如何使用：
                 1.在全局配置中settings中添加cacheEnable为true，若为false 只会关闭二级缓存
                 2.在需要使用的xml文件中加上&lt;cache&gt;&lt;/cache&gt;
                 3.所有的pojo都需要实现序列化接口
         相关设置：
                1.每个select标签都有一个useCache属性 true为允许二级缓存false反之
                 2.每个增删改标签都有一个flushCache=&quot;true&quot; 每次增删改都会清空一二级缓存。(查询也有但默认为false)
               3.clearCache()不会清空二级缓存
                 4.localCacheScope:本地缓存作用域(一般不会设置默认为session)
</code></pre>
</li>
</ul>
<h2 id="Mybatis执行流程"><a href="#Mybatis执行流程" class="headerlink" title="Mybatis执行流程"></a>Mybatis执行流程</h2><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20210409170334962.png" alt="image-20210409170334962"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20210409170306849.png" alt="image-20210409170306849"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20210409170357702.png" alt="image-20210409170357702"></p>
<p>4.sql查询流程</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20210410133742452.png" alt="image-20210410133742452"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20210410133440137.png" alt="image-20210410133440137"></p>
<h3 id="执行流程总结"><a href="#执行流程总结" class="headerlink" title="执行流程总结"></a>执行流程总结</h3><ol>
<li><p>根据配置文件(全局，sql映射)初始化出Configuration对象</p>
</li>
<li><p>创建一个DefaultSqlSession对象：</p>
<p> 他里面包含Configuration对象以及Executor(根据全局配置文件中的defaultExecutorType创建出对应的Executor)</p>
</li>
<li><p>DefaultSqlSession.getMapper():拿到Mapper接口对应的MapperProxy代理对象</p>
</li>
<li><p>MapperProxy里面有(DefaultSqlSession对象)</p>
</li>
<li><p>执行增删改查方法：</p>
<ol>
<li><p>调用DefaultSqlSession的增删改查(Executor)</p>
</li>
<li><p>会创建一个StatementHandler对象（同时会创建出ParamterHandler和ResultSetHandler）</p>
</li>
<li><p>调用StatementHandler预编译以及设置参数值</p>
<ol>
<li>ParamterHandler设置参数</li>
</ol>
</li>
<li><p>调用StatementHandler的增删改查</p>
</li>
<li><p>ResultSetHandler封装结果</p>
<p>注意：四大对象创建时都有一个interceptorChain.pluginAll(paramterHandler);</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>ORM持久层框架</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatisPlus</title>
    <url>/2022/04/04/%E6%95%B0%E6%8D%AE%E5%BA%93/ORM%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/MyBatis/MyBatisPlus/</url>
    <content><![CDATA[<h1 id="MyBatisPlus"><a href="#MyBatisPlus" class="headerlink" title="MyBatisPlus"></a>MyBatisPlus</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MyBatis-Plus简称 MP，是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<h3 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/ca8c342eaf9efd69.png" alt="image-20220330213819094"></p>
<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><h3 id="相关starter依赖"><a href="#相关starter依赖" class="headerlink" title="相关starter依赖"></a>相关starter依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mapper接口"><a href="#mapper接口" class="headerlink" title="mapper接口"></a>mapper接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span>  <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要application添加上@MapperScan(“com.wht.mapper”)注解扫描mapper接口/或者用@Mapper注解</p>
<h3 id="入门测试"><a href="#入门测试" class="headerlink" title="入门测试"></a>入门测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BaseMapper的具体功能介绍"><a href="#BaseMapper的具体功能介绍" class="headerlink" title="BaseMapper的具体功能介绍"></a>BaseMapper的具体功能介绍</h2><h3 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="keyword">null</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>,<span class="string">&quot;1369281736@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = userMapper.insert(user);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;res:&quot;</span>+res);</span><br><span class="line">    System.out.println(<span class="string">&quot;id:&quot;</span>+user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//根据主键id删除</span></span><br><span class="line">      <span class="keyword">int</span> res = userMapper.deleteById(<span class="number">1509495136467660801L</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;res:&quot;</span>+res);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//根据map条件删除</span></span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> res = userMapper.deleteByMap(map);</span><br><span class="line">        System.out.println(<span class="string">&quot;res:&quot;</span>+ res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//批量删除</span></span><br><span class="line">        List&lt;Long&gt; list = Arrays.asList(<span class="number">1L</span>, <span class="number">2L</span>);</span><br><span class="line">        <span class="keyword">int</span> res = userMapper.deleteBatchIds(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;res:&quot;</span>+ res);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改功能"><a href="#修改功能" class="headerlink" title="修改功能"></a>修改功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">4L</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="comment">//根据id修改</span></span><br><span class="line">        <span class="keyword">int</span> res = userMapper.updateById(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;res:&quot;</span>+ res);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询功能"><a href="#查询功能" class="headerlink" title="查询功能"></a>查询功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//根据单一id查询</span></span><br><span class="line">        User user = userMapper.selectById(<span class="number">4L</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="comment">//多个id查询</span></span><br><span class="line">        List&lt;User&gt; list = userMapper.selectBatchIds(Arrays.asList(<span class="number">3L</span>, <span class="number">4L</span>));</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">        <span class="comment">//根据条件map查询</span></span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectByMap(map);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义功能"><a href="#自定义功能" class="headerlink" title="自定义功能"></a>自定义功能</h3><p>完全同MyBatis：</p>
<ul>
<li>在Mapper接口中定义方法</li>
<li>在项目resources.mapper文件夹下创建对应的XXXmapper.xml</li>
<li>编写对应sql</li>
</ul>
<h2 id="通用Service接口"><a href="#通用Service接口" class="headerlink" title="通用Service接口"></a>通用Service接口</h2><p>说明：</p>
<ul>
<li><p>通用 Service CRUD 封装IService接口，进一步封装 CRUD 采用 get 查询单行remove 删除list 查询集合 page 分页 前缀命名方式区分 Mapper层避免混淆，</p>
</li>
<li><p>泛型 T 为任意实体对象</p>
</li>
<li><p>建议如果存在自定义通用 Service 方法的可能，请创建自己的 IBaseService继承 Mybatis-Plus提供的基类</p>
</li>
<li><p>对象 Wrapper 为 条件构造器</p>
</li>
</ul>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>为了方便以后自定义需要自行定义一个接口和一个实现类来继承MyBatisPlus提供的接口和实现类</p>
<ul>
<li>service接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>service实现类(需要加入容器)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">UserMapper</span>, <span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>进行测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">		<span class="comment">//获取总记录数</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> count = userService.count();</span><br><span class="line">        System.out.println(<span class="string">&quot;总记录数：&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//批量插入</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBathAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setName(<span class="string">&quot;李&quot;</span>+i);</span><br><span class="line">            user.setAge(<span class="number">20</span>+i);</span><br><span class="line">            list.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">        userService.saveBatch(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MyBatisPlus提供的注解"><a href="#MyBatisPlus提供的注解" class="headerlink" title="MyBatisPlus提供的注解"></a>MyBatisPlus提供的注解</h2><ul>
<li><p>设置实体类所对应的表名</p>
<ul>
<li><p>@TableName(“数据库的真实表名”)</p>
</li>
<li><p>或者使用全局配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">global-config:</span></span><br><span class="line">	<span class="attr">db-config:</span></span><br><span class="line">		<span class="attr">table-prefix:</span> <span class="string">t_</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>因为MyBatisPlus默认以id为主键，所以当主键名不为id时需要使用注解来指定</p>
<ul>
<li>@TableId<ul>
<li>属性：<ul>
<li>value = “数据库主键名”</li>
<li>type = IdType. AUTO/IdType. ASSIGN_ID (自增/雪花算法)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>设置实体类属性与数据库字段名的对应</p>
<ul>
<li>@TableField(“字段名”)</li>
</ul>
</li>
<li><p>设置数据的逻辑删除</p>
<ul>
<li>首先在表中设置一个逻辑删除判断字段<ul>
<li>并在实体类添加该属性</li>
<li>再使用@TableLogic字段</li>
</ul>
</li>
</ul>
</li>
<li><p>当实体类使用通用枚举属性时</p>
<ul>
<li><p>配置枚举类</p>
</li>
<li><p>在相应的枚举类里的存数据库的字段上添加@EnumValue</p>
</li>
<li><p>设置全局配置:  type-enums-package: com.wht.enums</p>
</li>
</ul>
</li>
</ul>
<h2 id="MyBatisPlus条件构造器"><a href="#MyBatisPlus条件构造器" class="headerlink" title="MyBatisPlus条件构造器"></a>MyBatisPlus条件构造器</h2><ul>
<li>Wrapper：条件构造抽象类<ul>
<li>AbostractWrapper：用于查询条件封装，生成sql的where条件<ul>
<li>QueryWrapper：查询条件封装</li>
<li>UpdateWrapper：更新条件封装</li>
<li>AbstractLambdaWrapper：使用Lambda语法<ul>
<li>LambdaQueryWrapper：用于Lambda语法使用的查询条件构造器</li>
<li>LambdaUpdateWrapper：用于Lambda语法使用的更新条件构造器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="组装查询条件"><a href="#组装查询条件" class="headerlink" title="组装查询条件"></a>组装查询条件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">       QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">       <span class="comment">//用户username包含a年龄在20~30之间并且email不为空</span></span><br><span class="line">       wrapper.like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">               .between(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">               .isNotNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">       List&lt;User&gt; list = userMapper.selectList(wrapper);</span><br><span class="line">       list.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">       <span class="comment">//只查询设置的字段</span></span><br><span class="line">       wrapper.select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;email&quot;</span>);</span><br><span class="line">       List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper);</span><br><span class="line">       maps.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">       <span class="comment">//使用子查询查询id小于等于100的用户信息</span></span><br><span class="line">       wrapper.inSql(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;select id from user where id &lt;= 100&quot;</span>);</span><br><span class="line">       List&lt;User&gt; list = userMapper.selectList(wrapper);</span><br><span class="line">       list.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test09</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String username = <span class="string">&quot;&quot;</span>;</span><br><span class="line">       Integer ageBegin = <span class="number">20</span>;</span><br><span class="line">       Integer ageEnd = <span class="number">30</span>;</span><br><span class="line">       QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(StringUtils.isNotBlank(username))&#123;</span><br><span class="line">           <span class="comment">//isNotBlank判断某个字符是否为空串不为null不为空白符</span></span><br><span class="line">           wrapper.like(<span class="string">&quot;name&quot;</span>, username);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(ageBegin != <span class="keyword">null</span>)&#123;</span><br><span class="line">           wrapper.ge(<span class="string">&quot;age&quot;</span>, ageBegin);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(ageEnd != <span class="keyword">null</span>)&#123;</span><br><span class="line">           wrapper.le(<span class="string">&quot;age&quot;</span>, ageEnd);</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;User&gt; list = userMapper.selectList(wrapper);</span><br><span class="line">       list.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String username = <span class="string">&quot;&quot;</span>;</span><br><span class="line">       Integer ageBegin = <span class="number">20</span>;</span><br><span class="line">       Integer ageEnd = <span class="number">30</span>;</span><br><span class="line">       QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">       wrapper.like(StringUtils.isBlank(username), <span class="string">&quot;name&quot;</span>, username)</span><br><span class="line">               .ge(ageBegin != <span class="keyword">null</span>, <span class="string">&quot;age&quot;</span>, ageBegin)</span><br><span class="line">               .le(ageEnd != <span class="keyword">null</span>, <span class="string">&quot;age&quot;</span>,ageEnd);</span><br><span class="line">       List&lt;User&gt; list = userMapper.selectList(wrapper);</span><br><span class="line">       list.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序条件"><a href="#排序条件" class="headerlink" title="排序条件"></a>排序条件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">       QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">       <span class="comment">//按照年龄降序排序若年龄相同按照id升序排序</span></span><br><span class="line">       wrapper.orderByDesc(<span class="string">&quot;age&quot;</span>).orderByAsc(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">       List&lt;User&gt; list = userMapper.selectList(wrapper);</span><br><span class="line">       list.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除条件"><a href="#删除条件" class="headerlink" title="删除条件"></a>删除条件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//删除邮箱为null的用户</span></span><br><span class="line">       QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">       wrapper.isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">       <span class="keyword">int</span> i = userMapper.delete(wrapper);</span><br><span class="line">       System.out.println(<span class="string">&quot;res：&quot;</span>+i);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改条件"><a href="#修改条件" class="headerlink" title="修改条件"></a>修改条件</h3><ul>
<li>使用QueryWrapper</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">       QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">       <span class="comment">//将年龄大于20且用户名包含有a或者邮箱为null的用户信息进行修改</span></span><br><span class="line">       wrapper.gt(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line">               .like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">               .or()</span><br><span class="line">               .isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">       User user = <span class="keyword">new</span> User();</span><br><span class="line">       user.setName(<span class="string">&quot;张四&quot;</span>);</span><br><span class="line">       <span class="keyword">int</span> i = userMapper.update(user, wrapper);</span><br><span class="line">       System.out.println(<span class="string">&quot;res：&quot;</span>+i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line">       QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">       <span class="comment">//将用户名包含有a并且（年龄大于20且或者邮箱为null）的用户信息进行修改</span></span><br><span class="line">       wrapper.like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">               .and(i -&gt; i.gt(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>).or().isNull(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">       User user = <span class="keyword">new</span> User();</span><br><span class="line">       user.setName(<span class="string">&quot;张四&quot;</span>);</span><br><span class="line">       <span class="keyword">int</span> i = userMapper.update(user, wrapper);</span><br><span class="line">       System.out.println(<span class="string">&quot;res：&quot;</span>+i);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用UpdateWrapper</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test08</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//将用户名包含有a并且（年龄大于20且或者邮箱为null）的用户信息进行修改</span></span><br><span class="line">       UpdateWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> UpdateWrapper&lt;&gt;();</span><br><span class="line">       wrapper.like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">               .and(i -&gt; i.gt(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>).or().isNull(<span class="string">&quot;email&quot;</span>));;</span><br><span class="line">       wrapper.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;大王&quot;</span>).set(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;1369281736@qq.com&quot;</span>);</span><br><span class="line">       <span class="keyword">int</span> i = userMapper.update(<span class="keyword">null</span>, wrapper);</span><br><span class="line">       System.out.println(<span class="string">&quot;res：&quot;</span>+i);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Lambda条件构造器"><a href="#Lambda条件构造器" class="headerlink" title="Lambda条件构造器"></a>Lambda条件构造器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String username = <span class="string">&quot;&quot;</span>;</span><br><span class="line">       Integer ageBegin = <span class="number">20</span>;</span><br><span class="line">       Integer ageEnd = <span class="number">30</span>;</span><br><span class="line">       LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">       wrapper.like(StringUtils.isBlank(username), User::getName, username)</span><br><span class="line">               .ge(ageBegin != <span class="keyword">null</span>, User::getAge, ageBegin)</span><br><span class="line">               .le(ageEnd != <span class="keyword">null</span>, User::getAge,ageEnd);</span><br><span class="line">       List&lt;User&gt; list = userMapper.selectList(wrapper);</span><br><span class="line">       list.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test12</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//将用户名包含有a并且（年龄大于20且或者邮箱为null）的用户信息进行修改</span></span><br><span class="line">       LambdaUpdateWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> LambdaUpdateWrapper&lt;&gt;();</span><br><span class="line">       wrapper.like(User::getName, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">               .and(i -&gt; i.gt(User::getAge, <span class="number">20</span>).or().isNull(User::getEmail));;</span><br><span class="line">       wrapper.set(User::getName, <span class="string">&quot;大王&quot;</span>).set(User::getEmail, <span class="string">&quot;1369281736@qq.com&quot;</span>);</span><br><span class="line">       <span class="keyword">int</span> i = userMapper.update(<span class="keyword">null</span>, wrapper);</span><br><span class="line">       System.out.println(<span class="string">&quot;res：&quot;</span>+i);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="MyBatisPlus分页插件"><a href="#MyBatisPlus分页插件" class="headerlink" title="MyBatisPlus分页插件"></a>MyBatisPlus分页插件</h2><ul>
<li><p>配置分页插件拦截器</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.wht.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title">mybatisPlusInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MybatisPlusInterceptor interceptor = <span class="keyword">new</span> MybatisPlusInterceptor();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> PaginationInnerInterceptor(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试分页</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">	</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">     	<span class="comment">//创建分页对象 使用构造器（当前页码，分页大小）</span></span><br><span class="line">       Page&lt;User&gt; page = <span class="keyword">new</span> Page&lt;&gt;(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">     	<span class="comment">//查询返回page的分页对象</span></span><br><span class="line">       Page&lt;User&gt; userPage = userMapper.selectPage(page, <span class="keyword">null</span>);</span><br><span class="line">       System.out.println(page);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自定义功能分页</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mapper接口中的方法</span></span><br><span class="line"><span class="function">Page&lt;User&gt; <span class="title">selectPageVo</span><span class="params">(<span class="meta">@Param(&quot;page&quot;)</span> Page&lt;User&gt; page,<span class="meta">@Param(&quot;age&quot;)</span> Integer age)</span></span>;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Page&lt;User&gt; page = <span class="keyword">new</span> Page&lt;&gt;(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        Page&lt;User&gt; userPage = userMapper.selectPageVo(page, <span class="number">15</span>);</span><br><span class="line">        System.out.println(userPage.getRecords());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="MyBatisPlus乐观锁插件"><a href="#MyBatisPlus乐观锁插件" class="headerlink" title="MyBatisPlus乐观锁插件"></a>MyBatisPlus乐观锁插件</h2><p>数据库由于并发操作的问题引起的数据查询结果不一致的问题：</p>
<p>解决方法：</p>
<ul>
<li>悲观锁：当一个用户对数据库操作时会直接加锁，另一个用户只能阻塞等待</li>
<li>乐观锁：认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了</li>
</ul>
<p>MyBatisPlus乐观锁的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先数据库和实体类需要多一个版本号的字段</span></span><br><span class="line"><span class="function">VERSION <span class="title">INT</span><span class="params">(<span class="number">11</span>)</span> DEFAULT 0 COMMENT &#x27;乐观锁版本号&#x27;</span></span><br><span class="line"><span class="function">@Version  <span class="comment">//标识版本号字段</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Integer version</span>;  </span><br><span class="line"><span class="comment">//在配置类中添加乐观锁插件</span></span><br><span class="line">interceptor.addInnerInterceptor(<span class="keyword">new</span> OptimisticLockerInnerInterceptor());</span><br></pre></td></tr></table></figure>
<h2 id="多数据源配置"><a href="#多数据源配置" class="headerlink" title="多数据源配置"></a>多数据源配置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="comment"># 配置数据源信息</span></span><br><span class="line">	<span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">dynamic:</span></span><br><span class="line">    <span class="comment"># 设置默认的数据源或者数据源组,默认值即为master</span></span><br><span class="line">    <span class="attr">primary:</span> <span class="string">master</span></span><br><span class="line">    <span class="comment"># 严格匹配数据源,默认false.true未匹配到指定数据源时抛异常,false使用默认数据源</span></span><br><span class="line">    <span class="attr">strict:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">master:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-</span></span><br><span class="line">          <span class="number">8</span><span class="string">&amp;useSSL=false</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">slave_1:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus_1?characterEncoding=utf-</span></span><br><span class="line">          <span class="number">8</span><span class="string">&amp;useSSL=false</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>并在service上使用@DS(“数据源”)</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>ORM持久层框架</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>MybatisPlus</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列</title>
    <url>/2023/02/05/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h2><p>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li><p>流量消峰：当系统到达请求极限时，为了让用户还能继续请求突破这个极限，就可以使用消息队列做缓冲，把一秒内请求分散成一段时间来处理。</p>
</li>
<li><p>应用解耦：可以使用消息队列将系统的某个模块从整个系统中解耦出来，这样就算该模块出现故障不会影响到整个系统。</p>
</li>
<li><p>异步处理：有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220824145056088.png" alt="image-20220824145056088" style="zoom: 50%;" />

</li>
</ul>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>2007 年发布，是一个在**AMQP(高级消息队列协议)**基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。</p>
<p><strong>优点：</strong>RabbitMQ 就像它的名字中的兔子一样：轻量级、迅捷。并且MQ 功能比较完备,健壮、稳定、易用、跨平台、支持多种语言。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>RabbitMQ 对消息堆积的支持并不好。</li>
<li>性能不算优秀，它大概每秒钟可以处理几万到十几万条消息，如果你的应用对消息队列的性能要求非常高，那不要选择 RabbitMQ。</li>
<li>RabbitMQ 使用的编程语言 Erlang，不好进行改造维护。</li>
</ul>
<h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><p>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进。</p>
<p><strong>优点：</strong>单机吞吐量十万级,可用性非常高，分布式架构,消息可以做到 0 丢失,MQ 功能较为完善，还是分布式的，扩展性好,支持 10 亿级别的消息堆积，不会因为堆积导致性能下降,源码是 java 我们可以自己阅读源码，定制自己公司的 MQ</p>
<p><strong>缺点：</strong>周边生态系统的集成和兼容程度要略逊一筹。</p>
<h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为大数据而生的消息中间件， 以其百万级 TPS 的吞吐量名声大噪。Kafka 最初的设计目的是用于处理海量的日志。</p>
<p><strong>优点：</strong></p>
<ul>
<li>当下的 Kafka 已经发展为一个非常成熟的消息队列产品，无论在数据可靠性、稳定性和功能特性等方面都可以满足绝大多数场景的需求。</li>
<li>Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域，几乎所有的相关开源软件系统都会优先支持 Kafka。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>Kafka 这种异步批量的设计带来的问题是，它的同步收发消息的响应时延比较高，<strong>Kafka 不太适合在线业务场景</strong>。</li>
</ul>
<blockquote>
<p>运用场景：</p>
<ul>
<li>如果说，消息队列并不是你将要构建系统的主角之一，你对消息队列功能和性能都没有很高的要求，只需要一个开箱即用易于维护的产品，我建议你使用 RabbitMQ。</li>
<li>如果你的系统使用消息队列主要场景是处理在线业务，比如在交易系统中用消息队列传递订单，那 RocketMQ 的低延迟和金融级的稳定性是你需要的。</li>
<li>如果你需要处理海量的消息，像收集日志、监控信息或是前端的埋点这类数据，或是你的应用场景大量使用了大数据、流计算相关的开源产品，那 Kafka 是最适合你的消息队列。</li>
</ul>
</blockquote>
<h2 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>RabbitMQ 是一个消息中间件：它接受并转发消息，它不负责处理而是接收， 存储和转发消息数据。</p>
<h3 id="核心角色"><a href="#核心角色" class="headerlink" title="核心角色"></a>核心角色</h3><ol>
<li>生成者：产生数据发送消息的程序。</li>
<li>交换机：交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。</li>
<li>队列：队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。</li>
<li>消费者：大多时候是一个等待接收消息的程序。</li>
</ol>
<h3 id="工作大致结构"><a href="#工作大致结构" class="headerlink" title="工作大致结构"></a>工作大致结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220824151143491.png" alt="image-20220824151143491"></p>
<p>相关名词解释：</p>
<ul>
<li><strong>Broker：</strong>接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</li>
<li><strong>Virtual host：</strong>出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</li>
<li><strong>Connection：</strong>publisher／consumer 和 broker 之间的 TCP 连接</li>
<li><strong>Channel：</strong>如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的Connection 极大减少了操作系统建立 TCP connection 的开销</strong></li>
<li><strong>Exchange：</strong>message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</li>
<li><strong>Queue：</strong>消息最终被送到这里等待 consumer 取走</li>
<li><strong>Binding：</strong>exchange 和queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据</li>
</ul>
<h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><ol>
<li><p>下载安装包(<a href="https://www.rabbitmq.com/download.html">官方地址</a>，注意也需要erlang安装包<a href="https://packagecloud.io/app/rabbitmq/erlang/search?dist=el/8&page=2">地址</a>)</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220824163937175.png" alt="image-20220824163937175"></p>
</li>
<li><p>上传到linux系统的/usr/local/mysoft/RabbitMQ目录下(没有文件夹需自己创建)</p>
</li>
<li><p>在该目录下进行安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh erlang-23.3.4.11-1.el7.x86_64.rpm</span><br><span class="line">yum install socat -y</span><br><span class="line">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure></li>
<li><p>添加开机启动<code>chkconfig rabbitmq-server on</code></p>
</li>
<li><p>启动服务 <code>/sbin/service rabbitmq-server start</code></p>
</li>
<li><p>关闭服务安装插件 <code>/sbin/service rabbitmq-server stop</code></p>
</li>
<li><p>开启 web 管理插件 <code>rabbitmq-plugins enable rabbitmq_management</code></p>
</li>
<li><p>查看用户 <code>rabbitmqctl list_users</code></p>
</li>
<li><p>创建新用户 <code>rabbitmqctl add_user admin 123</code></p>
</li>
<li><p>设置用户角色 <code>rabbitmqctl set_user_tags admin administrator</code></p>
</li>
<li><p>设置用户权限 <code>rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code>(命令语法：set_permissions [-p <vhostpath>] <user> <conf> <write> <read>)</p>
</li>
<li><p>访问web管理页面（<a href="http://47.115.185.244:15672）（使用admin登录、或者系统提供的guest登录密码也为guest）">http://47.115.185.244:15672）（使用admin登录、或者系统提供的guest登录密码也为guest）</a></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220824164445553.png" alt="image-20220824164445553"></p>
</li>
<li><p>进入后：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220824164954687.png" alt="image-20220824164954687"></p>
</li>
</ol>
<h3 id="Java使用RabbitMQ"><a href="#Java使用RabbitMQ" class="headerlink" title="Java使用RabbitMQ"></a>Java使用RabbitMQ</h3><p>RabbitMQ的6种工作模式：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220824172943741.png" alt="image-20220824172943741"></p>
<h4 id="Hello-World简单队列"><a href="#Hello-World简单队列" class="headerlink" title="Hello World简单队列"></a>Hello World简单队列</h4><ol>
<li><p>导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--rabbitmq 依赖客户端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写生产者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wht</span></span><br><span class="line"><span class="comment"> * 生产者：发消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;demo&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        <span class="comment">//创建一个连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//工厂IP 连接RabbitMQ的队列</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.227.130&quot;</span>);</span><br><span class="line">        <span class="comment">//用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//密码</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//因为基本使用，不需要交换机直接连接队列</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个队列的参数说明</span></span><br><span class="line"><span class="comment">         * 1.队列名称</span></span><br><span class="line"><span class="comment">         * 2.队列里面的消息是否持久化 默认消息存储在内存中</span></span><br><span class="line"><span class="comment">         * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费</span></span><br><span class="line"><span class="comment">         * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除</span></span><br><span class="line"><span class="comment">         * 5.其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//发送的消息</span></span><br><span class="line">        String message = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送一个消息的参数说明</span></span><br><span class="line"><span class="comment">         * 1.发送到那个交换机</span></span><br><span class="line"><span class="comment">         * 2.路由的 key 是哪个</span></span><br><span class="line"><span class="comment">         * 3.其他的参数信息</span></span><br><span class="line"><span class="comment">         * 4.发送消息的消息体</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写消费者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wht</span></span><br><span class="line"><span class="comment"> * 消费者： 接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;demo&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        <span class="comment">//创建一个连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//工厂IP 连接RabbitMQ的队列</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.227.130&quot;</span>);</span><br><span class="line">        <span class="comment">//用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//密码</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//推送的消息如何进行消费的接口回调</span></span><br><span class="line">        DeliverCallback deliverCallback= (consumerTag, delivery)-&gt;&#123;</span><br><span class="line">            String message= <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//取消消费的一个回调接口 如在消费的时候队列被删除掉了调用</span></span><br><span class="line">        CancelCallback cancelCallback=(consumerTag)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消费者接收消息</span></span><br><span class="line"><span class="comment">         * 1.消费哪个队列</span></span><br><span class="line"><span class="comment">         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答</span></span><br><span class="line"><span class="comment">         * 3.消费者未成功消费的回调</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Work-queues工作队列"><a href="#Work-queues工作队列" class="headerlink" title="Work queues工作队列"></a>Work queues工作队列</h4></li>
</ol>
<p>工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。</p>
<h5 id="轮训分发消息"><a href="#轮训分发消息" class="headerlink" title="轮训分发消息"></a>轮训分发消息</h5><p>进行轮训的发送消息，轮流依次接收一条</p>
<ol>
<li><p>首先抽取获取信道的公共代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到一个连接的 channel</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//工厂IP 连接RabbitMQ的队列</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.227.130&quot;</span>);</span><br><span class="line">        <span class="comment">//用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//密码</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建两个工作线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker01</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;demo&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        <span class="comment">//推送的消息如何进行消费的接口回调</span></span><br><span class="line">        DeliverCallback deliverCallback= (consumerTag, delivery)-&gt;&#123;</span><br><span class="line">            String message= <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//取消消费的一个回调接口</span></span><br><span class="line">        CancelCallback cancelCallback=(consumerTag)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span> + consumerTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;Worker01等待接收消息&quot;</span>);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个工作线程同上。</p>
</li>
<li><p>创建生产者线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task01</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;demo&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//从控制台中发送消息</span></span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            String message = sc.next();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息完成:&quot;</span>+message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动各线程，并在生产者线程中发送消息，发现各接收一条消息</p>
</li>
</ol>
<h5 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h5><p>为了保证消息在发送过程中不丢失，RabbitMQ 引入消息应答机制，消息应答就是:消费者在接收到消息并且处理该消息之后，告诉 RabbitMQ 它已经处理了，RabbitMQ 可以把该消息删除了。</p>
<p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。</p>
<h6 id="消息应答的方法"><a href="#消息应答的方法" class="headerlink" title="消息应答的方法"></a>消息应答的方法</h6><ul>
<li>Channel.basicAck(消息标记，是否批量应答未应答消息)  : 用于肯定确认</li>
<li>Channel.basicNack(消息标记，是否批量应答未应答消息，是否重新入队)：用于否定确认</li>
<li>Channel.basicReject(消息标记，是否重新入队)：同样用于否定确认</li>
</ul>
<h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><p>在工作线程接收消息时设置为手动应答，并在接收回调中进行应答</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        <span class="comment">//推送的消息如何进行消费的接口回调</span></span><br><span class="line">        DeliverCallback deliverCallback= (consumerTag, delivery)-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            String message= <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到的消息：&quot;</span> + message);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1.消息标记 tag</span></span><br><span class="line"><span class="comment">             * 2.是否批量应答未应答消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//取消消费的一个回调接口</span></span><br><span class="line">        CancelCallback cancelCallback=(consumerTag)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span> + consumerTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;Worker01等待接收消息&quot;</span>);</span><br><span class="line">        <span class="comment">//取消自动应答</span></span><br><span class="line">        <span class="keyword">boolean</span> isAutoAck = <span class="keyword">false</span>;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,isAutoAck,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h5><p>在某些场景下以上两种策略并不太合适，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，这种情况下就需要不公平分发。</p>
<h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><p>只要需要给消费者的信道Qos设置为1，默认是0轮训分发。</p>
<p><code>channel.basicQos(1);</code></p>
<p>这样就会在分配任务时，如果我没有完成之前的任务，就会将任务分配给其他消费者。</p>
<p>当然如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker 或者改变其他存储任务的策略。</p>
<blockquote>
<p>剩下的几种模式会在后续篇章进行讲解</p>
</blockquote>
<h3 id="RabbitMQ持久化"><a href="#RabbitMQ持久化" class="headerlink" title="RabbitMQ持久化"></a>RabbitMQ持久化</h3><p>默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：我们需要将队列和消息都标记为持久化。</p>
<h4 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h4><p>只需要在创建队列时，指定持久化：<code>channel.queueDeclare(QUEUE_NAME,true,false,false,null);</code></p>
<h4 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h4><p> 要想让消息实现持久化需要在消息生产者修改代码，MessageProperties.PERSISTENT_TEXT_PLAIN 添加这个文本持久化属性。</p>
<p><code>channel.basicPublish(&quot;&quot;,QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes());</code></p>
<blockquote>
<p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。</p>
<p>如果需要更强有力的持久化策略，可以利用后边的发布确认机制。</p>
</blockquote>
<h3 id="设置预取值"><a href="#设置预取值" class="headerlink" title="设置预取值"></a>设置预取值</h3><p>本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。</p>
<p>这个时候就可以通过使用 basic.qos 方法设置“预取计数”值来完成的。该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><p>通过在消费者中设置：<code>channel.basicQos(4)</code>(将预取值设为4)</p>
<h3 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h3><p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了。（如果消息和队列时持久化的，当消息写入磁盘之后就会想生产者发送确认消息）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220825190037088.png" alt="image-20220825190037088"></p>
<h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><p>首先需要开启发布确认功能：<code>channel.confirmSelect();</code></p>
<h5 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h5><p>一种同步确认发布的方式，就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布。</p>
<p><strong>实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单个确认</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageIndividually</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//获取信道</span></span><br><span class="line">    Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">    <span class="comment">//设置队列名称</span></span><br><span class="line">    String queueName = UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//开启发布确认</span></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        <span class="comment">//服务端返回 false 或超时时间内未返回，生产者可以消息重发</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = channel.waitForConfirms();</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="批量确认发布"><a href="#批量确认发布" class="headerlink" title="批量确认发布"></a>批量确认发布</h5><p>与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，但仍然是同步的，也一样阻塞消息的发布。</p>
<p><strong>实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量发布确认</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//获取信道</span></span><br><span class="line">    Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">    <span class="comment">//设置队列名称</span></span><br><span class="line">    String queueName = UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//开启发布确认</span></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    <span class="comment">//批量确认消息大小</span></span><br><span class="line">    <span class="keyword">int</span> batchSize = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//未确认消息个数</span></span><br><span class="line">    <span class="keyword">int</span> outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        <span class="comment">//当发送100条消息之后再进行确认</span></span><br><span class="line">        <span class="keyword">if</span>(i % batchSize == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//进行确认</span></span><br><span class="line">            channel.waitForConfirms();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="异步确认发布"><a href="#异步确认发布" class="headerlink" title="异步确认发布"></a>异步确认发布</h5><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的。</p>
<p><strong>实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步发布确认</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//设置队列名称</span></span><br><span class="line">        String queueName = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">//创建一个线程安全的哈希表,用于存放发送失败的消息</span></span><br><span class="line">        ConcurrentSkipListMap&lt;Long,String&gt; outstandingConfirms = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息确认成功的回调函数</span></span><br><span class="line">        ConfirmCallback ackCallback = (deliveryTag,multiple) -&gt;&#123;</span><br><span class="line">            <span class="comment">//是否是批量确认</span></span><br><span class="line">            <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line">                ConcurrentNavigableMap&lt;Long, String&gt; confirmed = outstandingConfirms.headMap(deliveryTag);</span><br><span class="line">                confirmed.clear();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                outstandingConfirms.remove(deliveryTag);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;确认的消息：&quot;</span>+deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消息确认失败的回调函数</span></span><br><span class="line">        ConfirmCallback nackCallback = (deliveryTag,multiple) -&gt;&#123;</span><br><span class="line">            <span class="comment">//获取未确认的消息</span></span><br><span class="line">            String message = outstandingConfirms.get(deliveryTag);</span><br><span class="line">            System.out.println(<span class="string">&quot;未确认的消息：&quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//准备消息的监听器，异步监听哪些消息成功失败</span></span><br><span class="line">        <span class="comment">//第一个参数成功的回调、第二个参数失败的回调</span></span><br><span class="line">        channel.addConfirmListener(ackCallback,nackCallback);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            String message = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            <span class="comment">//将消息存map中key为下一次发送的序号value为消息</span></span><br><span class="line">            outstandingConfirms.put(channel.getNextPublishSeqNo(), message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>3种发布确认的特点：</p>
<ul>
<li>单独发布消息：同步等待确认，简单，但吞吐量非常有限。</li>
<li>批量发布消息：批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。</li>
<li>异步处理：最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</li>
</ul>
</blockquote>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>RabbitMQ 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中，而是生产者将消息发送到交换机中，由交换机来决定放入队列，这种模式称为 ”发布/订阅”。</p>
<p>交换机一共有5种类型：</p>
<ul>
<li><p>无名默认(即为前面我们一直使用的以空串设置的交换机)</p>
</li>
<li><p>直接(direct)</p>
</li>
<li><p>主题(topic)</p>
</li>
<li><p>标题(headers) 不常用</p>
</li>
<li><p>扇出(fanout)</p>
</li>
</ul>
<h4 id="Direct交换机"><a href="#Direct交换机" class="headerlink" title="Direct交换机"></a>Direct交换机</h4><p>这种类型的交换机，只会把消息发送到你绑定的routingKey 队列中去，不会进行广播，当然也可以将不同的routingKey设置为一样的队列进行多重绑定。</p>
<h5 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h5><ul>
<li><p>消费者01：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsDirect01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        String queueName = <span class="string">&quot;disk&quot;</span>;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//将队列与交换机进行绑定</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息 ........... &quot;</span>);</span><br><span class="line">        <span class="comment">//处理消息回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            message = <span class="string">&quot;接收绑定键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;,消息:&quot;</span> + message;</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\rabbitmq_info.txt&quot;</span>);</span><br><span class="line">            FileUtils.writeStringToFile(file, message, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;错误日志已经接收&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消费者02：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsDirect02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        String queueName = <span class="string">&quot;console&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//进行多重绑定</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;warning&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息 ........... &quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; 接收绑定键 :&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;, 消息:&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>生产者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogDirect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">            <span class="comment">//创建多个 bindingKey</span></span><br><span class="line">            Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;info&quot;</span>, <span class="string">&quot;普通 info 信息&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;warning&quot;</span>, <span class="string">&quot;警告 warning 信息&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;错误 error 信息&quot;</span>);</span><br><span class="line">            <span class="comment">//debug 没有消费这接收这个消息 所有就丢失了</span></span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;debug&quot;</span>, <span class="string">&quot;调试 debug 信息&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class="line">                String bindingKey = bindingKeyEntry.getKey();</span><br><span class="line">                String message = bindingKeyEntry.getValue();</span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, bindingKey, <span class="keyword">null</span>,</span><br><span class="line">                        message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者发出消息:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>开启生成者，两个消费者各自收到自己的消息取决于routingKey</p>
</li>
</ul>
<h4 id="Fanout交换机"><a href="#Fanout交换机" class="headerlink" title="Fanout交换机"></a>Fanout交换机</h4><p>Fanout交换机将接收到的所有消息<strong>广播</strong>到它知道的所有队列中。</p>
<h5 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h5><ul>
<li><p>消费者01(负责将消息打印在控制台中)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wht</span></span><br><span class="line"><span class="comment"> * 消费者01 接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogs01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成一个临时的队列 队列的名称是随机的</span></span><br><span class="line"><span class="comment">         * 当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息,把接收到的消息打印在屏幕 ........... &quot;</span>);</span><br><span class="line">        <span class="comment">//处理消息的回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;控制台打印接收到的消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消费者02(负责将消息存磁盘中)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wht</span></span><br><span class="line"><span class="comment"> * 消费者02 负责将消息存磁盘</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogs02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息,把接收到的消息写到文件 ........... &quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\rabbitmq_info.txt&quot;</span>);</span><br><span class="line">            FileUtils.writeStringToFile(file, message, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;数据写入文件成功&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>生成者发送消息给交换机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wht</span></span><br><span class="line"><span class="comment"> * 生成者发送消息给交换机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 声明一个 exchange 只需要声明一次</span></span><br><span class="line"><span class="comment">             * 1.exchange 的名称</span></span><br><span class="line"><span class="comment">             * 2.exchange 的类型</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);</span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入信息&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">                String message = sc.nextLine();</span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>发送消息，消费者01消费者02都收到消息</p>
</li>
</ul>
<h4 id="Topics交换机"><a href="#Topics交换机" class="headerlink" title="Topics交换机"></a>Topics交换机</h4><p>topic 交换机可以对消息的接收更加细化，比如可以接收routingKey为info.base的消息，但是direct不行；</p>
<p>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单词列表，以点号分隔开。</p>
<blockquote>
<p>两个替换符：</p>
<p>*(星号)可以代替一个单词<br>#(井号)可以替代零个或多个单词</p>
</blockquote>
<h5 id="实战-2"><a href="#实战-2" class="headerlink" title="实战"></a>实战</h5><ul>
<li><p>消费者01：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsTopic01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明 Q1 队列与绑定关系</span></span><br><span class="line">        String queueName = <span class="string">&quot;Q1&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.orange.*&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息 ........... &quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; 接 收 队 列 :&quot;</span> + queueName + <span class="string">&quot; 绑定键:&quot;</span>+delivery.getEnvelope().getRoutingKey()+<span class="string">&quot;, 消息:&quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消费者02：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsTopic02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"><span class="comment">//声明 Q2 队列与绑定关系</span></span><br><span class="line">        String queueName = <span class="string">&quot;Q2&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;lazy.#&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息 ........... &quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; 接 收 队 列 :&quot;</span> + queueName + <span class="string">&quot; 绑定 键:&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;, 消息:&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>生产者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogTopic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Q1--&gt;绑定的是</span></span><br><span class="line"><span class="comment">             * 中间带 orange 带 3 个单词的字符串(*.orange.*)</span></span><br><span class="line"><span class="comment">             * Q2--&gt;绑定的是</span></span><br><span class="line"><span class="comment">             * 最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)</span></span><br><span class="line"><span class="comment">             * 第一个单词是 lazy 的多个单词(lazy.#)</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;quick.orange.rabbit&quot;</span>, <span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;lazy.orange.elephant&quot;</span>, <span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;quick.orange.fox&quot;</span>, <span class="string">&quot;被队列 Q1 接收到&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;lazy.brown.fox&quot;</span>, <span class="string">&quot;被队列 Q2 接收到&quot;</span>);</span><br><span class="line">        </span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;lazy.pink.rabbit&quot;</span>, <span class="string">&quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;quick.brown.fox&quot;</span>, <span class="string">&quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;quick.orange.male.rabbit&quot;</span>, <span class="string">&quot;是四个单词不匹配任何绑定会被丢弃&quot;</span>);</span><br><span class="line">            bindingKeyMap.put(<span class="string">&quot;lazy.orange.male.rabbit&quot;</span>, <span class="string">&quot;是四个单词但匹配 Q2&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class="line">                String bindingKey = bindingKeyEntry.getKey();</span><br><span class="line">                String message = bindingKeyEntry.getValue();</span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, bindingKey, <span class="keyword">null</span>,</span><br><span class="line">                        message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>开启生成者发送消息，交换机会根据各自规则判断发送哪些队列</p>
</li>
</ul>
<h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p>
<p>常见原因：</p>
<ul>
<li>消息 TTL 过期</li>
<li>队列达到最大长度(队列满了，无法再添加数据到 mq 中)</li>
<li>消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false.</li>
</ul>
<h4 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h4><h5 id="消息-TTL-过期"><a href="#消息-TTL-过期" class="headerlink" title="消息 TTL 过期"></a>消息 TTL 过期</h5><ul>
<li><p>生产者（负责发送消息并且设置消息过期时间）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            <span class="comment">//设置消息的 TTL 时间</span></span><br><span class="line">            AMQP.BasicProperties properties =</span><br><span class="line">                    <span class="keyword">new</span> AMQP.BasicProperties().builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line">            <span class="comment">//该信息是用作演示队列个数限制</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">                String message = <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">                <span class="comment">//往普通队列发送消息</span></span><br><span class="line">                channel.basicPublish(NORMAL_EXCHANGE,<span class="string">&quot;normal_queue&quot;</span>,properties ,message.getBytes());</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者发送消息:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消费者01（负责申明一个普通交换机、死信交换机、普通队列、死信队列，并将两两绑定）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer01</span> </span>&#123;</span><br><span class="line">    <span class="comment">//普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE = <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明死信和普通交换机 类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        String deadQueue = <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(deadQueue, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//死信队列绑定死信交换机与 routingKey</span></span><br><span class="line">        channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;deadQueue&quot;</span>);</span><br><span class="line">        <span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//正常队列设置死信交换机 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//正常队列设置死信 routing-key 参数 key 是固定值</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;deadQueue&quot;</span>);</span><br><span class="line">        <span class="comment">//创建普通队列,注意需要设置上述参数才能将死信传给死信交换机</span></span><br><span class="line">        String normalQueue = <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(normalQueue, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br><span class="line">        <span class="comment">//绑定普通队列</span></span><br><span class="line">        channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;normalQueue&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息 ........... &quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span>+message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(normalQueue, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消费者02（负责重新处理死信队列中的消息）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE = <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收死信队列消息 ........... &quot;</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer02 接收死信队列的消息&quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(deadQueue, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>开启消费者01然后关闭，再开启生产者和消费者02</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220826204101440.png" alt="image-20220826204101440"></p>
</li>
</ul>
<h5 id="队列达到最大长度"><a href="#队列达到最大长度" class="headerlink" title="队列达到最大长度"></a>队列达到最大长度</h5><ul>
<li><p>首先取消掉刚才生产者中的过期时间</p>
</li>
<li><p>将消费者01中添加队列最大长度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//跟死信参数一样放在参数map中</span></span><br><span class="line"><span class="comment">//设置队列最大长度</span></span><br><span class="line">params.put(<span class="string">&quot;x-max-length&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>效果：6个消息被消费者01处理，其余4个被放入死信队列中被消费者02处理</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220826204548460.png" alt="image-20220826204548460"></p>
</li>
</ul>
<h5 id="消息被拒"><a href="#消息被拒" class="headerlink" title="消息被拒"></a>消息被拒</h5><ul>
<li><p>取消最大长度参数设置</p>
</li>
<li><p>在消费者01中进行消息的拒绝（通过basicReject）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    		<span class="comment">//将info5拒收</span></span><br><span class="line">            <span class="keyword">if</span>(message.equals(<span class="string">&quot;info5&quot;</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message + <span class="string">&quot;并拒绝签收该消息&quot;</span>);</span><br><span class="line">                <span class="comment">//requeue 设置为 false 代表拒绝重新入普通队列 该队列如果配置了死信交换机将发送到死信队列中</span></span><br><span class="line">                channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span>+message); </span><br><span class="line">                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="comment">//注意需要取消自动确认</span></span><br><span class="line">        channel.basicConsume(normalQueue, <span class="keyword">false</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3></li>
</ul>
<p>延时队列就是用来存放需要在指定时间被处理的元素的队列。类似于死信队列中的TTL消息过期情况。</p>
<blockquote>
<p>使用场景：</p>
<ol>
<li>订单在十分钟之内未支付则自动取消</li>
<li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。</li>
<li>用户注册成功后，如果三天内没有登陆则进行短信提醒。</li>
<li>用户发起退款，如果三天内没有得到处理则通知相关运营人员。</li>
<li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li>
</ol>
</blockquote>
<h4 id="基于SpringBoot实现延迟队列"><a href="#基于SpringBoot实现延迟队列" class="headerlink" title="基于SpringBoot实现延迟队列"></a>基于SpringBoot实现延迟队列</h4><ul>
<li><p>导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--RabbitMQ 依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.73<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--RabbitMQ 测试依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置ip、端口、账号、密码：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.227</span><span class="number">.111</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置swagger配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">webApiConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">                .apiInfo(webApiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">webApiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">&quot;rabbitmq 接口文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;本文档描述了 rabbitmq 微服务接口定义&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> Contact(<span class="string">&quot;enjoyWht&quot;</span>, <span class="string">&quot;http://baidu.com&quot;</span>,<span class="string">&quot;1369281736@qq.com&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建队列和交换机的配置类：</p>
<p>负责创建一个普通交换机一个死信交换机，两个延时队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TtlQueueConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_EXCHANGE = <span class="string">&quot;X&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个普通队列名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_A = <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_B = <span class="string">&quot;QB&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信交换机名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String Y_DEAD_LETTER_EXCHANGE = <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUE = <span class="string">&quot;QD&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明普通交换机</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;xExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">xExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(X_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明死信交换机</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;yExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">yExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明普通队列A</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//声明队列的 TTL过期时间 单位ms</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明队列 A 绑定 X 交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queueA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xExchange</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueABindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明普通队列B</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//声明队列的 TTL过期时间 单位ms</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">40000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明队列 B 绑定 X 交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queueB</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xExchange</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queueB,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(xExchange).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明死信队列 QD</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueD&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueD</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DEAD_LETTER_QUEUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明死信队列 QD 绑定关系</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queueD</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> yExchange</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">deadLetterBindingQAD</span><span class="params">(<span class="meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>生产者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成者发送延迟消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ttl&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMsgController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条信息给两个 TTL 队列:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date(), message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XA&quot;</span>, <span class="string">&quot;消息来自 ttl 为 10S 的队列: &quot;</span> + message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XB&quot;</span>, <span class="string">&quot;消息来自 ttl 为 40S 的队列: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消费者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 消费者监听队列并且消费消息</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class DeadLetterQueueConsumer &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 监听QD队列的消息</span><br><span class="line">     * @param message</span><br><span class="line">     * @param channel</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RabbitListener(queues &#x3D; &quot;QD&quot;)</span><br><span class="line">    public void receiveD(Message message, Channel channel) throws IOException &#123;</span><br><span class="line">        String msg &#x3D; new String(message.getBody());</span><br><span class="line">        log.info(&quot;当前时间：&#123;&#125;,收到死信队列信息&#123;&#125;&quot;, new Date().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方案有一个很大的问题，就是每当延时时间不一致时需要重新创建一个队列，这样很不灵活。接下来的方案将会使用一个队列来适应所有延时时间（但是同样会有问题）。</p>
</li>
</ul>
<ol>
<li><p>重新创建队列C（这个队列不设置ttl过期时间）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 适应所有延时时间的队列</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_C = <span class="string">&quot;QC&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 声明队列 C 死信交换机</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean(&quot;queueC&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Queue <span class="title">queueC</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">       <span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">       args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">       <span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">       args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">       <span class="comment">//没有声明 TTL 属性</span></span><br><span class="line">       <span class="keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(args).build();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 声明队列 C 绑定 X 交换机</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Binding <span class="title">queueCBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="string">&quot;XC&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在生产者中发出消息和过期时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message, <span class="meta">@PathVariable</span> String ttlTime)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在消息后置处理器中添加过期时间</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XC&quot;</span>, message, correlationData -&gt; &#123;</span><br><span class="line">            correlationData.getMessageProperties().setExpiration(ttlTime);</span><br><span class="line">            <span class="keyword">return</span> correlationData;</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条时长&#123;&#125;毫秒 TTL 信息给队列 C:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date(), ttlTime, message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述方案的问题是消息会在队列中排队，会依次执行消息，所以如果第一个消息时间长，第二个消息短会让第一个消息进入死信队列，马上第二个消息也一起进入死信队列，并不会严格按照过期时间来执行。</p>
</li>
</ol>
<p>下面的方案使用延时队列的插件进行解决：</p>
<ol>
<li><p>下载延时队列插件<a href="https://www.rabbitmq.com/community-plugins.html">官方</a></p>
</li>
<li><p>上传到linux系统的RabbitMQ的插件目录下<code>/usr/lib/rabbitmq/lib/rabbitmq_server-3.8.22/plugins</code>目录</p>
</li>
<li><p>进入该目录<code>cd /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.22/plugins</code> </p>
</li>
<li><p>安装插件<code>rabbitmq-plugins enable rabbitmq_delayed_message_exchange</code></p>
</li>
<li><p>重启服务<code>systemctl restart rabbitmq-server</code></p>
</li>
<li><p>使用浏览器进入ui管理页面</p>
</li>
<li><p>在交换机中可以新增延时消息交换机</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220902215453647.png" alt="image-20220902215453647" style="zoom:67%;" />
</li>
<li><p>具体代码的实现：</p>
<ul>
<li><p>创建配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedQueueConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_QUEUE_NAME = <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXCHANGE_NAME = <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_ROUTING_KEY = <span class="string">&quot;delayed.routingKey&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明延时队列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">delayedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DELAYED_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义交换机 我们在这里定义的是一个延迟交换机</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomExchange <span class="title">delayedExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置延时类型</span></span><br><span class="line">        args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造函数参数：</span></span><br><span class="line"><span class="comment">         * 1.交换机名称</span></span><br><span class="line"><span class="comment">         * 2.交换机类型</span></span><br><span class="line"><span class="comment">         * 3.是否需要持久化</span></span><br><span class="line"><span class="comment">         * 4.是否需要自动删除</span></span><br><span class="line"><span class="comment">         * 5.其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomExchange(DELAYED_EXCHANGE_NAME, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将交换机和队列进行绑定</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delayedExchange</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDelayedQueue</span><span class="params">(<span class="meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange</span></span></span><br><span class="line"><span class="function"><span class="params">                                               delayedExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">                BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建生产者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXCHANGE_NAME = <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_ROUTING_KEY = <span class="string">&quot;delayed.routingKey&quot;</span>;	</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping(&quot;sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message, <span class="meta">@PathVariable</span> Integer delayTime)</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, message, correlationData -&gt; &#123;</span><br><span class="line">            correlationData.getMessageProperties().setDelay(delayTime);</span><br><span class="line">            <span class="keyword">return</span> correlationData;</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(<span class="string">&quot; 当 前 时 间 ： &#123;&#125;, 发送一条延迟 &#123;&#125; 毫秒的信息给队列 delayed.queue:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date(), delayTime, message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建消费者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_QUEUE_NAME = <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveDelayedQueue</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,收到延时队列的消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>发送两个请求：<code>http://localhost:8080/ttl/sendDelayMsg/hello01/3000</code>和<code>http://localhost:8080/ttl/sendDelayMsg/hello02/1000</code></p>
</li>
<li><p>效果：保证了延时的准确性</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220902221516105.png" alt="image-20220902221516105"></p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>基于插件的基础流程：</p>
<img src= "/img/loading.gif" data-lazy-src="https://blogpic-1305209282.cos.ap-chengdu.myqcloud.com/img/image-20220902215658015.png" alt="image-20220902215658015" style="zoom:67%;" />
</blockquote>
<h3 id="发布确认高级版"><a href="#发布确认高级版" class="headerlink" title="发布确认高级版"></a>发布确认高级版</h3><p>在生产环境中由于一些不明原因，导致 rabbitmq 重启，在 RabbitMQ 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复。所以当rabbitmq宕机之后将丢失的消息存入缓存。</p>
<h4 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h4><p>​    首先开启发布确认模式：</p>
<p>​    在springboot配置类中配置：<code>spring.rabbitmq.publisher-confirm-type=correlated</code>(可以选择的值有NONE:禁用发布确认模式默认、CORRELATED:开启、SIMPLE:同步确认消息)</p>
<h5 id="解决交换机发布确认问题"><a href="#解决交换机发布确认问题" class="headerlink" title="解决交换机发布确认问题"></a>解决交换机发布确认问题</h5><ol>
<li><p>创建配置类，声明交换机和队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_EXCHANGE_NAME = <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE_NAME = <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明业务 Exchange</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">confirmExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(CONFIRM_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明确认队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">confirmQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明确认队列绑定关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>回调接口(可以知道是否消息发送到交换机中)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallBack</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机不管是否收到消息的一个回调方法</span></span><br><span class="line"><span class="comment">     * CorrelationData</span></span><br><span class="line"><span class="comment">     * 消息相关数据</span></span><br><span class="line"><span class="comment">     * ack</span></span><br><span class="line"><span class="comment">     * 交换机是否收到消息</span></span><br><span class="line"><span class="comment">     * cause</span></span><br><span class="line"><span class="comment">     * 失败原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123; String id=correlationData!=<span class="keyword">null</span>?correlationData.getId():<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>,id);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机还未收到 id 为:&#123;&#125;消息,由于原因:&#123;&#125;&quot;</span>,id,cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>生产者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_EXCHANGE_NAME = <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyCallBack myCallBack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 依赖注入 rabbitTemplate 之后再设置它的回调对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(myCallBack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;sendMessage/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//指定消息 id 为 1</span></span><br><span class="line">        CorrelationData correlationData1 = <span class="keyword">new</span> CorrelationData(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        String routingKey = <span class="string">&quot;key1&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData1);</span><br><span class="line">        CorrelationData correlationData2 = <span class="keyword">new</span> CorrelationData(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        routingKey = <span class="string">&quot;key2&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData2);</span><br><span class="line">        log.info(<span class="string">&quot;发送消息内容:&#123;&#125;&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消费者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE_NAME = <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = CONFIRM_QUEUE_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;接受到队列 confirm.queue 消息:&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解决队列发布确认问题"><a href="#解决队列发布确认问题" class="headerlink" title="解决队列发布确认问题"></a>解决队列发布确认问题</h5></li>
</ol>
<p>上述方案会有一个问题是如果队列出问题但是交换机收到了，并不会返回错误回调。</p>
<p>所以回调实现类还需要实现一个回退接口，当路由不到队列时进行回退</p>
<ol>
<li><p>在配置文件中开启回退功能：<code>spring.rabbitmq.publisher-returns=true</code></p>
</li>
<li><p>让回调实现类实现回退接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallBack</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span>, <span class="title">RabbitTemplate</span>.<span class="title">ReturnsCallback</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机不管是否收到消息的一个回调方法</span></span><br><span class="line"><span class="comment">     * CorrelationData</span></span><br><span class="line"><span class="comment">     * 消息相关数据</span></span><br><span class="line"><span class="comment">     * ack</span></span><br><span class="line"><span class="comment">     * 交换机是否收到消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        String id = correlationData != <span class="keyword">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机还未收到 id 为:&#123;&#125;消息,由于原因:&#123;&#125;&quot;</span>, id, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回退回调</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnedMessage 封装了消息的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot; 消 息 &#123;&#125;, 被 交 换 机 &#123;&#125; 退 回 ， 退 回 原 因 :&#123;&#125;, 路 由 key:&#123;&#125;&quot;</span>, <span class="keyword">new</span></span><br><span class="line">                String(returnedMessage.getMessage().getBody()), </span><br><span class="line">                returnedMessage.getExchange(), </span><br><span class="line">                returnedMessage.getReplyText(), </span><br><span class="line">                returnedMessage.getRoutingKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将回退接口注入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rabbitTemplate.setConfirmCallback(myCallBack);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * true：</span></span><br><span class="line"><span class="comment">     * 交换机无法将消息进行路由时，会将该消息返回给生产者</span></span><br><span class="line"><span class="comment">     * false：</span></span><br><span class="line"><span class="comment">     * 如果发现消息无法进行路由，则直接丢弃</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">    rabbitTemplate.setReturnsCallback(myCallBack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用备份交换机解决宕机"><a href="#使用备份交换机解决宕机" class="headerlink" title="使用备份交换机解决宕机"></a>使用备份交换机解决宕机</h5></li>
</ol>
<p>这种方案多创建一个备份交换机，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中不会将消息回退，由备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定的队列中，就可以进行检测和报警。</p>
<ol>
<li><p>修改原本的配置类多创建一个备份交换机以及一个备份队列和一个报警队列，并且重新构建确认交换机让其出错时将信息交给备份交换机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_EXCHANGE_NAME = <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE_NAME = <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BACKUP_EXCHANGE_NAME = <span class="string">&quot;backup.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BACKUP_QUEUE_NAME = <span class="string">&quot;backup.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WARNING_QUEUE_NAME = <span class="string">&quot;warning.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明业务 Exchange</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">confirmExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExchangeBuilder exchangeBuilder =</span><br><span class="line">                ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME)</span><br><span class="line">                        .durable(<span class="keyword">true</span>)</span><br><span class="line">                        <span class="comment">//设置该交换机的备份交换机</span></span><br><span class="line">                        .withArgument(<span class="string">&quot;alternate-exchange&quot;</span>, BACKUP_EXCHANGE_NAME);</span><br><span class="line">        <span class="keyword">return</span> (DirectExchange) exchangeBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明确认队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">confirmQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明确认队列绑定关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明备份 Exchange</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;backupExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">backupExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(BACKUP_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明警告队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;warningQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">warningQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明报警队列绑定关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">warningBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange</span></span></span><br><span class="line"><span class="function"><span class="params">                                          backupExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明备份队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;backQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">backQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明备份队列绑定关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">backupBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;backQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>报警消费者、普通备份消费者（省略）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 报警消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WarningConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = ConfirmConfig.WARNING_QUEUE_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveWarningMsg</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.error(<span class="string">&quot;报警发现不可路由消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3></li>
</ol>
<p>一个按照优先级来排序的队列，不用严格按照先进先出的策略来消费消息。</p>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><ol>
<li><p>首先在创建队列时设置最大优先级：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap(); </span><br><span class="line">params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br></pre></td></tr></table></figure></li>
<li><p>在发送消息之前设置消息的优先级（数字越大优先级越大）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, properties, message.getBytes());</span><br></pre></td></tr></table></figure>
<h3 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h3></li>
</ol>
<p>RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。</p>
<p>常用于当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积的场景下。</p>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><ul>
<li><p>只需要在声明队列时设置一个参数即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(); </span><br><span class="line">args.put(<span class="string">&quot;x-queue-mode&quot;</span>, <span class="string">&quot;lazy&quot;</span>); </span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myqueue&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure>


</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
</search>
